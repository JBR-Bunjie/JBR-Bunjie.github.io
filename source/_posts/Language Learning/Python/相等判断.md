# python的is和\=\=，java的\=\=和equal（相等判断）



## Python判断对象是否相等（== 和 is）

**Python中的对象包含三个基本要素，分别是：**

- **id：**用来唯一标识一个对象，可以理解为内存地址；
- **type：**标识对象的类型；
- **value：**对象的值；

**== ：**比较两个对象的内容是否 **相等**，即两个对象的 value 是否相等，无论 id 是否相等，默认会调用对象的 **\_\_eq\_\_()**方法

**is：** 比较的是两个对象是不是完全 **相同**，即他们的 id 要相等。

也就是说：如果 a is b 为 True，那么 a == b 也为True

### 字符串比较

```python
a = 'hello'
b = 'hello'
print(a is b)
print(id(a))
print(id(b))
# 执行结果：
True
1830826496176
1830826496176
```

### 数字比较

先看一个有趣的现象

```python
In[43]: a = 256
In[44]: b = 256
In[45]: a is b
Out[45]: True
In[46]: id(a)
Out[46]: 140711685177712
In[47]: id(b)
Out[47]: 140711685177712
In[48]: a = 257
In[49]: b = 257
In[50]: a is b
Out[50]: False
In[51]: id(a)
Out[51]: 2097451837488
In[52]: id(b)
Out[52]: 2097451837648
```

为什么当 a,b为257的时候 a is b 为False呢？

Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。

而Python 对小整数的定义是 [-5, 256)，只有数字在-5到256之间它们的id才会相等，超过了这个范围就不行了，同样的道理，字符串对象也有一个类似的缓冲池，超过区间范围内自然不会相等了。

需要注意的是这仅仅是在命令行中执行时才会有小整数缓存，而在文件中执行时，结果是不一样的，这是因为解释器做了一部分优化，如下：

```python
x = 257
y = 257
print(id(x))
print(id(y))
print(x is y)
# 执行结果：
2177330411024
2177330411024
True
```

### 元组比较

```python
x = (1, 2, 3)
y = (1, 2, 3)
print(x is y)
print(id(x))
print(id(y))
# 执行结果：
True
3014830376024
3014830376024
```

### 列表比较

```python
x = [1, 2, 3]
y = [1, 2, 3]
print(x == y)
print(x is y)
print(id(x))
print(id(y))
# 执行结果：
True
False
2968991650248
2968991650760
```

### 列表赋值比较

```python
x = [1, 2, 3]
y = x
print(x is y)
print(id(x))
print(id(y))
# 执行结果：
True
2294971781576
2294971781576
```

### 字典比较

```python
x = {"a": 1, "b": 2, "b": 3}
y = {"a": 1, "b": 2, "b": 3}
print(x == y)
print(x is y)
print(id(x))
print(id(y))
# 执行结果：
True
False
2522908527576
2522908269848
```

### 集合比较

```python
x = set([1, 2, 3])
y = set([1, 2, 3])
print(x == y)
print(x is y)
print(id(x))
print(id(y))
# 执行结果：
True
False
2080395955784
2080414590120
```

## 小结：

可以看到，当 x, y 为字符串、整数，元组（都是不可变类型）的时候，如果 x 和 y的值一样的话，x is y 则为True；

然而为列表，字典，集合（都是可变类型）的时候，x is y 为False，列表赋值的时候为True；

**与 == 相比，is 的计算速度快**——因为它不能重载，不用进行特殊的函数调用，少了函数调用的开销而直接比较两个整数 id。而 a == b 则是等同于**a.__eq__(b)**。继承自 object 的 **__****eq__** 方法比较两个对象的id，结果与 is 一样。但是多数Python的对象会覆盖object的 **\_\_eq\_\_**方法，而定义内容的相关比较，所以比较的是对象属性的值。

在变量和单例值之间比较时，应该使用 is。目前，最常使用 is 的地方是判断对象是不是 None

关于python的可变类型不可变类型可参考：https://www.runoob.com/python/python-variable-types.html

python的赋值、浅拷贝和深拷贝可参考：https://blog.csdn.net/bufengzj/article/details/90486991



## Java判断对象是否相等（== 和equal）

java中没有 is ,有 == 和 equal。。

**==：**比较两个变量本身的值，即两个对象在内存中的首地址（类似也就是和python的 is ）；

**equals：**比较变量所包含的内容是否相同（类似也就是和python的 == ）；

java 具体参考：https://www.cnblogs.com/weibanggang/p/9457757.html