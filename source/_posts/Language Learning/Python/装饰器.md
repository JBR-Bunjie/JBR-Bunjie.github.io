---
title: Python装饰器
date: 2022-2-13 12:07:03
tags:
  - Python
  - Language Learning
categories:
  - Python
  - Language Learning
<!--feature: true-->
cover: https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg
---

# Python装饰器

## 1、闭包

要想了解装饰器，首先要了解一个概念，闭包。

什么是闭包，一句话说就是，在函数中再嵌套一个函数，并且引用外部函数的变量，这就是一个闭包了。光说没有概念，直接上一个例子。

```python
def outer(x):
    def inner(y):
        return x + y
    return inner

print(outer(6)(5))

# output: 11
```

如代码所示，在outer函数内，又定义了一个inner函数，并且inner函数又引用了外部函数outer的变量x，这就是一个闭包了。在输出时，outer(6)(5),第一个括号传进去的值返回inner函数，其实就是返回6 + y，所以再传第二个参数进去，就可以得到返回值，6 + 5。



## 2.@符号

### 含义解释

@符号会使用一个简短的方式来生成一个被装饰的函数，具体过程可以理解为：

```python
# 装饰函数：
def a_new_decorator(a_func):
    def wrapTheFunction():
        print("I am doing some boring work before executing a_func()")
 
        a_func()
 
        print("I am doing some boring work after executing a_func()")
 
    return wrapTheFunction
 
# 需要被装饰的目标函数：
def a_function_requiring_decoration():
    print("I am the function which needs some decoration to remove my foul smell")

# 当前 a_function_requiring_decoration 函数的执行结果
# outputs: "I am the function which needs some decoration to remove my foul smell"


# 可行的装饰方式：
a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
#now a_function_requiring_decoration is wrapped by wrapTheFunction()

#---------或者：
@a_new_decorator
def a_function_requiring_decoration():
    """Now the func is wrapped"""
    print("I am the function which needs some decoration to remove my foul smell")

# 不管是怎么修饰，都可以在修饰后，执行得到：
a_function_requiring_decoration()
#outputs:I am doing some boring work before executing a_func()
#        I am the function which needs some decoration to remove my foul smell
#        I am doing some boring work after executing a_func()
```

也就是说：`@a_new_decorator` 就是
`a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)`的简写

### 一个小问题

在上方的代码执行完后，如果再打印：

```python
print(a_function_requiring_decoration.__name__)
# Output: wrapTheFunction
```

为啥？

修饰的实际过程是怎么样的吗？->就上方的例子而言，该装饰器的修饰过程是：`a = a_new_decorator(a)`，而a实际上只是一个地址的指向，现在a指向的位置是哪里？

是decorator执行结束时，return的wrapTheFunction，也就是说，a所指向的函数被新的a_new_decorator代替了。

为了解决“名字”的问题，我们可以再用一个装饰器`functools.wraps`：

```python
from functools import wraps
 
def a_new_decorator(a_func):
    @wraps(a_func)
    def wrapTheFunction():
        print("I am doing some boring work before executing a_func()")
        a_func()
        print("I am doing some boring work after executing a_func()")
    return wrapTheFunction
 
@a_new_decorator
def a_function_requiring_decoration():
    print("I am the function which needs some decoration to remove my foul smell")
 
print(a_function_requiring_decoration.__name__)
# Output: a_function_requiring_decoration
```

**@wraps**接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。



## 3、装饰器

解决了两个前置目标后，我们实际上就已经理解了什么是装饰器了

而python对装饰器的定义是：



接下来就讲装饰器，其实装饰器就是一个闭包，装饰器是闭包的一种应用。什么是装饰器呢，简言之，python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。使用时，再需要的函数前加上@demo即可。

```python
def debug(func):
    def wrapper():
        print("[DEBUG]: enter {}()".format(func.__name__))
        return func()
    return wrapper

@debug
def hello():
    print("hello")

hello()
-----------------------------
>>>[DEBUG]: enter hello()
>>>hello
```

例子中的装饰器给函数加上一个进入函数的debug模式，不用修改原函数代码就完成了这个功能，可以说是很方便了。



## 3、带参数的装饰器

上面例子中的装饰器是不是功能太简单了，那么装饰器可以加一些参数吗，当然是可以的，另外装饰的函数当然也是可以传参数的。

```python
def logging(level):
    def outwrapper(func):
        def wrapper(*args, **kwargs):
            print("[{0}]: enter {1}()".format(level, func.__name__))
            return func(*args, **kwargs)
        return wrapper
    return outwrapper

@logging(level="INFO")
def hello(a, b, c):
    print(a, b, c)

hello("hello,","good","morning")
-----------------------------
>>>[INFO]: enter hello()
>>>hello, good morning
```

如上，**装饰器中可以传入参数，先形成一个完整的装饰器，然后再来装饰函数**，当然函数如果需要传入参数也是可以的，用不定长参数符号就可以接收，例子中传入了三个参数。

```python
@logging(level="INFO") 
可以看做是 
hello = logging(level="INFO")(hello)

# 这里的hello是函数对象，python中一切皆是对象，函数也可以像变量一样传递，加括号后hello()才是执行函数。于是这里就变成了hello = outwrapper(hello)
# 而outwrapper() 的返回是 wrapper，hello 就等于 wrapper，执行 hello() 就等价于执行 wrapper()，而等号右边的 hello 已经作为参数传递给 outrapper() 了
```





## 4、类装饰器

装饰器也不一定只能用函数来写，也可以使用类装饰器，用法与函数装饰器并没有太大区别，实质是使用了类方法中的**call**魔法方法来实现类的直接调用。

```python
class logging(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print("[DEBUG]: enter {}()".format(self.func.__name__))
        return self.func(*args, **kwargs)

@logging
def hello(a, b, c):
    print(a, b, c)

hello("hello,","good","morning")	
-----------------------------
>>>[DEBUG]: enter hello()
>>>hello, good morning
```

​	类装饰器也是可以带参数的，如下实现

```python
class logging(object):
    def __init__(self, level):
        self.level = level

    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print("[{0}]: enter {1}()".format(self.level, func.__name__))
            return func(*args, **kwargs)
        return wrapper

@logging(level="TEST")
def hello(a, b, c):
    print(a, b, c)

hello("hello,","good","morning")
-----------------------------
>>>[TEST]: enter hello()
>>>hello, good morning
```

好了，如上就是装饰器的一些概念和大致的用法啦，想更深入的了解装饰器还是需要自己在平时的练习和应用中多体会，本篇只是给出一个概念，谢谢~







## 编写装饰器







## property装饰器

既要保护类的封装特性，又要让开发者可以使用“对象.属性”的方式操作操作类属性，除了使用 property() 函数，[Python](http://c.biancheng.net/python/) 还提供了 @property 装饰器。通过 @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“()”小括号

@property 的语法格式如下：

```python
@property
def 方法名(self)
  代码块
```

例如，定义一个矩形类，并定义用 @property 修饰的方法操作类中的 area 私有属性，代码如下：

```python
class Rect:   
    def __init__(self,area):    
        self.__area = area
    @property 
    def area(self):    
        return self.__arearect = Rect(30)  # 直接通过方法名来访问 area 方法
print("矩形的面积是：",rect.area)  # 运行结果: 30
```

上面程序中，使用 ＠property 修饰了 area() 方法，这样就使得该方法变成了 area 属性的 getter 方法。需要注意的是，如果类中只包含该方法，那么 area 属性将是一个只读属性。

也就是说，在使用 Rect 类时，无法对 area 属性重新赋值，即运行如下代码会报错：

```python
rect.area = 90
print("修改后的面积：",rect.area)
```

运行结果为：

```python
Traceback (most recent call last):
File "C:\Users\mengma\Desktop\1.py", line 10, in <module> rect.area = 90
AttributeError: can't set attribute
```


而要想实现修改 area 属性的值，还需要为 area 属性添加 setter 方法，也就需要用到 setter 装饰器

## setter装饰器

它的语法格式如下：

```python
@方法名.setter
def 方法名(self, value):
    代码块
```

例如，为 Rect 类中的 area 方法添加 setter 方法，代码如下：

```python
@area.setter
def area(self, value):  
    self.__area = value
```

再次运行如下代码：

```python
rect.area = 90
print("修改后的面积：",rect.area)  #运行结果 area: 90
```

这样，area 属性就有了 getter 和 setter 方法，该属性就变成了具有读写功能的属性。

除此之外，还可以使用 deleter 装饰器来删除指定属性

## deleter装饰器

语法格式

```python
@方法名.deleter
def 方法名(self):
  代码块
```

例如，在 Rect 类中，给 area() 方法添加 deleter 方法，实现代码如下：

```python
@area.deleter
def area(self):
	self.__area = 0
```

然后运行如下代码：

```python
del rect.areaprint("删除后的area值为：",rect.area)  # 运行结果 area: 0
```

## All in one: property() 函数

**property()** 函数的作用是在新式类中返回属性值。

### 语法

```python
class property([fget[, fset[, fdel[, doc]]]])
```

### 参数

- fget -- 获取属性值的函数
- fset -- 设置属性值的函数
- fdel -- 删除属性值函数
- doc -- 属性描述信息

### 返回值

返回新式类属性。

### 实例

```python
class C(object):
    def __init__(self):
        self._x = None
 
    def getx(self):
        return self._x
 
    def setx(self, value):
        self._x = value
 
    def delx(self):
        del self._x
 
    x = property(getx, setx, delx, "I'm the 'x' property.")
```

如果 *c* 是 *C* 的实例化, then => 

- c.{object} 将触发 getter

- c.{object} = value 将触发 setter 

- del c.{object} 触发 deleter

如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property 函数就会复制 fget 函数的 docstring（如果有的话）





@wraps() 相当于：

```
def Wraps(fWrap):
    def TmpWraps(func):
        def WrapsDecorator(*args, **kwargs):
            WrapsDecorator.__name__=fWrap.__name__
            WrapsDecorator.__doc__=fWrap.__doc__
            return func(*args, **kwargs)
        return WrapsDecorator
    return TmpWraps
```

示例代码如下：

```
def Wraps(fWrap):
    def TmpWraps(func):
        def WrapsDecorator(*args, **kwargs):
            WrapsDecorator.__name__=fWrap.__name__
            WrapsDecorator.__doc__=fWrap.__doc__
            return func(*args, **kwargs)
        return WrapsDecorator
    return TmpWraps


def NewDecorator(level):
    def TmpDecorator(func):
        def anotherFunc():
            '''it's another function'''
            pass
        #from functools import wraps
        #@wraps(anotherFunc)
        @Wraps(anotherFunc)
        def NewFibonacci(*args, **kwargs):
            print('[%s]func: %s is called, %s'%(level,func.__name__,NewFibonacci.__doc__))
            from time import time
            start = time()
            rst=func(*args, **kwargs)
            end=time()
            print('cost time: %.2fs'%(end-start))
            return rst
        return NewFibonacci
    return TmpDecorator


@NewDecorator('log')
def Fibonacci_print(num=10):
    if num <= 0:
        return
    minNum,maxNum=0,1
    while num > 0:
        tmpNum=minNum
        print(tmpNum, end=',')
        minNum=maxNum
        maxNum+=tmpNum
        num-=1

Fibonacci_print()
print(Fibonacci_print.__name__)
```

输出为：

```
[log]func: Fibonacci_print is called, it's another function
0,1,1,2,3,5,8,13,21,34,cost time: 0.07s
anotherFunc
```





再论 **@wraps(func)** 装饰器实现原理。

纠正下楼上 **@DragonZ** 描述的基本代码框架，应该是如下：

```
def Wraps(fWrap):
    def TmpWraps(func):
        def WrapsDecorator(*args, **kwargs):
            return func(*args, **kwargs)
            WrapsDecorator.__name__=fWrap.__name__
            WrapsDecorator.__doc__=fWrap.__doc__
        return WrapsDecorator
    return TmpWraps
```

并且该装饰器不仅仅只是复制了__name__ 和 __doc__ 函数元信息，还有更多其他信息，正确的实现代码如下：

```
def mywraps(fwrap):
    def TmpWraps(func):
        def dec(**args):
            return func(**args)
        meta_info=['__module__', '__name__', '__qualname__', '__doc__', '__annotations__']
        for meta in meta_info:
            setattr(dec,meta,getattr(fwrap,meta))
        #逐个获取fwrap函数的元信息，并复制到dec函数上
        return dec
    return TmpWraps
```

另外，针对类装饰器，可能下面这样解释，会对初学者更加友好：

装饰器还可以通过类来实现，其实主要是利用类的以下特点来变相实现函数装饰器功能：

函数调用语语法f()等同于类的实例化，即调用类的__init__函数创建对象

对象的调用obj()等同于运行对象的__call__魔法函数

通过类实现装饰器，可以避免函数装饰器超过2层的嵌套情况，因为如果有三层的话，最外层函数可以认为是在调用类的__init__函数，这样可以让代码更易读和维护

本质，只要实现类的__init__和__call__魔法函数，并在__init__函数内接受装饰器参数，在__call__函数内实现具体装饰器结构即可

下面举例，用类实现带参装饰器，可以观察下不同

```
from functools import wraps 
#定义一个装饰器名称的类
class  with_para_decorator: 
    #在类的__init__函数内接受装饰器参数，并赋值给类的实例参数，这样可以让其他函数随时使用
    #当然，如果装饰器没有参数，此处不转a,b即可，相当于类无参实例化
    def __init__(self,a,b):    
        self.a=a
        self.b=b
    #在类的__call__函数内接受被装饰函数，并具体定义装饰器
    def __call__(self,func):   
    @wraps(func)   
    def wrap_function(arg1,arg2):  
        print('装饰带参数的函数，函数传的参数为：{0}, {1}'.format(arg1,arg2))
        print('带参数的装饰器，装饰器传的参数为：{0}, {1}'.format(self.a,self.b))
        return func(arg1,arg2)   
    return wrap_function
#使用装饰器
@with_para_decorator(1,2)  
def need_decorate(a,b):   
pass
need_decorate(4,5) 
```

以上代码具体原理解析如下：

-  @with_para_decorator(1,2)，因为是类的名称，相当于使用(1,2)参数创建并返回该类的一个实例对象，比如是 obj
-  此时，语法变为@obj，相当于need_decorate=obj(need_decorate)，此时会调用obj.__call__魔法函数，而我们在该魔法函数具体实现了装饰器功能
-  可以看到，其本质的运行原理，和函数装饰器没区别，只是将三层函数嵌套，变成了一个__init__函数和__call__函数的两层嵌套
-  对比下来，可以看到，类装饰器，代码更加直观

## Link:

- [Python 函数装饰器 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/python-func-decorators.html)
- [python 装饰器详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/87353829)
- [functools — Higher-order functions and operations on callable objects — Python 3.10.7 documentation](https://docs.python.org/3/library/functools.html)
- [什么是闭包？闭包的优缺点？ | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/closure-intro.html)
- [闭包 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)