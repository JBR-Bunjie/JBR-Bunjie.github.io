---
title: LUA急速入门
date: 2022-12-23 12:23:23
tags:
  - LUA
  - Coding Language
categories:
  - Coding Language
<!--feature: true-->
cover: https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg
---

## 安装

```shell
# for ubuntu
apt install lua5.4

# for windows
# Go to github to install lua_for_windows
```

### 代码执行

#### 交互式编程

lua5.4已经支持了交互式编程，这样我们可以直接在命令行中输入程序语句并立即查看执行结果

```lua
~#: lua
Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio
> print("Hello World")
Hello World
> 
-- 退出交互式编程状态：Ctrl+D(发送退出信号)、Ctrl+C(强制中断)、os.exit()
```

#### 脚本式编程

传统的lua编写过程，和别的语言并无二致

```lua
#!/someDir/bin/lua --我们指定了 Lua 的解释器 /someDir/bin directory，加上 # 号标记后，解释器会忽略它。当我们为脚本添加可执行权限后，就可以通过输入 ./hello.lua 来快速执行该脚本了

print("Hello World！")
print("www.runoob.com")

-- 完成编写后，我们通过 lua hello.lua 的方式来执行该脚本
```

## 变量：

### 作用域

Lua中，所有创建的变量，默认为全局变量
而对于删除一个全局变量，我们只需将变量赋为nil

当然，你也可以用 `local` 来设置局部变量

> 应尽可能多地使用局部变量：
>
> - 避免命名冲突与逻辑错误
> - 访问局部变量的速度比全局变量更快

### 数据类型

Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。

你总是可以通过 `type(x)` 来检查数据类型

```lua
type(nil) == nil; -- false
type(nil) == "nil" -- true
```



| 数据类型 | 描述                                                         |
| :------: | :----------------------------------------------------------- |
|   nil    | 只有值nil属于该类，代表被删除、不存在等，是表示一个无效值（在条件表达式中相当于false） |
| boolean  | 包含两个值：false和true。                                    |
|  number  | 表示**双精度**类型的实浮点数                                 |
|  string  | 字符串由一对**双引号或单引号**来表示                         |
| function | 由 **C **或 **Lua** 编写的函数                               |
| userdata | 表示任意**存储在变量中的C数据结构****                        |
|  thread  | 表示执行的独立线路，用于执行协同程序                         |
|  table   | 字典或者"关联数组"。其索引可以是数字、字符串或表类型。我们用"构造表达式"来创建表 |

#### table

##### 实例：

```lua
-- table_test.lua 脚本文件
a = {} -- 创建空表
a["key"] = "value" -- 添加键值对
key = 10
a[key] = 22
a[key] = a[key] + 11
for k, v in pairs(a) do
    print(k .. " : " .. v)
end
-- 结果：
-- key : value
-- 10 : 33
```

##### 索引：

不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。

```lua
-- table_test2.lua 脚本文件
local tbl = {"apple", "pear", "orange", "grape"}
for key, val in pairs(tbl) do
    print("Key", key)
end

-- Key    1
-- Key    2
-- ..
```

##### 无序：

```lua
tab = {"Hello","World",a=1,b=2,z=3,x=10,y=20,"Good","Bye"}
for k,v in pairs(tab) do
    print(k.."  "..v)
end
```

如上代码输出结果存在一定规律，"Hello"、"World"、"Good"、"Bye"是表中的值，在存储时是按照顺序存储的，并且不同于其他脚本语言，Lua是从1开始排序的，因此，使用pairs遍历打印输出时，会先按照顺序输出表的值，然后再按照键值对的键的哈希值打印。

```
1  Hello
2  World
3  Good
4  Bye
y  20
x  10
z  3
b  2
a  1 
```

##### 构建数组

我们可以使用整数索引来访问数组元素，如果指定的索引没有值则返回 **nil**

```lua
array = {"Lua", "Tutorial"}

for i= 0, 2 do
   print(array[i])
end

-- nil
-- Lua
-- Tutorial
```

##### "指针"

当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都会指向同一个内存。而当 a 设置为 nil 时，Lua只会回收变量 a 本身，而 b 仍然能访问原 table 的元素。这种规则同样适用于传参数的情况

```Lua
mytable["wow"] = "修改前"
print("mytable 索引为 wow 的元素是 ", mytable["wow"])

-- alternatetable和mytable的是指同一个 table
alternatetable = mytable

print("mytable 索引为 wow 的元素是 ", alternatetable["wow"])
alternatetable["wow"] = "修改后"
print("mytable 索引为 wow 的元素是 ", mytable["wow"])

-- 释放变量
alternatetable = nil
print("alternatetable 是 ", alternatetable)

-- mytable 仍然可以访问
print("mytable 索引为 wow 的元素是 ", mytable["wow"])

-- mytable 索引为 wow 的元素是     修改前
-- mytable 索引为 wow 的元素是     修改前
-- mytable 索引为 wow 的元素是     修改后
-- alternatetable 是     nil
-- mytable 索引为 wow 的元素是     修改后
```

##### 插入删除

| 方法 |	 用途 |
| ---- | ------------------------------------------------------------ |
| **table.insert (table, [pos,] value):**   | 在table的数组部分指定位置(pos)插入值为value的一个元素. <br />pos参数可选, 默认为数组部分末尾. |
| **table.remove (table [, pos])**   | 返回table数组部分位于pos位置的元素. 其后的元素会被前移. <br />pos参数可选, 默认为table长度, 即从最后一个元素删起。 |

##### Sort

>`table.sort (list [, comp])`
>
>Sorts the list elements in a given order, *in-place*, from `list[1]` to `list[#list]`. If `comp` is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order, so that, after the sort, `i <= j` implies `not comp(list[j],list[i])`. If `comp` is not given, then the standard Lua operator `<` is used instead.

#### function

在 Lua 中，函数是被看作是"第一类值（First-Class Value）"

值得注意的是，我们可以临时创建一个匿名函数来进行参数传递：

```lua
testFun(tab,
    function(key, val)
        return key - val;
    end
);
```

#### thread

>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。
>
>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。

#### 字符串

##### 定义

Lua 语言中字符串可以使用以下三种方式来表示：

- 单引号间的一串字符。
- 双引号间的一串字符。
- **[[** 与 **]]** 间的一串字符。

特别的，我们可以通过嵌套来给字符串中加入引号：

```lua
a = "'test'"
print(a) -- 'a'
```

##### 字符串格式化

Lua 提供了 **string.format()** 函数来生成具有特定格式的字符串，这个函数的格式很像 C 语言中的 printf()。同时由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。

格式字符串可能包含以下的转义码:

- %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符
- %d, %i - 接受一个数字并将其转化为有符号的整数格式
- %o - 接受一个数字并将其转化为八进制数格式
- %u - 接受一个数字并将其转化为无符号整数格式
- %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母
- %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母
- %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e
- %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E
- %f - 接受一个数字并将其转化为浮点数格式
- %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式
- %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式
- %s - 接受一个字符串并按照给定的参数格式化该字符串

为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:

- (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.
- (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.
- (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.
- (4) 宽度数值
- (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.

##### 匹配

Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 **string.find, string.gmatch, string.gsub, string.match**。

字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类 **%d** 匹配任意数字。所以你可以使用模式串 **%d%d/%d%d/%d%d%d%d** 搜索 **dd/mm/yyyy** 格式的日期：

```lua
s = "Deadline is 30/05/1999, firm"
date = "%d%d/%d%d/%d%d%d%d"
print(string.sub(s, string.find(s, date)))    --> 30/05/1999
```





### 赋值语句：

```lua
-- Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量
a, b = 10, 2*x           -- a=10; b=2*x

-- 遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：
x, y = y, x              -- swap 'x' for 'y'

-- 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略：
a. 变量个数 > 值的个数      -- 按变量个数补足nil
b. 变量个数 < 值的个数      -- 多余的值会被忽略
--> 常见的错误情况:
a, b, c = 0
print(a,b,c)             --> 0   nil   nil
```

## 循环

相对于其它语言来说，Lua的循环结构是特殊而合理的：

| 方法名称 | 描述 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [while 循环](https://www.runoob.com/lua/lua-while-loop.html) | 在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。 |
| [for 循环](https://www.runoob.com/lua/lua-for-loop.html)     | 重复执行指定语句，重复次数可在 for 语句中控制。              |
| [repeat...until](https://www.runoob.com/lua/lua-repeat-until-loop.html) | 重复执行循环，直到 指定的条件为真时为止                      |

| 控制语句                                                     | 描述                                             |
| :----------------------------------------------------------- | :----------------------------------------------- |
| [break 语句](https://www.runoob.com/lua/lua-break-statement.html) | 退出当前循环或语句，并开始脚本执行紧接着的语句。 |
| [goto 语句](https://www.runoob.com/lua/lua-goto.html)        | 将程序的控制点转移到一个标签处。                 |

值得注意的是，lua中并不包含 `continue` 控制语句，要想实现 `continue` 的功能，我们可以利用 `goto` 语句：

```lua
for i=1, 10 do
	if i % 2 == 0 then goto continue end
    print(i)
    ::continue::
end
```

> [loops - Why does Lua have no "continue" statement? - Stack Overflow](https://stackoverflow.com/questions/3524970/why-does-lua-have-no-continue-statement)

## 流程控制

我们利用 `if...elseif...else` 语句来完成流程控制

```lua
if( 布尔表达式 1) then
   --[ 在布尔表达式 1 为 true 时执行该语句块 --]
elseif( 布尔表达式 2) then
   --[ 在布尔表达式 2 为 true 时执行该语句块 --]
else 
   --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]
end
```

## 函数

> 在Lua中，函数是对语句和表达式进行抽象的主要方法。

Lua 函数主要有两种用途：

- 1.完成指定的任务，这种情况下函数作为调用语句使用；
- 2.计算并返回值，这种情况下函数作为赋值语句的表达式使用。

### 函数定义

Lua 编程语言函数定义格式如下：

```lua
optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)
    function_body
    return result_params_comma_separated
end
```

- **optional_function_scope:** 该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 **local**。
- **function_name:** 指定函数名称。
- **argument1, argument2, argument3..., argumentn:** 函数参数，多个参数以逗号隔开，函数也可以不带参数。
- **function_body:** 函数体，函数中需要执行的代码语句块。
- **result_params_comma_separated:** 函数返回值，**Lua语言函数可以返回多个值**，每个值以逗号隔开。

### "重载"

关于函数的"重载"能力：Lua能自动去适应传入的参数，如果传入的参数个数多于定义的个数，则会自动忽略后面多于的参数，如果传入的参数个数少于定义的个数，则会将不足的参数用nil补齐。如：

```lua
function Add(a,b,c)
     if c == nil then
         return a + b
     else
         return a + b + c
     end
end
```

### 可变参数：

> Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 **...** 表示函数有可变的参数。

```lua
function average(...)
   result = 0
   local arg={...}    --> arg 为一个表，局部变量
   for i,v in ipairs(arg) do
      result = result + v
   end
   print("总共传入 " .. #arg .. " 个数")
   return result/#arg
end

print("平均值为",average(10,5,3,4,5,6))
```

我们常将可变参数通过 `{...}` 来组合为table，此时，我们可以通过select方法来访问可变参数的信息：

- **select('#', …)** 返回可变参数的长度。
- **select(n, …)** 用于返回从起点 **n** 开始到结束位置的所有参数列表。

请注意，select方法中的参数并非是table，这当然意味着select只适用于可变参数，不适合table

>**select (index, ···)**
>
>If index is a number, returns all arguments after argument number index;
>a negative number indexes from the end (-1 is the last argument).
>Otherwise, index must be the string "#", and select returns the total number of extra arguments it received.

## 运算符

| 操作符 | 描述 | 实例              |
| :----- | :--- | :---------------- |
| ^      | 乘幂 | 10^2 输出结果 100 |
| //      | 整除(>=lua5.3) | 5//2 输出结果 2 |
| ~=     | 不等于         | (1 ~= 2) 为 true。 |
| and    | 逻辑与         | (true and false) 为 false。   |
| or     | 逻辑或         | (false or false) 为 true。    |
| not    | 逻辑非         | not(true and false) 为 true。 |
| .      | 连接两个字符串                             | a..b，若a为 "Hello " ，b为 "World", 输出结果为 "Hello World" |
| #      | 一元运算符，返回**字符串**或**表**的长度。 | #"Hello" 返回 5                                              |

### 特别的，当对 `table` 使用 `#` 运算时会遇到的问题

```lua
> a = {"1", "2", nil, "3"}
> #a
4
> b = {"1", "2","3", nil}
> #b
3
```

其获取长度时，依靠的其实是最大索引值：

在获取表的长度时，根据的是表的最大索引的值:

```lua
tab1 = {"1","2"}
print("tab1长度"..#tab1)

tab2 = {key1="1","2"}
print("tab2长度"..#tab2)

tab3 = {}
tab3[1]="1"
tab3[2]="2"
tab3[4]="4"
print("tab3长度"..#tab3)

-- tab1长度2
-- tab2长度1
-- tab3长度4
```

而当下标越位超过 `1` 时：

下标越过 1 位以上，长度还是为 2：

```lua
tab3={}
tab3[1]="1"
tab3[2]="2"
tab3[5]="5"
print("tab3的长度",#tab3)

-- tab3的长度    2
```

>当我们获取 table 的长度的时候无论是使用 **#** 还是 **table.getn** 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。
>
>可以使用以下方法来代替：
>
>```lua
>function table_leng(t)
>  local leng=0
>  for k, v in pairs(t) do
>    leng=leng+1
>  end
>  return leng;
>end
>```

### 实现三目运算

使用 Lua 的逻辑运算符实现就需要一些小技巧，写法如下（具体可查看[Lua 中的三目运算符](https://www.runoob.com/w3cnote/trinocular-operators-in-lua.html)）

```lua
(condition and {result1} or {result2})[1]
```

例：

```lua
local isAppel = false
print(isAppel and "苹果" or "梨")
```

原理：

> - (A and B), 若 A 为 false 返回 A(返回false) ;
>
> - (A or B), 若 A 为 false 返回 B ;
>
> - 除 nil 外其他数据类型被当做 true



## 元表

Lua中我们使用元表来增强Table的表现：通过为table赋予元表，我们可以改变对table进行操作时的默认行为，以达到更多的效果。

当我们为一个 table 指定好对应的 metatable 后，我们就可以为元表增添即时字段来修改上层 table 行为了

### 为指定的表设定元表

两个主要方法：

- **setmetatable(table, metatable):** 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。
- **getmetatable(table):** 返回对象的元表(metatable)。

### 为元表增添元方法

~仅列出部分主要方法~

#### __index 元方法

生效情况：当你通过键来访问 table 的时候，如果这个键没有值，那么 Lua 就会寻找该 table 的 metatable 中的\_\_index 键。当 \_\_index生效时：

##### \_\_index包含表格

若\_\_index包含一个表格，Lua 会在表格中查找相应的键。

```lua
other = { foo = 3 }
t = setmetatable({}, { __index = other })
print(t.foo) -- 3
print(t.bar) -- nil
```

##### 若\_\_index包含函数

若\_\_index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。

```lua
mytable = setmetatable({key1 = "value1"}, {
  __index = function(mytable, key)
    print(mytable, key)
  end
})
print(mytable.key1, mytable.key2)
```

>### 总结
>
>Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:
>
>- 1.在表中查找，如果找到，返回该元素，找不到则继续
>- 2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。
>- 3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。
>
>该部分内容来自作者寰子：https://blog.csdn.net/xocoder/article/details/9028347

#### __newindex 元方法

生效情况：当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法。如果存在则调用该方法而不进行赋值操作。

> __newindex 元方法用来对表更新，__index则用来对表访问 。

```lua

mymetatable = {}
mytable = setmetatable({key1 = "value1"}, { __newindex = mymetatable })

print(mytable.key1)

mytable.newkey = "新值2"
print(mytable.newkey,mymetatable.newkey)

mytable.key1 = "新值1"
print(mytable.key1,mymetatable.key1)
```

#### 重载操作符：\_\_add、\_\_sub等元方法：

>以下实例演示了两表相加操作：
>
>## 实例
>
>```lua
>-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数
>function table_maxn(t)
>    local mn = 0
>    for k, v in pairs(t) do
>        if mn < k then
>            mn = k
>        end
>    end
>    return mn
>end
>
>-- 两表相加操作
>mytable = setmetatable({ 1, 2, 3 }, {
>  __add = function(mytable, newtable)
>    for i = 1, table_maxn(newtable) do
>      table.insert(mytable, table_maxn(mytable)+1,newtable[i])
>    end
>    return mytable
>  end
>})
>
>secondtable = {4,5,6}
>
>mytable = mytable + secondtable
>for k,v in ipairs(mytable) do
>	print(k,v)
>end
>
>-- 以上实例执行输出结果为：
>-- 1    1
>-- 2    2
>-- 3    3
>-- 4    4
>-- 5    5
>-- 6    6
>```

全部的操作符元方法如下：

| 模式     | 描述               |
| :------- | :----------------- |
| __add    | 对应的运算符 '+'.  |
| __sub    | 对应的运算符 '-'.  |
| __mul    | 对应的运算符 '*'.  |
| __div    | 对应的运算符 '/'.  |
| __mod    | 对应的运算符 '%'.  |
| __unm    | 对应的运算符 '-'.  |
| __concat | 对应的运算符 '..'. |
| __eq     | 对应的运算符 '=='. |
| __lt     | 对应的运算符 '<'.  |
| __le     | 对应的运算符 '<='. |

#### __call 元方法

> **`__call`: The call operation `func(args)`.** 
>
> **This event happens when Lua tries to call a non-function value** (that is, `func` is not a function). The metamethod is looked up in `func`. If present, the metamethod is called with `func` as its first argument, followed by the arguments of the original call (`args`). All results of the call are the results of the operation. This is the only metamethod that allows multiple results.

```lua
-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数
function table_maxn(t)
    local mn = 0
    for k, v in pairs(t) do
        if mn < k then
            mn = k
        end
    end
    return mn
end

-- 定义元方法__call
mytable = setmetatable({10}, {
  __call = function(mytable, newtable)
        sum = 0
        for i = 1, table_maxn(mytable) do
                sum = sum + mytable[i]
        end
    for i = 1, table_maxn(newtable) do
                sum = sum + newtable[i]
        end
        return sum
  end
})
newtable = {10,20,30}
print(mytable(newtable)) -- 70
```

#### __tostring 元方法

__tostring 元方法用于修改表的输出行为。

```lua
mytable = setmetatable({ 10, 20, 30 }, {
    __tostring = function(mytable)
        sum = 0
        for k, v in pairs(mytable) do
            	sum = sum + v
            end
        return "表所有元素的和为 " .. sum
    end
})
print(mytable) -- 表所有元素的和为 60
```

### 绕开元方法

以\_\_newindex为例：设置了元方法 \_\_newindex 后，在对新索引键(newkey)赋值时，会调用元方法，而自身不再主动进行赋值。而对于已存在的索引键(oldkey)，则会进行赋值，而不调用元方法 newindex。为了保证我们仍然能实现赋值语句本身的功能，我们在\_\_newindex调用的方法中，会需要绕开该元方法本身直接进行赋值，这时我们需要用到 `rawser`、`rawget` 两个函数，它们能在完成本身功能时避免激活元方法

>`rawset (table, index, value)`
>
>Sets the real value of `table[index]` to `value`, without using the `__newindex` metavalue. `table` must be a table, `index` any value different from **nil** and NaN, and `value` any Lua value.

>`rawget (table, index)`
>
>Gets the real value of `table[index]`, without using the `__index` metavalue. `table` must be a table; `index` may be any value.

```lua
mytable = setmetatable({key1 = "value1"}, {
    __newindex = function(mytable, key, value)
        rawset(mytable, key, "\""..value.."\"")
    end
})

mytable.key1 = "new value"
mytable.key2 = 4

print(mytable.key1, mytable.key2) -- new value    "4"
```

## 协程 - coroutine：

Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。

### 线程和协同程序区别

线程与协同程序的主要区别在于：一个具有多个线程的程序可以同时运行几个线程，而在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。

### 基本语法

| 方法                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| coroutine.create()  | 创建 coroutine，返回 coroutine (**thread**)， 参数是一个函数<br />当和 resume 配合使用的时候就唤醒函数调用 |
| coroutine.resume()  | 重启 coroutine，和 create 配合使用                           |
| coroutine.yield()   | 挂起 coroutine，将 coroutine 设置为挂起状态<br />这个和 resume 配合使用能有很多有用的效果 |
| coroutine.status()  | 查看 coroutine 的状态<br />※: coroutine 的状态共三种：dead，suspended，running |
| coroutine.wrap（）  | 创建 coroutine 并返回一个**函数**，如调用该函数就进入 coroutine<br />和 create 功能重复 |
| coroutine.running() | 返回正在跑的 coroutine，一个 coroutine 就是一个线程<br />当使用running的时候，就是返回一个 corouting 的线程号 |

```lua
-- coroutine_test.lua 文件
co = coroutine.create(
    function(i)
        print(i);
    end) 
-- 刚创建时并未执行

coroutine.resume(co, 1)   -- 1
print(coroutine.status(co))  -- dead -- 执行完毕

print("----------")  -- ----------
 
co = coroutine.wrap(
    function(i)
        print(i);
    end
)
 
co(10)  -- 10 -- warp创建和create创建的调用方式是不一样的，因为create返回的是thread对象，而wrap返回的是function
print("----------")  -- ----------
 
co2 = coroutine.create(function()
    for i=1,10 do
        print(i)
        if i == 3 then
            print(coroutine.status(co2))  -- running
            print(coroutine.running())  -- thread:XXXXXX
        end
        coroutine.yield()
    end
end)

coroutine.resume(co2) --1
coroutine.resume(co2) --2
coroutine.resume(co2) --3
 
print(coroutine.status(co2))   -- suspended
print(coroutine.running())  -- thread: 0x7fb801c04c88    true
```

>- coroutine.creat方法只要建立了一个协程 ，那么这个协程的状态默认就是suspend。使用resume方法启动后，会变成running状态；遇到yield时将状态设为suspend；如果遇到return，那么将协程的状态改为dead。
>
>- coroutine.resume方法需要特别注意的一点是，这个方法只要调用就会返回一个boolean值。
>
>  - coroutine.resume方法如果调用成功，那么返回true；如果有yield方法，同时返回yield括号里的参数；如果没有yield，那么继续运行直到协程结束；直到遇到return，将协程的状态改为dead，并同时返回return的值。
>  - coroutine.resume方法如果调用失败(调用状态为dead的协程会导致失败)，那么返回false，并且带上一句"cannot resume dead coroutine"
>
>- wrap不会返回boolean值，但是当coroutine执行完dead后，如继续执行该coroutine则会导致程序报错。
>
>- coroutine.yield 除了挂起协程外，还可以同时返回数据给 resume ,并且还可以同时定义下一次唤醒时需要传递的参数。
>
>  ```lua
>  cor = coroutine.create(function(a)
>      print("参数 a 值为：", a);
>      local b, c = coroutine.yield(a + 1); --这里表示挂起协程，并且将a+1的值进行返回，并且指定下一次唤醒需要 b,c 两个参数。
>      print("参数 b, c 值分别为：", b, c);
>      return b * c; --协程结束，并且返回 b*c 的值。
>  end);
>  
>  print("第一次调用：", coroutine.resume(cor, 1));
>  print("第二次调用：", coroutine.resume(cor, 2, 2));
>  print("第三次调用：", coroutine.resume(cor));
>  
>  --[[
>  参数 a 值为：    1
>  第一次调用：    true    2
>  参数 b, c 值分别为：    2    2
>  第二次调用：    true    4
>  第三次调用：    false    cannot resume dead coroutine ]]
>  ```
>
>  ```lua
>  cor = coroutine.wrap(function(a)
>      print("参数 a 值为：", a);
>      local b, c = coroutine.yield(a + 1); --这里表示挂起协程，并且将a+1的值进行返回，并且指定下一次唤醒需要 b,c 两个参数。
>      print("参数 b, c 值分别为：", b, c);
>      return b * c; --协程结束，并且返回 b*c 的值。
>  end);
>  
>  print("第一次调用：", cor(1));
>  print("第二次调用：", cor(2, 2));
>  print("第三次调用：", cor());
>  
>  --[[
>  参数 a 值为：   1
>  第一次调用：    2
>  参数 b, c 值分别为：    2       2
>  第二次调用：    4
>  lua: test.lua:18: cannot resume dead coroutine
>  stack traceback:
>          [C]: in function 'cor'
>          test.lua:18: in main chunk
>          [C]: in ?  ]]
>  ```
>
>  



## 迭代器

迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。

Lua 的迭代器（迭代函数）包含以下两种类型：

- 无状态的迭代器
- 多状态的迭代器

### 泛型 for 调用迭代器

泛型 for 的执行过程：

- 首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。
- 第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。
- 第三，将迭代函数返回的值赋给变量列表。
- 第四，如果返回的第一个值为nil循环结束，否则执行循环体。
- 第五，回到第二步再次调用迭代函数

如：

```lua
array = {"Google", "Runoob"}

for key,value in ipairs(array)
do
   print(key, value)
end
```

### 无状态的迭代器

类似pairs, ipairs的，没有更多信息(状态)的迭代器

```lua
function square(iteratorMaxCount, currentNumber)
   if currentNumber < iteratorMaxCount
   then
      currentNumber = currentNumber+1
   return currentNumber, currentNumber*currentNumber
   end
end

for i,n in square(3,0) do
   print(i,n)
end
```

### 多状态的迭代器

为了保存更多信息，使用闭包来构造迭代器

```lua
array = {"Google", "Runoob"}

function elementIterator (collection)
   local index = 0
   local count = #collection
   -- 闭包函数
   return function ()
      index = index + 1
      if index <= count
      then
         --  返回迭代器的当前元素
         return collection[index]
      end
   end
end

for element in elementIterator(array)
do
   print(element)
end
```







## 模块化

从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。

```lua
-- 文件名为 Test1.lua
-- 定义一个名为 module 的模块(Table)
module = {}
 
-- 定义一个常量
module.constant = "这是一个常量"
 
-- 定义一个函数
function module.func1()
    io.write("这是一个公有函数！\n")
end
 
local function func2()
    print("这是一个私有函数！")
end
 
function module.func3()
    func2()
end
 
return module
```

由上可知，**模块的结构就是一个 table 的结构**，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。其中：

- func1 声明为程序块的全局变量，我们以这样的方式实现了 **public** 属性，可以在引入后随意调用.
- func2 则声明为程序块的局部变量，即表示一个 **private** 函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的函数来调用.





## 面向对象

### 利用function实现面向对象

#### 闭包

一句话说就是，在函数中引用外部函数来进行嵌套的函数。

```python
def outer(x):
    def inner(y):
        return x + y
    return inner

print(outer(6)(5))

>>> 11
```

如代码所示，在outer函数内，又定义了一个inner函数，并且inner函数又引用了外部函数outer的变量x，这就是一个闭包了。在输出时，outer(6)(5),第一个括号传进去的值返回inner函数，其实就是返回6 + y，所以再传第二个参数进去，就可以得到返回值，6 + 5。

#### 实现

```lua
-- 元类
Rectangle = {area = 0, length = 0, breadth = 0}

-- 派生类的方法 new
function Rectangle:new (o,length,breadth)
  o = o or {}
  setmetatable(o, self)
  self.__index = self  -- 子类没设置area这三个属性时，会导回Rectangle
  self.length = length or 0
  self.breadth = breadth or 0
  self.area = length*breadth;
  return o
end

-- 派生类的方法 printArea
function Rectangle:printArea ()
  print("矩形面积为 ",self.area)
end
```

> [Lua中的self - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/115159195)

### 利用table实现

- 封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性
  - table已经完备
- 继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。
  - 我们需要自己实现clone/copy函数
- 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。
  - Lua function已完备

```lua
-- clone function
function clone(tb)
    local ins = {}
    for key, var in pairs(tb) do
        ins[key] = var
    end
    return ins
end
-- copy function
function copy(dist, tb)
    for key, var in pairs(tb) do
        dist[key] = var
    end
end

-- define original table
table = {}
table.funHello = function(tb)
    print("Hello "..tb.name)
end
table.new = function(name)
    local self = clone(table);
    self.name = name
    return self
end

-- 实例化
local tb1 = table.new("World")
tb1:funHello(tb1)  -- 事实上，常规地使用 . 或者 : 来引用funHello是几乎完全一样的，但是为了提升可读性，我们需要做出区分

-- 继承
tb2 = {}
tb2.new = function(name)
    local self = table.new(name)
    copy(self, tb2)
    return self
end

tb2.tb2Hello = function()
    print("tb2 Hello")
end
tb2.funHello = function()
    print("tb2 fun Hello")
end

local m = tb2.new("Lili")
m:funHello()
m:tb2Hello()
```



## 错误处理

程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。

这里我们主要着眼运行时错误。

### Raise Error

Lua主要使用两个函数：`assert` 和 `error` 来错误。

> `assert (v [, message])`
>
> - Raises an error if the value of its argument `v` is false (i.e., **nil** or **false**); 
>   - In case of error, `message` is the error object; when absent, it defaults to "`assertion failed!`"
> - otherwise, returns all its arguments. 
>
> >assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。

> `error (message [, level])`
>
> Raises an error (see [§2.3](http://www.lua.org/manual/5.4/manual.html#2.3)) with `message` as the error object. This function never returns.
>
> Usually, `error` adds some information about the error position at the beginning of the message, if the message is a string. The `level` argument specifies how to get the error position. With level 1 (the default), the error position is where the `error` function was called. Level 2 points the error to where the function that called `error` was called; and so on. Passing a level 0 avoids the addition of error position information to the message.
>
> >功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)
> >
> >通常情况下，error会附加一些错误位置的信息到message头部。
> >
> >Level参数指示获得错误的位置:
> >
> >- Level=1[默认]：为调用error位置(文件+行号)
> >- Level=2：指出哪个调用error的函数的函数
> >- Level=0:不添加错误位置信息

```lua
local function add(a,b)
   assert(type(a) == "number", "a 不是一个数字")
   assert(type(b) == "number", "b 不是一个数字")
   return a+b
end
add(10)
```

### Process Error

#### pcall

pcall接收一个函数和要传递给后者的参数，并执行。最后根据执行结果是否有错误返回true或者或false及errorinfo

```lua
> if pcall(function_name, ….) then
-- 没有错误
else
-- 存在错误
end

> pcall(function(i) print(i) end, 33)
33
true

> pcall(function(i) print(i) error('error..') end, 33)
33
false   stdin:1: error..
```

pcall会以一种"保护模式"来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。

不过，通常在错误发生时，我们往往希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。为了获取更多信息，我们可以直接使用的办法：xpcall

#### xpcall

>`xpcall (f, msgh [, arg1, ···])`
>
>This function is similar to [`pcall`](http://www.lua.org/manual/5.4/manual.html#pdf-pcall), except that it sets a new message handler `msgh`.

xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用 **`debug`** 库来获取关于错误的额外信息了。

debug库提供了两个通用的错误处理函数:

- debug.debug：提供一个Lua提示符，让用户来检查错误的原因
- debug.traceback：根据调用桟来构建一个扩展的错误消息

```lua
function myfunction ()
   n = n/nil
end

function myerrorhandler( err )
   print( "ERROR:", err )
end

status = xpcall( myfunction, myerrorhandler )
print( status )

-- ERROR:  test.lua:10: attempt to perform arithmetic on a nil value (global 'n')     		 -- from xpcall(..)
-- false 		-- from print( status )
```

#### debug

| 方法                                          | 用途                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| **traceback ([thread,] [message [, level]])** | 如果 message 存在且不是字符串或 nil，那么函数不做任何处理直接返回 message。<br /> 否则，traceback将返回调用栈的栈回溯信息。 <br />字符串可选项 message 被添加在栈回溯信息的开头。 <br />数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。 |
| **getinfo ([thread,] f [, what]):**           | 返回关于一个函数信息的**表**。 <br />你可以直接提供该函数，也可以用一个**数字** f 表示该函数——它表示运行在指定线程的调用栈对应层次上的函数： <br />0 层表示当前函数（getinfo 自身）； <br />1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）等等。<br /> 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。 |
| **getupvalue (f, up)**                        | 此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。<br/>以 '(' （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块） |
| **setupvalue (f, up, value):**                | 这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。 |

```lua
function newCounter ()
    local n = 0
    local k = 0
    return function ()
        k = n
        n = n + 1
        return n
    end
end
  
counter = newCounter()
print(counter())
print(counter())

local i = 1
repeat
    name, val = debug.getupvalue(counter, i)
    if name then
        print ("index", i, name, "=", val)
        
        if(name == "n") then
            debug.setupvalue (counter,2,10)
        end
        i = i + 1
    end -- if
until not name

print(counter())
```

## 垃圾回收

### 概述

Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。

Lua 运行了一个**垃圾收集器**来收集所有**死对象** （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。

Lua 实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： **垃圾收集器间歇率**和**垃圾收集器步进倍率**。 这两个数字都使用百分数为单位(例如：值 100 在内部表示 1)：

- **垃圾收集器间歇率**控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到之前的两倍时才开始新的循环。
- **垃圾收集器步进倍率**控制着收集器运作速度相对于内存分配速度的倍率。增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100，那样的话收集器就工作的太慢了以至于永远都干不完一个循环。默认值是 200，这表示收集器以内存分配的"两倍"速工作。如果你把步进倍率设为一个非常大的数字(比你的程序可能用到的字节数还大 10%)，收集器的行为就像一个 stop-the-world 收集器。接着你若把间歇率设为 200，收集器的行为就和过去的 Lua 版本一样了：每次 Lua 使用的内存翻倍时，就做一次完整的收集。

### 运用

我们可以通过函数**`collectgarbage ([opt [, arg]])`**来控制垃圾收集器：

- **collectgarbage("setpause", 200)**： 内存增大 2 倍（200/100）时自动释放一次内存 （200 是默认值）。

  **collectgarbage("setstepmul", 200)**：收集器单步收集的速度相对于内存分配速度的倍率，设置 200 的倍率等于 2 倍（200/100）。（200 是默认值）

- **collectgarbage("collect"):** 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：

- **collectgarbage("count"):** 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。

- **collectgarbage("restart"):** 重启垃圾收集器的自动运行。

- **collectgarbage("setpause"):** 将 arg 设为收集器的 间歇率。 返回 间歇率 的前一个值。

- **collectgarbage("setstepmul"):** 返回 步进倍率 的前一个值。

- **collectgarbage("step"):** 单步运行垃圾收集器。 步长"大小"由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。

- **collectgarbage("stop"):** 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。

#### 实例

```lua
mytable = {"apple", "orange", "banana"}
print(collectgarbage("count"))

mytable = nil

print(collectgarbage("count"))
print(collectgarbage("collect"))
print(collectgarbage("count"))
```

执行以上程序，输出结果如下(注意内存使用的变化)：

```
20.9560546875
20.9853515625
0
19.4111328125
```

## Main Origin

- Lua Official Site：[The Programming Language Lua](http://www.lua.org/)
- [Lua 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/lua/lua-tutorial.html)