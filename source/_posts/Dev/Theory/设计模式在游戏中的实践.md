---
title: 设计模式在游戏编程中的实践
date: 2023-2-2 12:23:23
tags:
  - Theroy
categories:
  - Theroy
<!--feature: true-->
cover: https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg
---

# 设计模式在游戏编程中的实践

## 设计模式

### 命令模式

> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化； 对请求排队或记录请求日志，以及支持可撤销的操作。

命令模式至少包含这样几个部分：

![img](https://www.runoob.com/wp-content/uploads/2014/08/commanduml.jpg)

#### 介绍

**意图：**将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。

**主要解决：**在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。

**何时使用：**在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。

**如何解决：**通过调用者调用接受者执行命令，顺序：调用者 → 命令 → 接受者。

**关键代码：**定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口

**应用实例：**struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。

**优点：** 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。

**缺点：**使用命令模式可能会导致某些系统有过多的具体命令类。

**使用场景：**认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。

**注意事项：**系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。

#### 使用命令模式之前...

> 在每个游戏中都有一块代码读取用户的输入——按钮按下，键盘敲击，鼠标点击，诸如此类。 这块代码会获取用户的输入，然后将其变为游戏中有意义的行为
>
> ![一个手柄, A键调用swapWeapon()，B键调用lurch()，X键调用jump()，Y键调用fireGun()。](https://gpp.tkchu.me/images/command-buttons-one.png)

如果对这样一个功能作出实现的话，最简单的实现也许是如下所示的：

```c++
void InputHandler::handleInput() {
  if (isPressed(BUTTON_X)) jump();
  else if (isPressed(BUTTON_Y)) fireGun();
  else if (isPressed(BUTTON_A)) swapWeapon();
  else if (isPressed(BUTTON_B)) lurchIneffectively();
}
```

它能实现我们的功能没错，但我们至少能发现这里的耦合度太高了，事实上，这里在实际游玩中，还不能允许玩家修改键位等等。要想实现更多的功能，我们就得将这里的代码解耦——这个时候命令模式就出场了。

命令模式有好几种实现思路，但是它们都有一些共性

#### 命令基类 / 抽象命令类

这一般是一个抽象类或接口，在其中声明了用于执行请求的 execute()等方法，通过这些方法可以调用请求接收者的相关操作。

这部分的示例如下：

```C++
class Command {
public:
  virtual ~Command() {}
  virtual void execute() = 0;
};
```

#### 具体命令类

我们根据实际需求，对基类进行实现

```C++
class JumpCommand : public Command {
public:
  virtual void execute() { jump(); }
};

class FireCommand : public Command {
public:
  virtual void execute() { fireGun(); }
};z`
```

这一部分往往是存在很多变化的：也许我们会设立

#### 调用部分 / 请求部分

在代码的输入处理部分，为每个按键存储一个指向命令的指针。

```c++
class InputHandler
{
public:
  void handleInput();

  // 绑定命令的方法……

private:
  Command* buttonX_;
  Command* buttonY_;
  Command* buttonA_;
  Command* buttonB_;
};
```

并对于这个接收输入的部分，我们将其修改为：

```c++
void InputHandler::handleInput() {
  if (isPressed(BUTTON_X)) buttonX_->execute();
  else if (isPressed(BUTTON_Y)) buttonY_->execute();
  else if (isPressed(BUTTON_A)) buttonA_->execute();
  else if (isPressed(BUTTON_B)) buttonB_->execute();
}
```

到这里，我们已经实现了这个应用中的解耦了——我们不关心我们具体调用的是什么方法，我们只需要知道，这就是我们需要的方法就行。

但是这里还可以有一个问题，之所以说“可以有”，是因为这里

#### 接收部分

> 接收者执行与请求相关的操作，它具体实现对请求的业务处理。

我们得根据实际情况判断我们是否真的需要这一部分：我们所谓的接收部分，往往就是我们实际的 GameObject，也就是说，这一部分决定了我们到底想要我们的功能对于谁生效——譬如我们在上一部分中的第一个例子，我们可以发现这样一个问题：我们假设了顶层的`jump()`, `fireGun()`之类的函数是用于找到玩家角色的——这些假定同样产生了耦合，而这些耦合限制了这些命令的用处——`JumpCommand`只能让玩家的角色跳跃。

让我们将这个接收命令的 GameObject 暴露出来，将函数控制的角色对象传进去——这需要修改一下前面的代码：

```c++
// 抽象类部分
class Command {
public:
  virtual ~Command() {}
  virtual void execute(GameObject& character) = 0;
};

// Jump
class JumpCommand : public Command {
public:
  virtual void execute(GameActor& actor) {
    actor.jump();
  }
};

// handle
Command* InputHandler::handleInput() {
  if (isPressed(BUTTON_X)) return buttonX_;
  if (isPressed(BUTTON_Y)) return buttonY_;
  if (isPressed(BUTTON_A)) return buttonA_;
  if (isPressed(BUTTON_B)) return buttonB_;

  // 没有按下任何按键，就什么也不做
  return NULL;
}

// 接收部分
Command* command = inputHandler.handleInput();
if (command) {
  command->execute(actor);
}
```

需要注意两点：

- 不管我们有没有暴露作用对象，我们实际产生影响的 Code，是存在于我们的接收部分中的
- 在新的实例中，我们的功能不是立即执行的——我们会延迟到调用执行时再知道

对于传入 GameObject 的情况，我们成功扩大了这个模板的可用性：即使是对于 AI，我们也只需编写适用于它们的`Command`对象，就可以复用它。

> 把控制角色的命令变为第一公民对象，去除直接方法调用中严厉的束缚。 将其视为命令队列，或者是命令流：
>
> ![一条连接AI到角色的管道。](https://gpp.tkchu.me/images/command-stream.png)
>
> 一些代码（输入控制器或者 AI）产生一系列命令放入流中。 另一些代码（调度器或者角色自身）调用并消耗命令。 通过在中间加入队列，我们解耦了消费者和生产者。

#### 撤销和重做

我想，命令模式最广泛的用例应该是用于实现撤销和重做功能了。

由于在本模式中，我们天然地将一个过程的进行拆分成了命令发出和命令执行两部分，那我们就可以很方便地记录命令的发出内容，并以此为作为回滚的依据。

我们已经使用了命令来抽象输入控制，所以每个玩家的举动都已经被封装其中。 举个例子，移动一个单位的代码可能如下：

```c++
// 注意这和前面的命令有些许不同：在前面的例子中，我们需要从修改的角色那里抽象命令; 在这个例子中，我们将命令绑定到要移动的单位上。
// 这条命令的实例不是通用的“移动某物”命令；而是游戏回合中特殊的一次移动
class MoveUnitCommand : public Command {
public:
  MoveUnitCommand(Unit* unit, int x, int y)
  : unit_(unit),
    x_(x),
    y_(y)
  {}

  virtual void execute() {
    unit_->moveTo(x_, y_);
  }

private:
  Unit* unit_;
  int x_, y_;
};
```

这展现了命令模式应用时的一种情形。 就像之前的例子，指令在某些情形中是可重用的对象，代表了可执行的事件。 我们早期的输入控制器将其实现为一个命令对象，然后在按键按下时调用其`execute()`方法。

这里的命令更加特殊。它们代表了特定时间点能做的特定事件。 这意味着输入控制代码可以在玩家下决定时*创造*一个实例。就像这样：

```c++
Command* handleInput()
{
  Unit* unit = getSelectedUnit();

  if (isPressed(BUTTON_UP)) {
    // 向上移动单位
    int destY = unit->y() - 1;
    return new MoveUnitCommand(unit, unit->x(), destY);
  }

  if (isPressed(BUTTON_DOWN)) {
    // 向下移动单位
    int destY = unit->y() + 1;
    return new MoveUnitCommand(unit, unit->x(), destY);
  }

  // 其他的移动……

  return NULL;
}
```

命令的一次性为我们很快地赢得了一个优点。 为了让指令可被取消，我们为每个类定义另一个需要实现的方法：

```c++
class Command
{
public:
  virtual ~Command() {}
  virtual void execute() = 0;
  virtual void undo() = 0;
};
```

`undo()`方法回滚了`execute()`方法造成的游戏状态改变。 这里是添加了撤销功能后的移动命令：

```c++
class MoveUnitCommand : public Command
{
public:
  MoveUnitCommand(Unit* unit, int x, int y)
  : unit_(unit),
    xBefore_(0),
    yBefore_(0),
    x_(x),
    y_(y)
  {}

  virtual void execute()
  {
    // 保存移动之前的位置
    // 这样之后可以复原。

    xBefore_ = unit_->x();
    yBefore_ = unit_->y();

    unit_->moveTo(x_, y_);
  }

  virtual void undo()
  {
    unit_->moveTo(xBefore_, yBefore_);
  }

private:
  Unit* unit_;
  int xBefore_, yBefore_;
  int x_, y_;
};
```

注意我们为类添加了更多的状态。 当单位移动时，它忘记了它之前是什么样的。 如果我们想要撤销这个移动，我们需要记得单位之前的状态，也就是`xBefore_`和`yBefore_`的作用。

由于命令趋向于修改对象状态的一小部分，对数据其他部分的快照就是浪费内存。手动内存管理的消耗更小。*[持久化数据结构](http://en.wikipedia.org/wiki/Persistent_data_structure)*是另一个选项。 使用它，每次修改对象都返回一个新对象，保持原来的对象不变。巧妙的实现下，这些新对象与之前的对象共享数据，所以比克隆整个对象开销更小。使用持久化数据结构，每条命令都存储了命令执行之前对象的引用，而撤销只是切换回之前的对象。

为了让玩家撤销移动，我们记录了执行的最后命令。当他们按下`control+z`时，我们调用命令的`undo()`方法。 （如果他们已经撤销了，那么就变成了“重做”，我们会再一次执行命令。）

支持多重的撤销也不太难。 我们不单单记录最后一条指令，还要记录指令列表，然后用一个引用指向“当前”的那个。 当玩家执行一条命令，我们将其添加到列表，然后将代表“当前”的指针指向它。

![从旧到新排列的命令栈。 一个当前箭头指向一条命令，一个“撤销”箭头指向之前的命令，一个“重做”指向之后的命令](https://gpp.tkchu.me/images/command-undo.png)

当玩家选择“撤销”，我们撤销现在的命令，将代表当前的指针往后退。 当他们选择“重做”，我们将代表当前的指针往前进，执行该指令。 如果在撤销后选择了新命令，那么清除命令列表中当前的指针所指命令之后的全部命令。

第一次在关卡编辑器中实现这点时，我觉得自己简直就是个天才。 我惊讶于它如此的简明有效。 你需要约束自己，保证每个数据修改都通过命令完成，一旦你做到了，余下的都很简单。

### 享元模式

享元模式最直接的影响就是数据复用：

> 迷雾散尽，露出了古朴庄严的森林。古老的铁杉，在头顶编成绿色穹顶。 阳光在树叶间破碎成金色顶棚。从树干间远眺，远处的森林渐渐隐去。
>
> 这是我们游戏开发者梦想的超凡场景，这样的场景通常由一个模式支撑着，它的名字低调至极：享元模式。
>
> 用几句话就能描述一片巨大的森林，但是在实时游戏中做这件事就完全是另外一件事了。 当屏幕上需要显示一整个森林时，图形程序员看到的是每秒需要送到 GPU 六十次的百万多边形——我们讨论的是成千上万的树，每棵都由上千的多边形组成。 就算有足够的*内存*描述森林，渲染的过程中，CPU 到 GPU 的部分也太过繁忙了。
>
> 让我们仔细分析一下这个场景——每棵树都有：
>
> - 定义树干，树枝和树叶形状的多边形网格。
> - 树皮和树叶的纹理。
> - 在森林中树的位置和朝向。
> - 大小和色彩之类的调节参数，让每棵树都看起来与众不同。
>
> 如果用代码表示，那么会得到这样的东西：
>
> ```c++
> class Tree {
> private:
>   Mesh mesh_;
>   Texture bark_;
>   Texture leaves_;
>   Vector position_;
>   double height_;
>   double thickness_;
>   Color barkTint_;
>   Color leafTint_;
> };
> ```
>
> 这是一大堆数据，多边形网格和纹理体积非常大。 描述整个森林的对象在一帧的时间就交给 GPU 实在是太过了。 幸运的是，有一种老办法来处理它：**关键点在于，哪怕森林里有千千万万的树，它们大多数长得一模一样。 它们使用了相同的网格和纹理。 这意味着这些树的实例的大部分字段是*一样的*。**
>
> > 你要么是疯了，要么是亿万富翁，才能让美术给森林里每棵树建立独立模型。
>
> ![一行树，每棵都有自己的网格、纹理、树叶，调节参数和位置朝向。](https://gpp.tkchu.me/images/flyweight-trees.png)注意每一棵树的小盒子中的东西都是一样的。
>
> **我们可以通过显式地将对象切为两部分来更加明确地模拟。**
>
> 第一，将树共有的数据拿出来分离到另一个类中：
>
> ```C++
> class TreeModel {
> private:
>   Mesh mesh_;
>   Texture bark_;
>   Texture leaves_;
> };
> ```
>
> 游戏只需要一个这种类， 因为没有必要在内存中把相同的网格和纹理重复一千遍。 游戏世界中每个树的实例只需有一个对这个共享`TreeModel`的*引用*。 留在`Tree`中的是那些实例相关的数据：
>
> ```C++
> class Tree {
> private:
>   TreeModel* model_;
>
>   Vector position_;
>   double height_;
>   double thickness_;
>   Color barkTint_;
>   Color leafTint_;
> };
> ```
>
> 你可以将其想象成这样：
>
> ![一行树，每个都有自己的参数和位置朝向，指向另一个有网格、纹理、树叶的树模型。](https://gpp.tkchu.me/images/flyweight-tree-model.png)
>
> 不过，虽然把所有的东西都存在主存里没什么问题，但是这对渲染也毫无帮助——在森林到屏幕上之前，它得先到 GPU。我们需要用显卡可以识别的方式共享数据。
>
> 为了减少需要推送到 GPU 的数据量，我们想把共享的数据——`TreeModel`——只发送*一次*。 然后再分别发送每个树独特的数据——位置，颜色，大小。 最后，我们告诉 GPU，“使用同一模型渲染每个实例”。
>
> 幸运的是，今日的图形接口和显卡正好支持这一点。 这些细节很繁琐且超出了这部书的范围，但是 Direct3D 和 OpenGL 都可以做[_实例渲染_](http://en.wikipedia.org/wiki/Geometry_instancing)。
>
> 在这些 API 中，你需要提供两部分数据流。 第一部分是一块需要渲染多次的共同数据——在例子中是树的网格和纹理。 第二部分是实例的列表以及绘制第一部分时需要使用的参数。 然后调用一次渲染，绘制整个森林。
>
> 这个 API 是由显卡直接实现的，我们可以说，享元模式是唯一的有硬件支持的 GoF 设计模式。

#### 介绍

好了，我们已经看了一个具体的例子，下面我介绍模式的通用部分。 享元，就像它的名字暗示的那样， 当你需要共享类时使用，通常是因为你有太多这种类了。

实例渲染时，每棵树通过总线送到 GPU 消耗的更多是*时间*而非内存，但是基本要点是一样的。

这个模式通过将对象的数据分为两种来解决这个问题。 第一种数据没有特定指明是哪个对象的*实例*，因此可以在它们间分享。 Gof 称之为*固有*状态，但是我更喜欢将其视为“上下文无关”部分。 在这里的例子中，是树的网格和纹理。

数据的剩余部分是*变化*状态，那些每个实例独一无二的东西。 在这个例子中，是每棵树的位置，拉伸和颜色。 就像这里的示例代码块一样，这种模式通过在每个对象出现时共享一份固有状态来节约内存。

就目前而言，这看上去像是基础的资源共享，很难被称为一种模式。 部分原因是在这个例子中，我们可以为共享状态划出一个清晰的*身份*：`TreeModel`。

我发现，当共享对象没有有效定义的实体时，使用这种模式就不那么明显（使用它也就越发显得精明）。 在那些情况下，这看上去是一个对象被魔术般地同时分配到了多个地方。 让我展示给你另外一个例子。

#### 合理示例

这些树长出来的地方也需要在游戏中表示。 这里可能有草，泥土，丘陵，湖泊，河流，以及其它任何你可以想到的地形。 我们*基于区块*建立地表：世界的表面被划分为由微小区块组成的巨大网格。 每个区块都由一种地形覆盖。

每种地形类型都有一系列特性会影响游戏玩法：

- 决定了玩家能够多快地穿过它的移动开销。
- 表明能否用船穿过的水域标识。
- 用来渲染它的纹理。

基于前面的教训，我们不会在每个区块中保存这些状态。 相反，一个通用的方式是为每种地形使用一个枚举。

```C++
enum Terrain {
  TERRAIN_GRASS,
  TERRAIN_HILL,
  TERRAIN_RIVER
  // 其他地形
};
```

然后，世界管理巨大的网格：

```C++
class World {
private:
  Terrain tiles_[WIDTH][HEIGHT];
};
```

> 这里我使用嵌套数组存储 2D 网格。 在 C/C++中这样是很有效率的，因为它会将所有元素打包在一起。 在 Java 或者其他内存管理语言中，那样做会实际给你一个数组，其中每个元素都是对数组的列的*引用*，那就不像你想要的那样内存友好了。
>
> 反正，隐藏 2D 网格数据结构背后的实现细节，能使代码更好地工作。 我这里这样做只是为了让其保持简单。

为了获得区块的实际有用的数据，我们做了一些这样的事情：

```C++
int World::getMovementCost(int x, int y) {
  switch (tiles_[x][y]) {
    case TERRAIN_GRASS: return 1;
    case TERRAIN_HILL:  return 3;
    case TERRAIN_RIVER: return 2;
      // 其他地形……
  }
}

bool World::isWater(int x, int y) {
  switch (tiles_[x][y]) {
    case TERRAIN_GRASS: return false;
    case TERRAIN_HILL:  return false;
    case TERRAIN_RIVER: return true;
      // 其他地形……
  }
}
```

你知道我的意思了。这可行，但是我觉得很丑。 移动开销和水域标识是区块的*数据*，但在这里它们散布在代码中。 更糟的是，简单地形的数据被众多方法拆开了。 如果能够将这些包裹起来就好了。毕竟，那是我们设计对象的目的。

如果我们有实际的地形*类*就好了，像这样：

```c++
class Terrain {
public:
  Terrain(int movementCost,
          bool isWater,
          Texture texture)
  : movementCost_(movementCost),
    isWater_(isWater),
    texture_(texture)
  {}

  int getMovementCost() const { return movementCost_; }
  bool isWater() const { return isWater_; }
  const Texture& getTexture() const { return texture_; }

private:
  int movementCost_;
  bool isWater_;
  Texture texture_;
};
```

你会注意这里所有的方法都是`const`。这不是巧合。 由于同一对象在多处引用，如果你修改了它， 改变会同时在多个地方出现。

这也许不是你想要的。 通过分享对象来节约内存的这种优化，不应该影响到应用的显性行为。 因此，享元对象几乎总是不可变的。

但是我们不想为每个区块都保存一个实例。 如果你看看这个类内部，你会发现里面实际上*什么也没有*， 唯一特别的是区块在*哪里*。 用享元的术语讲，区块的*所有*状态都是“固有的”或者说“上下文无关的”。

鉴于此，我们没有必要保存多个同种地形类型。 地面上的草区块两两无异。 我们不用地形区块对象枚举构成世界网格，而是用`Terrain`对象*指针*组成网格：

```
class World
{
private:
  Terrain* tiles_[WIDTH][HEIGHT];

  // 其他代码……
};
```

每个相同地形的区块会指向相同的地形实例。

![一行区块，每个区块指向共享的草、河、山丘对象。](https://gpp.tkchu.me/images/flyweight-tiles.png)

由于地形实例在很多地方使用，如果你想要动态分配，它们的生命周期会有点复杂。 因此，我们直接在游戏世界中存储它们。

```
class World
{
public:
  World()
  : grassTerrain_(1, false, GRASS_TEXTURE),
    hillTerrain_(3, false, HILL_TEXTURE),
    riverTerrain_(2, true, RIVER_TEXTURE)
  {}

private:
  Terrain grassTerrain_;
  Terrain hillTerrain_;
  Terrain riverTerrain_;

  // 其他代码……
};
```

然后我们可以像这样来描绘地面：

```
void World::generateTerrain()
{
  // 将地面填满草皮.
  for (int x = 0; x < WIDTH; x++)
  {
    for (int y = 0; y < HEIGHT; y++)
    {
      // 加入一些丘陵
      if (random(10) == 0)
      {
        tiles_[x][y] = &hillTerrain_;
      }
      else
      {
        tiles_[x][y] = &grassTerrain_;
      }
    }
  }

  // 放置河流
  int x = random(WIDTH);
  for (int y = 0; y < HEIGHT; y++) {
    tiles_[x][y] = &riverTerrain_;
  }
}
```

我承认这不是世界上最好的地形生成算法。

现在不需要`World`中的方法来接触地形属性，我们可以直接暴露出`Terrain`对象。

```
const Terrain& World::getTile(int x, int y) const
{
  return *tiles_[x][y];
}
```

用这种方式，`World`不再与各种地形的细节耦合。 如果你想要某一区块的属性，可直接从那个对象获得：

```
int cost = world.getTile(2, 3).getMovementCost();
```

我们回到了操作实体对象的 API，几乎没有额外开销——指针通常不比枚举大。

### 观察者模式

观察者模式是 C#中的一个基本模式，已经以 `event` 语法的形式嵌入了整个语言中。

#### 引入

> 假设我们向游戏中添加了成就系统。 它存储了玩家可以完成的各种各样的成就，比如“杀死 1000 只猴子恶魔”，“从桥上掉下去”，或者“一命通关”。
>
> ![成就：一无所成](https://gpp.tkchu.me/images/observer-weasel-wielder.png)
> 我发誓画的这个没有第二个意思，笑。
>
> 要实现这样一个包含各种行为来解锁成就的系统是很有技巧的。 如果我们不够小心，成就系统会缠绕在代码库的每个黑暗角落。 当然，“从桥上掉落”和物理引擎相关， 但我们并不想看到在处理撞击代码的线性代数时， 有个对`unlockFallOffBridge()`的调用是不？
>
> 我们喜欢的是，照旧，让关注游戏一部分的所有代码集成到一块。挑战在于，成就在游戏的不同层面被触发。怎么解耦成就系统和其他部分呢？
>
> 这就是观察者模式出现的原因。这让代码宣称有趣的事情发生了，_而不必关心到底是谁接受了通知。_
>
> 举个例子，有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。 为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。 相反，可以这样做：
>
> ```C++
> void Physics::updateEntity(Entity& entity) {
>   bool wasOnSurface = entity.isOnSurface();
>   entity.accelerate(GRAVITY);
>   entity.update();
>   if (wasOnSurface && !entity.isOnSurface()) {
>     notify(entity, EVENT_START_FALL);
>   }
> }
> // 物理引擎确实决定了要发送什么通知，所以这并没有完全解耦。但在架构这个领域，通常只能让系统变得*更好*，而不是*完美*。
> ```
>
> 它做的就是声称，“额，我不知道有谁感兴趣，但是这个东西刚刚掉下去了。做你想做的事吧。”
>
> 成就系统注册它自己为观察者，这样无论何时物理代码发送通知，成就系统都能收到。 它可以检查掉落的物体是不是我们的失足英雄， 他之前有没有做过这种不愉快的与桥的经典力学遭遇。 如果满足条件，就伴着礼花和炫光解锁合适的成就，而这些都无需牵扯到物理代码。
>
> 事实上，我们可以改变成就的集合或者删除整个成就系统，而不必修改物理引擎。 它仍然会发送它的通知，哪怕实际没有东西接收。

#### 介绍

在观察者模式中，我们理所当然地存在两个主要对象：观察者和被观察者

我们可以这样简单归纳这两者的关系：观察者订阅被观察者的状态，当被观察者状态改变时，被观察者主动通知所有订阅的观察者。

##### 观察者

我们从那个需要知道别的对象做了什么事的类开始。 这些好打听的对象用如下接口定义：

```c++
class Observer
{
public:
  virtual ~Observer() {}
  virtual void onNotify(const Entity& entity, Event event) = 0;
};
```

任何实现了这个的具体类就成为了观察者。 在我们的例子中，是成就系统，所以我们可以像这样实现：

```c++
class Achievements : public Observer {
public:
  virtual void onNotify(const Entity& entity, Event event) {
    switch (event) {
    case EVENT_ENTITY_FELL:
      if (entity.isHero() && heroIsOnBridge_) {
        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
      }
      break;

      // 处理其他事件，更新heroIsOnBridge_变量……
    }
  }

private:
  void unlock(Achievement achievement) {
    // 如果还没有解锁，那就解锁成就……
  }

  bool heroIsOnBridge_;
};
```

##### 被观察者

被观察的对象拥有通知的方法函数，用 GoF 的说法，那些对象被称为“主题”。 它有两个任务。首先，它有一个列表，保存默默等它通知的观察者：

```C++
class Subject
{
private:
  Observer* observers_[MAX_OBSERVERS];
  int numObservers_;
};
```

重点是被观察者暴露了*公开的*API 来修改这个列表：

```c++
class Subject {
public:
  void addObserver(Observer* observer) {
    // 添加到数组中……
  }

  void removeObserver(Observer* observer) {
    // 从数组中移除……
  }

  // 其他代码……
};
```

这就允许了外界代码控制谁接收通知。 \*被观察者与观察者交流，但是不与它们**耦合\***。 在我们的例子中，没有一行物理代码会提及成就。 但它仍然可以与成就系统交流。这就是这个模式的聪慧之处。

被观察者有一*列表*观察者而不是单个观察者也是很重要的。 这保证了观察者不会相互干扰。 举个例子，假设音频引擎也需要观察坠落事件来播放合适的音乐。 如果客体只支持单个观察者，当音频引擎注册时，就会*取消*成就系统的注册。这意味着这两个系统需要相互交互——而且是用一种极其糟糕的方式， 第二个注册时会使第一个的注册失效。 支持一列表的观察者保证了每个观察者都是被独立处理的。 就它们各自的视角来看，自己是这世界上唯一看着被观察者的。

被观察者的剩余任务就是发送通知：

```c++
class Subject {
protected:
  void notify(const Entity& entity, Event event) {
    for (int i = 0; i < numObservers_; i++) {
      observers_[i]->onNotify(entity, event);
    }
  }

  // 其他代码…………
};
```

现在，我们只需要给物理引擎和这些挂钩，这样它可以发送消息， 成就系统可以和引擎连线来接受消息。 我们按照传统的*设计模式*方法实现，继承`Subject`：

```c++
class Physics : public Subject {
public:
  void updateEntity(Entity& entity);
};
```

这让我们将`notify()`实现为了`Subject`内的保护方法。 这样派生的物理引擎类可以调用并发送通知，但是外部的代码不行。 同时，`addObserver()`和`removeObserver()`是公开的， 所以任何可以接触物理引擎的东西都可以观察它。

在真实代码中，我会避免使用这里的继承。 相反，我会让`Physics` _有_ 一个`Subject`的实例。 不再是观察物理引擎本身，被观察的会是独立的“下落事件”对象。 观察者可以用像这样注册它们自己：

```c++
physics.entityFell()
  .addObserver(this);
```

对我而言，这是“观察者”系统与“事件”系统的不同之处。 使用前者，你观察*做了有趣事情的事物*。 使用后者，你观察的对象代表了*发生的有趣事情*。

现在，当物理引擎做了些值得关注的事情，它调用`notify()`，就像之前的例子。 它遍历了观察者列表，通知所有观察者。

![被观察者包含一列表观察者的指针。前两个指向成就和音频系统。](https://gpp.tkchu.me/images/observer-list.png)

很简单，对吧？只要一个类管理一列表指向接口实例的指针。 难以置信的是，如此直观的东西是无数程序和应用框架交流的主心骨。

观察者模式不是完美无缺的。当我问其他程序员怎么看，他们提出了一些抱怨。 让我们看看可以做些什么来处理这些抱怨。

#### 观察者模式的一般实现

创建 Subject 类：

```java
import java.util.ArrayList;
import java.util.List;

public class Subject {
   private List<Observer> observers  = new ArrayList<Observer>();
   private int state;

   public int getState() {
      return state;
   }

   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }

   public void attach(Observer observer){
      observers.add(observer);
   }

   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }
}
```

创建 Observer 类：

```java
public abstract class Observer {
   protected Subject subject;
   public abstract void update();
}
```

创建实体观察者类：

```java
public class BinaryObserver extends Observer{
   public BinaryObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
   @Override
   public void update() {
      System.out.println( "Binary String: " + Integer.toBinaryString( subject.getState() ) );
   }
}

public class OctalObserver extends Observer{
   public OctalObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
   @Override
   public void update() {
     System.out.println( "Octal String: " + Integer.toOctalString( subject.getState() ) );
   }
}

public class HexaObserver extends Observer{
   public HexaObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
   @Override
   public void update() {
      System.out.println( "Hex String: " + Integer.toHexString( subject.getState() ).toUpperCase() );
   }
}
```

使用 _Subject_ 和实体观察者对象：

```java
public class ObserverPatternDemo {
   public static void main(String[] args) {
      Subject subject = new Subject();

      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);

      System.out.println("First state change: 15");
      subject.setState(15);
      System.out.println("Second state change: 10");
      subject.setState(10);
   }
}
```

执行程序，输出结果：

```c++
First state change: 15
Hex String: F
Octal String: 17
Binary String: 1111
Second state change: 10
Hex String: A
Octal String: 12
Binary String: 1010
```

### 原型模式

> 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。这种模式实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。

#### 正式采用原型设计模式

原型模式的关键思路是*一个对象可以产出与它自己相近的对象。* 如果你有一个恶灵，你可以制造更多恶灵。 如果你有一个恶魔，你可以制造其他恶魔。 任何怪物都可以被视为*原型*怪物，产出其他版本的自己。

为了实现这个功能，我们给基类`Monster`添加一个抽象方法`clone()`：

创建一个顶级的基类

```c++
class Monster
{
public:
  virtual ~Monster() {}
  virtual Monster* clone() = 0;

  // 其他代码……
};
```

每个怪兽子类提供一个特定实现，返回与它自己的类和状态都完全一样的新对象。举个例子：

```C++
class Ghost : public Monster {
public:
  Ghost(int health, int speed)
  : health_(health),
    speed_(speed)
  {}
  // 关键在于特定实现中覆写的clone方法
  virtual Monster* clone() {
    return new Ghost(health_, speed_);
  }

private:
  int health_;
  int speed_;
};
```

一旦我们所有的怪物都支持这个， 我们不再需要为每个怪物类创建生产者类。我们只需定义一个类：

```c++
class Spawner
{
public:
  Spawner(Monster* prototype)
  : prototype_(prototype)
  {}

  Monster* spawnMonster()
  {
    return prototype_->clone();
  }

private:
  Monster* prototype_;
};
```

它内部存有一个怪物，一个隐藏的怪物， 它唯一的任务就是被生产者当做模板，去产生更多一样的怪物， 有点像一个从来不离开巢穴的蜂后。

![一个生产者包含一个对怪物应用的原型字段。 他调用原型的clone()方法来产生新的怪物。](https://gpp.tkchu.me/images/prototype-spawner.png)

为了得到恶灵生产者，我们创建一个恶灵的原型实例，然后创建拥有这个实例的生产者：

```c++
Monster* ghostPrototype = new Ghost(15, 3);
Spawner* ghostSpawner = new Spawner(ghostPrototype);
```

这个模式的灵巧之处在于它不但拷贝原型的*类*，也拷贝它的*状态*。 这就意味着我们可以创建一个生产者，生产快速鬼魂，虚弱鬼魂，慢速鬼魂，而只需创建一个合适的原型鬼魂。

我在这个模式中找到了一些既优雅又令人惊叹的东西。 我无法想象自己是如何创造出它们的，但我更无法想象*不知道*这些东西的自己该如何是好。

> **效果如何?**
>
> 好吧，我们不需要为每个怪物创建单独的生产者类，那很好。 但我们*确实*需要在每个怪物类中实现`clone()`。 这和使用生产者方法比起来也没节约多少代码量。
>
> 当你坐下来试着写一个正确的`clone()`，会遇见令人不快的语义漏洞。 做深层拷贝还是浅层拷贝呢？换言之，如果恶魔拿着叉子，克隆恶魔也要克隆叉子吗？
>
> 同时，这看上去没减少已存问题上的代码， 事实上还增添了些*人为的问题*。 我们需要将每个怪物有独立的类作为前提条件。 这绝对*不是*当今大多数游戏引擎运作的方法。
>
> 我们中大部分痛苦地学到，这样庞杂的类层次管理起来很痛苦， 那就是我们为什么用[组件模式](https://gpp.tkchu.me/component.html)和[类型对象](https://gpp.tkchu.me/type-object.html)为不同的实体建模，这样无需一一建构自己的类。

#### 用原型模式来优化数据结构

随着编程的进行，如果你比较程序与数据的字节数， 那么你会发现数据的占比稳定地增长。 早期的游戏在程序中生成几乎所有东西，这样程序可以塞进磁盘和老式游戏卡带。 在今日的游戏中，代码只是驱动游戏的“引擎”，游戏是完全由数据定义的。

这很好，但是将内容推到数据文件中并不能魔术般地解决组织大项目的挑战。 它只能把这挑战变得更难。 我们使用高级编程语言就因为它们有办法管理复杂性：不再是将一堆代码拷来拷去，我们将其移入函数中，通过名字调用。 不再是在一堆类之间复制方法，我们将其放入单独的类中，让其他类可以继承或者组合。

让我们在游戏中考虑考虑：使用原型和委托来重用数据。

游戏中的哥布林也许被定义为像这样的东西：

```json
{
  "name": "goblin grunt",
  "minHealth": 20,
  "maxHealth": 30,
  "resists": ["cold", "poison"],
  "weaknesses": ["fire", "light"]
}
```

这看上去很易懂，哪怕是最讨厌文本的设计者也能使用它。 所以，你可以给哥布林大家族添加几个兄弟分支：

```json
{
  "name": "goblin wizard",
  "minHealth": 20,
  "maxHealth": 30,
  "resists": ["cold", "poison"],
  "weaknesses": ["fire", "light"],
  "spells": ["fire ball", "lightning bolt"]
}

{
  "name": "goblin archer",
  "minHealth": 20,
  "maxHealth": 30,
  "resists": ["cold", "poison"],
  "weaknesses": ["fire", "light"],
  "attacks": ["short bow"]
}
```

现在，如果这是代码，我们会闻到了臭味。 在实体间有很多的重复，训练优良的程序员*讨厌*重复。 它浪费了空间，消耗了作者更多时间。 你需要仔细阅读代码才知道这些数据*是不是*相同的。 这难以维护。 如果我们决定让所有哥布林变强，需要记得将三个哥布林都更新一遍。糟糕糟糕糟糕。

如果这是代码，我们会为“哥布林”构建抽象，并在三个哥布林类型中重用。 但是无能的 JSON 没法这么做。所以让我们把它做得更加巧妙些。

**我们可以为对象添加`"prototype"`字段，记录委托对象的名字。 如果在此对象内没找到一个字段，那就去委托对象中查找。**

这样，我们可以简化我们的哥布林 JSON 内容：

```json
{
  "name": "goblin grunt",
  "minHealth": 20,
  "maxHealth": 30,
  "resists": ["cold", "poison"],
  "weaknesses": ["fire", "light"]
}

{
  "name": "goblin wizard",
  "prototype": "goblin grunt",
  "spells": ["fire ball", "lightning bolt"]
}

{
  "name": "goblin archer",
  "prototype": "goblin grunt",
  "attacks": ["short bow"]
}
```

由于弓箭手和术士都将 grunt 作为 `原型`，我们就不需要在它们中重复血量，防御和弱点。 我们为数据模型增加的逻辑超级简单——基本的单一委托——但已经成功摆脱了一堆冗余。

有趣的事情是，我们没有更进一步，把哥布林委托的*抽象*原型设置成“基本哥布林”。 相反，我们选择了最简单的哥布林，然后委托给它。

在基于原型的系统中，对象可以克隆产生新对象是很自然的， 我认为在这里也一样自然。这特别适合记录那些只有一处不同的实体的数据。

想想 Boss 和其他独特的事物，它们通常是更加常见事物的重新定义， 原型委托是定义它们的好方法。 断头魔剑，就是一把拥有加成的长剑，可以像下面这样表示：

```json
{
  "name": "Sword of Head-Detaching",
  "prototype": "longsword",
  "damageBonus": "20"
}
```

只需在游戏引擎上多花点时间，你就能让设计者更加方便地添加不同的武器和怪物，而增加的这些丰富度能够取悦玩家。

### 单例模式

_设计模式_ 像这样描述单例模式：

> 保证一个类只有一个实例，并且提供了访问该实例的全局访问点。

我们从“并且”那里将句子分为两部分，分别进行考虑。

#### [保证一个类只有一个实例](https://gpp.tkchu.me/singleton.html#保证一个类只有一个实例)

有时候，如果类存在多个实例就不能正确的运行。 通常发生在类与保存全局状态的外部系统互动时。

考虑封装文件系统的 API 类。 因为文件操作需要一段时间完成，所以类使用异步操作。 这就意味着可以同时运行多个操作，必须让它们相互协调。 如果一个操作创建文件，另一个操作删除同一文件，封装器类需要同时考虑，保证它们没有相互妨碍。

为了实现这点，对我们封装器类的调用必须接触之前的每个操作。 如果用户可以自由地创建类的实例，这个实例就无法知道另一实例之前的操作。 而单例模式提供的构建类的方式，在编译时保证类只有单一实例。

#### [提供了访问该实例的全局访问点](https://gpp.tkchu.me/singleton.html#提供了访问该实例的全局访问点)

游戏中的不同系统都会使用文件系统封装类：日志，内容加载，游戏状态保存，等等。 如果这些系统不能创建文件系统封装类的实例，它们如何访问该实例呢？

单例为这点也提供了解决方案。 除了创建单一实例以外，它也提供了一种获得它的全局方法。 使用这种范式，无论何处何人都可以访问实例。 综合起来，经典的实现方案如下：

```c++
class FileSystem {
public:
  static FileSystem& instance() {
    // 惰性初始化
    if (instance_ == NULL) instance_ = new FileSystem();
    return *instance_;
  }

private:
  FileSystem() {}

  static FileSystem* instance_;
};
```

静态的`instance_`成员保存了一个类的实例， 私有的构造器保证了它是*唯一*的。 公开的静态方法`instance()`让任何地方的代码都能访问实例。 在首次被请求时，它同样负责惰性实例化该单例。

现代的实现方案看起来是这样的：

```C++
class FileSystem {
public:
  static FileSystem& instance() {
    static FileSystem *instance = new FileSystem();
    return *instance;
  }

private:
  FileSystem() {}
};
```

哪怕是在多线程情况下，C++11 标准也保证了本地静态变量只会初始化一次， 因此，假设你有一个现代 C++编译器，这段代码是线程安全的，而前面的那个例子不是。

#### C#

Double Check 的懒汉模式

```c#
public sealed class Singleton {
    private static volatile Singleton _instance;
    private static readonly object _lockObject = new Object();

    public static Singleton Instance {
        get {
            if (_instance == null) {
                lock (_lockObject) {
                    if (_instance == null) { _instance = new Singleton(); }
                }
            }
            return _instance;
        }
    }
}
```

Lazy\<T\>的懒汉模式

```C#
public class LazySingleton {
    private static readonly Lazy<LazySingleton> _instance = new Lazy<LazySingleton>(() => new LazySingleton());

    public static LazySingleton Instance {
        get { return _instance.Value; }
    }

    private LazySingleton() { }
}
```

[Lazy thread-safe Singleton using LazyT (programming-books.io)](https://www.programming-books.io/essential/csharp/lazy-thread-safe-singleton-using-lazyt-d94da571077a42519f1a67c1b4b23584)

> .Net 4.0 type Lazy guarantees thread-safe object initialization, so this type could be used to make Singletons.
>
> Using `Lazy<T>` will make sure that the object is only instantiated when it is used somewhere in the calling code.

#### 单例模式的弊端

### 状态模式

我们用状态模式来解决繁复状态切换的代码，这种模式与状态机的构造紧密相连。

## Reference

- [游戏编程模式 (tkchu.me)](https://gpp.tkchu.me/)
- [设计模式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
