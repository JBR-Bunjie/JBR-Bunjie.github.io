---
title: Shader Book Github Issue Collections
date: 2023-3-8 21:29:45
tags:
  - Unity
  - Shader
categories:
  - Unity
<!--feature: true-->
cover: https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg
---

# Shader Book Github Issue Collections

[saturate 和 max · Issue #198 · candycat1992/Unity_Shaders_Book (github.com)](https://github.com/candycat1992/Unity_Shaders_Book/issues/198)

为什么后来从 sature 改到了 max？

> > Q: 在基础光照那一章中，我看到计算 worldNormal 与 worldLightDir 的时候用的是 saturate，而后面章节使用的是 max（0，…），这两个方法在计算结果上会产生什么差异吗？
>
> > A: 对于那些值范围在-1 到 1 的变量，两个方法在计算结果上没有区别。不过，saturate 在 Unity 里通常会编译成两个指令，大致是 min(max(val, 0.0), 1.0)，如果自己知道值的范围可以直接使用 max 来节省一条运算指令。
>
> > AQ: 我在 Unity 里面，点 Shader 属性中 “Compile and show code”按钮，看到
> >
> > ```
> > u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);
> > u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
> > ```
> >
> > 对应的是 `saturate(dot(lightDir, worldNormal)); `。所以应该不是解析成 `min(max(val, 0.0), 1.0)`吧？
> >
> > 因为今天看到《Real-time Rendering 3rd》5.5 节 115 页 中提到
> >
> > > **staturate** is faster than the more general **max** function on most hardware.
> >
> > 所以有点奇怪。
>
> > AA: [@alasja](https://github.com/alasja) 我之前的回答的确说得很模糊，这里补充下。
> >
> > 在 Unity 里，同一份 ShaderLab 代码在不同目标平台上、甚至不同设备上编译结果都是不同的。比如同样一份 fragment shader：
> >
> > ```
> > fixed4 frag (v2f i) : SV_Target
> > {
> > 	fixed4 col = i.uv.xyxy;
> > 	col = saturate(col);
> > 	return col;
> > }
> > ```
> >
> > 在 DX9 下，编译出来就是：
> >
> > ```
> > -- Fragment shader for "d3d9":
> > // Stats: 1 math
> > Shader Disassembly:
> > //
> > // Generated by Microsoft (R) HLSL Shader Compiler 10.1
> >     ps_3_0
> >     dcl_texcoord_pp v0.xy
> >     mov_sat_pp oC0, v0.xyxy
> >
> > // approximately 1 instruction slot used
> > ```
> >
> > DX11 下就是：
> >
> > ```
> > -- Fragment shader for "d3d11":
> > Shader Disassembly:
> > //
> > // Generated by Microsoft (R) D3D Shader Disassembler
> > //
> > //
> > // Input signature:
> > //
> > // Name                 Index   Mask Register SysValue  Format   Used
> > // -------------------- ----- ------ -------- -------- ------- ------
> > // TEXCOORD                 0   xy          0     NONE   float   xy
> > // SV_POSITION              0   xyzw        1      POS   float
> > //
> > //
> > // Output signature:
> > //
> > // Name                 Index   Mask Register SysValue  Format   Used
> > // -------------------- ----- ------ -------- -------- ------- ------
> > // SV_Target                0   xyzw        0   TARGET   float   xyzw
> > //
> >       ps_4_0
> >       dcl_input_ps linear v0.xy
> >       dcl_output o0.xyzw
> >    0: mov_sat o0.xyzw, v0.xyxy
> >    1: ret
> > // Approximately 0 instruction slots used
> > ```
> >
> > OpenGL ES2.0 下是：
> >
> > ```
> > #ifdef FRAGMENT
> > varying highp vec2 xlv_TEXCOORD0;
> > void main ()
> > {
> >   lowp vec4 col_1;
> >   highp vec4 tmpvar_2;
> >   tmpvar_2 = xlv_TEXCOORD0.xyxy;
> >   col_1 = tmpvar_2;
> >   lowp vec4 tmpvar_3;
> >   tmpvar_3 = clamp (col_1, 0.0, 1.0);
> >   col_1 = tmpvar_3;
> >   gl_FragData[0] = tmpvar_3;
> > }
> > ```
> >
> > OpenGLES 3.0 下是：
> >
> > ```
> > #ifdef FRAGMENT
> > #version 300 es
> >
> > precision highp int;
> > in highp vec2 vs_TEXCOORD0;
> > layout(location = 0) out mediump vec4 SV_Target0;
> > void main()
> > {
> >     SV_Target0 = vs_TEXCOORD0.xyxy;
> > #ifdef UNITY_ADRENO_ES3
> >     SV_Target0 = min(max(SV_Target0, 0.0), 1.0);
> > #else
> >     SV_Target0 = clamp(SV_Target0, 0.0, 1.0);
> > #endif
> >     return;
> > }
> >
> > #endif
> > ```
> >
> > Metal 下是：
> >
> > ```
> > -- Fragment shader for "metal":
> > Shader Disassembly:
> > #include <metal_stdlib>
> > #include <metal_texture>
> > using namespace metal;
> > struct Mtl_FragmentIn
> > {
> >     float2 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
> > };
> >
> > struct Mtl_FragmentOut
> > {
> >     float4 SV_Target0 [[ color(0) ]];
> > };
> >
> > fragment Mtl_FragmentOut xlatMtlMain(
> >     Mtl_FragmentIn input [[ stage_in ]])
> > {
> >     Mtl_FragmentOut output;
> >     output.SV_Target0 = input.TEXCOORD0.xyxy;
> >     output.SV_Target0 = clamp(output.SV_Target0, 0.0f, 1.0f);
> >     return output;
> > }
> > ```
> >
> > Vulkan 太长了我就不粘贴了……
> >
> > 你可以看出来在一些平台下，比如 DX9、DX11 下，编译出来的确是使用真正的 saturate 运算操作，而在大多数移动平台上，比如 ES 2.0、Metal 等，是编译成了 clamp，而在 ES 3.0 下跟设备还有关系。至于为什么要分这么多种情况，Unity 应该是根据各个平台每种操作耗时的平衡，**选择同等运算结果下最优的等价操作来代替 saturate**。

[关于屏幕后处理效果的疑问 · Issue #59 · candycat1992/Unity_Shaders_Book (github.com)](https://github.com/candycat1992/Unity_Shaders_Book/issues/59)

> 的确，屏幕后处理本身本质上是在近裁剪平面处又渲染了一个四边形，这个四边形使用的是我们自定义的材质和 shader，它的确本身会走一遍流水管线。
>
> 网上说的它是“流水线的最后阶段”，是想指明我们操作的顺序，也就是说我们会在进行完其他物体的渲染后，最后进行这个操作。

[高斯模糊代码化简建议 · Issue #194 · candycat1992/Unity_Shaders_Book (github.com)](https://github.com/candycat1992/Unity_Shaders_Book/issues/194)
