---
title: Regex
date: 2022-12-23 12:23:23
tags:
  - String Processing
  - Regex
categories:
  - Algorithm
<!--feature: true-->
cover: https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg
---

1. 让匹配更快失败，尤其是匹配很长的字符串时，匹配失败的位置要比成功的位置多得多。

2. 以简单、必须的字元开始，排除明显不匹配的位置，如锚点(^或$)，特殊字符(x或\u263A)字符类([a-z]或\d之类的速记符)，和单词边界(\b)；尽量避免使用分组、选择、重复量词开头，如/one|two/、\s、\s{1,}等。
3. 使用量词模式时，尽量让重复部分具体化，让字元互斥，如用”[^"\r\n]*”代替”.*?”（这个依赖回溯）。

4. 减少分支数量、缩小分支范围，用字符集和选项组件来减少分支的出现，或把分支在正则上出现的位置推后，把分支中最常出现的情况放在分支的最前面。

   ```bash
   cat|bat -> [cb]at;red|read -> rea?d;red|raw -> r(?:ed|aw); 
   
   (.|\r|\n) -> [\s\S]
   ```

5. 精确匹配需要的文本以减少后续的处理，如果需要引用匹配的一部分，可使用捕获，然后通过反向引用来处理。
6. 暴露必需的字元，用`/^(ab|cd)/`而不是`/(^ab|^cd)/`。
7. 使用合适的量词，基于预期的回溯数量，使用合适的量词类型。
8. 把正则表达式赋值给变量以便复用和提升提升性能，这样可以让正则减少不必要的编译过程。while (/regex1/.test(str1)) {/regex2/.exec(str2);…}用下面的代替上面的   var regex1 = /regex1/,regex2 = /regex2/;while (regex1.test(str1)) {regex2.exec(str2);…}
9. 将复杂的正则表达式拆分成简单的片段，每个正则只在上一个成功的匹配中查找，更高效，而且可以减少回溯。
10. 使用非捕获组，因为捕获组需要消耗时间和内存来记录反向引用，并不断更新，如果不需要反向引用，可用非捕获组(?:…)代替捕获组(…)；当需要全文匹配的反向引用时，可用regex.exec()返回的结果或者在替换字符串是使用$&。   此优化在firefox中效果较小，但其他浏览器中处理长字符串时有较大影响



And More？

[觉得正则表达式太慢？这里有一个提速100倍的方案！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/47401769)

项目地址

[vi3k6i5/flashtext: Extract Keywords from sentence or Replace keywords in sentences. (github.com)](https://github.com/vi3k6i5/flashtext)