{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/yeild","date":"2023-03-07T16:14:45.230Z","updated":"2023-01-31T13:44:00.227Z","comments":true,"path":"api/articles/Language Learning/yeild.json","keywords":null,"cover":null,"content":"<p>关键词：<code>yeild关键字</code>，<code>yeild return</code>，<code>生成器函数</code>，<code>协程</code></p>\r\n<h2 id=\"yeild-in-js\">Yeild in JS</h2>\r\n<p><a\r\nhref=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield\">yield\r\n- JavaScript | MDN (mozilla.org)</a></p>\r\n<p><a\r\nhref=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*\">function*\r\n- JavaScript | MDN (mozilla.org)</a></p>\r\n<p>简单地说，Yeild可以在JS中暂停一个生成器函数，当我们再次呼叫这个生成器函数示例时，我们就可以该示例相关的一次结果</p>\r\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function* foo(index) &#123;\n  while (index &lt; 5) &#123;\n    yield index;\n    index++;\n  &#125;\n&#125;\n\nconst iterator &#x3D; foo(0);\n\nconsole.log(iterator.next().value);\n&#x2F;&#x2F; Expected output: 0\n\nconsole.log(iterator.next().value);\n&#x2F;&#x2F; Expected output: 1\n\nconsole.log(iterator.next().value); &#x2F;&#x2F; 2\nconsole.log(iterator.next().value); &#x2F;&#x2F; 3\nconsole.log(iterator.next().value); &#x2F;&#x2F; 4\nconsole.log(iterator.next().value); &#x2F;&#x2F; undefined</code></pre>\r\n<h2 id=\"yeild-in-python\">Yeild in Python</h2>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/268605982\">如何理解Python中的yield用法?\r\n- 知乎 (zhihu.com)</a></p>\r\n<p>事实上，Python中的yield与JS中的yield十分相近：同样是对规则的定义、会暂停执行函数，返回generator对象等等。</p>\r\n<p>不同的是，Python不需要使用类似<code>function*</code>这样的单独的定义字符。</p>\r\n<p>不过，在Python中我们可以直接使用for等方法来直接遍历整个生成器对象来快速获得全部的结果。</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def fab(max): \n    n, a, b &#x3D; 0, 0, 1 \n    while n &lt; max: \n        yield b      # 使用 yield\n        # print b \n        a, b &#x3D; b, a + b \n        n &#x3D; n + 1\n \nfor n in fab(5): \n    print n</code></pre>\r\n<blockquote>\r\n<p>生成器就是一个使用了yield关键字的函数，此函数可返回生成器对象</p>\r\n</blockquote>\r\n<p>对了，我们在Python中还可以使用send方法来在实时调用中给生成器函数传入我们需要的值：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\ndef fib(n):\n    index &#x3D; 0\n    a &#x3D; 0\n    b &#x3D; 1\n\n    while index &lt; n:\n        sleep &#x3D; yield b\n        print(&#39;等待%s秒&#39; %sleep)\n        time.sleep(sleep)\n        a,b &#x3D; b, a+b\n        index +&#x3D; 1\n\nfib &#x3D; fib(20)\nprint(fib.send(None))   # 效果等同于print(next(fib))\nprint(fib.send(2))\nprint(fib.send(3))\nprint(fib.send(4))\n\n# -----output:-----\n# </code></pre>\r\n<p>~更多示例：<a\r\nhref=\"https://blog.csdn.net/Z2572862506/article/details/128766574\">Python\r\n中 yield 的用法理解 与 send()\r\n函数对生成器赋值_怎样才能回到过去的博客-CSDN博客</a> ~</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def test():\n    print(&quot;--------Test starting------&quot;)\n    while True:\n        print(&quot;Stop here, position NO.0&quot;)\n        a &#x3D; &quot;a is unassigned!!!&quot;\n        print(a)\n        print(&quot;Stop here, position NO.1&quot;)\n        a &#x3D; yield &quot;--------Test over----------\\n&quot;\n        print(a)\n        print(&quot;Stop here, position NO.2&quot;)\n\n\nt &#x3D; test()\nprint(&quot;*&quot; * 20 + &quot;Next 1 Start&quot; + &quot;*&quot; * 20 + &quot;\\n&quot;)\nprint(next(t))\nprint(&quot;*&quot; * 20 + &quot;Next 2 Start&quot; + &quot;*&quot; * 20 + &quot;\\n&quot;)\nprint(next(t))\nprint(&quot;*&quot; * 20 + &quot;Next 3 Start&quot; + &quot;*&quot; * 20 + &quot;\\n&quot;)\nprint(t.send(&quot;a is assigned!&quot;))\n\n# ********************Next 1 Start********************\n# \n# --------Test starting------\n# Stop here, position NO.0\n# a is unassigned!!!\n# Stop here, position NO.1\n# --------Test over----------\n# \n# ********************Next 2 Start********************\n# \n# None\n# Stop here, position NO.2\n# Stop here, position NO.0\n# a is unassigned!!!\n# Stop here, position NO.1\n# --------Test over----------\n# \n# ********************Next 3 Start********************\n#\n# a is assigned!\n# Stop here, position NO.2\n# Stop here, position NO.0\n# a is unassigned!!!\n# Stop here, position NO.1\n# --------Test over----------\n#\n\n\n# 规律总结：\n# 1. 生成器函数实例化时，是不会执行的\n# 2. 当调用next函数时，我们的函数才会开始执行，每次执行时只会执行到yeild处一次\n# \t2.1. 初次执行时，函数是从头开始执行，执行到第一个yeild的地方放回yeild后面的值，如果没有外部传值，则yeild本身返回None\n#\t2.2. 后续执行时，函数从上一次yeild中断的地方重新开始执行直到下一个yeild出现（然后在那个地方再次中断）\n# 3. 我们可以通过send向生成器传值，这是JS所没有的</code></pre>\r\n<h3 id=\"小拓展\">小拓展</h3>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/267966140\">深入理解Python 中的\r\nyield from语法 - 知乎 (zhihu.com)</a></p>\r\n<p>就Python而言，它还有更多的语法糖：<code>yeild from</code>:</p>\r\n<blockquote>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">&gt;使用yield\n\n&gt;# 字符串\n&gt;astr&#x3D;&#39;ABC&#39;\n&gt;# 列表\n&gt;alist&#x3D;[1,2,3]\n&gt;# 字典\n&gt;adict&#x3D;&#123;&quot;name&quot;:&quot;wangbm&quot;,&quot;age&quot;:18&#125;\n&gt;# 生成器\n&gt;agen&#x3D;(i for i in range(4,8))\n\n&gt;def gen(*args, **kw):\n   for item in args:\n       for i in item:\n           yield i\n\n&gt;new_list&#x3D;gen(astr, alist, adict, agen)\n&gt;print(list(new_list))\n&gt;# [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, &#39;name&#39;, &#39;age&#39;, 4, 5, 6, 7]\n&gt;使用yield from\n\n&gt;# 字符串\n&gt;astr&#x3D;&#39;ABC&#39;\n&gt;# 列表\n&gt;alist&#x3D;[1,2,3]\n&gt;# 字典\n&gt;adict&#x3D;&#123;&quot;name&quot;:&quot;wangbm&quot;,&quot;age&quot;:18&#125;\n&gt;# 生成器\n&gt;agen&#x3D;(i for i in range(4,8))\n\n&gt;def gen(*args, **kw):\n   for item in args:\n       yield from item\n\n&gt;new_list&#x3D;gen(astr, alist, adict, agen)\n&gt;print(list(new_list))\n&gt;# [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, &#39;name&#39;, &#39;age&#39;, 4, 5, 6, 7]</code></pre>\r\n</blockquote>\r\n<h2 id=\"yeild-in-c-and-unity\">Yeild in C# and Unity</h2>\r\n","text":"关键词：yeild关键字，yeild return，生成器函数，协程 Yeild in JS yield - JavaScript | MDN (mozilla.org) function* - JavaScript | MDN (mozilla.org) 简单地说，Yeild可...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#yeild-in-js\"><span class=\"toc-text\">Yeild in JS</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#yeild-in-python\"><span class=\"toc-text\">Yeild in Python</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">小拓展</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#yeild-in-c-and-unity\"><span class=\"toc-text\">Yeild in C# and Unity</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Java/Java后端学习路径","date":"2023-03-07T16:14:45.418Z","updated":"2021-10-11T04:30:57.000Z","comments":true,"path":"api/articles/Language Learning/Java/Java后端学习路径.json","keywords":null,"cover":null,"text":"Java语言： 教程网站： Oracle Official Site：The Java™ Tutorials (oracle.com) Runoob：Java 教程 | 菜鸟教程 (runoob.com) w3school：Java Tutorial (w3schools.com...","link":"","photos":[],"count_time":{"symbolsCount":436,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/NAMING CONVENTIONS","date":"2023-03-07T16:14:45.225Z","updated":"2022-04-03T14:54:17.000Z","comments":true,"path":"api/articles/Language Learning/NAMING CONVENTIONS.json","keywords":null,"cover":null,"text":"GENERAL Standard Naming Conventions - JAVA: Details: The below list outlines the standard Java naming conventions for each identifier type: ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}