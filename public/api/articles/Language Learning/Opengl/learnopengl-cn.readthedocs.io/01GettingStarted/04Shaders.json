{"title":"learningOpenGl Chapter 1.5","uid":"eb947faf7dc84fa49cb79bdd22ec183a","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/04Shaders","date":"2023-03-08T02:24:08.000Z","updated":"2023-10-27T19:52:26.000Z","comments":true,"path":"api/articles/Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/04Shaders.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"shaders\">1.5 Shaders</h1>\r\n<blockquote>\r\n<p>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。</p>\r\n<p>从基本意义上来说，着色器只是一种把输入转化为输出的程序。<strong>着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</strong></p>\r\n</blockquote>\r\n<h2 id=\"glsl\">1.5.1 GLSL</h2>\r\n<p>OpenGL中的Shader是用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p>\r\n<p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。一个典型的着色器有下面的结构：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version version_number</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">in</span> type in_variable_name;</span><br><span class=\"line\"><span class=\"keyword\">in</span> type in_variable_name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">out</span> type out_variable_name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> type uniform_name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理输入并进行一些图形操作</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 输出处理过的结果到输出变量</span></span><br><span class=\"line\">  out_variable_name = weird_stuff_we_processed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>特别的，当我们特别谈论到顶点着色器的时候，每个<strong>输入变量</strong>也叫<strong>顶点属性</strong>(Vertex\r\nAttribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLint nrAttributes;</span><br><span class=\"line\">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class=\"line\">std::cout &lt;&lt; &quot;Maximum nr of vertex attributes supported: &quot; &lt;&lt; nrAttributes &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\r\n<p>通常情况下它至少会返回16个，大部分情况下是够用了。</p>\r\n<h2 id=\"数据类型\">1.5.2 数据类型</h2>\r\n<p>GLSL有数据类型可以来指定变量的种类。</p>\r\n<p>GLSL中包含C等其它语言大部分的默认基础数据类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>uint</code>和<code>bool</code>。</p>\r\n<p>GLSL也有两种特殊的但是<strong>容器</strong>类型，分别是向量(Vector)和矩阵(Matrix)</p>\r\n<h2 id=\"向量容器\">1.5.2.1 向量容器</h2>\r\n<blockquote>\r\n<p>向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。</p>\r\n</blockquote>\r\n<h4 id=\"向量容器的存在形式\">1.5.2.1.1 向量容器的存在形式</h4>\r\n<blockquote>\r\n<p>GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。</p>\r\n</blockquote>\r\n<p>在GLSL中，向量容器中可以容纳的基本内容可以是：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>类型</th>\r\n<th>含义</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>vecn</code></td>\r\n<td>包含<code>n</code>个float分量的默认向量</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>bvecn</code></td>\r\n<td>包含<code>n</code>个bool分量的向量</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>ivecn</code></td>\r\n<td>包含<code>n</code>个int分量的向量</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>uvecn</code></td>\r\n<td>包含<code>n</code>个unsigned int分量的向量</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>dvecn</code></td>\r\n<td>包含<code>n</code>个double分量的向量</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h4 id=\"向量容器内容获取\">1.5.2.1.2 向量容器内容获取</h4>\r\n<p>以<code>vec4</code>类型的向量\"test\"为例，想要获取其中的各个分量，可以使用：</p>\r\n<p><code>test.x</code>; <code>test.y</code>; <code>test.z</code>;\r\n<code>test.w</code> （位置坐标）</p>\r\n<p>这种分量的获取方式，完全等同于 <code>rgba</code>（颜色值） 与\r\n<code>stpq</code>（纹理坐标），但是为了维护程序良好的可读性，请务必根据具体数据类型选择分量的获取方式</p>\r\n<h4 id=\"swizzling-向量容器内容的重组\">1.5.2.1.3 Swizzling:\r\n向量容器内容的“重组”</h4>\r\n<p>向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec2</span> someVec;</span><br><span class=\"line\"><span class=\"type\">vec4</span> differentVec = someVec.xyxx;</span><br><span class=\"line\"><span class=\"type\">vec3</span> anotherVec = differentVec.zyw;</span><br><span class=\"line\"><span class=\"type\">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;</span><br></pre></td></tr></table></figure>\r\n<p>你可以使用上面4个字母任意组合来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，你不允许在一个<code>vec2</code>向量中去获取<code>.z</code>元素。我们也可以<strong>把一个向量作为一个参数</strong>传给不同的向量构造函数，以减少需求参数的数量：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec2</span> vect = <span class=\"type\">vec2</span>(<span class=\"number\">0.5</span>f, <span class=\"number\">0.7</span>f);</span><br><span class=\"line\"><span class=\"type\">vec4</span> result = <span class=\"type\">vec4</span>(vect, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f);</span><br><span class=\"line\"><span class=\"type\">vec4</span> otherResult = <span class=\"type\">vec4</span>(result.xyz, <span class=\"number\">1.0</span>f);</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"矩阵\">1.5.2.2 矩阵</h3>\r\n<h2 id=\"数据输入与输出\">1.5.3 数据输入与输出</h2>\r\n<blockquote>\r\n<p>虽然Shader是各自独立的小程序，但是它们都是渲染管线上的一小部分，出于这样的原因，我们希望每个Shader都有输入和输出，这样才能进行数据交流和传递。GLSL定义了<code>in</code>和<code>out</code>关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。</p>\r\n</blockquote>\r\n<p>顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从<strong>顶点数据</strong>中直接接收输入。为了定义顶点数据该如何管理，我们使用<code>location</code>这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，<code>layout (location = 0)</code>。顶点着色器需要为它的输入提供一个额外的<code>layout</code>标识，这样我们才能把它链接到顶点数据。</p>\r\n<blockquote>\r\n<p><a href=\"https://www.khronos.org/opengl/wiki/Vertex_Shader\">Vertex\r\nShader - OpenGL Wiki (khronos.org)</a></p>\r\n<p><a\r\nhref=\"https://www.khronos.org/opengl/wiki/Fragment_Shader#Outputs\">Fragment\r\nShader - OpenGL Wiki (khronos.org)</a></p>\r\n<p><a\r\nhref=\"https://stackoverflow.com/questions/9222217/how-does-the-fragment-shader-know-what-variable-to-use-for-the-color-of-a-pixel\">opengl\r\n- How does the fragment shader know what variable to use for the color\r\nof a pixel? - Stack Overflow</a></p>\r\n</blockquote>\r\n<p>如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。</p>\r\n<p>示例如下：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点着色器</span></span><br><span class=\"line\"><span class=\"meta\">#version 330 core</span></span><br><span class=\"line\"><span class=\"keyword\">layout</span> (<span class=\"keyword\">location</span> = <span class=\"number\">0</span>) <span class=\"keyword\">in</span> <span class=\"type\">vec3</span> position; <span class=\"comment\">// position变量的属性位置值为0</span></span><br><span class=\"line\"><span class=\"keyword\">out</span> <span class=\"type\">vec4</span> vertexColor; <span class=\"comment\">// 为片段着色器指定一个颜色输出</span></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">gl_Position</span> = <span class=\"type\">vec4</span>(position, <span class=\"number\">1.0</span>); <span class=\"comment\">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class=\"line\">    vertexColor = <span class=\"type\">vec4</span>(<span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f); <span class=\"comment\">// 把输出变量设置为暗红色</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 片段着色器</span></span><br><span class=\"line\"><span class=\"meta\">#version 330 core</span></span><br><span class=\"line\"><span class=\"keyword\">in</span> <span class=\"type\">vec4</span> vertexColor; <span class=\"comment\">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class=\"line\"><span class=\"keyword\">out</span> <span class=\"type\">vec4</span> color; <span class=\"comment\">// 片段着色器输出的变量名可以任意命名，但类型必须是vec4</span></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    color = vertexColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"uniform\">1.5.4 Uniform</h2>\r\n<blockquote>\r\n<p>Uniform是一种<strong>从CPU中的应用向GPU中的着色器发送数据的方式</strong>，但uniform和顶点属性有些不同。首先，uniform是<strong>全局</strong>的(Global)，这意味着它可以被着色器程序的任意着色器在任意阶段访问。在完成一次设置（赋值）后，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>\r\n</blockquote>\r\n<p>我们可以在一个着色器中添加<code>uniform</code>关键字至类型和变量名前来声明一个GLSL的uniform。</p>\r\n<p>示例如下：我在片段着色器中声明一个uniform\r\n<code>vec4</code>的变量，并把片段着色器的输出颜色设置为该变量的值。</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 330 core</span></span><br><span class=\"line\"><span class=\"keyword\">out</span> <span class=\"type\">vec4</span> color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec4</span> ourColor; <span class=\"comment\">// 在OpenGL程序代码中设定这个变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    color = ourColor;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\r\n<p>由于uniform变量是全局变量，因此我们可以在任何shader中定义它们，而无需像<code>1.5.3</code>那样用in\r\nout作为中介来传递到目标Shader中。因此，既然顶点着色器中不需要这个uniform，那我们便不在那里定义它。</p>\r\n<p>:warning:如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量</p>\r\n<p>而在shader中写下的ourColor，只是一个声明/定义，这个uniform现在还是空的，我们还没有给它添加任何数据。还记得吗：“Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式”，也就是说，Uniform的具体定义及实现应该在CPU也就是main.c里完成而不是Shader中</p>\r\n<p>我们可以这样：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...(game loop); <span class=\"comment\">// 做底色等等</span></span><br><span class=\"line\"></span><br><span class=\"line\">GLint vertexColorLocation = glGetUniformLocation(shaderProgram, <span class=\"string\">&quot;ourColor&quot;</span>); <span class=\"comment\">// 在CPU阶段，查找对应Uniform定义</span></span><br><span class=\"line\"><span class=\"comment\">// 拿到该Uniform变量后，我们就可以对其进行处理。</span></span><br><span class=\"line\"></span><br><span class=\"line\">GLfloat timeValue = glfwGetTime(); <span class=\"comment\">// 获取时间</span></span><br><span class=\"line\">GLfloat greenValue = (<span class=\"built_in\">sin</span>(timeValue) / <span class=\"number\">2</span>) + <span class=\"number\">0.5</span>; <span class=\"comment\">// 对时间求sin，结果在(-1, 1)，值在(0, 1)波动</span></span><br><span class=\"line\"></span><br><span class=\"line\">glUseProgram(shaderProgram); <span class=\"comment\">// 先激活着色器(Use)，再更新Uniform</span></span><br><span class=\"line\">glUniform4f(vertexColorLocation, <span class=\"number\">0.0f</span>, greenValue, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">...(draw&amp;call); <span class=\"comment\">// draw call在这之后</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"解决更多属性\">1.5.5 解决更多属性</h2>\r\n<blockquote>\r\n<p>如有必要，请重新回看1.4部分</p>\r\n</blockquote>\r\n<p>在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 位置              // 颜色</span></span><br><span class=\"line\">     <span class=\"number\">0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,   <span class=\"comment\">// 右下</span></span><br><span class=\"line\">    <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>,   <span class=\"comment\">// 左下</span></span><br><span class=\"line\">     <span class=\"number\">0.0f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>    <span class=\"comment\">// 顶部</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>根据我们的数据，我们需要做的修改如下：</p>\r\n<ul>\r\n<li>VS，接收新的Color信息</li>\r\n<li>FS，接受该Color信息</li>\r\n<li>main.c，对该数据进行解析，配置VAO指针等</li>\r\n</ul>\r\n<p>特别注意，<code>glVertexAttribPointer</code>函数有两处修改：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">6</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (GLvoid*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">6</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (GLvoid*)(<span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat)));</span><br><span class=\"line\"><span class=\"comment\">// 1. 修改了步长</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 修改了偏移量，注意偏移量的具体格式与计算思路（对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以偏移量就是3 * sizeof(GLfloat)，用字节来计算就是12字节）</span></span><br></pre></td></tr></table></figure>\r\n<p>这个图片可能不是你所期望的\"只有3个颜色\"(因为我们只提供了3个颜色)，这是一个大调色板——这是在片段着色器中进行的所谓片段插值(Fragment\r\nInterpolation)的结果。</p>\r\n<blockquote>\r\n<p>当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。基于这些位置，它会插值(Interpolate)所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是30%蓝\r\n+ 70%绿。</p>\r\n<p>这正是在这个三角形中发生了什么。我们有3个顶点，和相应的3个颜色，从这个三角形的像素来看它可能包含50000左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。</p>\r\n</blockquote>\r\n<h2 id=\"我们自己的着色器类\">1.5.6 我们自己的着色器类</h2>\r\n<blockquote>\r\n<p>编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。</p>\r\n<p>我们会把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。我们先来添加必要的include，并定义类结构：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;#ifndef SHADER_H</span><br><span class=\"line\">&gt;#define SHADER_H</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;#include &lt;string&gt;</span><br><span class=\"line\">&gt;#include &lt;fstream&gt;</span><br><span class=\"line\">&gt;#include &lt;sstream&gt;</span><br><span class=\"line\">&gt;#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;#include &lt;GL/glew.h&gt;; // 包含glew来获取所有的必须OpenGL头文件</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;class Shader</span><br><span class=\"line\">&gt;&#123;</span><br><span class=\"line\">&gt;public:</span><br><span class=\"line\">   // 程序ID</span><br><span class=\"line\">   GLuint Program;</span><br><span class=\"line\">   // 构造器读取并构建着色器</span><br><span class=\"line\">   Shader(const GLchar* vertexPath, const GLchar* fragmentPath);</span><br><span class=\"line\">   // 使用程序</span><br><span class=\"line\">   void Use();</span><br><span class=\"line\">&gt;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;#endif</span><br></pre></td></tr></table></figure>\r\n<p>:warning:在上面，我们在头文件顶部使用了几个预处理指令(Preprocessor\r\nDirectives)。这些预处理指令会告知你的编译器只在它没被包含过的情况下才包含和编译这个头文件，即使多个文件都包含了这个着色器头文件。它是用来防止链接冲突的。</p>\r\n<p>着色器类储存了着色器程序的ID。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。我们还添加了一个Use函数，它其实不那么重要，但是能够显示这个自造类如何让我们的生活变得轻松（虽然只有一点）。</p>\r\n<h2 id=\"从文件读取\">从文件读取</h2>\r\n<p>我们使用C++文件流读取着色器内容，储存到几个<code>string</code>对象里：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;Shader(const GLchar* vertexPath, const GLchar* fragmentPath)</span><br><span class=\"line\">&gt;&#123;</span><br><span class=\"line\">   // 1. 从文件路径中获取顶点/片段着色器</span><br><span class=\"line\">   std::string vertexCode;</span><br><span class=\"line\">   std::string fragmentCode;</span><br><span class=\"line\">   std::ifstream vShaderFile;</span><br><span class=\"line\">   std::ifstream fShaderFile;</span><br><span class=\"line\">   // 保证ifstream对象可以抛出异常：</span><br><span class=\"line\">   vShaderFile.exceptions(std::ifstream::badbit);</span><br><span class=\"line\">   fShaderFile.exceptions(std::ifstream::badbit);</span><br><span class=\"line\">   try </span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       // 打开文件</span><br><span class=\"line\">       vShaderFile.open(vertexPath);</span><br><span class=\"line\">       fShaderFile.open(fragmentPath);</span><br><span class=\"line\">       std::stringstream vShaderStream, fShaderStream;</span><br><span class=\"line\">       // 读取文件的缓冲内容到流中</span><br><span class=\"line\">       vShaderStream &lt;&lt; vShaderFile.rdbuf();</span><br><span class=\"line\">       fShaderStream &lt;&lt; fShaderFile.rdbuf();       </span><br><span class=\"line\">       // 关闭文件</span><br><span class=\"line\">       vShaderFile.close();</span><br><span class=\"line\">       fShaderFile.close();</span><br><span class=\"line\">       // 转换流至GLchar数组</span><br><span class=\"line\">       vertexCode = vShaderStream.str();</span><br><span class=\"line\">       fragmentCode = fShaderStream.str();     </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch(std::ifstream::failure e)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   const GLchar* vShaderCode = vertexCode.c_str();</span><br><span class=\"line\">   const GLchar* fShaderCode = fragmentCode.c_str();</span><br><span class=\"line\">   [...]</span><br></pre></td></tr></table></figure>\r\n<p>下一步，我们需要编译和链接着色器。注意，我们也将检查编译/链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;// 2. 编译着色器</span><br><span class=\"line\">&gt;GLuint vertex, fragment;</span><br><span class=\"line\">&gt;GLint success;</span><br><span class=\"line\">&gt;GLchar infoLog[512];</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;// 顶点着色器</span><br><span class=\"line\">&gt;vertex = glCreateShader(GL_VERTEX_SHADER);</span><br><span class=\"line\">&gt;glShaderSource(vertex, 1, &amp;vShaderCode, NULL);</span><br><span class=\"line\">&gt;glCompileShader(vertex);</span><br><span class=\"line\">&gt;// 打印编译错误（如果有的话）</span><br><span class=\"line\">&gt;glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success);</span><br><span class=\"line\">&gt;if(!success)</span><br><span class=\"line\">&gt;&#123;</span><br><span class=\"line\">   glGetShaderInfoLog(vertex, 512, NULL, infoLog);</span><br><span class=\"line\">   std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class=\"line\">&gt;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;// 片段着色器也类似</span><br><span class=\"line\">&gt;[...]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;// 着色器程序</span><br><span class=\"line\">&gt;this-&gt;Program = glCreateProgram();</span><br><span class=\"line\">&gt;glAttachShader(this-&gt;Program, vertex);</span><br><span class=\"line\">&gt;glAttachShader(this-&gt;Program, fragment);</span><br><span class=\"line\">&gt;glLinkProgram(this-&gt;Program);</span><br><span class=\"line\">&gt;// 打印连接错误（如果有的话）</span><br><span class=\"line\">&gt;glGetProgramiv(this-&gt;Program, GL_LINK_STATUS, &amp;success);</span><br><span class=\"line\">&gt;if(!success)</span><br><span class=\"line\">&gt;&#123;</span><br><span class=\"line\">   glGetProgramInfoLog(this-&gt;Program, 512, NULL, infoLog);</span><br><span class=\"line\">   std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了</span><br><span class=\"line\">&gt;glDeleteShader(vertex);</span><br><span class=\"line\">&gt;glDeleteShader(fragment);</span><br></pre></td></tr></table></figure>\r\n<p>最后我们也会实现Use函数：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;void Use()</span><br><span class=\"line\">&gt;&#123;</span><br><span class=\"line\">   glUseProgram(this-&gt;Program);</span><br><span class=\"line\">&gt;&#125;</span><br></pre></td></tr></table></figure>\r\n<p>现在我们就写完了一个完整的着色器类。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;Shader ourShader(&quot;path/to/shaders/shader.vs&quot;, &quot;path/to/shaders/shader.frag&quot;);</span><br><span class=\"line\">&gt;...</span><br><span class=\"line\">&gt;while(...)</span><br><span class=\"line\">&gt;&#123;</span><br><span class=\"line\">   ourShader.Use();</span><br><span class=\"line\">   glUniform1f(glGetUniformLocation(ourShader.Program, &quot;someUniform&quot;), 1.0f);</span><br><span class=\"line\">   DrawStuff();</span><br><span class=\"line\">&gt;&#125;</span><br></pre></td></tr></table></figure>\r\n<p>我们把顶点和片段着色器储存为两个叫做<code>shader.vs</code>和<code>shader.frag</code>的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用<code>.vs</code>和<code>.frag</code>作为扩展名很直观。</p>\r\n<p>源码：<a\r\nhref=\"http://learnopengl.com/code_viewer.php?code=getting-started/shaders-using-object\">使用新着色器类的程序</a>，<a\r\nhref=\"http://learnopengl.com/code_viewer.php?type=header&amp;code=shader\">着色器类</a>，<a\r\nhref=\"http://learnopengl.com/code_viewer.php?type=vertex&amp;code=getting-started/basic\">顶点着色器</a>，和<a\r\nhref=\"http://learnopengl.com/code_viewer.php?type=fragment&amp;code=getting-started/basic\">片段着色器</a>。</p>\r\n</blockquote>\r\n","text":"1.5 Shaders 着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。 从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。 1.5....","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"Opengl","slug":"Opengl","count":16,"path":"api/categories/Opengl.json"},{"name":"Shader","slug":"Opengl/Shader","count":16,"path":"api/categories/Opengl/Shader.json"}],"tags":[{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":16,"path":"api/tags/Opengl.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#shaders\"><span class=\"toc-text\">1.5 Shaders</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#glsl\"><span class=\"toc-text\">1.5.1 GLSL</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">1.5.2 数据类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">1.5.2.1 向量容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AD%98%E5%9C%A8%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">1.5.2.1.1 向量容器的存在形式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E5%AE%B9%E5%99%A8%E5%86%85%E5%AE%B9%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">1.5.2.1.2 向量容器内容获取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#swizzling-%E5%90%91%E9%87%8F%E5%AE%B9%E5%99%A8%E5%86%85%E5%AE%B9%E7%9A%84%E9%87%8D%E7%BB%84\"><span class=\"toc-text\">1.5.2.1.3 Swizzling:\r\n向量容器内容的“重组”</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">1.5.2.2 矩阵</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">1.5.3 数据输入与输出</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#uniform\"><span class=\"toc-text\">1.5.4 Uniform</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">1.5.5 解决更多属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9D%80%E8%89%B2%E5%99%A8%E7%B1%BB\"><span class=\"toc-text\">1.5.6 我们自己的着色器类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">从文件读取</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"learningOpenGl Chapter 1.6","uid":"59e0ee426fc499572e79ecdf9cee6601","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/05Texture","date":"2023-03-08T02:25:08.000Z","updated":"2023-10-27T19:52:29.000Z","comments":true,"path":"api/articles/Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/05Texture.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"1.6 Texture 1.6.1 纹理坐标与纹理的应用 1.6.1.1 定义纹理坐标 我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"Opengl","slug":"Opengl","count":16,"path":"api/categories/Opengl.json"},{"name":"Shader","slug":"Opengl/Shader","count":16,"path":"api/categories/Opengl/Shader.json"}],"tags":[{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":16,"path":"api/tags/Opengl.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"learningOpenGl Chapter 1.4","uid":"4fc32846a71333fda5c166e6a4c0c980","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/03.Hello Triangle","date":"2023-03-08T02:23:08.000Z","updated":"2023-10-27T19:52:22.000Z","comments":true,"path":"api/articles/Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/03.Hello Triangle.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"1.4 绘制三角形 在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。 3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Opengl","slug":"Opengl","count":16,"path":"api/categories/Opengl.json"},{"name":"Shader","slug":"Opengl/Shader","count":16,"path":"api/categories/Opengl/Shader.json"}],"tags":[{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":16,"path":"api/tags/Opengl.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}