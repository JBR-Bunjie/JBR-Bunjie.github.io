{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/相等判断","date":"2023-03-07T16:14:45.652Z","updated":"2022-02-25T14:19:52.000Z","comments":true,"path":"api/articles/Language Learning/Python/相等判断.json","keywords":null,"cover":null,"content":"<h1\r\nid=\"python的is和java的和equal相等判断\">python的is和==，java的==和equal（相等判断）</h1>\r\n<h2 id=\"python判断对象是否相等-和-is\">Python判断对象是否相等（== 和\r\nis）</h2>\r\n<p><strong>Python中的对象包含三个基本要素，分别是：</strong></p>\r\n<ul>\r\n<li><strong>id：</strong>用来唯一标识一个对象，可以理解为内存地址；</li>\r\n<li><strong>type：</strong>标识对象的类型；</li>\r\n<li><strong>value：</strong>对象的值；</li>\r\n</ul>\r\n<p><strong>== ：</strong>比较两个对象的内容是否\r\n<strong>相等</strong>，即两个对象的 value 是否相等，无论 id\r\n是否相等，默认会调用对象的 <strong>__eq__()</strong>方法</p>\r\n<p><strong>is：</strong> 比较的是两个对象是不是完全\r\n<strong>相同</strong>，即他们的 id 要相等。</p>\r\n<p>也就是说：如果 a is b 为 True，那么 a == b 也为True</p>\r\n<h3 id=\"字符串比较\">字符串比较</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">a &#x3D; &#39;hello&#39;\nb &#x3D; &#39;hello&#39;\nprint(a is b)\nprint(id(a))\nprint(id(b))\n# 执行结果：\nTrue\n1830826496176\n1830826496176</code></pre>\r\n<h3 id=\"数字比较\">数字比较</h3>\r\n<p>先看一个有趣的现象</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">In[43]: a &#x3D; 256\nIn[44]: b &#x3D; 256\nIn[45]: a is b\nOut[45]: True\nIn[46]: id(a)\nOut[46]: 140711685177712\nIn[47]: id(b)\nOut[47]: 140711685177712\nIn[48]: a &#x3D; 257\nIn[49]: b &#x3D; 257\nIn[50]: a is b\nOut[50]: False\nIn[51]: id(a)\nOut[51]: 2097451837488\nIn[52]: id(b)\nOut[52]: 2097451837648</code></pre>\r\n<p>为什么当 a,b为257的时候 a is b 为False呢？</p>\r\n<p>Python\r\n为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。</p>\r\n<p>而Python 对小整数的定义是 [-5,\r\n256)，只有数字在-5到256之间它们的id才会相等，超过了这个范围就不行了，同样的道理，字符串对象也有一个类似的缓冲池，超过区间范围内自然不会相等了。</p>\r\n<p>需要注意的是这仅仅是在命令行中执行时才会有小整数缓存，而在文件中执行时，结果是不一样的，这是因为解释器做了一部分优化，如下：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; 257\ny &#x3D; 257\nprint(id(x))\nprint(id(y))\nprint(x is y)\n# 执行结果：\n2177330411024\n2177330411024\nTrue</code></pre>\r\n<h3 id=\"元组比较\">元组比较</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; (1, 2, 3)\ny &#x3D; (1, 2, 3)\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\n3014830376024\n3014830376024</code></pre>\r\n<h3 id=\"列表比较\">列表比较</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; [1, 2, 3]\ny &#x3D; [1, 2, 3]\nprint(x &#x3D;&#x3D; y)\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\nFalse\n2968991650248\n2968991650760</code></pre>\r\n<h3 id=\"列表赋值比较\">列表赋值比较</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; [1, 2, 3]\ny &#x3D; x\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\n2294971781576\n2294971781576</code></pre>\r\n<h3 id=\"字典比较\">字典比较</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;b&quot;: 3&#125;\ny &#x3D; &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;b&quot;: 3&#125;\nprint(x &#x3D;&#x3D; y)\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\nFalse\n2522908527576\n2522908269848</code></pre>\r\n<h3 id=\"集合比较\">集合比较</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; set([1, 2, 3])\ny &#x3D; set([1, 2, 3])\nprint(x &#x3D;&#x3D; y)\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\nFalse\n2080395955784\n2080414590120</code></pre>\r\n<h2 id=\"小结\">小结：</h2>\r\n<p>可以看到，当 x, y 为字符串、整数，元组（都是不可变类型）的时候，如果\r\nx 和 y的值一样的话，x is y 则为True；</p>\r\n<p>然而为列表，字典，集合（都是可变类型）的时候，x is y\r\n为False，列表赋值的时候为True；</p>\r\n<p><strong>与 == 相比，is\r\n的计算速度快</strong>——因为它不能重载，不用进行特殊的函数调用，少了函数调用的开销而直接比较两个整数\r\nid。而 a == b 则是等同于**a.__eq<strong>(b)<strong>。继承自 object 的\r\n</strong></strong>****eq__** 方法比较两个对象的id，结果与 is\r\n一样。但是多数Python的对象会覆盖object的\r\n<strong>__eq__</strong>方法，而定义内容的相关比较，所以比较的是对象属性的值。</p>\r\n<p>在变量和单例值之间比较时，应该使用 is。目前，最常使用 is\r\n的地方是判断对象是不是 None</p>\r\n<p>关于python的可变类型不可变类型可参考：https://www.runoob.com/python/python-variable-types.html</p>\r\n<p>python的赋值、浅拷贝和深拷贝可参考：https://blog.csdn.net/bufengzj/article/details/90486991</p>\r\n<h2 id=\"java判断对象是否相等-和equal\">Java判断对象是否相等（==\r\n和equal）</h2>\r\n<p>java中没有 is ,有 == 和 equal。。</p>\r\n<p><strong>==：</strong>比较两个变量本身的值，即两个对象在内存中的首地址（类似也就是和python的\r\nis ）；</p>\r\n<p><strong>equals：</strong>比较变量所包含的内容是否相同（类似也就是和python的\r\n== ）；</p>\r\n<p>java 具体参考：https://www.cnblogs.com/weibanggang/p/9457757.html</p>\r\n","text":"python的is和==，java的==和equal（相等判断） Python判断对象是否相等（== 和 is） Python中的对象包含三个基本要素，分别是： id：用来唯一标识一个对象，可以理解为内存地址； type：标识对象的类型； value：对象的值； == ：比较两个...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#python%E7%9A%84is%E5%92%8Cjava%E7%9A%84%E5%92%8Cequal%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">python的is和&#x3D;&#x3D;，java的&#x3D;&#x3D;和equal（相等判断）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#python%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89-%E5%92%8C-is\"><span class=\"toc-text\">Python判断对象是否相等（&#x3D;&#x3D; 和\r\nis）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">字符串比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">数字比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">元组比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">列表比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8%E8%B5%8B%E5%80%BC%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">列表赋值比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E5%85%B8%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">字典比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">集合比较</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#java%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89-%E5%92%8Cequal\"><span class=\"toc-text\">Java判断对象是否相等（&#x3D;&#x3D;\r\n和equal）</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/计时器","date":"2023-03-07T16:14:45.658Z","updated":"2022-02-24T13:23:48.000Z","comments":true,"path":"api/articles/Language Learning/Python/计时器.json","keywords":null,"cover":[],"text":"python 定时器 在工作中，我们有时候会需要定时去做一些操作，比如凌晨更新远程代码，仓库每小时更新一次远程分支。这些操作，我们如果要人工进行，不仅要耗费精力，也更容易出错。 如果一件事情，具有周期操作的特点，那么把这件事情设置为定时器操作，最合适不过。 不借助第三方插件 在不...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/数组","date":"2023-03-07T16:14:45.646Z","updated":"2022-02-24T13:22:22.000Z","comments":true,"path":"api/articles/Language Learning/Python/数组.json","keywords":null,"cover":null,"text":"二维数组的定义 创建一个二维数组？还是一个n*n的二维数组？ 1. 直接定义： a &#x3D; [[]] 2.众多间接定义？ a.直接地间接创建 a&#x3D;[] arrays&#x3D;[a*3] 注意！这里的arrays并不是[[], [], []]，而是[[]] b.通...","link":"","photos":[],"count_time":{"symbolsCount":629,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}