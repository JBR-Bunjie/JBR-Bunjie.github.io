{"title":"使用python自动化处理的文件及zipfile模块的介绍","uid":"54ad4410b8e441eafc3ef2cc6f0cea8f","slug":"Language Learning/Python/使用python解决文件自动化处理的方案及zipfile模块的介绍","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T20:02:46.000Z","comments":true,"path":"api/articles/Language Learning/Python/使用python解决文件自动化处理的方案及zipfile模块的介绍.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1\r\nid=\"使用python自动化处理的文件及zipfile模块的介绍\">使用python自动化处理的文件及zipfile模块的介绍</h1>\r\n<h2 id=\"使用-python-解决文件自动化改名和命名\">使用 Python\r\n解决文件自动化改名和命名</h2>\r\n<h3 id=\"原因获取压缩文件的实际名称\">原因：获取压缩文件的实际名称：</h3>\r\n<p>压缩文件名称使用了随机字符，而原文件夹作为压缩文件的根目录来保存，为了避免打开压缩文件才能知道打开的到底是哪个文件，需要将压缩文件内的文件夹名复制出来为外部压缩文件改名</p>\r\n<h3 id=\"采用方案\">采用方案：</h3>\r\n<h4 id=\"解压缩模块zipfile\">解压缩模块：zipfile</h4>\r\n<p>official site <a\r\nhref=\"https://docs.python.org/3/library/zipfile.html\">zipfile — Work\r\nwith ZIP archives — Python 3.9.6 documentation</a></p>\r\n<ol type=\"1\">\r\n<li>提取所有压缩文件的实际名称</li>\r\n</ol>\r\n<h4 id=\"文件处理模块os\">文件处理模块：os</h4>\r\n<ol type=\"1\">\r\n<li>确定实际工作目录</li>\r\n<li>找到所有需要改名的文件并存储</li>\r\n<li>在压缩文件中提取完实际名称后对源文件进行改名</li>\r\n</ol>\r\n<h4 id=\"文字提取模块正则表达式re\">文字提取模块（正则表达式）：re</h4>\r\n<ol type=\"1\">\r\n<li>对路径使用正则表达式来处理文件</li>\r\n</ol>\r\n<p>程序实例：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> zipfile</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">os.getcwd()\t\t\t<span class=\"comment\"># 等待结果</span></span><br><span class=\"line\">path = <span class=\"string\">r&quot;&quot;</span>\t\t\t<span class=\"comment\"># 输入要处理文件的路径</span></span><br><span class=\"line\">os.chdir(path)\t\t<span class=\"comment\"># 进入目标目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">A = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> os.walk(path):</span><br><span class=\"line\">    A.append(i)</span><br><span class=\"line\"></span><br><span class=\"line\">B = A[<span class=\"number\">0</span>][<span class=\"number\">2</span>] <span class=\"comment\"># B按顺序存储了需要修改的所有文件，注意A[0][2]的真正含义！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注意，B可能包含已经修改了的文件，这时有两个方案</span></span><br><span class=\"line\">\t<span class=\"comment\"># 1. （通过操作）规避这些文件，单独处理（费时费力，但是可以在一个文件夹下完成所有操作，也符合我个人直觉，毕竟是存在某些文件没有</span></span><br><span class=\"line\">\t<span class=\"comment\"># 2. 将这些文件全部复制到新文件夹下保持文件纯净</span></span><br><span class=\"line\"><span class=\"comment\"># 采用方案2</span></span><br><span class=\"line\"></span><br><span class=\"line\">C = [] <span class=\"comment\"># 存储真实名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> B:</span><br><span class=\"line\">    <span class=\"keyword\">with</span> zipfile.ZipFile(i, <span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> z:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> z.namelist():</span><br><span class=\"line\">            C.append(i)</span><br><span class=\"line\">        z.close() <span class=\"comment\"># 可能会有几百行？_(:з」∠)_，总之，拿下了就行</span></span><br><span class=\"line\"></span><br><span class=\"line\">get_name_rule = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&quot; &quot;</span>, re.S) <span class=\"comment\"># 正则表达式的筛选规则</span></span><br><span class=\"line\">D = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> C:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> re.findall(get_name_rule, i) != []:</span><br><span class=\"line\">        D.append(re.findall(get_name_rule, i)[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">E = []</span></span><br><span class=\"line\"><span class=\"string\">rule_extended = re.compile(r&quot; &quot;, re.S)</span></span><br><span class=\"line\"><span class=\"string\">for i in D:</span></span><br><span class=\"line\"><span class=\"string\">    if re.findall(rule_extended, i) != []:</span></span><br><span class=\"line\"><span class=\"string\">    \tE.append(re.findall(rule_extended, i)[0])</span></span><br><span class=\"line\"><span class=\"string\">    else:</span></span><br><span class=\"line\"><span class=\"string\">    \tE.append(i)</span></span><br><span class=\"line\"><span class=\"string\">补充提取，将所有违规字符如&#x27;/&#x27;，&#x27;*&#x27;等全部剔除</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">count = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> B:</span><br><span class=\"line\">    temp = E[count] + <span class=\"string\">&quot;.zip&quot;</span> \t<span class=\"comment\"># 注意后缀！</span></span><br><span class=\"line\">    os.rename(i, temp)</span><br><span class=\"line\">    count = count + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"有关zipfile的常用方法\">有关<code>zipfile</code>的常用方法：</h2>\r\n<ol type=\"1\">\r\n<li><p>一看就懂：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> zipfile</span><br><span class=\"line\">f = zipfile.ZipFile(<span class=\"string\">&#x27;filename.zip&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span> ,zipfile.ZIP_DEFLATED)</span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;file1.txt&#x27;</span>)</span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;file2.doc&#x27;</span>)</span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;file3.rar&#x27;</span>)</span><br><span class=\"line\">f.close()</span><br><span class=\"line\">f = zipfile.ZipFile(<span class=\"string\">&#x27;filename&#x27;</span>)</span><br><span class=\"line\">f.extractall()</span><br><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\r\n<p>1.1 <code>zipfile.</code><strong>ZipFile</strong>(<em>file</em>,\r\n<em>mode='r'</em>, <em>compression=ZIP_STORED</em>,\r\n<em>allowZip64=True</em>, <em>compresslevel=None</em>, <em>**,\r\n</em>strict_timestamps=True*)</p>\r\n<p>Open a ZIP file, where <em>file</em> can be a path to a file (a\r\nstring), a file-like object or a <a\r\nhref=\"https://docs.python.org/3/glossary.html#term-path-like-object\">path-like\r\nobject</a>.</p>\r\n<blockquote>\r\n<p>fileName 是没有什么疑问的了。</p>\r\n<p>mode 和一般的文件操作一样,'r'表示打开一个存在的只读 ZIP\r\n文件；'w'表示清空并打开一个只写的 ZIP 文件，或创建一个只写的 ZIP\r\n文件；'a'表示打开一个 ZIP 文件，并添加内容。</p>\r\n</blockquote></li>\r\n</ol>\r\n<blockquote>\r\n<blockquote>\r\n<p>The <em>mode</em> parameter should be <code>'r'</code> to read an\r\nexisting file,</p>\r\n<p><code>'w'</code> to truncate and write a new file,</p>\r\n<p><code>'x'</code> to exclusively create and write a new file.</p>\r\n<blockquote>\r\n<p>If <em>mode</em> is <code>'x'</code> and <em>file</em> refers to an\r\nexisting file, a <a\r\nhref=\"https://docs.python.org/3/library/exceptions.html#FileExistsError\"><code>FileExistsError</code></a>\r\nwill be raised.</p>\r\n</blockquote>\r\n<p><code>'a'</code> to append to an existing file,</p>\r\n<blockquote>\r\n<p>If <em>mode</em> is <code>'a'</code> and <em>file</em> refers to an\r\nexisting ZIP file, then additional files are added to it.</p>\r\n<p>If <em>file</em> does not refer to a ZIP file, then a new ZIP archive\r\nis appended to the file. This is meant for adding a ZIP archive to\r\nanother file (such as <code>python.exe</code>).</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#比如：我有一个new.txt文件</span></span><br><span class=\"line\">a = zipfile.ZipFile(<span class=\"string\">&#x27;new.txt&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>) <span class=\"comment\"># 此时new.txt文件会被归档，new.txt会被改写为zip文件</span></span><br><span class=\"line\">a.write(<span class=\"string\">&#x27;new.txt&#x27;</span>)</span><br><span class=\"line\">a.close()</span><br><span class=\"line\"><span class=\"comment\"># 并在外侧改写new.txt的后缀为.zip，发现存在是一个正式的.zip文件且存在一个new.txt</span></span><br></pre></td></tr></table></figure>\r\n<p>If <em>mode</em> is <code>'a'</code> and the file does not exist at\r\nall, it is created.</p>\r\n</blockquote>\r\n<p>If <em>mode</em> is <code>'r'</code> or <code>'a'</code>, the file\r\nshould be seekable.</p>\r\n</blockquote>\r\n</blockquote>\r\n<blockquote>\r\n<p>compression 表示压缩格式，可选的压缩格式只有 2\r\n个：ZIP_STORE;ZIP_DEFLATED。ZIP_STORE 是默认的，表示不压缩；ZIP_DEFLATED\r\n表示压缩。</p>\r\n<p>allowZip64 为 True 时，表示支持 64\r\n位的压缩，一般而言，在所压缩的文件大于 2G\r\n时，会用到这个选项；默认情况下，该值为 False，因为 Unix 系统不支持。</p>\r\n</blockquote>\r\n<p>1.2 <code>zipfile</code>.<strong>close</strong>()</p>\r\n<blockquote>\r\n<p>你写入的任何文件在关闭之前不会真正写入磁盘。</p>\r\n</blockquote>\r\n<p>1.3 <code>zipfile</code>.<strong>write</strong>(filename[, arcname[,\r\ncompress_type]])</p>\r\n<blockquote>\r\n<p>acrname 是压缩文件中该文件的名字，默认情况下和 filename 一样</p>\r\n<p>compress_type 的存在是因为 zip\r\n文件允许被压缩的文件可以有不同的压缩类型。</p>\r\n</blockquote>\r\n<p>1.4 <code>zipfile</code>.<strong>extractall</strong>([path[, member[,\r\npassword]]])</p>\r\n<blockquote>\r\n<p>path 解压缩目录</p>\r\n<p>member 需要解压缩的文件名儿列表</p>\r\n<p>password 当 zip 文件有密码时需要该选项</p>\r\n<blockquote>\r\n<p>Extract all members from the archive to the current working\r\ndirectory.</p>\r\n<p><em>path</em> specifies a different directory to extract to.\r\n<em>members</em> is optional and must be a subset of the list returned\r\nby <a\r\nhref=\"https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile.namelist\"><code>namelist()</code></a>.\r\n<em>pwd</em> is the password used for encrypted files.</p>\r\n</blockquote>\r\n</blockquote>\r\n<ol type=\"1\">\r\n<li><code>ZipFile.</code><strong>namelist</strong>()</li>\r\n</ol>\r\n","text":"使用python自动化处理的文件及zipfile模块的介绍 使用 Python 解决文件自动化改名和命名 原因：获取压缩文件的实际名称： 压缩文件名称使用了随机字符，而原文件夹作为压缩文件的根目录来保存，为了避免打开压缩文件才能知道打开的到底是哪个文件，需要将压缩文件内的文件夹名...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%84%E7%90%86%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%8Azipfile%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">使用python自动化处理的文件及zipfile模块的介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-python-%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E6%94%B9%E5%90%8D%E5%92%8C%E5%91%BD%E5%90%8D\"><span class=\"toc-text\">使用 Python\r\n解决文件自动化改名和命名</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0%E8%8E%B7%E5%8F%96%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E9%99%85%E5%90%8D%E7%A7%B0\"><span class=\"toc-text\">原因：获取压缩文件的实际名称：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%87%E7%94%A8%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">采用方案：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%A8%A1%E5%9D%97zipfile\"><span class=\"toc-text\">解压缩模块：zipfile</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97os\"><span class=\"toc-text\">文件处理模块：os</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E5%AD%97%E6%8F%90%E5%8F%96%E6%A8%A1%E5%9D%97%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre\"><span class=\"toc-text\">文字提取模块（正则表达式）：re</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%85%B3zipfile%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">有关zipfile的常用方法：</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"基本的Python爬虫","uid":"d2b3e77ca5e5c321ffd72dd8a363d797","slug":"Language Learning/Python/python爬虫","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T20:01:22.000Z","comments":true,"path":"api/articles/Language Learning/Python/python爬虫.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"基本的Python爬虫 第一步：引入包并准备临时存储数据的列表 12345678910111213141516171819import urllib.requestimport urllib.parseimport requestsfrom bs4 import Beautifu...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Birthday Paradox","uid":"b0298187d3b43e42af9c0e2b93f65724","slug":"Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T14:27:36.000Z","comments":true,"path":"api/articles/Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"生日悖论-birthday paradox 一个很简单的概率关系，由于其反直觉而称为“悖论”： 一个房间要多少人，则两个人的生日相同的概率 对应情况 所需人数 大于50%？ 23人 大于70%？ 30人 大于97%？ 50人 大于99%？ 57人 可以发现，概率大于99%所需的人...","link":"","photos":[],"count_time":{"symbolsCount":966,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}