{"title":"售货员问题","uid":"ab5351d849d735008d49a961e1e5262a","slug":"Algorithm/DP/Traveling Salesman Problem","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T16:10:04.000Z","comments":true,"path":"api/articles/Algorithm/DP/Traveling Salesman Problem.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h2 id=\"一题目\">一、题目</h2>\r\n<ul>\r\n<li>一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。\r\n售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。</li>\r\n<li>（等价于求图的最短哈密尔顿回路问题）令G=(V,\r\nE)是一个带权重的有向图，顶点集V=(v0, v1, ...,\r\nvn-1)。从图中任一顶点vi出发，经图中所有其他顶点一次且只有一次，最后回到同一顶点vi的最短路径。</li>\r\n</ul>\r\n<h2 id=\"二测试用例\">二、测试用例</h2>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923191204612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>其中1,2,3,4,5代表五个城市。此模型可抽象为图，可用邻接矩阵c表示，如下图所示：</p>\r\n<figure>\r\n<img src=\"https://img-blog.csdnimg.cn/20190917202003190.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h2 id=\"三动态规划方程\">三、动态规划方程</h2>\r\n<p>假设从顶点s出发，令d(i,\r\nV)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。</p>\r\n<p>​ 推导：(分情况来讨论)</p>\r\n<p>​ ①当V为空集，那么d()<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28i%2C%20V%29\" />，表示直接从i回到s了，此时<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28i%2CV%29%20%3D%20c_%7Bis%7D\" />\r\n且 <embed\r\nsrc=\"https://private.codecogs.com/gif.latex?%28i%5Cneq%20s%29\" /></p>\r\n<p>​\r\n②如果V不为空，那么就是对子问题的最优求解。你必须在V这个城市集合中，尝试每一个，并求出最优解。</p>\r\n<p>​ <embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28i%2C%20V%29%3Dmin%28C_%7Bik%7D%20+%20d%28k%2C%20V-%28k%29%29\" /></p>\r\n<p>​ 注：<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?c_%7Bik%7D\" />表示选择的城市和城市i的距离，<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28k%2C%20V-%28k%29%29\" />是一个子问题。</p>\r\n<p>​ 综上所述，TSP问题的动态规划方程就出来了：</p>\r\n<figure>\r\n<img src=\"https://img-blog.csdnimg.cn/20190923192452307.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h2 id=\"四用例分析\">四、用例分析</h2>\r\n<p>现在对问题定义中的例子来说明TSP的求解过程。(假设出发城市是 0城市)</p>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923192924546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923192935826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>这里只画出了d(1,{2,3,4}),由于篇幅有限这里就不画了。</p>\r\n<p>①我们要求的最终结果是d(0,{1,2,3,4}),它表示，从城市0开始，经过{1,2,3,4}之中的城市并且只有一次，求出最短路径.。\r\n②d(0,{1,2,3,4})是不能一下子求出来的，那么他的值是怎么得出的呢？看上图的第二层，第二层表明了d(0,{1,2,3,4})所需依赖的值。那么得出：\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923194300642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n③d(1,{2,3,4})，d(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样也不是一步就能求出来的，它们的解一样需要有依赖，就比如说d(1,{2,3,4})\r\n<img src=\"https://img-blog.csdnimg.cn/20190923194321514.png\"\r\nalt=\"img\" />\r\nd(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样需要这么求。</p>\r\n<p>④按照上面的思路，只有最后一层的，当V为空集时，就可以满足<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28i%2CV%29%20%3D%20c_%7Bis%7D\" />\r\n且 <embed\r\nsrc=\"https://private.codecogs.com/gif.latex?%28i%5Cneq%20s%29\" />该条件，直接求出dp数组部分的值。</p>\r\n<h2 id=\"五数据结构\">五、数据结构</h2>\r\n<p>由上述动态规划公式d(i,V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。根据上述给的测试用例有5个城市编号0,1,2,3,4。那么访问n个城市，恰好访问每个城市一次，并最终回到出发城市的嘴短距离可表示为d(0,{1,2,3,4}),那么问题来了我们用什么数据结构表示d(i,V)，这里我们就可二维数据dp[N][M]来表示，N表示城市的个数，M表示集合的数量，即<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?M%20%3D%202%5E%7BN-1%7D\" />,之所以这么表示因为集合V有<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?2%5E%7BN-1%7D\" />个子集。根据测试用例可得出如下dp数组表格：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923200357348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>那么你们可能就有疑问了，为什么这么表示？这里说明一下比如集合{1,2,3,4}为什么用15表示，<strong>我们可以把集合中元素看成二进制1的位置</strong>（二进制从右开始看），1表示从右开始第一位为1,2表示从又开始第二位为1，所以集合{1,2,3,4}可表示二进制（1111）转化为十进制为15。再举个例子比如集合{1,3}表示为二进制为0101，十进制为5。所以我们求出dp[0][15]（通用表示dp[0][<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?2%5E%7BN-1%7D-1\" />]）就是本题的最终解。</p>\r\n<p>注意：</p>\r\n<ul>\r\n<li>对于第y个城市，他的二进制表达为，1&lt;&lt;(y-1)。</li>\r\n<li>对于数字x，要看它的第i位是不是1，那么可以通过判断布尔表达式 (((x\r\n&gt;&gt; (i - 1) ) &amp; 1) == 1或者（x &amp; (1&lt;&lt;(i-1))）!=\r\n0的真值来实现。</li>\r\n<li>由动态规划公式可知，需要从集合中剔除元素。假如集合用索引x表示，要剔除元素标号为i,我们异或运算实现减法，其运算表示为：\r\nx = x ^ (1&lt;&lt;(i - 1))。</li>\r\n</ul>\r\n<h2 id=\"六最短路径顶点的计算\">六、最短路径顶点的计算</h2>\r\n<p>我们先计算dp[N][M]数组之后，我可以用dp数组来反向推出其路径。其算法思想如下：</p>\r\n<p>比如在第一步时，我们就知道那个值最小，如下图所示：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923194300642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>因为dp[][]数组我们已经计算出来了，由计算可知C01+d(1,{2,3,4})最小，所以一开始从起始点0出发，经过1。接下来同样计算d(1,{2,3,4})</p>\r\n<figure>\r\n<img src=\"https://img-blog.csdnimg.cn/20190923194321514.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>由计算可知C14+d(4,{2,3})所以0---&gt;1----&gt;4，接下来同理求d(4,{2,3})，这里就省略，读者可以自行计算。最终计算出来的路径为：0---&gt;1---&gt;4---&gt;2---&gt;3---&gt;0</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INF 10e7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> min(a,b) ((a&gt;b)?b:a)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> M = <span class=\"number\">1</span> &lt;&lt; (N<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"comment\">//存储城市之间的距离</span></span><br><span class=\"line\"><span class=\"type\">int</span> g[N][N] = &#123;&#123;<span class=\"number\">0</span>,<span class=\"number\">3</span>,INF,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;,</span><br><span class=\"line\">               &#123;<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>,<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">               &#123;INF,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">               &#123;<span class=\"number\">8</span>,<span class=\"number\">10</span>,<span class=\"number\">4</span>,<span class=\"number\">0</span>,<span class=\"number\">20</span>&#125;,</span><br><span class=\"line\">               &#123;<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">20</span>,<span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//保存顶点i到状态s最后回到起始点的最小距离</span></span><br><span class=\"line\"><span class=\"type\">int</span> dp[N][M];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//保存路径</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; path;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//核心函数，求出动态规划dp数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TSP</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化dp[i][0]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        dp[i][<span class=\"number\">0</span>] = g[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//求解dp[i][j]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; M; j++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++ ) &#123;</span><br><span class=\"line\">            dp[i][j] = INF;</span><br><span class=\"line\">            <span class=\"comment\">//如果集和j(或状态j)中包含结点i,则不符合条件退出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( ((j &gt;&gt; (i<span class=\"number\">-1</span>)) &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt; N; k++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( ((j &gt;&gt; (k<span class=\"number\">-1</span>)) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span>( dp[i][j] &gt; g[i][k] + dp[k][j^(<span class=\"number\">1</span>&lt;&lt;(k<span class=\"number\">-1</span>))] )</span><br><span class=\"line\">                    dp[i][j] = g[i][k] + dp[k][j^(<span class=\"number\">1</span>&lt;&lt;(k<span class=\"number\">-1</span>))] ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断结点是否都以访问,不包括0号结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isVisited</span><span class=\"params\">(<span class=\"type\">bool</span> visited[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i&lt;N ;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(visited[i] == <span class=\"literal\">false</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取最优路径，保存在path中,根据动态规划公式反向找出最短路径结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getPath</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//标记访问数组</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> visited[N] = &#123;<span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//前驱节点编号</span></span><br><span class=\"line\">    <span class=\"type\">int</span> pioneer = <span class=\"number\">0</span> ,min = INF, S = M - <span class=\"number\">1</span>,temp ;</span><br><span class=\"line\">    <span class=\"comment\">//把起点结点编号加入容器</span></span><br><span class=\"line\">    path.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">isVisited</span>(visited))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;N;i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[i] == <span class=\"literal\">false</span> &amp;&amp; (S&amp;(<span class=\"number\">1</span>&lt;&lt;(i<span class=\"number\">-1</span>))) != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(min &gt; g[i][pioneer] + dp[i][(S^(<span class=\"number\">1</span>&lt;&lt;(i<span class=\"number\">-1</span>)))])</span><br><span class=\"line\">                    min = g[i][pioneer] + dp[i][(S^(<span class=\"number\">1</span>&lt;&lt;(i<span class=\"number\">-1</span>)))] ;</span><br><span class=\"line\">                    temp = i;</span><br><span class=\"line\">            </span><br><span class=\"line\">        pioneer = temp;</span><br><span class=\"line\">        path.<span class=\"built_in\">push_back</span>(pioneer);</span><br><span class=\"line\">        visited[pioneer] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        S = S ^ (<span class=\"number\">1</span>&lt;&lt;(pioneer - <span class=\"number\">1</span>));</span><br><span class=\"line\">        min = INF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printPath</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;最小路径为：&quot;</span>;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt;::iterator  it = path.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(it ; it != path.<span class=\"built_in\">end</span>();it++)</span><br><span class=\"line\">        cout&lt;&lt;*it&lt;&lt;<span class=\"string\">&quot;---&gt;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//单独输出起点编号</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">TSP</span>();</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;最小值为：&quot;</span>&lt;&lt;dp[<span class=\"number\">0</span>][M<span class=\"number\">-1</span>]&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"built_in\">getPath</span>();</span><br><span class=\"line\">    <span class=\"built_in\">printPath</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"八测试结果及性能分析\">八、测试结果及性能分析</h2>\r\n<figure>\r\n<img src=\"https://img-blog.csdnimg.cn/20190923205046784.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>时间复杂度：<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?O%282%5E%7Bn%7Dn%5E%7B2%7D%29\" /></p>\r\n<p>空间复杂度：<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?O%282%5E%7Bn%7D%29\" /></p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/qq_39559641/article/details/101209534\">旅行商问题（动态规划方法，超级详细的）_仁者乐山智者乐水的博客-CSDN博客_旅行商问题</a></p>\r\n","text":"一、题目 一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。 售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。 （等价于求图的最短哈密尔顿回路问题）令G=(V, E)是一个带权重的有向...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"DP","slug":"DP","count":1,"path":"api/tags/DP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">一、题目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B\"><span class=\"toc-text\">二、测试用例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">三、动态规划方程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E7%94%A8%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">四、用例分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">五、数据结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">六、最短路径顶点的计算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\"><span class=\"toc-text\">八、测试结果及性能分析</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Birthday Paradox","uid":"b0298187d3b43e42af9c0e2b93f65724","slug":"Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T14:27:36.000Z","comments":true,"path":"api/articles/Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"生日悖论-birthday paradox 一个很简单的概率关系，由于其反直觉而称为“悖论”： 一个房间要多少人，则两个人的生日相同的概率 对应情况 所需人数 大于50%？ 23人 大于70%？ 30人 大于97%？ 50人 大于99%？ 57人 可以发现，概率大于99%所需的人...","link":"","photos":[],"count_time":{"symbolsCount":966,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Hash Function","uid":"991c84bc86acdc32c9243fba302e2655","slug":"Algorithm/HashFunction/HashFunction","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T14:28:14.000Z","comments":true,"path":"api/articles/Algorithm/HashFunction/HashFunction.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"简明Hash function教程 请注意！这篇文档是关于散列函数Hash function的，如果需要了解Hash table相关内容请查阅“简明Hash table教程”等相关文章 引子 在各种下载站的资源页面下方，经常会有如下以SHA开头的特殊字段 SHA1：9B71AD5...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"Hash","slug":"Hash","count":1,"path":"api/tags/Hash.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}