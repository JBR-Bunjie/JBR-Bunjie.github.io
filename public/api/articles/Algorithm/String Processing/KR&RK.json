{"title":"R&K Algorithm","uid":"3300e6e8edea21eb33ad89b2150bf9cc","slug":"Algorithm/String Processing/KR&RK","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:10:37.847Z","comments":true,"path":"api/articles/Algorithm/String Processing/KR&RK.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"rabinkarp-algorithm---拉宾-卡普算法\">Rabin–Karp algorithm -\r\n拉宾-卡普算法</h1>\r\n<p><del>拉宾-卡普算法（英語：Rabin–Karp\r\nalgorithm）或卡普-拉宾算法（Karp–Rabin algorithm）</del></p>\r\n<h2 id=\"general\">General</h2>\r\n<p><a\r\nhref=\"https://en.wikipedia.org/wiki/Rabin–Karp_algorithm\">Rabin-Karp\r\n算法</a>是由 <a\r\nhref=\"https://en.wikipedia.org/wiki/Richard_M._Karp\">Richard M.\r\nKarp</a>和 <a\r\nhref=\"https://en.wikipedia.org/wiki/Michael_O._Rabin\">Michael O.\r\nRabin</a>创建的字符串搜索算法</p>\r\n<p>KR Algorithm使用散列来查找文本中的一组模式字符串中的任何一个。</p>\r\n<h2 id=\"detail\">Detail</h2>\r\n<p>假设我们有一个文本： <strong>yeminsajid</strong>\r\n，我们想知道文本中是否存在模式 <strong>nsa</strong>\r\n。要计算散列和滚动散列，我们需要使用素数。这可以是任何素数。让我们在这个例子中使用\r\n<strong>prime</strong> = <strong>11</strong>\r\n。我们将使用以下公式确定哈希值：</p>\r\n<pre class=\"line-numbers language-placeholder\" data-language=\"placeholder\"><code class=\"language-placeholder\">(1st letter) X (prime) + (2nd letter) X (prime)¹ + (3rd letter) X (prime)² X + ......</code></pre>\r\n<p>我们将表示：</p>\r\n<pre class=\"line-numbers language-placeholder\" data-language=\"placeholder\"><code class=\"language-placeholder\">a -&gt; 1    g -&gt; 7    m -&gt; 13   s -&gt; 19   y -&gt; 25\nb -&gt; 2    h -&gt; 8    n -&gt; 14   t -&gt; 20   z -&gt; 26\nc -&gt; 3    i -&gt; 9    o -&gt; 15   u -&gt; 21\nd -&gt; 4    j -&gt; 10   p -&gt; 16   v -&gt; 22\ne -&gt; 5    k -&gt; 11   q -&gt; 17   w -&gt; 23\nf -&gt; 6    l -&gt; 12   r -&gt; 18   x -&gt; 24</code></pre>\r\n<p><strong>nsa</strong> 的哈希值为 ： <span class=\"math display\">\\[\r\nHASH(nsa) = 14 * 11^0 + 19 * 11^1 + 1 * 11^2 = 344\r\n\\]</span></p>\r\n<p>现在我们找到文本的滚动哈希值。如果滚动哈希与模式的哈希值匹配，我们将检查字符串是否匹配。因为我们的模式有\r\n<strong>3 个</strong>字母，我们将采取 1 日 <strong>3</strong> 封\r\n<strong>YEM</strong> 从我们的文本，并计算哈希值。我们得到： <span\r\nclass=\"math display\">\\[\r\nHASH(yem) = 25 * 11^0 + 5 * 11^1 + 13 * 11^2 = 1653\r\n\\]</span>\r\n此值与我们的模式的哈希值不匹配。所以字符串在这里不存在。现在我们需要考虑下一步。计算下一个字符串\r\n<strong>emi</strong>\r\n的哈希值。我们当然可以直接重新从。但这将是相当微不足道的，并且会花费更多。相反，我们使用另一种技术。</p>\r\n<ul>\r\n<li>我们从当前哈希值中减去 <strong>Previous String</strong> 中的\r\n<strong>第一个字母的</strong> 即 <strong>y</strong>\r\n的值。即：<code>1653 - 25 = 1628</code>。</li>\r\n<li>再次除以设定的<strong>素数 prime——11</strong>，可得：1628 / 11 =\r\n148`。</li>\r\n<li>最后加上<strong>新的字母 *（素数）^ m -\r\n1</strong>，可得：<code>148 + 9 X 11² = 1237</code>。</li>\r\n</ul>\r\n<p>新的哈希值不等于我们的模式哈希值。继续前进直到 <strong>a</strong>\r\n(nsa)，有：</p>\r\n<pre class=\"line-numbers language-placeholder\" data-language=\"placeholder\"><code class=\"language-placeholder\">Previous String: ins\nFirst Letter of Previous String: i(9)\nNew Letter: a(1)\nNew String: &quot;nsa&quot;\n------------------------------\n2462 - 9 &#x3D; 2453\n2453 &#x2F; 11 &#x3D; 223\n223 + 1 X 11² &#x3D; 344</code></pre>\r\n<p>这是一个匹配！\r\n现由于两个字符串都匹配，因此匹配字符串存在于目标字符串中，现在我们只需要返回目标字符串匹配字段的起始位置即可。</p>\r\n<h2 id=\"code\">Code</h2>\r\n<h3 id=\"kr---js\">KR - JS</h3>\r\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;string&#125; haystack\n * @param &#123;string&#125; needle\n * @return &#123;number&#125;\n *&#x2F;\n&#x2F;*\n\n*&#x2F;\n&#x2F;**\n * @param &#123;string&#125; haystack\n * @param &#123;string&#125; needle\n * @return &#123;number&#125;\n *&#x2F;\nvar strStr &#x3D; function(haystack, needle)&#123;\n    if(needle.length &#x3D;&#x3D; 0) return 0;\n    let n &#x3D; haystack.length;\n    let m &#x3D; needle.length;\n    let s &#x3D; &#39; &#39;+haystack;\n    let t &#x3D; &#39; &#39;+needle;\n    \n    &#x2F;&#x2F;String添加一个重新确定字符值得方法\n    String.prototype.newCode &#x3D; function()&#123;\n        return this.charCodeAt()-97+1;\n    &#125;\n    &#x2F;&#x2F;确定模数 尽量避免冲突\n    let p &#x3D; 999991, d &#x3D; 131;\n    &#x2F;&#x2F;计算thash\n    let tHash &#x3D; 0;\n    for(let i&#x3D;1; i&lt;&#x3D;m; i++)&#123;\n        tHash &#x3D; (tHash*d + t[i].newCode()) % p;\n    &#125;\n    &#x2F;&#x2F;计算sHash子串的值\n    let sHash &#x3D; new Array(n+1);\n    sHash[0] &#x3D; 0;\n    for(let i&#x3D;1; i&lt;&#x3D;n; i++)&#123;\n        sHash[i] &#x3D; (sHash[i-1]*d + s[i].newCode()) % p;\n    &#125;\n   \n\n    &#x2F;&#x2F;hello ll\n    for(let i&#x3D;m; i&lt;&#x3D;n; i++)&#123;\n        if(calcHash(i-m, i, m) &#x3D;&#x3D; tHash)&#123;\n            return i-m;\n        &#125;\n    &#125;\n    return -1;\n    function calcHash(l, r, len)&#123;\n        &#x2F;&#x2F;_hello  求ll的hash\n        &#x2F;&#x2F;先求_hell的hash, 再求_he的hash进行补位\n        &#x2F;&#x2F;_hell - _he00 就是ll\n        &#x2F;&#x2F;注意相减的时候为避免负数，可以先加上模数。再取模\n        return (sHash[r] - (sHash[l]*myPow(d, len, p))%p + p) % p;\n    &#125;\n&#125;\nfunction myPow(x,n, m)&#123;\n    function helper(x,n)&#123;\n        if(n&#x3D;&#x3D;0) return 1.0;\n        let y &#x3D; helper(x, n&#x2F;2 | 0);\n        return n%2 &#x3D;&#x3D;0 ? (y*y)%m: (y*y*x)%m;\n    &#125;\n    return n&gt;&#x3D;0? helper(x, n) : 1.0&#x2F;helper(x, n);\n&#125;</code></pre>\r\n<h2 id=\"reference\">Reference</h2>\r\n<ul>\r\n<li><a\r\nhref=\"http://www.tastones.com/stackoverflow/algorithm/substring-search/introduction_to_rabin-karp_algorithm/\">Rabin-Karp\r\n算法简介 | 他山教程，只选择最优质的自学材料 (tastones.com)</a></li>\r\n<li><a\r\nhref=\"https://leetcode-cn.com/problems/implement-strstr/solution/28-shi-xian-strstr-rabin-karp-by-jingyua-w3h1/\">28.\r\n实现 strStr() 题解 - 力扣（LeetCode） (leetcode-cn.com)</a></li>\r\n</ul>\r\n","text":"Rabin–Karp algorithm - 拉宾-卡普算法 拉宾-卡普算法（英語：Rabin–Karp algorithm）或卡普-拉宾算法（Karp–Rabin algorithm） General Rabin-Karp 算法是由 Richard M. Karp和 Micha...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"String Processing","slug":"String-Processing","count":7,"path":"api/tags/String-Processing.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#rabinkarp-algorithm---%E6%8B%89%E5%AE%BE-%E5%8D%A1%E6%99%AE%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Rabin–Karp algorithm -\r\n拉宾-卡普算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#general\"><span class=\"toc-text\">General</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#detail\"><span class=\"toc-text\">Detail</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#code\"><span class=\"toc-text\">Code</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#kr---js\"><span class=\"toc-text\">KR - JS</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"KMP","uid":"53896b079468d4c41963b2300dea196e","slug":"Algorithm/String Processing/KMP","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:10:22.191Z","comments":true,"path":"api/articles/Algorithm/String Processing/KMP.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"KMP算法 KMP算法作用简介： 在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"String Processing","slug":"String-Processing","count":7,"path":"api/tags/String-Processing.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Cpp `#pragma Once` and `#ifndef`","uid":"9804ef7a4cf22f333e494cd94f29c482","slug":"Language Learning/CPP/[F]PragmaOnce","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:37:46.943Z","comments":true,"path":"api/articles/Language Learning/CPP/[F]PragmaOnce.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Source 在 C++ 中防止头文件被重复包含时为什么同时使用 #ifndef 和 #pragma once？ - 望山的回答 - 知乎 https://www.zhihu.com/question/40990594/answer/1675549910 #pragma once...","link":"","photos":[],"count_time":{"symbolsCount":506,"symbolsTime":"1 mins."},"categories":[{"name":"Coding Language","slug":"Coding-Language","count":4,"path":"api/categories/Coding-Language.json"}],"tags":[{"name":"CPP","slug":"CPP","count":1,"path":"api/tags/CPP.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}