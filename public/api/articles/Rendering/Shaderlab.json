{"title":"Shaderlab 总览及其基本执行逻辑","uid":"3efe5f95488e956915246e267ac83bb6","slug":"Rendering/Shaderlab","date":"2023-05-02T04:23:23.000Z","updated":"2023-10-27T20:14:20.000Z","comments":true,"path":"api/articles/Rendering/Shaderlab.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"shaderlab-总览及其基本执行逻辑\">Shaderlab\r\n总览及其基本执行逻辑</h1>\r\n<h2 id=\"shaderlab-结构总览\">Shaderlab 结构总览</h2>\r\n<p>Shaderlab 是 Unity\r\n所使用的，独立的着色器语言。这是一种跨平台的语言体系，大体包含四部分：</p>\r\n<ul>\r\n<li>ShaderLab Text</li>\r\n<li>ShaderLab Compiler</li>\r\n<li>ShaderLab Asset</li>\r\n<li>ShaderLab Runtime</li>\r\n</ul>\r\n<p>我们将一一解释：</p>\r\n<h2 id=\"shaderlab-text\">Shaderlab Text</h2>\r\n<p>ShaderLab Text 指的是在 <code>.shader</code>\r\n文件中，由我们所定义的那些代码。它们需要使用或 <code>CG</code> 或\r\n<code>HLSL</code>\r\n等的语法规则来编写。官方文档可见：<a href=\"#ShaderlabManual\">Reference</a></p>\r\n<p>而 ShaderLab Text 的基本结构如下：</p>\r\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Shader</span> <span class=\"string\">&quot;&lt;name&gt;&quot;</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">Material</span> <span class=\"string\">properties&gt;</span> <span class=\"comment\"># 暴露在外的材质属性</span></span><br><span class=\"line\">    <span class=\"string\">&lt;One</span> <span class=\"string\">or</span> <span class=\"string\">more</span> <span class=\"string\">SubShader</span> <span class=\"string\">definitions&gt;</span> <span class=\"comment\"># Subshader块是必选的，这是Shader中的实在代码</span></span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">fallback&gt;</span> <span class=\"comment\"># 回调Shader</span></span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">custom</span> <span class=\"string\">editor&gt;</span> <span class=\"comment\">#指定该Shader需要采用的editor，比如Amplify Shader Editor等</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"properties\">Properties</h3>\r\n<p>我们利用 <code>Material properties</code>\r\n可选项来可以定义在应用了当前 <code>Shader</code> 的\r\n<code>Material</code> 上显示的数据，而中的格式如下：</p>\r\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Properties</span> &#123;</span><br><span class=\"line\">    [<span class=\"attr\">optional:</span> <span class=\"string\">attribute</span>] <span class=\"string\">name(&quot;display</span> <span class=\"string\">text</span> <span class=\"string\">in</span> <span class=\"string\">Inspector&quot;</span>, <span class=\"string\">type</span> <span class=\"string\">name)</span> <span class=\"string\">=</span> <span class=\"string\">default</span> <span class=\"string\">value</span></span><br><span class=\"line\">    [<span class=\"attr\">optional:</span> <span class=\"string\">attribute</span>] <span class=\"string\">name(&quot;display</span> <span class=\"string\">text</span> <span class=\"string\">in</span> <span class=\"string\">Inspector&quot;</span>, <span class=\"string\">type</span> <span class=\"string\">name)</span> <span class=\"string\">=</span> <span class=\"string\">default</span> <span class=\"string\">value</span></span><br><span class=\"line\">    <span class=\"string\">......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在我们日常编写中，我们不太长见到 <code>attribute</code>\r\n的使用，但事实上 <code>Properties</code> 中是存在很多类型的\r\n<code>attribute</code> 的，注明这些 <code>attribute</code>\r\n能让我们在脚本中实时控制 <code>Properties</code> 更加方便</p>\r\n<p>特别的，如果使用的是 SRP，想使用\r\n<strong><code>SRP Batcher compatibility</code></strong>\r\n特性，我们像下方这样必须把每个 Properties 里的变量放到在 HLSL 代码中的\r\n<strong>CBUFFER</strong> 中： 特殊的，贴图和采样器本身不需要再 CBUFFER\r\n中声明，但是其相关参数 <code>Texel_size</code> 及 <code>ST</code>\r\n则需要</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties &#123;</span><br><span class=\"line\">    _Color (&quot;Colot Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class=\"line\">    _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class=\"line\">    _Layers (&quot;Cloud Level&quot;, Range(8, 128)) = 16</span><br><span class=\"line\">    _SpeedX (&quot;Speed X&quot;, float) = 0.05</span><br><span class=\"line\">    _SpeedY (&quot;Speed Y&quot;, float) = 0.05</span><br><span class=\"line\">    _Alpha (&quot;Cloud Alpha Value&quot;, Range(0, 1)) = 0.6</span><br><span class=\"line\">    _HeightOffset (&quot;Height Offset&quot;, float) = 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubShader &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    HLSLINCLUDE</span><br><span class=\"line\"></span><br><span class=\"line\">    TEXTURE2D(_MainTex);</span><br><span class=\"line\">    SAMPLER(sampler_MainTex);</span><br><span class=\"line\"></span><br><span class=\"line\">    CBUFFER_START(UnityPerMaterial)</span><br><span class=\"line\">        half4 _Color;</span><br><span class=\"line\">        float4 _MainTex_ST;</span><br><span class=\"line\">        float _Layers;</span><br><span class=\"line\">        float _SpeedX;</span><br><span class=\"line\">        float _SpeedY;</span><br><span class=\"line\">        half _Alpha;</span><br><span class=\"line\">        half _HeightOffset;</span><br><span class=\"line\">        CBUFFER_END</span><br><span class=\"line\">    ENDHLSL</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"subshader\">SubShader</h3>\r\n<p>SubShader 是主要逻辑的实现部分，它又可以再次细分：</p>\r\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">SubShader</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">LOD&gt;</span></span><br><span class=\"line\">    <span class=\"comment\"># Level Of Detial，这个值越小，意味着当前Shader的细节越少，也就是说这个Shader越容易被执行，不过当多个SubShader的LOD都比要求的LOD小时，会从上到下地(第一行代码到最后一行地)执行第一个符合条件的SubShader</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">tags&gt;</span></span><br><span class=\"line\">    <span class=\"comment\"># SubShader Tags，形式为键值对，Unity会根据它们决定何时、如何使用SubShader</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">commands&gt;</span></span><br><span class=\"line\">    <span class=\"comment\"># 诸如Blend、ZTest等命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&lt;One</span> <span class=\"string\">or</span> <span class=\"string\">more</span> <span class=\"string\">Pass</span> <span class=\"string\">definitions&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>而最后的 Pass 则是我们实在代码中，具体渲染过程所在的部分了。对于 Pass\r\n本身的结构，可以概括为：</p>\r\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Pass</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">name&gt;</span></span><br><span class=\"line\">    <span class=\"comment\"># 给Pass设置一个名字，以后可以用这个名字在别的Shader中使用UsePass Command来调用这个名字的Pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">tags&gt;</span></span><br><span class=\"line\">    <span class=\"comment\"># 和SubShader中的tags大同小异，但工作方式并不一样，具体来看就是所管理的键值对并不相同。下方的commands也是如此，请注意，#pragma这样的语句，不是Command</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">commands&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&lt;optional:</span> <span class=\"string\">shader</span> <span class=\"string\">code&gt;</span></span><br><span class=\"line\">    <span class=\"comment\"># 最终的Shader Code落脚的地方，包裹在HLSLPROGRAM之类的命令中</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"shaderlab-compiler\">ShaderLab Compiler</h2>\r\n<blockquote>\r\n<p>光有文本是不行的，就如同你写 C++，如果只是写了一堆 CPP\r\n文件，依然是无法被计算机认可并执行的。中间需要有翻译的过程，就是 shader\r\nCompiler 的过程。</p>\r\n</blockquote>\r\n<p>简单来说，Unity 会在后台提供的一种服务，用来帮助我们去把写好的\r\nShaderLab 语言翻译为目标机器能够认可并执行的语言</p>\r\n<p>这事实上包含两层：</p>\r\n<ul>\r\n<li>首先，对于我们的电脑本机来说：<code>HLSL</code> 及 <code>CG</code>\r\n等代码是不能直接运行在 DirectX 设备上的，而 Unity\r\n的编译器会把我们写好的这些代码编译成可执行的机器语言</li>\r\n<li>其次，我们所编写的 <code>HLSL</code> 等语言是不能直接运行在\r\n<code>OpenGL</code>，<code>Vulkan</code>\r\n等平台上的，我们得把代码转译为目标平台山的语言</li>\r\n</ul>\r\n<p>也就是说，ShaderLab Compiler 的实际行为是：把 ShaderLab Text\r\n翻译成最终目标机器上能够认可和执行的语言，对应的编译代码，我们可以通过点击\r\nInspect 面板下的 <code>Compile and show code</code> 来查看</p>\r\n<p><a\r\nhref=\"https://docs.unity.cn/2021.3/Documentation/Manual/shader-compilation.html\">Unity\r\n- Manual: Shader compilation</a></p>\r\n<h2 id=\"shaderlab-asset\">ShaderLab Asset</h2>\r\n<p>我们已经知道，ShaderLab\r\n里面有很多东西都是不能直接使用的，需要进行翻译。而加工之后得到的东西就叫做\r\nShaderLab Asset。Asset 比较常见的地方有两个：</p>\r\n<p>一个就是由 Shader 打成的 AssetBundle。另一个是我们打出来的包里面的\r\nlevel 或 sharedassets 包。</p>\r\n<h2 id=\"reference\">Reference:</h2>\r\n<ul>\r\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/400470713\">【Unity\r\n笔记】ShaderLab 与其底层原理浅谈 - 知乎 (zhihu.com)</a></p></li>\r\n<li><p><span id=\"ShaderlabManual\"><a\r\nhref=\"https://docs.unity3d.com/2021.3/Documentation/Manual/SL-Reference.html\">Unity\r\n- Manual: ShaderLab (unity3d.com)</a></span></p></li>\r\n</ul>\r\n","text":"Shaderlab 总览及其基本执行逻辑 Shaderlab 结构总览 Shaderlab 是 Unity 所使用的，独立的着色器语言。这是一种跨平台的语言体系，大体包含四部分： ShaderLab Text ShaderLab Compiler ShaderLab Asset ...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#shaderlab-%E6%80%BB%E8%A7%88%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">Shaderlab\r\n总览及其基本执行逻辑</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shaderlab-%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88\"><span class=\"toc-text\">Shaderlab 结构总览</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shaderlab-text\"><span class=\"toc-text\">Shaderlab Text</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#properties\"><span class=\"toc-text\">Properties</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#subshader\"><span class=\"toc-text\">SubShader</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shaderlab-compiler\"><span class=\"toc-text\">ShaderLab Compiler</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shaderlab-asset\"><span class=\"toc-text\">ShaderLab Asset</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference:</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"UnityURPToonLitShaderExample 源码分析","uid":"b0e884d72c7c6bc5c7d44e3b4aa33541","slug":"Rendering/SimpleToonShader","date":"2023-05-03T04:23:23.000Z","updated":"2023-10-27T20:13:22.000Z","comments":true,"path":"api/articles/Rendering/SimpleToonShader.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"最简的 Toon Shader 的源码分析 - UnityURPToonLitShaderExample What is included in this \"simplified version\" toon lit shader repository? This reposito...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"PBR","uid":"db4c4d4811d5722c3a2acb135b7ca20d","slug":"Rendering/PBR","date":"2023-05-01T04:23:23.000Z","updated":"2023-10-27T20:21:54.000Z","comments":true,"path":"api/articles/Rendering/PBR.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"PBR PBR，或者用更通俗一些的称呼是指基于物理的渲染(Physically Based Rendering)，它指的是一些在不同程度上都基于与现实世界的物理原理更相符的基本理论所构成的渲染技术的集合。 PBR 综述 PBR 是基于物理的渲染，具体表现为使用一种更符合物理学规律...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}