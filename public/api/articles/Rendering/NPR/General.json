{"title":"全排列","uid":"4bbde60d3dafb255adad1c9293392efa","slug":"Rendering/NPR/General","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T20:06:49.000Z","comments":true,"path":"api/articles/Rendering/NPR/General.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h2 id=\"光照模型特点概括\">光照模型特点概括：</h2>\r\n<p>首先，分析一下所谓的 <code>日式卡通渲染</code> 都有些什么特点：</p>\r\n<ul>\r\n<li>硬过渡亮暗面</li>\r\n<li>描边</li>\r\n<li></li>\r\n</ul>\r\n<p>因此，其可采用的具体的表现形式有：</p>\r\n<ul>\r\n<li>裁边漫反射 - StepDiffuse</li>\r\n<li>裁边高光</li>\r\n<li>裁边边缘光</li>\r\n<li>裁边视角光</li>\r\n<li>裁边光源光</li>\r\n</ul>\r\n<h3 id=\"裁边漫反射\">裁边漫反射</h3>\r\n<p>卡通渲染里希望存在明快的色调对比，而不希望存在额外的过渡光照信息：</p>\r\n<p>在实际执行中，我们使用：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> NL = <span class=\"built_in\">dot</span>(N, L);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传统Lambert漫反射</span></span><br><span class=\"line\"><span class=\"comment\">// traditionalDiffuse = _ObjectColor.rgb * _ColorTint_rgb * max(0, NL);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行映射以增大光照区域，当然也会方便后续可能的RampTexture取样</span></span><br><span class=\"line\"><span class=\"type\">float</span> NL01 = NL * <span class=\"number\">0.5</span> + <span class=\"number\">0.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> Threshold = <span class=\"built_in\">step</span>(_LightThreshold, NL01);</span><br><span class=\"line\">diffuse = <span class=\"built_in\">lerp</span>(DarkSide, BrightSide, Threshold);</span><br></pre></td></tr></table></figure>\r\n<p>来改写传统的漫反射光照，这样我们就能得到如下效果：</p>\r\n<p><img\r\nsrc=\"........\\images\\Technical%20Artist\\Rendering\\NPR\\General\\StepDiffuse.png\"\r\nalt=\"image-20230406155635370\" /> 裁边漫反射结果示意</p>\r\n<p>当然，我们也可以尝试在明暗交界线上做出特殊效果：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NL01 = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0</span>, _Smooth, NL01 - _SmoothRange);</span><br><span class=\"line\"><span class=\"comment\">// 我们也可以用Step的结果加上traditional diffuse的结果来做出类似smooth step的效果，但是这样就达不到可控交界线位置的效果了</span></span><br><span class=\"line\"><span class=\"comment\">// https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-smoothstep</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> Threshold = <span class=\"built_in\">step</span>(_LightThreshold, NL01);</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"裁边高光\">裁边高光</h3>\r\n<p>在传统的 BlinPhong 高光中，我们的光照计算公式为：<br /></p>\r\n<p><span class=\"math display\">\\[\r\nresult = pow(NH, \\_Exp) * SpecularScale\r\n\\]</span></p>\r\n<p>而为了裁边，我们会改用这样的计算：<br /></p>\r\n<p><span class=\"math display\">\\[\r\nNH = pow(NH, \\_Exp)\\\\\\\\\r\nresult = step(1 - \\_StepSpecularWidth * 0.01, NH)*SpecularIntensity;\r\n\\]</span></p>\r\n<p>改写的基本思路为：使用额外的宽度控制参数的情况下，利用 step\r\n函数对整个结果进行裁剪。在完成裁剪后，最后使用一个 Intensity\r\n参数来控制最终 specular\r\n呈现的值，这个值不会改变高光的范围，只会改变高光的具体数值，这会对我们的后续处理(如果存在的话)产生影响。</p>\r\n<p>后面的大多数裁边算法的思路与裁剪高光的思路大体相同。</p>\r\n<h3 id=\"裁边边缘光\">裁边边缘光</h3>\r\n<p>传统边缘光使用下方的计算方法，这会存在一个明显的明暗过渡：</p>\r\n<p><span class=\"math display\">\\[\r\nfloat3\\space Rim = pow(1-NV,RimExp)*RimIntensity;\r\n\\]</span></p>\r\n<p>因此我们使用一种和裁边高光相似的算法来改写这个过程：</p>\r\n<p><span class=\"math display\">\\[\r\nRim = step(1 - \\_RimWidth * 0.01, 1 - NV) * RimIntensity;\r\n\\]</span></p>\r\n<p>当然，我们可能还会对边缘光做很多额外的处理，比如在某种情况下，我们只希望物体上存在亮部相关的边缘光，那么我们可以：</p>\r\n<p><span class=\"math display\">\\[\r\ndiffuse = dot(N, L)\\\\\\\\\r\nRim = step(1 - \\_RimWidth * 0.01, 1 - NV) * RimIntensity;\\\\\\\\\r\nBrightSideRim = lerp(0, Rim, diffuse)\r\n\\]</span></p>\r\n<p>这种实现所得到的结果类似于菲涅尔效果，这里也给出菲涅尔的实现（可参考入门精要\r\n10.1.5 节）：</p>\r\n<p><strong>Schlick 菲涅尔近似等式</strong>：</p>\r\n<p><span class=\"math display\">\\[\r\nF_{Schlick}(\\overrightarrow v,\\space \\overrightarrow n) = F_0 + (1 -\r\nF_0)(1 - \\overrightarrow v \\cdot \\overrightarrow n)\r\n\\]</span></p>\r\n<p>其中，F<sub>0</sub>是一个反射系数，这回是一个常数，一般我们会将它暴露出来以方便调整；<strong>v</strong>是视角方向；<strong>n</strong>是表面法线</p>\r\n<p><strong>Empricial 菲涅尔近似等式</strong>：</p>\r\n<p><span class=\"math display\">\\[\r\nF_{Empricial}(\\overrightarrow v,\\space \\overrightarrow n) = max(0,\r\nmin(1,\\space bias + scale \\times (1- \\overrightarrow v \\cdot\r\n\\overrightarrow n)^{power}))\r\n\\]</span></p>\r\n<p>bias，scale，power 都是控制项</p>\r\n<p>从以上不难看出，菲涅尔其实也可以被归为一种边缘光，而边缘光的核心就是：<strong><em>1\r\n- NV</em></strong></p>\r\n<h3 id=\"裁边视角光\">裁边视角光</h3>\r\n<p>为了使眼睛看到的部分更亮而被运用的光。传统的视角光的计算是：</p>\r\n<p><span class=\"math display\">\\[\r\nViewLight = pow(NV,\\space ViewLightExp)*ViewLightIntensity;\r\n\\]</span></p>\r\n<p>我们仍然采用雷同高光的做法：</p>\r\n<p><span class=\"math display\">\\[\r\nViewLight = step(1 - \\_ViewLightWidth,\\space NV)*ViewLightIntensity;\r\n\\]</span></p>\r\n<h3 id=\"裁边光源光\">裁边光源光</h3>\r\n<p>裁边光源光对 NL 做\r\nStep，这意味着其结果与视角无关，仅与法线与光方向相关。这种\r\n<code>光源光</code> 可以算作 <code>视角光</code>\r\n的一种，只是光源方向和视角方向重合了</p>\r\n<p><span class=\"math display\">\\[\r\nStepLight = step(1-StepLightWidth,\\space NL);\r\n\\]</span></p>\r\n<p>关于裁光边缘的锯齿，我们也需要作出处理：<a\r\nhref=\"http://tuyg.top/archives/850\">涂月观 (tuyg.top)</a></p>\r\n<h3 id=\"outline\">Outline</h3>\r\n<h4 id=\"outline-的实现方式\">Outline 的实现方式</h4>\r\n<p>Outline 有多种实现方式，入门精要中提到过这么几种：</p>\r\n<ol type=\"1\">\r\n<li>基于观察角度和表面法线的轮廓线渲染：使用视角方向和表面法线的点乘结果来得到轮廓信息</li>\r\n<li>过程式几何轮廓线渲染：使用两个 Pass 来进行构建：第一个 Pass\r\n用来渲染背面的面片，并利用诸如顶点扩张等手法来使这些面片可见；第二个面片则用来渲染正面。这是大多数情况下的做法</li>\r\n<li>基于图像处理的轮廓线渲染：直接利用后处理来完成</li>\r\n<li>基于轮廓检测的轮廓线渲染：专用于需要精确检测出边缘并直接渲染它们以达到强烈的风格化效果的情况。利用一些特殊的判别式来确定轮廓线</li>\r\n</ol>\r\n<p>第二类中，我们一般采用背面法线外扩的方式，这是基于模型的：我们一般先沿法线方向挤出顶点。但是这个方法有较大的限制，如果盲目地进行，可能会出现各种问题，比如：转折处大的或者硬表面会经常发生断裂，内凹的模型在描边后正面的面片被背面的面片遮挡等问题。</p>\r\n<blockquote>\r\n<p>需要明确的是，平滑与平整是完全不同的</p>\r\n</blockquote>\r\n<p>还是入门精要，书中共用到了两种描边方式：一种是后处理时，通过边缘检测来描边，另一种是背部法线扩张。事实上，单是这两种方法就能实现很不错的效果。我们逐个开始：</p>\r\n<h4 id=\"后处理边缘检测\">后处理边缘检测</h4>\r\n<blockquote>\r\n<p>核心内容基本对应入门精要 12.3 节</p>\r\n</blockquote>\r\n<p>利用基于卷积的边缘检测，可以实现对剧烈变化的图像区块进行描边</p>\r\n<blockquote>\r\n<p>\"入门精要：...如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，我们就会认为他们之间应该有一条边界，这样的相邻像素之间的差值可以用梯度(Gradient)来表示...\"</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>什么是卷积？</p>\r\n<blockquote>\r\n<p>3blue1brown: <a\r\nhref=\"https://www.bilibili.com/video/BV1Vd4y1e7pj/?vd_source=c8eda79dd90c30ff02e09fb39906ac54\">【官方双语】那么……什么是卷积？_哔哩哔哩_bilibili</a></p>\r\n</blockquote>\r\n<blockquote>\r\n<p>入门精要：</p>\r\n<p>卷积操作是指，使用一个卷积核，对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形网络结构，该区域对每个方格都有一个权重值，当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置在像素上，并在翻转核之后再依次计算核中每个元素的每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。</p>\r\n</blockquote>\r\n</blockquote>\r\n<p>边缘检测的卷积核被称为边缘检测算子，常用的边缘检测算子有：</p>\r\n$$ Roberts: Gx =\r\n<span class=\"math display\">\\[\\begin{bmatrix}\r\n-1 &amp; 0\\\\\r\n0 &amp; 1\r\n\\end{bmatrix}\\]</span>\r\n; Gy=\r\n<span class=\"math display\">\\[\\begin{bmatrix}\r\n-1 &amp; 0\\\\\r\n0 &amp; 1\r\n\\end{bmatrix}\\]</span>\r\n<p>\\\\</p>\r\nPrewitt: Gx =\r\n<span class=\"math display\">\\[\\begin{bmatrix}\r\n-1 &amp; 0 &amp; 1\\\\\r\n-1 &amp; 0 &amp; 1\\\\\r\n-1 &amp; 0 &amp; 1\r\n\\end{bmatrix}\\]</span>\r\n<span class=\"math display\">\\[\\begin{bmatrix}\r\n-1 &amp; -1 &amp; -1\\\\\r\n0 &amp; 0 &amp; 0\\\\\r\n1 &amp; 1 &amp; 1\r\n\\end{bmatrix}\\]</span>\r\n<p>\\\\</p>\r\nSobel: Gx =\r\n<span class=\"math display\">\\[\\begin{bmatrix}\r\n-1 &amp; 0 &amp; 1\\\\\r\n-2 &amp; 0 &amp; 2\\\\\r\n-1 &amp; 0 &amp; 1\r\n\\end{bmatrix}\\]</span>\r\n<span class=\"math display\">\\[\\begin{bmatrix}\r\n-1 &amp; -2 &amp; -1\\\\\r\n0 &amp; 0 &amp; 0\\\\\r\n1 &amp; 2 &amp; 1\r\n\\end{bmatrix}\\]</span>\r\n<p>$$</p>\r\n<p>当我们进行卷积运算时，我们需要对每个像素分别使用 Gx 和 Gy\r\n两个卷积核，进行两次卷积操作。之后我们会得到两个方向上的梯度值。再整合这两者就可以得到整体的梯度值：</p>\r\n<p>$$ G=</p>\r\n<p>$$</p>\r\n<p>这个梯度值越大，说明当前位置像素周围的颜色变化越剧烈，就越有可能是图像的边缘。</p>\r\n<p>在 Built-in\r\n管线中，我们可以直接通过向场景中的摄像机挂载脚本，通过调用<code>OnRenderImage</code>方法来实现后处理系统，但是\r\nURP 中，我们则需要使用系统提供的 Render Feature\r\n来完成这件事。具体实现可参考：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/526234665?utm_id=0\">unity urp 14\r\nrender feature 实现简单后处理系统 - 知乎 (zhihu.com)</a></p>\r\n<p>对新手而言，在 Render Feature 下有几个要点需要指明：</p>\r\n<h5 id=\"脚本结构\">脚本结构：</h5>\r\n<blockquote>\r\n<p>快速创建 Render Feature\r\n的脚本模板：Asserts-&gt;Create-&gt;Rendering-&gt;Universal Render\r\nPipeline-&gt;Renderer Feature</p>\r\n<p><a\r\nhref=\"https://068089dy.github.io/2021/06/14/2021-06-14-unity-urp-postprocessing/\">Unity\r\n中 URP 管线实现后处理的几种方式 (068089dy.github.io)</a></p>\r\n</blockquote>\r\n<p>具体流程为，构造一个继承<code>ScriptableRendererFeature</code>的主类，并在这之中或者引用别处的自定义<code>ScriptableRenderPass</code>，实现其中的部分方法。</p>\r\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">custom</span> : <span class=\"title\">ScriptableRendererFeature</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Create</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> System.NotImplementedException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">AddRenderPasses</span>(<span class=\"params\">ScriptableRenderer renderer, <span class=\"keyword\">ref</span> RenderingData renderingData</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> System.NotImplementedException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title\">RenderOutlinePass</span> : <span class=\"title\">ScriptableRenderPass</span> &#123;</span><br><span class=\"line\">    \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Execute</span>(<span class=\"params\">ScriptableRenderContext context, <span class=\"keyword\">ref</span> RenderingData renderingData</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> System.NotImplementedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h5 id=\"脚本一般流程\">脚本一般流程：</h5>\r\n<p>在当前的 Universal Renderer Data\r\n下挂载好了对应的脚本后，我们的脚本就会开始生效。</p>\r\n<p>Create\r\n函数会最先执行，我们在这里初始化我们会用到的全部数据及内容，包括<code>ScriptableRenderPass</code>的初始化等</p>\r\n<p>然后会转到 AddRenderPasses\r\n的执行阶段，这里的标准流程是获取某个阶段的摄像机内容，传入<code>ScriptableRenderPass</code>实例中并将它重新压入这一帧的渲染队列</p>\r\n<p>等到了<code>ScriptableRenderPass</code>执行时，便会按照我们在<code>ScriptableRenderPass</code>类中定义的\r\nExecute 方法执行，这一方法的具体内容和 OnRenderImage 函数很像</p>\r\n<h5 id=\"脚本核心内容\">脚本核心内容：</h5>\r\n<h6 id=\"外部参数\">外部参数</h6>\r\n<p>对于一个后处理描边，我们会有如下的控制需求：</p>\r\n<ul>\r\n<li>实际使用的材质（也可以只汇入 Shader，然后再临时创建专用的\r\nMaterial，但终究是需要一个所专用的 Material 用于最后的函数调用）</li>\r\n<li>描边的颜色、描边的程度等</li>\r\n<li>用于指定 Render Feature 生效阶段的<code>renderPassEvent</code></li>\r\n</ul>\r\n<h6 id=\"scriptablerenderpass\">ScriptableRenderPass</h6>\r\n<blockquote>\r\n<ul>\r\n<li>https://docs.unity3d.com/Manual/render-pipelines-feature-comparison.html\r\nScriptableRenderPass implements a logical rendering pass that can be\r\nused to extend Universal RP renderer.</li>\r\n</ul>\r\n</blockquote>\r\n<p>在由 AddRenderPasses\r\n压入栈之后，我们所定义的<code>ScriptableRenderPass</code>就会在对应的阶段被执行，为此，我们需要至少在<code>ScriptableRenderPass</code>中，实现这些内容：</p>\r\n<ul>\r\n<li><p>接收在 Create 函数中汇入的外部参数，包括指定\r\nrenderPassEvent、Material 等</p></li>\r\n<li><p>编写实际执行调用 Material 去渲染的函数 Execute，这会包括：</p>\r\n<ul>\r\n<li>申请 Command Buffer</li>\r\n<li>获取当前阶段的摄像机内结果</li>\r\n<li>（如有多步的 Blit（如高斯模糊）调用）申请临时 RT 作缓冲区</li>\r\n<li>调用执行 Command Buffer</li>\r\n<li>释放所有资源</li>\r\n</ul></li>\r\n<li><p>特别的，我们会遇到这些特殊内容：</p>\r\n<ul>\r\n<li><p>CommandBuffer:\r\nhttps://docs.unity3d.com/2021.3/Documentation/ScriptReference/Rendering.CommandBuffer.html</p>\r\n<ul>\r\n<li>CommandBuffer.GetTemporaryRT:\r\nhttps://docs.unity3d.com/2021.3/Documentation/ScriptReference/Rendering.CommandBuffer.GetTemporaryRT.html</li>\r\n</ul></li>\r\n<li><p>RenderTargetIdentifier:\r\nhttps://docs.unity3d.com/2021.3/Documentation/ScriptReference/Rendering.RenderTargetIdentifier.html，我们用此对象来接收从Camera传入的Src\r\nRT</p></li>\r\n<li><p>RenderTargetHandle: RenderTargetHandle.cs，于 namespace\r\nUnityEngine.Rendering.Universal 中</p></li>\r\n<li><p>获取摄像机输入的 RT：</p>\r\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> Returns the camera color target for this renderer.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> It&#x27;s only valid to call cameraColorTarget in the scope of <span class=\"doctag\">&lt;c&gt;</span>ScriptableRenderPass<span class=\"doctag\">&lt;/c&gt;</span>.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;seealso cref=&quot;ScriptableRenderPass&quot;/&gt;</span>.</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">public</span> RenderTargetIdentifier cameraColorTarget &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(m_IsPipelineExecuting || isCameraColorTargetValid)) &#123;</span><br><span class=\"line\">            Debug.LogWarning(<span class=\"string\">&quot;You can only call cameraColorTarget inside the scope of a ScriptableRenderPass. Otherwise the pipeline camera target texture might have not been created or might have already been disposed.&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Ideally we should return an error texture (BuiltinRenderTextureType.None?)</span></span><br><span class=\"line\">            <span class=\"comment\">// but this might break some existing content, so we return the pipeline texture in the hope it gives a &quot;soft&quot; upgrade to users.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_CameraColorTarget;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul></li>\r\n<li><p>RenderTextureDescriptor:\r\nhttps://docs.unity3d.com/2021.3/Documentation/ScriptReference/RenderTextureDescriptor.html</p></li>\r\n</ul>\r\n<h4\r\nid=\"更进一步在后处理的边缘检测中加入深度与法线纹理\">更进一步：在后处理的边缘检测中加入深度与法线纹理</h4>\r\n<blockquote>\r\n<p>核心内容基本对应入门精要 13.4 节</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>在 urp 中快速获取深度图：<a\r\nhref=\"https://juejin.cn/post/7239910114949152826\">【转载】Unity URP\r\n获取深度图 - 掘金 (juejin.cn)</a></p>\r\n<p>在 urp 中自己生成特定情况下的深度图：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/351390737\">Unity3D:URP\r\n下输出深度图以及自定义 ScriptableRenderer - 知乎 (zhihu.com)</a></p>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/575655530\">基于深度与法线贴图的屏幕后处理——Unity\r\nURP“_CameraDepthTexture”和“_CameraNormalsTexture”使用讲解 - 知乎\r\n(zhihu.com)</a></p>\r\n</blockquote>\r\n<blockquote>\r\n<p><a href=\"https://codeantenna.com/a/ZS067JQogu\">练习项目(八)：在 URP\r\n中显示法线图 - CodeAntenna</a></p>\r\n</blockquote>\r\n<p>需要说明的是，我们使用了一种特殊的技巧：我们将 Shader 中的 Lightmode\r\n的值，设为了 URP 中不存在的值，这样这个 Pass 一开始不会执行，而我们在\r\nRender Feature 中捕获这个值，并去替换这个\r\nPass，就可以拿到深度与法线纹理。</p>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@11.0/manual/urp-shaders/urp-shaderlab-pass-tags.html#urp-pass-tags-lightmode\">URP\r\nShaderLab Pass tags | Universal RP | 11.0.0 (unity3d.com)</a></p>\r\n<p><a\r\nhref=\"https://docs.unity3d.com/Manual/shader-predefined-pass-tags-built-in.html\">Unity\r\n- Manual: ShaderLab: Predefined Pass tags in the Built-in Render\r\nPipeline (unity3d.com)</a></p>\r\n</blockquote>\r\n<blockquote>\r\n<p><a href=\"https://docs.unity3d.com/Manual/SL-PassTags.html\">Unity -\r\nManual: ShaderLab: assigning tags to a Pass (unity3d.com)</a> \"Using\r\nPass tags with C# scripts\" Part</p>\r\n</blockquote>\r\n<h4 id=\"更多办法\">更多办法？</h4>\r\n<p>很显然，基于后处理的边缘检测所得到的结果不够精确：不只是人物，场景中的所有内容都被一视同仁地进行处理，使结果包含了大量的不必要的描边。</p>\r\n<p>而对于基于深度与法线后处理检测，虽然它能得到比较准确的效果，但是并非是完全适用于人物的描边.</p>\r\n<p>在入门精要中，对这种基于图像处理的轮廓线渲染的优缺点的描述为：</p>\r\n<blockquote>\r\n<p>这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>在米哈游 2017 年的分享中，有这样两张 PPT：</p>\r\n<figure>\r\n<img\r\nsrc=\"C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\JBR-Bunjie.github.io\\source\\images\\Technical%20Artist\\Rendering\\NPR\\General\\007Outline.png\"\r\nalt=\"image-20230729213125901\" />\r\n<figcaption aria-hidden=\"true\">image-20230729213125901</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\JBR-Bunjie.github.io\\source\\images\\Technical%20Artist\\Rendering\\NPR\\General\\008Outline.png\"\r\nalt=\"image-20230729213257293\" />\r\n<figcaption aria-hidden=\"true\">image-20230729213257293</figcaption>\r\n</figure>\r\n<p>即，这种 Image Space 的 Outline\r\n更加适用于对场景进行描边，而对于人物，我们会使用基于 Backface\r\n的描边。这些内容与 2019 年的分享内容没有太大变化。</p>\r\n</blockquote>\r\n<p>为了得到更加精确的描边，我们可以采用一种基于法线扩张的描边办法：</p>\r\n<h4 id=\"backfacing-描边\">BackFacing 描边</h4>\r\n<p>BackFacing 有很多优点，首先就是实现简单，特别是在 Unity Shader\r\n中，我们只需要新开一个 Pass，然后沿法线方向延展顶点就可以了。</p>\r\n<p>另外，由于我们的描边是模型渲染的一个内容，我们可以很方便地控制很多细节，比如描边颜色与描边粗细等。</p>\r\n<p>在入门精要中，给出的描边 Pass 是在 View Space\r\n中进行的，这样子有一个问题：描边的粗细是固定的，这意味着它会受透视效果而改变，即：当摄像机靠近角色时，描边会变得很粗。因此，我们应该在透视变换后再进行顶点扩张。我们需要将法线转换到\r\nNDC Space，并在该空间下进行运算。</p>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/109101851\">【01】从零开始的卡通渲染-描边篇\r\n- 知乎 (zhihu.com)</a></p>\r\n</blockquote>\r\n<p>在 NDC\r\n下变换后，我们可以发现现在描边粗细已经是摄像机无关的了——无论摄像机远近，我们都能保证描边粗细一致。但是还有一个问题：描边会在某些边缘断裂，准确的说：当模型上出现弯折较大的部位的情况下，其对应位置的法线变化会过大，导致的结果就是最终的描边就会像这样裂开。</p>\r\n<p>为了解决这个问题，我们需要进行法线平滑。最简单的是平均法线，我们在脚本中检测每个顶点上的法线、相加，最后求平均。这样得到的结果基本上可以保证法线不会断裂，但是又另一个问题，就是如果直接使用平均法线，可能并不能完全保证法线的原始效果，我们可能需要对着个平滑过程进行加权：</p>\r\n<blockquote>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/546554527\">Tech-Artist\r\n学习笔记：Smooth Shade 平均法线与加权法线 - 知乎 (zhihu.com)</a></p>\r\n</blockquote>\r\n<p>最后，当我们计算完平滑的法线后，我们需要将它存储到模型中，如果是使用模型的\r\nTangent 空间的话，我们可以直接将当前 Object Space 下的计算结果直接覆写\r\nTangent 中的数据，可是如果我们需要使用原始的 Tangent\r\n数据，那我们就要考虑别的存储位置例如\r\nUV，此时我们需要多做一件事：将法线转换到切线空间再存储：</p>\r\n<blockquote>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/643206592\">Unity\r\n平滑法线用于卡渲描边 - 知乎 (zhihu.com)</a></p>\r\n</blockquote>\r\n<p>值得一提的是，这里的加权方式是角度变量加权。不同的平滑思路会造成不同的结果，这种不同甚至可能出现在模型的不同分件中，我们需要在不同的部位，采用不同的平滑方案。</p>\r\n<p>这样子，我们就基本上构建了一个完善的法线平滑脚本了。这是在模型导入后的二次处理，那么可不可以在模型导入时，就直接对其进行操作呢？</p>\r\n<blockquote>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/107664564\">【Job/Toon Shading\r\nWorkflow】自动生成硬表面模型 Outline Normal - 知乎 (zhihu.com)</a></p>\r\n</blockquote>\r\n<h4 id=\"一些补充\">一些补充</h4>\r\n<p>至此，我们常用的描边办法就全部介绍完了，不过除此之外，还有几个可以补充的要点：</p>\r\n<ol type=\"1\">\r\n<li><p>入门精要中还提到过一种可用的轮廓线渲染办法：基于轮廓边检测的轮廓线渲染：Mesh\r\n上的每一条边一定被两个三角形共用，检测 Mesh\r\n上所有像这样相邻的三角面片是否符合：</p>\r\n<p><span class=\"math display\">\\[\r\n(\\vec{n_0} * \\vec{v} &gt; 0) \\ne (\\vec{n_1} * \\vec{v} &gt; 0)\\\\\\\\\r\n其中，n_0和n_1分别代表了两个相邻三角面片的法向，v是从视角到该边上任意顶点的方向\r\n\\]</span></p></li>\r\n<li><p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/72734738\">渲染管线中的法线变换矩阵 -\r\n知乎 (zhihu.com)</a></p></li>\r\n</ol>\r\n<h3 id=\"高光形变\">高光形变</h3>\r\n<p><a\r\nhref=\"https://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf\">Hair\r\nRendering and Shading (oregonstate.edu)</a></p>\r\n<p>我们并不希望高光总是⼀个圆形的光斑，因此我们需要对高光的形状也进行风格化处理：对高光点进行形变</p>\r\n<ol type=\"1\">\r\n<li><p>Kajiya Kay 模型：</p>\r\n<p>需要注意的是，这里的 T\r\n并非是切线，它代表的是当前模型的副切线</p></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nSpecular = L_i * k_s * \\sqrt{ \\overrightarrow T \\cdot \\overrightarrow H\r\n} ^ {strength}\r\n\\]</span></p>\r\n<p><img\r\nsrc=\"........\\images\\Technical%20Artist\\Rendering\\NPR\\General\\004.png\"\r\nalt=\"image-20230501160324069\" /> 用 Kajiya Kay\r\n模型实现的环形高光，Strength == 64，没有使用 Shift\r\nMap，没有使用衰减。（计算 W 型高光需要使用 Shift\r\nMap，可用的处理办法可参考：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/135910659\">基于 Kajiya-Kay\r\n模型的毛发渲染 - 知乎 (zhihu.com)</a>)</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>Marschner 模型：<a\r\nhref=\"http://graphics.stanford.edu/papers/hair/hair-sg03final.pdf\">hair-sg03final.pdf\r\n(stanford.edu)</a></p>\r\n<p>就 Marschner 模型本身而言，这是一个基于物理的模型。<a\r\nhref=\"https://zhuanlan.zhihu.com/p/372590873\">Marschner Hair Model\r\n论文细读与推导 - 知乎 (zhihu.com)</a></p></li>\r\n</ol>\r\n<figure>\r\n<img\r\nsrc=\"........\\images\\Technical%20Artist\\Rendering\\NPR\\General\\005.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>R：反射光线，T：透射光线。R，TT 和 TRT\r\n是三个对毛发反射率产生明显影响部分。 R：\r\n从头发纤维表面向观察者反弹的光。TT：\r\n折射到头发中并再次向观察者折射的光。TRT：光线折射到头发纤维中，从内表面反射，然后再次向观察者折射。</p>\r\n<p><span class=\"math display\">\\[\r\nS=S_R+S_{TT}+S_{TRT} \\\\\r\nSP=MP⋅NP\\\\\r\nfor \\space P = R, TT, TRT\\\\\r\n\\]</span></p>\r\n<p><a href=\"https://www.cnblogs.com/timlly/p/11199385.html\">剖析 Unreal\r\nEngine 超真实人类的渲染技术 Part 3 - 毛发渲染及其它 - 0 向往 0 - 博客园\r\n(cnblogs.com)</a></p>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/372590873\">Marschner Hair Model\r\n论文细读与推导 - 知乎 (zhihu.com)</a></p>\r\n<blockquote>\r\n<p>Kajiya-Kay\r\n模型是一种基于经验的头发渲染模型，它使用头发的切线来模拟平面法线的效果，能够近似地表现出高光的效果，并使用漫反射项来近似头发间的相互散射情况。然而，Kajiya-Kay\r\n模型不是基于物理的，它将头发建模成不透明的圆柱体，因此不能模拟光线可能穿过头发或者在头发中传播的情况，这就导致了其不能模拟出背光以及二次高光等效果</p>\r\n<p>Marschner 模型是一种基于物理的头发渲染模型，它在 Kajiya-Kay\r\n模型的基础上对单根头发的散射情况进行了实验和理论分析，然后建立了一个实用且基于物理的着色模型。Marschner\r\n模型将光照在毛发上的作用分为三个部分：R、TT 和\r\nTRT。这三个部分对毛发反射率产生明显影响</p>\r\n</blockquote>\r\n<ol start=\"3\" type=\"1\">\r\n<li><p>近似的 Marschner Model？</p>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/434058280\">【UE4】材质藏宝阁\r\n01_头发 Kajiya-Kay Shading - 知乎 (zhihu.com)</a>，即 Kajiya Kay + Shift\r\nMap + 第二层 Base Color 高光</p></li>\r\n</ol>\r\n<p>可参考的各向异性高光示例：</p>\r\n<p><a href=\"https://www.cnblogs.com/2Yous/p/4234811.html\">Unity3D\r\nShaderLab 各向异性高光 - 川北 - 博客园 (cnblogs.com)</a></p>\r\n<p>一个风格高光实现：</p>\r\n<p><a href=\"http://tuyg.top/archives/927\">涂月观 (tuyg.top)</a></p>\r\n<p>ATI 示例代码：</p>\r\n<figure>\r\n<img\r\nsrc=\"........\\images\\Technical%20Artist\\Rendering\\NPR\\General\\006.png\"\r\nalt=\"image-20230501191639629\" />\r\n<figcaption aria-hidden=\"true\">image-20230501191639629</figcaption>\r\n</figure>\r\n<h3 id=\"小结\">小结：</h3>\r\n<p>卡通渲染中，最重要的就是：使用 Step 的、强烈的明暗分割</p>\r\n<h2 id=\"pbr-下的材质表达\">PBR 下的材质表达</h2>\r\n<h3 id=\"pbr-材质分析\">PBR 材质分析</h3>\r\n<p><img\r\nsrc=\"........\\images\\Technical%20Artist\\Rendering\\NPR\\General\\002_PBRInURP.png\"\r\nalt=\"image-20230407210359909\" /> ASE 在 URP 管线下的默认 PBR\r\n材质输出节点</p>\r\n<p>对于 PBR 预制节点所不能表达的效果，我们有两种解决思路：</p>\r\n<ol type=\"1\">\r\n<li><p>每种特性单独做一个 Shader。这种方案的优点是 Shader\r\n功能相对确定，GPU 计算效率快，缺点是会增加 DrawCall</p></li>\r\n<li><p>使用 UberShader 以包含所有特性，然后再通过 Mask\r\n进行材质分层。这种方案的优点是 DrawCall 少，基本上⼀个通⽤的 Shader\r\n可以满足大多数功能，同时可以减少贴图数量，缺点是会产生许多无用的 GPU\r\n计算。</p>\r\n<p>产生无用计算的原因：</p>\r\n<p><img\r\nsrc=\"........\\images\\Technical%20Artist\\Rendering\\NPR\\General\\003_UselessCalculations.png\"\r\nalt=\"image-20230407212230706\" /> If\r\n语句会先计算出括号里面的内容，再根据条件值判断是否接受这个值。这种运行方式与\r\nCPU 不同，CPU\r\n是先根据条件值是否为真，再去判断是否要执行括号内的内容。</p></li>\r\n</ol>\r\n<p>和大多数最终的解决方案类似的——⼀种成熟的解决方案是 1 与 2\r\n的结合，即在通用的 Shader\r\n中做出通用特性，每个特性不能消耗太多的计算，而特殊的特性用单独的\r\nShader。</p>\r\n<h2 id=\"texture-介绍\">Texture 介绍</h2>\r\n<p>Base Map：基础色</p>\r\n<p>Shadow Map：暗部衰减色，我们</p>\r\n<h2 id=\"具体案例分析\">具体案例分析</h2>\r\n<h3 id=\"罪恶装备-strive-的渲染分析与复现\">罪恶装备 Strive\r\n的渲染分析与复现</h3>\r\n<h4 id=\"部分引用\">部分引用</h4>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/TracePlus/p/4205798.html\">【翻译】西川善司「实验做出的游戏图形」「GUILTY\r\nGEAR Xrd -SIGN-」中实现的「纯卡通动画的实时 3D 图形」的秘密，前篇（1） -\r\nTrace0429 - 博客园 (cnblogs.com)</a></p>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/TracePlus/p/4205834.html\">【翻译】西川善司「实验做出的游戏图形」「GUILTY\r\nGEAR Xrd -SIGN-」中实现的「纯卡通动画的实时 3D 图形」的秘密，前篇（2） -\r\nTrace0429 - 博客园 (cnblogs.com)</a></p>\r\n<h4 id=\"shader-编写\">Shader 编写</h4>\r\n<p>数据使用：</p>\r\n<ul>\r\n<li>BaseMap：基础⾊</li>\r\n<li>ShadowMap：暗部衰减色，与 BaseMap 相乘构成暗部</li>\r\n<li>DetailTex：磨损线条</li>\r\n<li>LightMap.r：高光类型</li>\r\n<li>LightMap.g：Ramp 偏移值</li>\r\n<li>LightMap.b：高光强度 mask</li>\r\n<li>LightMap.a：内勾线的 Mask</li>\r\n<li>VertexColor.r：AO，常暗部分</li>\r\n<li>VertexColor.g：用来区分身体的部位</li>\r\n<li>VertexColor.b：描边遮罩</li>\r\n<li>VertexColor.a：渲染无用</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"碧蓝幻想\">碧蓝幻想</h3>\r\n<h3 id=\"原神\">原神</h3>\r\n<h3 id=\"破晓传说\">破晓传说</h3>\r\n<h3 id=\"战双\">战双</h3>\r\n<h2 id=\"reference\">Reference</h2>\r\n<ul>\r\n<li></li>\r\n<li><a\r\nhref=\"https://zhuanlan.zhihu.com/p/109101851\">【01】从零开始的卡通渲染-描边篇\r\n- 知乎 (zhihu.com)</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/508319122\">Unity\r\n描边法线平滑工具 x 踩坑记录 - 知乎 (zhihu.com)</a></li>\r\n<li><a\r\nhref=\"https://zhuanlan.zhihu.com/p/72734738\">渲染管线中的法线变换矩阵 -\r\n知乎 (zhihu.com)</a></li>\r\n<li><a\r\nhref=\"https://forum.unity.com/threads/menuitem-is-not-working-properly.853822/\">MenuItem\r\nis not working properly - Unity Forum</a></li>\r\n<li><a\r\nhref=\"https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/urp-shaders/urp-shaderlab-pass-tags.html\">URP\r\nShaderLab Pass 标签 | Universal RP | 12.1.1 (unity3d.com)</a></li>\r\n<li><a\r\nhref=\"https://zhuanlan.zhihu.com/p/95986273\">【02】卡通渲染基本光照模型的实现\r\n- 知乎 (zhihu.com)</a></li>\r\n<li><a\r\nhref=\"https://www.deviantart.com/o-dv89-o/art/Guilty-Gear-Strive-Sol-Badguy-pack-for-XPS-882551758\">Guilty\r\nGear Strive - Sol Badguy XPS (Updated) by o-DV89-o on\r\nDeviantArt</a></li>\r\n<li><a href=\"https://github.com/ChiliMilk/URP_Toon\">ChiliMilk/URP_Toon:\r\nA Toon Shader in Unity Universal Render Pipeline. (github.com)</a></li>\r\n<li>[<a\r\nhref=\"https://zhuanlan.zhihu.com/p/546396053\">卡通渲染]一、罪恶装备角色渲染还原\r\n- 知乎 (zhihu.com)</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/135910659\">基于 Kajiya-Kay\r\n模型的毛发渲染 - 知乎 (zhihu.com)</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/434058280\">【UE4】材质藏宝阁\r\n01_头发 Kajiya-Kay Shading - 知乎 (zhihu.com)</a></li>\r\n<li><a href=\"http://tuyg.top/\">涂月观-吹灯窗更明，月照一天雪\r\n(tuyg.top)</a></li>\r\n<li><a\r\nhref=\"https://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf\">Hair\r\nRendering and Shading (oregonstate.edu)</a></li>\r\n<li><a\r\nhref=\"https://twitter.com/Yoolies/status/1232345380991438855\">Yoolie on\r\nTwitter: \"Tutorial on adjusting vertex normals for that 3D Anime look!\r\nsince a couple of people were asking for it, I decided to make it!\r\nHopefully it's useful to someone! It's the first tutorial I've ever\r\nmade, so I apologize if it's kind of unclear ;-; #blender #bnpr #3D\r\n#BlenderNPR https://t.co/3cctLK8tFD\" / Twitter</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/493802718\">TA\r\n技术美术-罪恶装备角色还原 - 知乎 (zhihu.com)</a></li>\r\n<li><a\r\nhref=\"https://zhuanlan.zhihu.com/p/50943366\">灯光技法-伦勃朗光（2） -\r\n知乎 (zhihu.com)</a></li>\r\n<li><a\r\nhref=\"https://zhuanlan.zhihu.com/p/95986273\">【02】卡通渲染基本光照模型的实现\r\n- 知乎 (zhihu.com)</a></li>\r\n</ul>\r\n<h2 id=\"既有渲染思路分析\">既有渲染思路分析</h2>\r\n<blockquote>\r\n<p><a href=\"https://github.com/ChiliMilk/URP_Toon\">ChiliMilk/URP_Toon: A\r\nToon Shader in Unity Universal Render Pipeline. (github.com)</a></p>\r\n</blockquote>\r\n<h3 id=\"项目结构分析\">项目结构分析</h3>\r\n<p>该项目有三个</p>\r\n<p>共有</p>\r\n<h3 id=\"核心代码分析\">核心代码分析</h3>\r\n<blockquote>\r\n<p>分析的文件包括：</p>\r\n<ul>\r\n<li>ToonShaderGUI.cs</li>\r\n<li>Toon.shader</li>\r\n<li></li>\r\n</ul>\r\n</blockquote>\r\n<p>Toon.shader 文件的布局仍然遵循我们所提到的 shaderlab 基本结构：</p>\r\n<ul>\r\n<li>Properties：作者在这里声明了所有可用的属性</li>\r\n<li>SubShader</li>\r\n<li>CustomEditor：作者的确在项目中定义一个简单的\r\nGUI，虽然没有以窗口的形式呈现，但是材质的面板上确实变得不同了</li>\r\n<li>FallBack：FallBack 到 Error</li>\r\n</ul>\r\n<h4 id=\"properties-部分\">Properties 部分</h4>\r\n<p>Properties 部分存在于 3 ~ 101 行.</p>\r\n<p>其中定义的大部分属性都直接用</p>\r\n<h4 id=\"定义输入结构\">定义输入结构</h4>\r\n<p>第一个 Pass 位于 109 ~ 130\r\n行。它通过引入了两个外部文件来实现主要功能，它们分别是：<code>ToonInput.hlsl</code>，<code>ToonHairShadowMaskPass.hlsl</code></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Name <span class=\"string\">&quot;HairShadowMask&quot;</span> <span class=\"comment\">//</span></span><br><span class=\"line\">    ZTest Less</span><br><span class=\"line\">    Tags&#123;<span class=\"string\">&quot;LightMode&quot;</span>=<span class=\"string\">&quot;HairShadowMask&quot;</span>&#125;</span><br><span class=\"line\">    ZWrite Off</span><br><span class=\"line\">    Cull Back</span><br><span class=\"line\"></span><br><span class=\"line\">    HLSLPROGRAM</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">pragma</span> exclude_renderers gles gles3 glcore</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">pragma</span> target 4.5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">pragma</span> multi_compile_instancing</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">pragma</span> multi_compile_fog</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">pragma</span> vertex Vertex</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">pragma</span> fragment Fragment</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;../Include/ToonInput.hlsl&quot;</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;../Include/ToonHairShadowMaskPass.hlsl&quot;</span></span></span><br><span class=\"line\">    ENDHLSL</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>显而易见的，这两个引入文件分别实现了输入结构的定义与 ShadowMap\r\n的计算</p>\r\n<p>我们先从 <code>ToonInput.hlsl</code> 开始：</p>\r\n","text":"光照模型特点概括： 首先，分析一下所谓的 日式卡通渲染 都有些什么特点： 硬过渡亮暗面 描边 因此，其可采用的具体的表现形式有： 裁边漫反射 - StepDiffuse 裁边高光 裁边边缘光 裁边视角光 裁边光源光 裁边漫反射 卡通渲染里希望存在明快的色调对比，而不希望存在额外的...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"Rendering","slug":"Rendering","count":1,"path":"api/categories/Rendering.json"}],"tags":[{"name":"Rendering","slug":"Rendering","count":3,"path":"api/tags/Rendering.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9%E6%A6%82%E6%8B%AC\"><span class=\"toc-text\">光照模型特点概括：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A3%81%E8%BE%B9%E6%BC%AB%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">裁边漫反射</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A3%81%E8%BE%B9%E9%AB%98%E5%85%89\"><span class=\"toc-text\">裁边高光</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A3%81%E8%BE%B9%E8%BE%B9%E7%BC%98%E5%85%89\"><span class=\"toc-text\">裁边边缘光</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A3%81%E8%BE%B9%E8%A7%86%E8%A7%92%E5%85%89\"><span class=\"toc-text\">裁边视角光</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A3%81%E8%BE%B9%E5%85%89%E6%BA%90%E5%85%89\"><span class=\"toc-text\">裁边光源光</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#outline\"><span class=\"toc-text\">Outline</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#outline-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">Outline 的实现方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%8E%E5%A4%84%E7%90%86%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">后处理边缘检测</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">脚本结构：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%84%9A%E6%9C%AC%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">脚本一般流程：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%84%9A%E6%9C%AC%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">脚本核心内容：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%A4%96%E9%83%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">外部参数</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#scriptablerenderpass\"><span class=\"toc-text\">ScriptableRenderPass</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%9C%A8%E5%90%8E%E5%A4%84%E7%90%86%E7%9A%84%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E4%B8%AD%E5%8A%A0%E5%85%A5%E6%B7%B1%E5%BA%A6%E4%B8%8E%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86\"><span class=\"toc-text\">更进一步：在后处理的边缘检测中加入深度与法线纹理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E5%A4%9A%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">更多办法？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#backfacing-%E6%8F%8F%E8%BE%B9\"><span class=\"toc-text\">BackFacing 描边</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">一些补充</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E5%85%89%E5%BD%A2%E5%8F%98\"><span class=\"toc-text\">高光形变</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pbr-%E4%B8%8B%E7%9A%84%E6%9D%90%E8%B4%A8%E8%A1%A8%E8%BE%BE\"><span class=\"toc-text\">PBR 下的材质表达</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pbr-%E6%9D%90%E8%B4%A8%E5%88%86%E6%9E%90\"><span class=\"toc-text\">PBR 材质分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#texture-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">Texture 介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">具体案例分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%AA%E6%81%B6%E8%A3%85%E5%A4%87-strive-%E7%9A%84%E6%B8%B2%E6%9F%93%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0\"><span class=\"toc-text\">罪恶装备 Strive\r\n的渲染分析与复现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%83%A8%E5%88%86%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">部分引用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shader-%E7%BC%96%E5%86%99\"><span class=\"toc-text\">Shader 编写</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A2%A7%E8%93%9D%E5%B9%BB%E6%83%B3\"><span class=\"toc-text\">碧蓝幻想</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%A5%9E\"><span class=\"toc-text\">原神</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A0%B4%E6%99%93%E4%BC%A0%E8%AF%B4\"><span class=\"toc-text\">破晓传说</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%98%E5%8F%8C\"><span class=\"toc-text\">战双</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A2%E6%9C%89%E6%B8%B2%E6%9F%93%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90\"><span class=\"toc-text\">既有渲染思路分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90\"><span class=\"toc-text\">项目结构分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">核心代码分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#properties-%E9%83%A8%E5%88%86\"><span class=\"toc-text\">Properties 部分</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">定义输入结构</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Vim 5. EDIT","uid":"6447ce34572a48189d0a25e47120ad48","slug":"Deploy/vim/05.editing","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T18:52:07.000Z","comments":true,"path":"api/articles/Deploy/vim/05.editing.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Vim 5. edit 综述 总览： Vim provides many commands which make editing functionality really powerful. In this chapter, we will discuss following i...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"Vim","slug":"Vim","count":7,"path":"api/categories/Vim.json"},{"name":"Linux","slug":"Vim/Linux","count":7,"path":"api/categories/Vim/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":12,"path":"api/tags/Linux.json"},{"name":"Vim","slug":"Vim","count":7,"path":"api/tags/Vim.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"全排列","uid":"4bbde60d3dafb255adad1c9293392efa","slug":"Rendering/NPR/UST","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T15:41:24.000Z","comments":true,"path":"api/articles/Rendering/NPR/UST.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"什么是 UST？ UST，即 Unity Toon Shader，截至成文时，UST 的版本为 0.9.4-preivew。对应： Unity Toon Shader overview | Unity Toon Shader | 0.9.4-preview (unity3d.co...","link":"","photos":[],"count_time":{"symbolsCount":413,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}