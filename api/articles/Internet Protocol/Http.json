{"title":"Http Explanations","uid":"86f05433afcd220f1d55c4667ed9f60c","slug":"Internet Protocol/Http","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:35:39.747Z","comments":true,"path":"api/articles/Internet Protocol/Http.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<blockquote>\r\n<p>Hypertext Transfer Protocol (HTTP) is an <a\r\nhref=\"https://en.wikipedia.org/wiki/Application_Layer\">application-layer</a>\r\nprotocol for transmitting hypermedia documents, such as HTML. It was\r\ndesigned for communication between web browsers and web servers, but it\r\ncan also be used for other purposes. HTTP follows a classical <a\r\nhref=\"https://en.wikipedia.org/wiki/Client–server_model\">client-server\r\nmodel</a>, with a client opening a connection to make a request, then\r\nwaiting until it receives a response. HTTP is a <a\r\nhref=\"https://en.wikipedia.org/wiki/Stateless_protocol\">stateless\r\nprotocol</a>, meaning that the server does not keep any data (state)\r\nbetween two requests.</p>\r\n</blockquote>\r\n<h2 id=\"overview\">Overview:</h2>\r\n<figure>\r\n<img src=\"http-layers.png\" alt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h2 id=\"components-of-http-based-systems\"><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#components_of_http-based_systems\">Components\r\nof HTTP-based systems</a></h2>\r\n<p>HTTP is a client-server protocol: requests are sent by one entity,\r\nthe <strong>user-agent</strong> (or a proxy on behalf of it). Most of\r\nthe time the user-agent is a Web browser, but it can be anything, for\r\nexample, a robot that crawls the Web to populate and maintain a search\r\nengine index.</p>\r\n<p>Each individual request is sent to a server, which handles it and\r\nprovides an answer called the <em>response</em>. Between the client and\r\nthe server there are numerous entities, collectively called <a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server\"><strong>proxies</strong></a>,\r\n<em>which perform different operations and act as gateways or <a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Glossary/Cache\">caches</a></em>,\r\nfor example<img src=\"client-server-chain.png\"\r\nalt=\"Client server chain\" /></p>\r\n<p>In reality, there are more computers between a browser and the server\r\nhandling the request: there are routers, modems, and more. Thanks to the\r\nlayered design of the Web, these are hidden in the network and transport\r\nlayers. HTTP is on top, at the application layer. Although important for\r\ndiagnosing network problems, the underlying layers are mostly irrelevant\r\nto the description of HTTP.</p>\r\n<h3 id=\"client-the-user-agent\"><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#client_the_user-agent\">Client:\r\nthe user-agent</a></h3>\r\n<p>The <em>user-agent</em> is any tool that acts on behalf of the user.\r\nThis role is primarily performed by the Web browser, but it may also be\r\nperformed by programs used by engineers and Web developers to debug\r\ntheir applications.</p>\r\n<p>The browser is <strong>always</strong> the entity initiating the\r\nrequest. It is never the server (though some mechanisms have been added\r\nover the years to simulate server-initiated messages).</p>\r\n<p><strong>To display a Web page, the browser sends an original request\r\nto fetch the HTML document that represents the page. It then parses this\r\nfile, making additional requests corresponding to execution scripts,\r\nlayout information (CSS) to display, and sub-resources contained within\r\nthe page (usually images and videos). The Web browser then combines\r\nthese resources to present the complete document, the Web page. Scripts\r\nexecuted by the browser can fetch more resources in later phases and the\r\nbrowser updates the Web page accordingly.</strong></p>\r\n<h3 id=\"the-web-server\"><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#the_web_server\">The\r\nWeb server</a></h3>\r\n<p>On the opposite side of the communication channel is the server,\r\nwhich <em>serves</em> the document as requested by the client. A server\r\nappears as only a single machine virtually; but it may actually be a\r\ncollection of servers sharing the load (load balancing), or a complex\r\npiece of software interrogating other computers (like cache, a DB\r\nserver, or e-commerce servers), totally or partially generating the\r\ndocument on demand.</p>\r\n<p>A server is not necessarily a single machine, but several server\r\nsoftware instances can be hosted on the same machine. With HTTP/1.1 and\r\nthe <a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host\"><code>Host</code></a>\r\nheader, they may even share the same IP address.</p>\r\n<h3 id=\"proxies\"><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#proxies\">Proxies</a></h3>\r\n<p>Between the Web browser and the server, numerous computers and\r\nmachines relay the HTTP messages. Due to the layered structure of the\r\nWeb stack, most of these operate at the transport, network or physical\r\nlevels, becoming transparent at the HTTP layer and potentially having a\r\nsignificant impact on performance. Those operating at the application\r\nlayers are generally called <strong>proxies</strong>. These can be\r\ntransparent, forwarding on the requests they receive without altering\r\nthem in any way, or non-transparent, in which case they will change the\r\nrequest in some way before passing it along to the server. Proxies may\r\nperform numerous functions:</p>\r\n<ul>\r\n<li>caching (the cache can be public or private, like the browser\r\ncache)</li>\r\n<li>filtering (like an antivirus scan or parental controls)</li>\r\n<li>load balancing (to allow multiple servers to serve different\r\nrequests)</li>\r\n<li>authentication (to control access to different resources)</li>\r\n<li>logging (allowing the storage of historical information)</li>\r\n</ul>\r\n<h2 id=\"basic-aspects-of-http\"><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#basic_aspects_of_http\">Basic\r\naspects of HTTP</a></h2>\r\n<h3 id=\"http-is-simple\"><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_is_simple\">HTTP\r\nis simple</a></h3>\r\n<p>HTTP is generally designed to be simple and human readable, even with\r\nthe added complexity introduced in HTTP/2 by encapsulating HTTP messages\r\ninto frames. HTTP messages can be read and understood by humans,\r\nproviding easier testing for developers, and reduced complexity for\r\nnewcomers.</p>\r\n<h3 id=\"http-is-extensible\"><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_is_extensible\">HTTP\r\nis extensible</a></h3>\r\n<p>Introduced in HTTP/1.0, <a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers\">HTTP\r\nheaders</a> make this protocol easy to extend and experiment with. New\r\nfunctionality can even be introduced by a simple agreement between a\r\nclient and a server about a new header's semantics.</p>\r\n<h3 id=\"http-is-stateless-but-not-sessionless\"><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_is_stateless_but_not_sessionless\">HTTP\r\nis stateless, but not sessionless</a></h3>\r\n<p>HTTP is stateless: there is no link between two requests being\r\nsuccessively carried out on the same connection. This immediately has\r\nthe prospect of being problematic for users attempting to interact with\r\ncertain pages coherently, for example, using e-commerce shopping\r\nbaskets. But while the core of HTTP itself is stateless, HTTP cookies\r\nallow the use of stateful sessions. Using header extensibility, HTTP\r\nCookies are added to the workflow, allowing session creation on each\r\nHTTP request to share the same context, or the same state.</p>\r\n<h3 id=\"http-and-connections\"><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_and_connections\">HTTP\r\nand connections</a></h3>\r\n<p>A connection is controlled at the transport layer, and therefore\r\nfundamentally out of scope for HTTP. HTTP doesn't require the underlying\r\ntransport protocol to be connection-based; it only requires it to be\r\n<em>reliable</em>, or not lose messages (at minimum, presenting an error\r\nin such cases). Among the two most common transport protocols on the\r\nInternet, TCP is reliable and UDP isn't. HTTP therefore relies on the\r\nTCP standard, which is connection-based.</p>\r\n<p>Before a client and server can exchange an HTTP request/response\r\npair, they must establish a TCP connection, a process which requires\r\nseveral round-trips. The default behavior of HTTP/1.0 is to open a\r\nseparate TCP connection for each HTTP request/response pair. This is\r\nless efficient than sharing a single TCP connection when multiple\r\nrequests are sent in close succession.</p>\r\n<p>In order to mitigate this flaw, HTTP/1.1 introduced\r\n<em>pipelining</em> (which proved difficult to implement) and\r\n<em>persistent connections</em>: the underlying TCP connection can be\r\npartially controlled using the <a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection\"><code>Connection</code></a>\r\nheader. HTTP/2 went a step further by multiplexing messages over a\r\nsingle connection, helping keep the connection warm and more\r\nefficient.</p>\r\n<p>Experiments are in progress to design a better transport protocol\r\nmore suited to HTTP. For example, Google is experimenting with <a\r\nhref=\"https://en.wikipedia.org/wiki/QUIC\">QUIC</a> which builds on UDP\r\nto provide a more reliable and efficient transport protocol.</p>\r\n<p><a\r\nhref=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview\">An\r\noverview of HTTP - HTTP | MDN (mozilla.org)</a></p>\r\n","text":" Hypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML. It was designed fo...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[{"name":"Protocol Theory","slug":"Protocol-Theory","count":9,"path":"api/categories/Protocol-Theory.json"}],"tags":[{"name":"Computer Network","slug":"Computer-Network","count":9,"path":"api/tags/Computer-Network.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#overview\"><span class=\"toc-text\">Overview:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#components-of-http-based-systems\"><span class=\"toc-text\">Components\r\nof HTTP-based systems</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#client-the-user-agent\"><span class=\"toc-text\">Client:\r\nthe user-agent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#the-web-server\"><span class=\"toc-text\">The\r\nWeb server</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#proxies\"><span class=\"toc-text\">Proxies</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#basic-aspects-of-http\"><span class=\"toc-text\">Basic\r\naspects of HTTP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#http-is-simple\"><span class=\"toc-text\">HTTP\r\nis simple</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#http-is-extensible\"><span class=\"toc-text\">HTTP\r\nis extensible</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#http-is-stateless-but-not-sessionless\"><span class=\"toc-text\">HTTP\r\nis stateless, but not sessionless</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#http-and-connections\"><span class=\"toc-text\">HTTP\r\nand connections</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"面经贴002","uid":"018a847738d23737cfe4d3b9bbf1a909","slug":"ExperiencesForJob/2","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:31:18.854Z","comments":true,"path":"api/articles/ExperiencesForJob/2.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"2 作为Unity程序员需要掌握的技能_海洋_的博客-CSDN博客_unity 在职技能 ","link":"","photos":[],"count_time":{"symbolsCount":48,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"面经","slug":"面经","count":2,"path":"api/tags/面经.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"OSI Model Explanations","uid":"aa8ff1f4cd866ae3e0deaae5a8bc6249","slug":"Internet Protocol/OSI","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:35:27.175Z","comments":true,"path":"api/articles/Internet Protocol/OSI.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"The OSI Model Defined The OSI Model (Open Systems Interconnection Model) is a conceptual framework used to describe the functions of a netwo...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Protocol Theory","slug":"Protocol-Theory","count":9,"path":"api/categories/Protocol-Theory.json"}],"tags":[{"name":"Computer Network","slug":"Computer-Network","count":9,"path":"api/tags/Computer-Network.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}