{"title":"LUA急速入门","uid":"c501575a20c82b47e7d6e471fd5a77bc","slug":"Language Learning/C++/QuickCPP","date":"2023-11-11T13:00:12.000Z","updated":"2023-11-22T15:04:18.838Z","comments":true,"path":"api/articles/Language Learning/C++/QuickCPP.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"cpp急速入门\">CPP急速入门</h1>\r\n<h2 id=\"c-with-class\">C with Class</h2>\r\n<p>首先，C++是面向对象的语言，而C是面向过程的语言，即，最起码，C++是建立在叫做C\r\nwith class的基础上的</p>\r\n<p>一个突出的点是，C++引入了函数重载的特性，而C中没有；</p>\r\n<p>而与面向对象最直接的结果就是：C++引入了 <code>new/delete</code>\r\n运算符，取代了C中的<code>malloc/free</code>库函数；</p>\r\n<h3 id=\"关于cpp中的newdelete\">关于cpp中的new&amp;delete</h3>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/62106872\">C++类实例化的两种方式：new和不new的区别\r\n- 知乎 (zhihu.com)</a></p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">A a;  &#x2F;&#x2F; a存在栈上\nA* a &#x3D; new a();  &#x2F;&#x2F; a存在堆中</code></pre>\r\n<p>以上两种方式皆可实现类的实例化，有无new的区别在于：</p>\r\n<p>前者在栈中分配内存，后者在堆中分配内存，这意味着后者必须在后续过程中调用delete删除，而前者系统会自动回收内存</p>\r\n<ul>\r\n<li>频繁调用场合并不适合new，就像new申请和释放内存一样</li>\r\n</ul>\r\n<h3 id=\"关于析构函数\">关于析构函数</h3>\r\n<p>与C#不同的是，CPP的析构函数是真正的，需要额外注意并控制的重要函数</p>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/zh-cn/cpp/cpp/destructors-cpp?view=msvc-170\">析构函数\r\n(C++) | Microsoft Learn</a></p>\r\n<p>析构函数作为成员函数，在对象超出范围或通过调用\r\n<strong><code>delete</code></strong>\r\n显式销毁对象时，会自动调用析构函数。\r\n<strong>如果未定义析构函数，编译器会提供一个默认的析构函数——对许多类来说，这就足够了。只有当类存储了需要释放的系统资源的句柄，或拥有其指向的内存的指针时，你才需要定义自定义析构函数。</strong></p>\r\n<p>MSDN上的例子是这个：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; spec1_destructors.cpp\n#include &lt;string&gt;\n\nclass String &#123;\npublic:\n   String( char *ch );  &#x2F;&#x2F; Declare constructor\n   ~String();           &#x2F;&#x2F;  and destructor.\nprivate:\n   char    *_text;\n   size_t  sizeOfText;\n&#125;;\n\n&#x2F;&#x2F; Define the constructor.\nString::String( char *ch ) &#123;\n   sizeOfText &#x3D; strlen( ch ) + 1;\n\n   &#x2F;&#x2F; Dynamically allocate the correct amount of memory.\n   _text &#x3D; new char[ sizeOfText ];\n\n   &#x2F;&#x2F; If the allocation succeeds, copy the initialization string.\n   if( _text )\n      strcpy_s( _text, sizeOfText, ch );\n&#125;\n\n&#x2F;&#x2F; Define the destructor.\nString::~String() &#123;\n   &#x2F;&#x2F; Deallocate the memory that was previously reserved\n   &#x2F;&#x2F;  for this string.\n   delete[] _text;\n&#125;\n\nint main() &#123;\n   String str(&quot;The piper in the glen...&quot;);\n&#125;</code></pre>\r\n<p>这里的 <code>~String()</code>\r\n是自定义的析构函数——为了手动释放申请的char指针数组。而析构函数中的\r\n<code>delete[]</code> 是用于释放使用 <code>new[]</code>\r\n运算符分配的动态数组内存的关键字：</p>\r\n<p>在C++中，当使用 <code>new</code> 分配单个对象的内存时，可以使用\r\n<code>delete</code> 来释放该内存。而当使用 <code>new[]</code>\r\n分配数组时，需要使用 <code>delete[]</code>\r\n来释放数组占用的内存空间。</p>\r\n<p>在示例中，<code>_text</code> 是使用 <code>new[]</code>\r\n分配的字符数组内存。因此，在析构函数中使用 <code>delete[] _text</code>\r\n来释放这块动态分配的数组内存，确保释放整个数组所占用的内存空间，而不仅仅是首个元素的内存。</p>\r\n<blockquote>\r\n<p>如果类获得了资源，就需要析构函数，为了安全地管理资源，它可能必须实现<strong>复制构造函数</strong>和<strong>复制赋值</strong>。</p>\r\n<p>如果用户未定义这些特殊函数，编译器会对其进行隐式定义。隐式生成的构造函数和赋值运算符执行浅层的、成员式的复制，如果一个对象管理一个资源，这基本上就可以确定是错的。</p>\r\n<p>在下一个示例中，隐式生成的复制构造函数将使指针 <code>str1.text</code>\r\n和 <code>str2.text</code> 引用同一内存，当我们从\r\n<code>copy_strings()</code>\r\n返回时，该内存将被删除两次，这是未定义的行为：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void copy_strings() &#123;\n   String str1(&quot;I have a sense of impending disaster...&quot;);\n   String str2 &#x3D; str1; &#x2F;&#x2F; str1.text and str2.text now refer to the same object\n&#125; &#x2F;&#x2F; delete[] _text; deallocates the same memory twice\n  &#x2F;&#x2F; undefined behavior</code></pre>\r\n<p>显式定义析构函数、复制构造函数或复制赋值运算符可防止对移动构造函数和移动赋值运算符进行隐式定义。\r\n在这种情况下，如果复制成本高昂，通常无法提供移动操作，从而导致错过优化机会</p>\r\n</blockquote>\r\n<h3 id=\"类的拷贝构造函数\">类的拷贝构造函数</h3>\r\n<p><a\r\nhref=\"https://www.runoob.com/cplusplus/cpp-copy-constructor.html\">C++\r\n拷贝构造函数 | 菜鸟教程 (runoob.com)</a></p>\r\n<blockquote>\r\n<p><strong>拷贝构造函数</strong>是一种特殊的<strong>构造函数</strong>，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</p>\r\n</blockquote>\r\n<p>拷贝构造函数通常用于：</p>\r\n<ul>\r\n<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>\r\n<li>复制对象把它作为参数传递给函数。</li>\r\n<li>复制对象，并从函数返回这个对象。</li>\r\n</ul>\r\n<blockquote>\r\n<p>当你传递一个指向对象的指针而不是对象本身时，不会触发拷贝构造函数。</p>\r\n<p>一个结论是：通过拷贝构造函数创建的实例本身，总是存在于栈上；不过不妨碍实例中的某些变量去可以开辟堆空间。</p>\r\n</blockquote>\r\n<p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。<strong>如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。</strong>拷贝构造函数的最常见形式如下：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">classname (const classname &amp;obj) &#123;   ..函数主体..  &#125;</code></pre>\r\n<p>在这里，<strong>obj</strong>\r\n是一个对象引用，该对象是用于初始化另一个对象的。</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n \nclass Line &#123;\npublic:\n    int getLength( void );\n    Line( int len );             &#x2F;&#x2F; 简单的构造函数\n    Line( const Line &amp;obj);      &#x2F;&#x2F; 拷贝构造函数\n    ~Line( void );               &#x2F;&#x2F; 析构函数\nprivate:\n\tint *ptr;\n&#125;;\n \n&#x2F;&#x2F; 成员函数定义，包括构造函数\nLine::Line(int len) &#123;\n    cout &lt;&lt; &quot;调用构造函数&quot; &lt;&lt; endl;\n    &#x2F;&#x2F; 为指针分配内存\n    ptr &#x3D; new int;\n    *ptr &#x3D; len;\n&#125;\n \nLine::Line(const Line &amp;obj) &#123;\n    cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl;\n    ptr &#x3D; new int;\n    *ptr &#x3D; *obj.ptr; &#x2F;&#x2F; 拷贝值\n&#125;\n \nLine::~Line( void ) &#123;\n    cout &lt;&lt; &quot;释放内存&quot; &lt;&lt; endl;\n    delete ptr;\n&#125;\nint Line::getLength( void ) &#123;\n    return *ptr;\n&#125;\n \nvoid display(Line obj) &#123;\n   cout &lt;&lt; &quot;line 大小 : &quot; &lt;&lt; obj.getLength() &lt;&lt;endl;\n&#125;\n \n&#x2F;&#x2F; 程序的主函数\nint main(void) &#123;\n   Line line1(10); &#x2F;&#x2F; 这个时候的line1是创建在栈上的\n \n   Line line2 &#x3D; line1; &#x2F;&#x2F;调用了拷贝构造函数 Place.1\n \n   display(line1); &#x2F;&#x2F;调用了拷贝构造函数 Place.2，对象本身创建在栈上，ptr指向某一堆空间，它们在函数执行完毕后被一起销毁\n   display(line2); &#x2F;&#x2F;调用了拷贝构造函数 Place.3\n \n   return 0;\n&#125;</code></pre>\r\n<p>乍一看，拷贝构造函数是可以通过重载一个以类名为参数的构造函数代替的，但事实上这样的“代替”并不能解决作函数参数传递的问题(display函数)，因此，拷贝构造函数是在特定情况下是相当必要的。</p>\r\n<h4 id=\"关于浅拷贝和深拷贝\">关于浅拷贝和深拷贝</h4>\r\n<h3 id=\"类的this指针与友元\">类的This指针与友元</h3>\r\n<p>在 C++ 中，<strong>this</strong>\r\n指针是一个特殊的指针，它指向当前对象的实例——每一个对象都能通过\r\n<strong>this</strong> 指针来访问自己的地址。</p>\r\n<p>类的成员函数也可以用它来指向调用的对象：当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为\r\nthis 指针。</p>\r\n<p>而类的<strong>友元函数</strong>是：<em>定义在类外部，但有权访问类的所有成员的函数</em>——包括私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数，即，友元函数没有this指针。</p>\r\n<p>所以，虽然友元函数能够访问这些成员，但有些时候，友元函数需要实例作为形参来充当媒介，这有两种情况：</p>\r\n<ul>\r\n<li>要访问非static成员时，需要对象做参数；</li>\r\n<li>要访问static成员或全局变量时，则不需要对象做参数；</li>\r\n</ul>\r\n<p>可以直接调用友元函数，不需要通过对象或指针</p>\r\n<p>除了友元函数外，也有友元类的写法——在这种情况下，整个类及其所有成员都是友元。</p>\r\n<p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字\r\n<strong>friend</strong>，如下所示：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Box &#123;\n   double width;\npublic:\n   double length;\n   friend void printWidth( Box box );\n   void setWidth( double wid );\n&#125;;</code></pre>\r\n<p>声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类\r\nClassOne 的定义中放置如下声明：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">friend class ClassTwo;</code></pre>\r\n<p>此时，</p>\r\n<h3 id=\"内联\">内联</h3>\r\n<p>内联是一种空间换时间的优化手段，内联函数会在调用处展开以减少函数调用的开销，缺点就是编译体积增大。</p>\r\n<ul>\r\n<li>如果希望把一个函数定义为内联函数，确实需要在函数名前面放置关键字\r\ninline，但具体是否进行内联具体仍由编译器决定。</li>\r\n<li>在类定义中的定义的函数都是内联函数，即使没有使用 inline\r\n说明符。</li>\r\n</ul>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://www.runoob.com/cplusplus/cpp-inline-functions.html\">C++\r\n内联函数 | 菜鸟教程 (runoob.com)</a></p>\r\n</blockquote>\r\n<h3 id=\"多态\">多态</h3>\r\n<p>我们说，多态是有区分的：一般可以分为运行时多态和静态多态</p>\r\n<h4 id=\"编译时多态静态多态--重载\">编译时多态（静态多态）- 重载</h4>\r\n<p>我们说 <strong>重载</strong>\r\n是C++相对于C的另一个重大变化。重载是指：一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但它们的参数列表和定义（实现）不相同。</p>\r\n<p>C++\r\n允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>\r\n<p>调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>\r\n<p>这里需要着重强调的，其实是运算符的重载：我们可以重载大部分 C++\r\n内置的运算符以实现特殊目标。</p>\r\n<p><strong>重载的运算符是带有特殊名称的函数</strong>，函数名是由关键字\r\n<code>operator</code>\r\n和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。并且，大多数的重载运算符是可以被定义为普通的非成员函数或者被定义为类成员函数的。</p>\r\n<p>以声明加法运算符为例，如果我们需要把两个 Box 对象相加，返回最终的 Box\r\n对象：</p>\r\n<ul>\r\n<li><p>如果我们定义该函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Box operator+(const Box&amp; lhs, const Box&amp; rhs);</code></pre></li>\r\n<li><p>但是，如果它是类的成员函数的话：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Box operator+(const Box&amp; rhs);\n\n&#x2F;&#x2F; Example:\nBox operator+(const Box&amp; rhs) &#123;\n    Box box;\n    box.length &#x3D; this-&gt;length + rhs.length;\n    box.breadth &#x3D; this-&gt;breadth + rhs.breadth;\n    box.height &#x3D; this-&gt;height + rhs.height;\n    return box;\n&#125;</code></pre></li>\r\n</ul>\r\n<p>与重载相对的是重写，即动态重载：</p>\r\n<h4 id=\"运行时多态动态多态--重写\">运行时多态（动态多态）- 重写</h4>\r\n<p>在 C++ 中，我们使用虚函数（virtual\r\nfunction）来实现方法的重写（override）。这种方法的重写是通过继承和虚函数机制来实现的：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 基类\nclass Base &#123;\npublic:\n    &#x2F;&#x2F; 虚函数，可被派生类重写\n    &#x2F;&#x2F; 在 C++ 中，虚函数必须显式声明为 virtual，否则不会触发动态多态，子类中的同名函数不会覆盖基类中的函数。\n    &#x2F;&#x2F; 这与C#中是不同的：C#中，所有非 static 方法默认都是虚函数，允许被子类覆盖。既可以用 virtual 显式指明，也可以用sealed禁止方法重写。\n    virtual void print() &#123; std::cout &lt;&lt; &quot;Base class print function.&quot; &lt;&lt; std::endl; &#125;\n&#125;;\n\n&#x2F;&#x2F; 派生类\nclass Derived : public Base &#123;\npublic:\n    &#x2F;&#x2F; 重写基类中的虚函数\n    &#x2F;&#x2F; &#96;override&#96; 关键字是 C++11 新增的特性，它用于显式指示该函数是重写基类中的虚函数，以提高代码的可读性。\n    void print() override &#123; Base::print(); std::cout &lt;&lt; &quot;Derived class print function.&quot; &lt;&lt; std::endl; &#125;\n&#125;;\n\nint main() &#123;\n    Base* b &#x3D; new Derived(); &#x2F;&#x2F; 创建 Derived 类对象的指针，指向基类类型\n\n    b-&gt;print(); &#x2F;&#x2F; 调用虚函数，将调用派生类中的重写函数\n\n    delete b; &#x2F;&#x2F; 记得释放内存\n    return 0;\n&#125;</code></pre>\r\n<p>这段代码中，<code>Base</code> 类中的 <code>print()</code>\r\n方法是虚函数，而 <code>Derived</code> 类中重写了 <code>Base</code> 类的\r\n<code>print()</code> 方法。在 <code>main()</code> 函数中，创建了一个指向\r\n<code>Derived</code> 类对象的基类指针，并调用了 <code>print()</code>\r\n方法。由于 <code>print()</code>\r\n是虚函数，并且指针指向派生类对象，因此将调用派生类中重写的函数。</p>\r\n<p>这种方式是 C++\r\n中实现方法重写的典型方法，利用虚函数和继承来达到在派生类中重写基类方法的目的。</p>\r\n<h4 id=\"虚函数\">虚函数</h4>\r\n<ul>\r\n<li><strong>普通虚函数：</strong>\r\n普通虚函数在基类中有函数体，但可以被派生类覆盖（重写）。\r\n<ul>\r\n<li>对于普通虚函数，我们可以不去实现，这时会默认调用父类的虚函数</li>\r\n<li></li>\r\n</ul></li>\r\n<li><strong>纯虚函数：</strong>\r\n纯虚函数在基类中没有实现（没有函数体），它只是一个接口，要求派生类必须重写该函数。\r\n<ul>\r\n<li>对于纯虚函数，更加类似于C#中的abstract，我们必须对这个函数进行实现</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"从指针取地址再到引用\">从指针、取地址、再到引用</h2>\r\n<h3 id=\"对-int-a-使用的-构成-a-时程序会做什么\">对 int a 使用的 &amp;\r\n构成 &amp;a 时，程序会做什么？</h3>\r\n<p>假设数组 <code>int a[10];</code> 与\r\n<code>int (*p)[10] = &amp;a;</code> 其中：</p>\r\n<ul>\r\n<li>a是数组名，其本身可以看作是<strong>指向数组首元素的指针</strong>，<code>int a[10]</code>\r\n就是基本的数组：\r\n<ul>\r\n<li>当我们使用 <code>cout &lt;&lt; a;</code>\r\n时，会输出数组首个元素的地址，即，a本身指向数组首元素地址；而\r\n<code>cout &lt;&lt; *a</code> 则会输出首个元素的内容。</li>\r\n<li>对 a 进行 +1\r\n操作表示指针的地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a\r\n+ 1) = a[1]。</li>\r\n<li>虽然说是\"数组首元素的指针\"，但实际上对 a 使用\r\nsizeof，我们得到的是整个数组的大小——这是存在区别的：c中，数组名跟指针有区别吗？\r\n- cache的回答 -\r\n知乎https://www.zhihu.com/question/41805285/answer/1405755895</li>\r\n</ul></li>\r\n<li>&amp;a是<strong>数组的指针</strong>，其类型为int\r\n(*)[10]，<code>int (*p)[10]</code> 是指，p\r\n是指向一个包含10个整数数组的指针\r\n<ul>\r\n<li>+1 时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量）\r\n，值为数组a尾元素后一个元素的地址。 若(int <em>)p ，此时输出\r\n</em>p时，其值为a[0]的值，因为被转为int\r\n*类型，解引用时按照int类型大小来读取。</li>\r\n<li>对于指针本身，其 sizeof 的结果仍是 8 byte (64位)</li>\r\n</ul></li>\r\n<li>另外 <code>int *p[10];</code> 则是指针的数组</li>\r\n</ul>\r\n<p>一次小实验：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int main() &#x2F;&#x2F; 64位环境\n&#123;\n    int a[10];\n    a[0] &#x3D; 1;\n    int(*p)[10] &#x3D; &amp;a;\n    int* t[10];\n\n    cout &lt;&lt; sizeof(a) &lt;&lt; endl;      &#x2F;&#x2F; 40\n    cout &lt;&lt; a[0] &lt;&lt; endl;           &#x2F;&#x2F; 1\n    cout &lt;&lt; a &lt;&lt; endl;              &#x2F;&#x2F; 0x637f9ffcd0\n\n    cout &lt;&lt; sizeof(p) &lt;&lt; endl;      &#x2F;&#x2F; 8\n    cout &lt;&lt; p &lt;&lt; endl;              &#x2F;&#x2F; 0x637f9ffcd0\n    cout &lt;&lt; p + 1 &lt;&lt; endl;          &#x2F;&#x2F; 0x637f9ffcf8\n    cout &lt;&lt; (int*)p &lt;&lt; endl;        &#x2F;&#x2F; 0x637f9ffcd0\n    cout &lt;&lt; (int*)(p + 1) &lt;&lt; endl;  &#x2F;&#x2F; 0x637f9ffcf8\n    cout &lt;&lt; (int*)(p) + 1 &lt;&lt; endl;  &#x2F;&#x2F; 0x637f9ffcd4\n    cout &lt;&lt; *p &lt;&lt; endl;             &#x2F;&#x2F; 0x637f9ffcd0\n    cout &lt;&lt; *(p) + 1 &lt;&lt; endl;       &#x2F;&#x2F; 0x637f9ffcd4\n    cout &lt;&lt; (int**)p &lt;&lt; endl;       &#x2F;&#x2F; 0x637f9ffcd0\n    cout &lt;&lt; **p &lt;&lt; endl;            &#x2F;&#x2F; 1\n    cout &lt;&lt; **(p + 1) &lt;&lt; endl;      &#x2F;&#x2F; 36\n\n    cout &lt;&lt; sizeof(t) &lt;&lt; endl;      &#x2F;&#x2F; 80\n\n    int* c &#x3D; &amp;a[0];\n    cout &lt;&lt; c &lt;&lt; endl;              &#x2F;&#x2F; 0x637f9ffcd0\n    cout &lt;&lt; *c &lt;&lt; endl;             &#x2F;&#x2F; 1\n&#125;</code></pre>\r\n<p>这里我们可以引出另一个问题：</p>\r\n<blockquote>\r\n<p>传值、传引用、传地址的区别是什么?</p>\r\n</blockquote>\r\n<h3 id=\"传值传引用以及传地址\">传值、传引用以及传地址</h3>\r\n<h4 id=\"关于的一点迷思\">关于&amp;的一点迷思</h4>\r\n<p>在C中的 <code>&amp;</code> 仅作为 <code>取地址运算符</code> 和\r\n<code>按位与</code> 运算使用</p>\r\n<p>但是到了C++中，我们赋予了该符号一个新用途——引用</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int A &#x3D; 1;\nint* a &#x3D; &amp;A; &#x2F;&#x2F; C 中 &amp; 符号的用法\nint&amp; b &#x3D; A; &#x2F;&#x2F; Cpp中 &amp; 符号的新用法：创建一个对原变量的引用</code></pre>\r\n<blockquote>\r\n<p>试想：变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int i &#x3D; 17;</code></pre>\r\n<p>我们可以为 i 声明引用变量，如下所示：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int&amp;  r &#x3D; i;</code></pre>\r\n<p>即：引用变量是一个别名，它就像某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>\r\n<p>与指针相似的是，引用将存储位于内存中其他位置的对象的地址。</p>\r\n<p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>\r\n<ul>\r\n<li>不存在空引用。引用必须在创建时被初始化，并且必须连接到一块合法的内存。而指针则可以在任何时间被初始化。</li>\r\n<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>\r\n<li>引用和指针各自的实现下所导致的寻址方式不同：\r\n<ul>\r\n<li>引用通常会被实现为被引用对象的别名，编译器可能会将引用实现为对象的地址或直接作为对象的别名。因此，对引用的操作类似于对对象本身的操作。</li>\r\n<li>指针存储了对象的地址，间接指向对象，因此对指针的操作实际上是对存储在指针所指向地址处的对象的操作。</li>\r\n</ul></li>\r\n</ul>\r\n<p><a href=\"https://www.runoob.com/cplusplus/cpp-references.html\">C++\r\n引用 | 菜鸟教程 (runoob.com)</a></p>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/zh-cn/cpp/cpp/references-cpp?view=msvc-170\">引用\r\n(C++) | Microsoft Learn</a></p>\r\n</blockquote>\r\n<h4 id=\"三种方式的函数参数传递\">三种方式的函数参数传递</h4>\r\n<ul>\r\n<li>传值(值传递，passl-by-value)，是把实参的值赋值给行参，那么对行参的修改，不会影响实参的值\r\n<ul>\r\n<li>函数压栈的是实参的副本。任何的修改是在副本上作用，没有作用在实参上。</li>\r\n<li>值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本——这就导致了函数内的变化一般不会影响主调函数的实参变量的值。</li>\r\n</ul></li>\r\n<li>传地址，仍是值传递(passl-by-value)的一种表现，以地址的方式传递参数，一般由指针接收\r\n<ul>\r\n<li>压栈的是指针变量的副本。只要指针副本仍指向原来的那个变量，就可以将影响反应到原来的指针上。</li>\r\n</ul></li>\r\n<li>传引用(pass-by-reference)，\"真正的\"，以地址的方式传递参数。传递以后，行参和实参都是同一个对象，对行参的修改将影响实参的值\r\n<ul>\r\n<li>值得注意的是：在 C++\r\n中，通过引用传递函数参数不会调用拷贝构造函数。因为，当我们以引用\r\n<code>&amp;</code>\r\n传递参数给函数时，实际上你传递的是原始对象的引用（地址），而不是对象本身的拷贝。因此，在函数中对这个引用进行操作时，操作的是原始对象，而不是其副本。</li>\r\n<li>引用传递(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</li>\r\n<li>压栈的是引用的副本。由于引用是指向某个变量的，对引用的操作其实就是对他指向的变量的操作。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"如果是返回引用呢\">如果是返回引用呢？</h4>\r\n<p>菜鸟教程上有一个返回引用的好例子，这个例子中，我们在函数中获取值并在主函数中更改值：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n \ndouble vals[] &#x3D; &#123;10.1, 12.6, 33.1, 24.1, 50.0&#125;;\n \ndouble&amp; setValues(int i) &#123;  \n   double&amp; ref &#x3D; vals[i];    \n   return ref;   &#x2F;&#x2F; 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i] \n&#125;\n\nint main () &#123;\n   cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl;\n   for ( int i &#x3D; 0; i &lt; 5; i++ ) &#123;\n       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] &#x3D; &quot;;\n       cout &lt;&lt; vals[i] &lt;&lt; endl;\n   &#125;\n \n   setValues(1) &#x3D; 20.23; &#x2F;&#x2F; 改变第 2 个元素\n   setValues(3) &#x3D; 70.8;  &#x2F;&#x2F; 改变第 4 个元素\n \n   cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl;\n   for ( int i &#x3D; 0; i &lt; 5; i++ ) &#123;\n       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] &#x3D; &quot;;\n       cout &lt;&lt; vals[i] &lt;&lt; endl;\n   &#125;\n   return 0;\n&#125;</code></pre>\r\n<h2 id=\"cpp的一些关键字\">CPP的一些关键字</h2>\r\n<h3 id=\"include\">Include</h3>\r\n<p>标准的\"Pre-processing\"语句，编译器在接收到source\r\nfiles后做的第一件事就是处理这些东西。而include做的事情就是将根据后续的文件名去寻找对应的文件，获取其中的内容并粘贴到当前文件中，这通常是“头文件”</p>\r\n<h3 id=\"static-const\">static &amp; const</h3>\r\n<p>首先让我们看向static——这个关键字的使用有两种不同情况：</p>\r\n<ul>\r\n<li>在类或者结构体内部使用：此时表示这部分内存（static变量）是这个类的所有实例共享的。即：该静态变量在类中创建的所有实例中，静态变量只有一个实例。一个改变就改变所有。</li>\r\n<li>在类或者结构体外部使用：这意味着所定义的函数和变量只对它的声明所在的cpp文件（编译单元）是“可见”的。换句话说此时static修饰的符号,（在link的时候）它只对定义它的翻译单元(.obj)可见（internal\r\nlinkage）。</li>\r\n</ul>\r\n<h2 id=\"编码\">编码</h2>\r\n<p><a\r\nhref=\"https://zh-google-styleguide.readthedocs.io/en/latest/\">Google\r\n开源项目风格指南——中文版 — Google 开源项目风格指南\r\n(zh-google-styleguide.readthedocs.io)</a></p>\r\n<h2 id=\"stl\">STL</h2>\r\n<h3 id=\"container\">Container</h3>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://cui-jiacai.gitbook.io/c++-stl-tutorial/gai-shu/guan-yu-rong-qi\">关于容器\r\n- C++ STL Tutorial (gitbook.io)</a></p>\r\n</blockquote>\r\n<p>容器，用于表示由同类型元素构成的、长度可变的元素序列。</p>\r\n<p>容器是由类模板来实现的，模板的参数是容器中元素的类型。</p>\r\n<p>STL中包含了很多种容器，虽然这些容器提供了一些相同的操作，但由于它们采用了不同的内部实现方法，因此，<strong>不同的容器</strong>往往适合于<strong>不同的应用场合</strong>。</p>\r\n<h4 id=\"vector\">Vector</h4>\r\n<p>可以说是最常用的容器：</p>\r\n<blockquote>\r\n<p><strong>用于需要快速定位（访问）任意位置上的元素</strong> 以及\r\n主要在元素序列的 尾部 增加 / 删除 元素的场合。</p>\r\n<p>在头文件<code>vector</code>中定义，用<strong>动态数组实现。</strong></p>\r\n</blockquote>\r\n<p>Vector的初始化方法很多，各种初始化方法有一些不同。</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 1.最基础的vector创建：此时容器的 size 为 0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。\nvector&lt;int&gt; ilist1;\n\n&#x2F;&#x2F; 2.在创建时指定容器大小：ilist2 中将包含 7 个元素，每个元素进行缺省的值初始化，对于int，即被赋值为0\nvector&lt;int&gt; ilist2(7);\n\n&#x2F;&#x2F; 3.在创建时统一初值：ilist3 被初始化为包含 7 个值为 3 的int\nvector&lt;int&gt; ilist3(7, 3);\n\n&#x2F;&#x2F; 4.利用复制拷贝函数：新 vector 初始化为同类型的、已有的 vector 的拷贝\nvector&lt;int&gt; ilist4(ilist); &#x2F;&#x2F; or:\nvector&lt;int&gt; ilist4 &#x3D; ilist; &#x2F;&#x2F; 两种方式等价，ilist4 将具有和 ilist 相同的容量和元素\n\n&#x2F;&#x2F; 5.ilist 初始化为列表中元素的拷贝，列表中元素必须与 ilist 的元素类型相同\nvector&lt;int&gt; ilist &#x3D; &#123;1,2,3.0,4,5,6,7&#125;; &#x2F;&#x2F; or\nvector&lt;int&gt; ilist &#123;1,2,3.0,4,5,6,7&#125;;\n\n&#x2F;&#x2F; 6. ilist6 初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与 ilist6 的元素类型相容\nvector&lt;int&gt; ilist6(ilist.begin() + 2, ilist.end() - 1); &#x2F;&#x2F; ilist6 被初始化为 &#123;3, 4, 5, 6&#125;</code></pre>\r\n<h4\r\nid=\"map关键字类型值类型-和-multimap关键字类型值类型\">map&lt;关键字类型，值类型&gt;\r\n和 multimap&lt;关键字类型，值类型&gt;</h4>\r\n<p>用于需要根据关键字来访问元素的场合。容器中每个元素是一个\r\n<code>pair</code>\r\n结构类型，该结构有两个成员：<code>first</code>和<code>second</code>，关键字对应<code>first</code>，值对应<code>second</code></p>\r\n<p><code>map</code> 和 <code>multimap</code>\r\n中的元素根据其关键字排序的，其中：</p>\r\n<ul>\r\n<li>对于<code>map</code>，不同元素的关键字不能相同；</li>\r\n<li>对于<code>multimap</code>，不同元素的关键字可以相同。</li>\r\n</ul>\r\n<p>它们在头文件<code>map</code>中定义，常常用某种<strong>二叉树</strong>来实现，且一般是红黑树。</p>\r\n<blockquote>\r\n<p>有时候我们不需要排序，所以在C++11标准中新增加了<code>unordered_map</code>和<code>unordered_multimap</code>容器。</p>\r\n</blockquote>\r\n<h4 id=\"set-和-multiset\">set<元素类型> 和 multiset<元素类型></h4>\r\n<p>它们分别是<code>map</code>和<code>multimap</code>的特例，<strong>每个元素只有关键字而没有值，或者说，关键字与值合一了</strong>。</p>\r\n<p>在头文件<code>set</code>中定义。</p>\r\n<blockquote>\r\n<p>C++11标准中增加了<code>unordered_set</code>和<code>unordered_multiset</code>容器。</p>\r\n</blockquote>\r\n<h4 id=\"更多容器\">更多容器</h4>\r\n<h5 id=\"list\">list<元素类型></h5>\r\n<p>用于经常在元素序列中任意位置上插入/删除元素的场合。</p>\r\n<p>在头文件<code>list</code>中定义，用<strong>双向链表</strong>实现。</p>\r\n<blockquote>\r\n<p>在C++11标准中增加了<code>forward_list</code>容器，本质上是一个<strong>单向链表</strong>，定义在头文件<code>forward_list</code>中。</p>\r\n</blockquote>\r\n<h5 id=\"stack\">stack<元素类型></h5>\r\n<p>栈 - 用于仅在元素序列的尾部增加/删除元素的场合。</p>\r\n<p>在头文件<code>stack</code>中定义，可基于<code>deque</code>、<code>list</code>或<code>vector</code>来实现。</p>\r\n<h5 id=\"queue\">queue<元素类型></h5>\r\n<p>队列 - 用于仅在元素序列的尾部增加、头部删除元素的场合。</p>\r\n<p>在头文件<code>queue</code>中定义，可基于<code>deque</code>和<code>list</code>来实现。</p>\r\n<h5 id=\"deque\">deque<元素类型></h5>\r\n<p>双向队列 -\r\n用于主要在元素序列的两端增加/删除元素以及需要快速定位（访问）任意位置上的元素的场合。</p>\r\n<p>在头文件<code>deque</code>中定义，用<strong>分段的连续空间结构</strong>实现。</p>\r\n<h5 id=\"priority_queue\">priority_queue<元素类型></h5>\r\n<p>它与<code>queue</code>的操作类似，不同之处在于：每次增加/删除元素之后，它将对元素位置进行调整，使得头部元素总是最大的。也就是说，每次删除操作总是把最大（优先级最高）的元素去掉。</p>\r\n<p>在头文件<code>queue</code>中定义，可基于<code>deque</code>和<code>vector</code>来实现。</p>\r\n<h5 id=\"basic_string\">basic_string<字符类型></h5>\r\n<p>与<code>vector</code>类似，不同之处在于其元素为字符类型，并提供了一系列与<strong>字符串</strong>相关的操作。</p>\r\n<p><code>string</code>和<code>wstring</code>分别是它的两个实例：</p>\r\n<ul>\r\n<li><code>basic_string&lt;char&gt;</code></li>\r\n<li><code>basic_string&lt;wchar_t&gt;</code></li>\r\n</ul>\r\n<p>在头文件<code>string</code>中定义。</p>\r\n<h4 id=\"容器的基本操作\">容器的基本操作</h4>\r\n<p>容器类模板提供了一些成员函数来实现容器的<strong>基本操作</strong>，其中包括：</p>\r\n<ul>\r\n<li>往容器中增加元素</li>\r\n<li>从容器中删除元素</li>\r\n<li>获取容器中指定位置的元素</li>\r\n<li>在容器中查找元素</li>\r\n<li>获取容器首/尾元素的迭代器</li>\r\n<li>......</li>\r\n</ul>\r\n<blockquote>\r\n<p>这些成员函数往往具有通用性（大部分容器类模板都包含它们）。</p>\r\n</blockquote>\r\n<p>注意：如果容器的元素类型是一个类，则针对该类可能需要：</p>\r\n<ul>\r\n<li>自定义拷贝构造函数和赋值操作符重载函数\r\n<ul>\r\n<li>对容器进行的一些操作中可能会创建新的元素（对象的拷贝构造）或进行元素间的赋值（对象赋值）。</li>\r\n<li>重载小于操作符（&lt;）\r\n对容器进行的一些操作中可能要进行元素比较运算。</li>\r\n</ul></li>\r\n</ul>\r\n<h4\r\nid=\"举例利用map实现一个简单的电话簿\">举例：利用<code>map</code>实现一个简单的电话簿</h4>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\nint main()\n&#123;\n    map&lt;string,int&gt; phone_book; &#x2F;&#x2F; 创建一个map类容器，用于存储电话号码簿\n    \n    &#x2F;&#x2F; 创建电话簿\n    phone_book[&quot;wang&quot;] &#x3D; 12345678; &#x2F;&#x2F; 通过[]操作和关键字往容器中加入元素\n    phone_book[&quot;li&quot;] &#x3D; 87654321;\n    phone_book[&quot;zhang&quot;] &#x3D; 56781234; &#x2F;&#x2F; ......  还可以添加更多的信息\n    \n    &#x2F;&#x2F; 输出电话号码簿\n    cout &lt;&lt; &quot;电话号码簿的信息如下：\\n&quot;;\n    for (pair&lt;string, int&gt; item: phone_book) &#x2F;&#x2F; C++11中引入的 enhanced-for loop\n        cout &lt;&lt; item.first &lt;&lt; &quot;: &quot; &lt;&lt; item.second &lt;&lt; endl; &#x2F;&#x2F; 输出元素的姓名和电话号码\n\n    &#x2F;&#x2F; 查找某个人的电话号码\n    string name;\n    cout &lt;&lt; &quot;请输入要查询号码的姓名：&quot;;\n    cin &gt;&gt; name;\n    map&lt;string,int&gt;::const_iterator it; &#x2F;&#x2F; 创建一个不能修改所指向的元素的迭代器\n    it &#x3D; phone_book.find(name); &#x2F;&#x2F; 查找关键字为name的容器元素\n    if (it &#x3D;&#x3D; phone_book.end()) &#x2F;&#x2F; 判断是否找到\n        cout &lt;&lt; name &lt;&lt; &quot;: not found\\n&quot;; &#x2F;&#x2F; 未找到\n    else\n        cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#x2F;&#x2F; 找到\n    return 0;\n&#125;</code></pre>\r\n<p>至此，读者应当对于STL中的容器有了一个整体上的把控，知晓各容器的基本特征。</p>\r\n<h2 id=\"关于新标准\">关于新标准</h2>\r\n<h3 id=\"auto\">auto</h3>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/zh-cn/cpp/cpp/auto-cpp?view=msvc-170\">auto\r\n(C++) | Microsoft Learn</a></p>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/101432602\">c++ 关键字auto -\r\n知乎 (zhihu.com)</a></p>\r\n</blockquote>\r\n<p>类似于C#中的var关键字：在编译时，从其初始化表达式中推导声明的变量的类型。</p>\r\n<h3 id=\"迭代器\">迭代器</h3>\r\n<h3 id=\"range-based-fors\">range-based fors</h3>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://stackoverflow.com/questions/8378583/enhanced-for-loops-in-c\">java\r\n- Enhanced FOR loops in C++ - Stack Overflow</a></p>\r\n<p>In C++11, if your compiler supports it, yes it is. It's called\r\nrange-based for.</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">std::vector&lt;int&gt; v;\n\n&#x2F;&#x2F; fill vector\n\nfor (const int&amp; i : v) &#123; std::cout &lt;&lt; i &lt;&lt; &quot;\\n&quot;; &#125;</code></pre>\r\n<p><strong>It works for C style arrays</strong>, and any type that has\r\nfunctions begin() and end() that return iterators. Example:</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class test &#123;\n       int* array;\n       size_t size;\npublic:\n       test(size_t n) : array(new int[n]), size(n)\n       &#123;\n           for (int i &#x3D; 0; i &lt; n; i++) &#123; array[i] &#x3D; i; &#125;\n       &#125;\n       ~test() &#123; delete [] array; &#125;\n       int* begin() &#123; return array; &#125;\n       int* end() &#123; return array + size; &#125;\n&#125;;\n\nint main()\n&#123;\n       test T(10);\n       for (auto&amp; i : T) &#123;\n           std::cout &lt;&lt; i;   &#x2F;&#x2F; prints 0123456789\n       &#125;\n&#125;</code></pre>\r\n</blockquote>\r\n<p>类似于C#中的foreach，可配合auto使用，对于遍历数组中每个元素的情况会很方便</p>\r\n<p>不过说到foreach，实际上c++有这么一号东西</p>\r\n<h3 id=\"左值右值\">左值，右值？</h3>\r\n<p>https://zhuanlan.zhihu.com/p/240833006</p>\r\n<h4 id=\"移动右值引用以及更多\">移动、右值引用以及更多：</h4>\r\n<p>当谈论 C++ 中的引用时，有两种主要类型的引用：左值引用（lvalue\r\nreference）和右值引用（rvalue\r\nreference）。它们在对对象进行引用时有不同的行为和用途。</p>\r\n<ol type=\"1\">\r\n<li><p><strong>左值引用（lvalue reference）：</strong></p>\r\n<ul>\r\n<li>左值引用用 <code>&amp;</code> 表示，在声明时用于引用命名变量。</li>\r\n<li>它们可以绑定到左值（具有标识和地址的表达式）。</li>\r\n<li>主要用于传统的引用语义，如传递参数给函数，允许函数修改传递的值。</li>\r\n</ul>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cppCopy codeint x &#x3D; 10;\nint&amp; lref &#x3D; x; &#x2F;&#x2F; lref 是 x 的左值引用</code></pre></li>\r\n<li><p><strong>右值引用（rvalue reference）：</strong></p>\r\n<ul>\r\n<li>右值引用用 <code>&amp;&amp;</code>\r\n表示，在声明时用于引用临时对象或右值。</li>\r\n<li>它们可以绑定到右值（临时或不具有标识的表达式）。</li>\r\n<li>主要用于移动语义（如在移动构造函数和移动赋值运算符中）和完美转发（用于实现通用函数，如模板函数）。</li>\r\n</ul>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cppCopy code\nint&amp;&amp; rref &#x3D; 5; &#x2F;&#x2F; rref 是右值引用，绑定到临时对象 5</code></pre></li>\r\n</ol>\r\n<p>左值引用主要用于传统的引用语义，允许对引用的对象进行修改。右值引用则是\r\nC++11\r\n引入的概念，主要用于支持移动语义和完美转发，允许有效地管理临时对象和实现更高效的资源管理。</p>\r\n<p>需要注意的是，右值引用除了在移动语义和完美转发中发挥作用外，也可以用于特定的函数重载和模板函数，以区分对左值和右值的不同处理方式。</p>\r\n<h2 id=\"一些没有注意过的东西\">一些没有注意过的东西</h2>\r\n<p>关于位域：<a href=\"https://zhuanlan.zhihu.com/p/354232756\">C/C++ 位域\r\nBit fields 学习心得 - 知乎 (zhihu.com)</a></p>\r\n","text":"CPP急速入门 C with Class 首先，C++是面向对象的语言，而C是面向过程的语言，即，最起码，C++是建立在叫做C with class的基础上的 一个突出的点是，C++引入了函数重载的特性，而C中没有； 而与面向对象最直接的结果就是：C++引入了 new/delet...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"Language Learning","slug":"Language-Learning","count":7,"path":"api/categories/Language-Learning.json"},{"name":"CPP","slug":"Language-Learning/CPP","count":1,"path":"api/categories/Language-Learning/CPP.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":19,"path":"api/tags/Language-Learning.json"},{"name":"CPP","slug":"CPP","count":1,"path":"api/tags/CPP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#cpp%E6%80%A5%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">CPP急速入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-with-class\"><span class=\"toc-text\">C with Class</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Ecpp%E4%B8%AD%E7%9A%84newdelete\"><span class=\"toc-text\">关于cpp中的new&amp;delete</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">关于析构函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">类的拷贝构造函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">关于浅拷贝和深拷贝</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84this%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">类的This指针与友元</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E8%81%94\"><span class=\"toc-text\">内联</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81--%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">编译时多态（静态多态）- 重载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81--%E9%87%8D%E5%86%99\"><span class=\"toc-text\">运行时多态（动态多态）- 重写</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">虚函数</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E6%8C%87%E9%92%88%E5%8F%96%E5%9C%B0%E5%9D%80%E5%86%8D%E5%88%B0%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">从指针、取地址、再到引用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9-int-a-%E4%BD%BF%E7%94%A8%E7%9A%84-%E6%9E%84%E6%88%90-a-%E6%97%B6%E7%A8%8B%E5%BA%8F%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">对 int a 使用的 &amp;\r\n构成 &amp;a 时，程序会做什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E5%80%BC%E4%BC%A0%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%BC%A0%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">传值、传引用以及传地址</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E7%9A%84%E4%B8%80%E7%82%B9%E8%BF%B7%E6%80%9D\"><span class=\"toc-text\">关于&amp;的一点迷思</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">三种方式的函数参数传递</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E6%98%AF%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E5%91%A2\"><span class=\"toc-text\">如果是返回引用呢？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cpp%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">CPP的一些关键字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#include\"><span class=\"toc-text\">Include</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#static-const\"><span class=\"toc-text\">static &amp; const</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">编码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stl\"><span class=\"toc-text\">STL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#container\"><span class=\"toc-text\">Container</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#vector\"><span class=\"toc-text\">Vector</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%B1%BB%E5%9E%8B-%E5%92%8C-multimap%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">map&lt;关键字类型，值类型&gt;\r\n和 multimap&lt;关键字类型，值类型&gt;</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#set-%E5%92%8C-multiset\"><span class=\"toc-text\">set&lt;元素类型&gt; 和 multiset&lt;元素类型&gt;</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E5%A4%9A%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">更多容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#list\"><span class=\"toc-text\">list&lt;元素类型&gt;</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#stack\"><span class=\"toc-text\">stack&lt;元素类型&gt;</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#queue\"><span class=\"toc-text\">queue&lt;元素类型&gt;</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#deque\"><span class=\"toc-text\">deque&lt;元素类型&gt;</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#priority_queue\"><span class=\"toc-text\">priority_queue&lt;元素类型&gt;</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#basic_string\"><span class=\"toc-text\">basic_string&lt;字符类型&gt;</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">容器的基本操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%BE%8B%E5%88%A9%E7%94%A8map%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%B5%E8%AF%9D%E7%B0%BF\"><span class=\"toc-text\">举例：利用map实现一个简单的电话簿</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%96%B0%E6%A0%87%E5%87%86\"><span class=\"toc-text\">关于新标准</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#auto\"><span class=\"toc-text\">auto</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">迭代器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#range-based-fors\"><span class=\"toc-text\">range-based fors</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC\"><span class=\"toc-text\">左值，右值？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E5%8A%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%9B%B4%E5%A4%9A\"><span class=\"toc-text\">移动、右值引用以及更多：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E6%B2%A1%E6%9C%89%E6%B3%A8%E6%84%8F%E8%BF%87%E7%9A%84%E4%B8%9C%E8%A5%BF\"><span class=\"toc-text\">一些没有注意过的东西</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"BitMap","uid":"6da2c62358c2aa6af38a7a4dc00803c1","slug":"Algorithm/Bitmap","date":"2023-11-12T13:33:38.000Z","updated":"2023-11-12T13:39:11.581Z","comments":true,"path":"api/articles/Algorithm/Bitmap.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"BitMap ","link":"","photos":[],"count_time":{"symbolsCount":8,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"定制一个SRP管线 Step 1","uid":"5d88bbec78b43b21461c0aea1be3a295","slug":"Rendering/SRP/SRP1","date":"2023-11-10T12:42:16.000Z","updated":"2023-11-09T12:53:08.577Z","comments":true,"path":"api/articles/Rendering/SRP/SRP1.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"定制一个SRP管线 Step 1 Reference Unity的URP HDRP等SRP管线详解（包含源码分析） - 知乎 (zhihu.com) 从零开始的SRP - 知乎 (zhihu.com) Unity SRP 实战（一）延迟渲染与 PBR - 知乎 (zhihu.co...","link":"","photos":[],"count_time":{"symbolsCount":155,"symbolsTime":"1 mins."},"categories":[{"name":"Unity","slug":"Unity","count":21,"path":"api/categories/Unity.json"},{"name":"SRP","slug":"Unity/SRP","count":2,"path":"api/categories/Unity/SRP.json"}],"tags":[{"name":"Unity","slug":"Unity","count":22,"path":"api/tags/Unity.json"},{"name":"SRP","slug":"SRP","count":2,"path":"api/tags/SRP.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}