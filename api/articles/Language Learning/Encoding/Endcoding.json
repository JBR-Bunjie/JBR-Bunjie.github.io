{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Encoding/Endcoding","date":"2023-03-07T16:14:45.286Z","updated":"2022-02-08T04:37:00.000Z","comments":true,"path":"api/articles/Language Learning/Encoding/Endcoding.json","keywords":null,"cover":null,"content":"<h2 id=\"ASCII码\"><a href=\"#ASCII码\" class=\"headerlink\" title=\"ASCII码\"></a>ASCII码</h2><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位是一个bit，有0和1两种状态。8个bit构成一个字节，也就是byte。这就是bit和byte的区别。</p>\n<p>存储的单位一般是字节byte，比如说到一个文件大小是2k，是说这个文件占用了2048个byte；一个内存条的容量为256M，说明该内存可以存储256<em>1024</em>1024个byte。</p>\n<p>网络传输的单位一般是比特bit，我们平常说到网络下行带宽1M，是说此网络在最好的情况下可以同时下载速度是每秒1024*1024个bit，换算成字节的话就是128k/s。</p>\n<p>而若利用0和1各代表一个状态，由于一个byte有8个bit，故总共可以表示2的8次方＝256个状态。若是每个状态对应一个符号，一个byte可以表示256个符号，也就是从0000000到11111111。</p>\n<p>根据这个思路，美国在上个世纪60年代制定了一套字符编码，用于安排控制字符、英语字符、数字等符号与二进制位之间对应的关系，形成了大名鼎鼎的ASCII码。</p>\n<p>但ASCII码一共只规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，而由于使用了8位二进制，故规定最前面的第一位二进制数则为0。</p>\n<h3 id=\"ASCII实现思路\"><a href=\"#ASCII实现思路\" class=\"headerlink\" title=\"ASCII实现思路\"></a>ASCII实现思路</h3><ul>\n<li>所有的控制字符(比如CR回车、DEL删除等)编码在0-31范围以及127中。</li>\n<li>把所有的标点符号，英文大小写全部放在32-126范围中。</li>\n</ul>\n<h3 id=\"ASCII实现形式\"><a href=\"#ASCII实现形式\" class=\"headerlink\" title=\"ASCII实现形式\"></a>ASCII实现形式</h3><ul>\n<li>0xxxx xxxx</li>\n</ul>\n<h2 id=\"GB2312-amp-GBK\"><a href=\"#GB2312-amp-GBK\" class=\"headerlink\" title=\"GB2312&amp;GBK\"></a>GB2312&amp;GBK</h2><h3 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。</p>\n<p>以中文为例，汉字有10万左右，即使是常用字也有六七千，必须得用多个字节来表示。</p>\n<p>最先诞生的是GB2312编码。其编码结构不用特别了解清楚，感兴趣的可以去网上搜索专门的文档。我们只需要明白以下两点：</p>\n<ul>\n<li><p>该编码可以表示大概7000左右个字符。其中有中文及一些常见的拉丁字母等。基本可以覆盖我们日常打字使用。</p>\n</li>\n<li><p>该编码完全兼容ASCII码，计算机去读的时候首先判断最高位，如果是0，那么这个字符只占用一个字节，表示的内容跟ASCII码表示的一样。如果该字符最高位是1，那么该字节连同下一个字节表示一个中文汉字。所以平常咱们常说的英文一个字节，中文两个字节其实是从这里来的。</p>\n</li>\n</ul>\n<h3 id=\"GB2312实现形式\"><a href=\"#GB2312实现形式\" class=\"headerlink\" title=\"GB2312实现形式\"></a>GB2312实现形式</h3><ul>\n<li>0xxxxxxx：表示为ASCII字符</li>\n<li>1xxxxxxx 1xxxxxxx：表示为汉字</li>\n</ul>\n<h3 id=\"后来？\"><a href=\"#后来？\" class=\"headerlink\" title=\"后来？\"></a>后来？</h3><p>两个字节最多可以表示的字符数是 2^16＝65536，如果要求首位必须是1，那么最多可以表示 32768 个字符，但是GB2312 只用了其中的7000左右的字符。这显然是没有做到物尽其用，而且如果有些特殊的中文，GB2312根本表示不了。所以GBK就应运而生了。</p>\n<p>GBK 就尽量将能用到的状态都表示成中文字符了，当然最终还是有些状态没办法用（具体可以自行查找文档），最终可以表示23940个字符，其中有21003是汉字。</p>\n<p>GBK是完全兼容GB2312的，所以GBK的应用是很广泛的，而且从Windows95开始，Windows的中文版默认中文支持就是GBK编码。你可以通过在cmd下输入<code>chcp</code>命令来查看你当前系统的默认编码</p>\n<h3 id=\"GBK实现形式：\"><a href=\"#GBK实现形式：\" class=\"headerlink\" title=\"GBK实现形式：\"></a>GBK实现形式：</h3><ul>\n<li>0xxxxxxx：表示为ASCII字符</li>\n<li>1xxxxxxx xxxxxxxx：表示为汉字</li>\n</ul>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><p>GBK基本解决了中文编码问题，但另外一个大问题随之而来，那就是国际化。</p>\n<p>从我们的视角看，我们按照这种方式来表示简体中文和英文，成了是成了，可是繁体中文怎么表示？日文又怎么表示？</p>\n<p>而又从他们的视角看，当然他们也利用最高位来做文章，发明了big5（台湾繁体），JIS（日文）等兼容ASCII码的编码格式，但是这几种编码之间是并不兼容的。一段GBK编码的文件在台湾友人的电脑里打开就是乱码了。</p>\n<p>这时候，Unicode就诞生了。</p>\n<p><a href=\"https://home.unicode.org/\">Unicode – The World Standard for Text and Emoji</a></p>\n<p>完全弄明白Unicode的细节是非常困难的，我们也是明白以下几点就够了：</p>\n<ol>\n<li><p>Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>\n</li>\n<li><p>Unicode 编码是给世界上所有的符号都分配了一个码。GBK最多也只能表示3万多的汉字，康熙字典里面的大部分汉字都没法用GBK表示，但是Unicode就能，它<del>(大概)</del>可以表示这个星球上所有的符号。</p>\n</li>\n<li><p>Unicode有UCS-2和UCS-4两种编码，2和4都是代表字节的意思，也就是说前者用两个字节表示，后者用4个字节表示。所以，UCS-2的表示范围是65536个字符，而UCS-4则可以表示超过22亿个字符，我想这真的是可以表示所有的字符了。其实日常使用我们用的只是UCS-2，一般说的Unicode编码也是只它。它包含了所有的简体中文，现用的繁体中文，火星文，以及其他国家的现用文字。古籍中的文字就得去UCS-4中去找了。</p>\n</li>\n</ol>\n<p>值得注意的是：Unicode中，中文的编码范围为4E00-9FCF，其中9FC4-9FCF之间的区间没有使用。</p>\n<p>一个比较突出的问题就是这个区间全部都是文字，而中文标点没有包含在其中，反而散落在各个位置。同时，一些特殊的文字和中文部首以及一些特殊符号也不在此范围内，需要特别注意。</p>\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><h3 id=\"说明-2\"><a href=\"#说明-2\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>很遗憾，Unicode并不是完美的。不完美的地方主要有两点：</p>\n<p>1）不兼容ASCII码。因为Unicode是用两个字节表示，ASCII码范围内的字符都被扩充成了两个字节，前面又补了8个0。所以，如果你的电脑只支持Unicode编码的话，所有的英文资料全都没法阅读了。</p>\n<p>2）占用的存储变大，如果涉及到传输，所耗费的流量也会变大。中文文本还好，英文就相当明显。纯英文文本所消耗的存储比以前增大了一倍。</p>\n<p>这个时候就出现了诸如UTF-8等实现方式。这里我们只讨论UTF-8，因为它是使用最广泛的。它弥补了Unicode的缺陷，同时主要有以下几个优点。</p>\n<ol>\n<li><p>UTF-8与Unicode是一一对应的。所以UTF-8是国际化的编码方式。</p>\n</li>\n<li><p>UTF-8是针对Unicode的可变长度字符编码，最短一个字节，最长3个字节，1个字节表示的就是ASCII码，所以UTF-8是完全兼容ASCII码的。</p>\n</li>\n<li><p>正是因为UTF-8的变长实现，解决了Unicode的存储多的问题。可能有朋友要问了，UTF-8最多需要用3个字节表示，而Unicode只需要两个，怎么能说UFT-8会省存储呢？因为目前英文是最通用的语言，大部分字符都是ASCII码。</p>\n</li>\n</ol>\n<p>但UTF-8并不是一点缺点也没有，因为变长表示，所以一段UTF-8编码没法一下子算出有多少个字符。而这一点能力对于以上几种编码格式来说是轻而易举的。所以当今世界上没有最完美的字符编码，只有最合适某个场景的编码。</p>\n<h3 id=\"UTF-8具体实现\"><a href=\"#UTF-8具体实现\" class=\"headerlink\" title=\"UTF-8具体实现\"></a>UTF-8具体实现</h3><table>\n<thead>\n<tr>\n<th>范围</th>\n<th>字节数</th>\n<th>存储格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x0000~0x007F (0 ~ 127)</td>\n<td>1字节</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0x0080~0x07FF(128 ~ 2047)</td>\n<td>2字节</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0x0800~FFFF(2048 ~ 65535)</td>\n<td>3字节</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0x10000~1FFFFFF(65536 ~ 2097152)</td>\n<td>4字节</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0x2000000~0x3FFFFFF</td>\n<td>5字节</td>\n<td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0x4000000~0x7FFFFFFF)</td>\n<td>6字节</td>\n<td>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<h2 id=\"番外：多字节编码的一些概念\"><a href=\"#番外：多字节编码的一些概念\" class=\"headerlink\" title=\"番外：多字节编码的一些概念\"></a>番外：多字节编码的一些概念</h2><h3 id=\"大尾-big-endian-和小尾-little-endian\"><a href=\"#大尾-big-endian-和小尾-little-endian\" class=\"headerlink\" title=\"大尾(big endian)和小尾(little endian)\"></a>大尾(big endian)和小尾(little endian)</h3><p>大尾和小尾是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。</p>\n<h3 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h3><p>UTF-8以字节为编码单元，故没有字节序的问题。而UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？</p>\n<p>Unicode规范中推荐的标记字节顺序的方法是BOM，即Byte Order Mark。BOM是一个有点小聪明的想法：</p>\n<p>在UCS编码中有一个叫做<code>&quot;ZERO WIDTH NO-BREAK SPACE&quot;</code>的字符，它的编码是<code>FEFF</code>。而<code>FFFE</code>在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符<code>&quot;ZERO WIDTH NO-BREAK SPACE&quot;</code>。这样如果接收者收到<code>FEFF</code>，就表明这个字节流是Big-Endian的；如果收到<code>FFFE</code>，就表明这个字节流是Little-Endian的。因此字符<code>&quot;ZERO WIDTH NO-BREAK SPACE&quot;</code>又被称作BOM。</p>\n<p>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符<code>&quot;ZERO WIDTH NO-BREAK SPACE&quot;</code>的UTF-8编码是<code>EF BB BF</code>（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以<code>EF BB BF</code>开头的字节流，就知道这是UTF-8编码了。</p>\n<p>不过话又说回来：理论上说，UTF-8并没有大小尾的困扰，所以并不需要BOM。但是一些Windows应用会指定大小尾，比如Notepad，而且Excel在没有指定BOM的UTF-8文件进行读取时会使用Windows的codepage，从而出现错误。 </p>\n","text":"ASCII码说明在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位是一个bit，有0和1两种状态。8个bit构成一个字节，也就是byte。这就是bit和byte的区别。 存储的单位一般是字节byte，比如说到一个文件大小是2k，是说这个文件占用了2048个by...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ASCII%E7%A0%81\"><span class=\"toc-text\">ASCII码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ASCII%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">ASCII实现思路</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ASCII%E5%AE%9E%E7%8E%B0%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">ASCII实现形式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GB2312-amp-GBK\"><span class=\"toc-text\">GB2312&amp;GBK</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E-1\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GB2312%E5%AE%9E%E7%8E%B0%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">GB2312实现形式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8E%E6%9D%A5%EF%BC%9F\"><span class=\"toc-text\">后来？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GBK%E5%AE%9E%E7%8E%B0%E5%BD%A2%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">GBK实现形式：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Unicode\"><span class=\"toc-text\">Unicode</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UTF-8\"><span class=\"toc-text\">UTF-8</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E-2\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#UTF-8%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">UTF-8具体实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%95%AA%E5%A4%96%EF%BC%9A%E5%A4%9A%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">番外：多字节编码的一些概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E5%B0%BE-big-endian-%E5%92%8C%E5%B0%8F%E5%B0%BE-little-endian\"><span class=\"toc-text\">大尾(big endian)和小尾(little endian)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BOM\"><span class=\"toc-text\">BOM</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Encoding/编码学习","date":"2023-03-07T16:14:45.292Z","updated":"2022-04-02T13:06:43.000Z","comments":true,"path":"api/articles/Language Learning/Encoding/编码学习.json","keywords":null,"cover":[],"text":"计算机编码介绍二进制记法：原码，反码，补码 第一阶段：ASCII ASCII：美国信息交换标准代码（American Standard Code for Information Interchange） 可以访问：ASCII Code - The extended ASCII t...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/CSS/RWD Design","date":"2023-03-07T16:14:45.277Z","updated":"2022-04-06T02:38:40.000Z","comments":true,"path":"api/articles/Language Learning/CSS/RWD Design.json","keywords":null,"cover":null,"text":"RWD: Responsive Web DesignIntro:Reference: Responsive Web Design Introduction (w3schools.com) Viewport - 术语表 | MDN (mozilla.org) Viewport:Wh...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}