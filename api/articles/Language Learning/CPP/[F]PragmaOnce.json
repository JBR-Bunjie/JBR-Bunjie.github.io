{"title":"Cpp `#pragma Once` and `#ifndef`","uid":"9804ef7a4cf22f333e494cd94f29c482","slug":"Language Learning/CPP/[F]PragmaOnce","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:37:46.943Z","comments":true,"path":"api/articles/Language Learning/CPP/[F]PragmaOnce.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"source\">Source</h1>\r\n<ul>\r\n<li><p>在 C++ 中防止头文件被重复包含时为什么同时使用 #ifndef 和 #pragma\r\nonce？ - 望山的回答 - 知乎\r\nhttps://www.zhihu.com/question/40990594/answer/1675549910</p></li>\r\n<li><p><a href=\"https://zh.m.wikipedia.org/zh-hans/Pragma_once\">#pragma\r\nonce - 维基百科，自由的百科全书 (wikipedia.org)</a></p></li>\r\n</ul>\r\n<h1 id=\"结论\">结论：</h1>\r\n<p>请同时使用<code>#ifdef</code>与<code>#pragma once</code></p>\r\n<p>解释：如果所用的编译器支持<code>#pragma once</code>，则可以加快我们的编译速度；如果不支持，也会有<code>#ifdef</code>语句来兜底</p>\r\n<blockquote>\r\n<p>使用<code>#pragma once</code>代替include防范将加快编译速度，因为这是一种高阶的机制；<a\r\nhref=\"https://zh.m.wikipedia.org/wiki/編譯器\">编译器</a>会自动比对档案名称或<a\r\nhref=\"https://zh.m.wikipedia.org/wiki/Inode\">inode</a>而不需要在<a\r\nhref=\"https://zh.m.wikipedia.org/wiki/標頭檔\">标头档</a>去判断<code>#ifndef</code>和<code>#endif</code>。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>使用#ifndef的话，缺点不单单是需要多写两行代码和想出一个合适的#define名字，更大的缺点是它要求编译器一直扫描到文件尾，找到对应的#endif，才能确定你的意图是整个头文件都要略过。然而这时候已经花费了许多CPU时间（和电能），前面做的那么多都是白忙。</p>\r\n</blockquote>\r\n","text":"Source 在 C++ 中防止头文件被重复包含时为什么同时使用 #ifndef 和 #pragma once？ - 望山的回答 - 知乎 https://www.zhihu.com/question/40990594/answer/1675549910 #pragma once...","link":"","photos":[],"count_time":{"symbolsCount":506,"symbolsTime":"1 mins."},"categories":[{"name":"Coding Language","slug":"Coding-Language","count":4,"path":"api/categories/Coding-Language.json"}],"tags":[{"name":"CPP","slug":"CPP","count":1,"path":"api/tags/CPP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#source\"><span class=\"toc-text\">Source</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">结论：</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"R&K Algorithm","uid":"3300e6e8edea21eb33ad89b2150bf9cc","slug":"Algorithm/String Processing/KR&RK","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:10:37.847Z","comments":true,"path":"api/articles/Algorithm/String Processing/KR&RK.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Rabin–Karp algorithm - 拉宾-卡普算法 拉宾-卡普算法（英語：Rabin–Karp algorithm）或卡普-拉宾算法（Karp–Rabin algorithm） General Rabin-Karp 算法是由 Richard M. Karp和 Micha...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"String Processing","slug":"String-Processing","count":7,"path":"api/tags/String-Processing.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Encoding Methods","uid":"b7afcba22e06e2e680735e918e5fcad8","slug":"Language Learning/Encoding/Endcoding","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T02:06:24.429Z","comments":true,"path":"api/articles/Language Learning/Encoding/Endcoding.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"计算机编码梳理 ASCII码 描述 这是计算机编码发展历程里的第一阶段：ASCII码，即：American Standard Code for Information Interchange，美国信息交换标准代码 设计思路： 在计算机内部存储单元的最小单位时Byte。不过Byte...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"Coding Language","slug":"Coding-Language","count":4,"path":"api/categories/Coding-Language.json"}],"tags":[{"name":"ASCII","slug":"ASCII","count":1,"path":"api/tags/ASCII.json"},{"name":"U","slug":"U","count":1,"path":"api/tags/U.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}