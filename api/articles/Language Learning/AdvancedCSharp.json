{"title":"Advanced CSharp","uid":"36e65544b0ba9be0c7ba1f8cd3f769cc","slug":"Language Learning/AdvancedCSharp","date":"2023-03-19T04:23:23.000Z","updated":"2023-11-01T05:26:39.181Z","comments":true,"path":"api/articles/Language Learning/AdvancedCSharp.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"advanced-csharp\">Advanced CSharp</h1>\r\n<p><a\r\nhref=\"https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,d3599058f8d79be0,references\">Dictionary\r\n(microsoft.com)</a></p>\r\n<p>哈希表、字典、二维数组的区别是什么？ - VTECISBEST的回答 - 知乎\r\nhttps://www.zhihu.com/question/266414962/answer/308222427</p>\r\n<h2 id=\"readonly-const-static\">readonly, const &amp; static</h2>\r\n<h2 id=\"virtual-interface-abstract\">Virtual, Interface &amp;\r\nAbstract</h2>\r\n<h2 id=\"delegate-action-func-event\">Delegate, Action, Func &amp;\r\nEvent</h2>\r\n<h3 id=\"delegate\">Delegate</h3>\r\n<h4 id=\"quick-start\">Quick Start</h4>\r\n<p>用实例快速了解 delegate：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class Program &#123;\n    public delegate void TestDelegate();\n\n    private static void MyTestDelegateFunction() &#123;\n        Console.WriteLine(&quot;My Test&quot;);\n    &#125;\n\n    public static void Main(string[] args) &#123;\n        TestDelegate testDelegateFunction;\n\n        testDelegateFunction &#x3D; MyTestDelegateFunction;\n\n        testDelegateFunction();\n    &#125;\n&#125;</code></pre>\r\n<blockquote>\r\n<p>A <a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types\">delegate</a>\r\nis a type that represents references to methods with a particular\r\nparameter list and return type. When you instantiate a delegate, you can\r\nassociate its instance with any method with a compatible signature and\r\nreturn type. You can invoke (or call) the method through the delegate\r\ninstance.</p>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/\">Delegates\r\n- C# Programming Guide - C# | Microsoft Learn</a></p>\r\n</blockquote>\r\n<h4 id=\"delegates-overview\">Delegates Overview</h4>\r\n<p>Delegates have the following properties:</p>\r\n<ul>\r\n<li><strong>Delegates are similar to C++ function pointers</strong>, but\r\ndelegates are fully object-oriented, and unlike C++ pointers to member\r\nfunctions, delegates encapsulate both an object instance and a\r\nmethod.</li>\r\n<li>Delegates allow methods to be passed as parameters.</li>\r\n<li>Delegates can be used to define callback methods.</li>\r\n<li>Delegates can be chained together; for example, multiple methods can\r\nbe called on a single event.</li>\r\n<li>Methods don't have to match the delegate type exactly. For more\r\ninformation, see <a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates\">Using\r\nVariance in Delegates</a>.</li>\r\n<li>Lambda expressions are a more concise way of writing inline code\r\nblocks. Lambda expressions (in certain contexts) are compiled to\r\ndelegate types. For more information about lambda expressions, see <a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions\">Lambda\r\nexpressions</a>.</li>\r\n</ul>\r\n<p>简单来说，Delegate\r\n即委托，可以用于托管任意数量的、和自己定义了一样参数的函数，事实上，和委托形态最接近的数据结构是——链表。你也许会从这下面的例子中找到结论：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class Program &#123;\n    public delegate void TestDelegate(int a, int b);\n\n    private static void MyTestDelegateFunction1(int i, int t) &#123;\n        Console.WriteLine(i + t);\n    &#125;\n\n    private static void MyTestDelegateFunction2(int x, int y) &#123;\n        Console.WriteLine(x * y);\n    &#125;\n\n    public static void Main(string[] args) &#123;\n        TestDelegate testDelegateFunction;\n\n        testDelegateFunction &#x3D; MyTestDelegateFunction1;\n        &#x2F;&#x2F; TestDelegate testDelegateFunction &#x3D; new TestDelegate(MyTestDelegateFunction1);\n\n        testDelegateFunction +&#x3D; MyTestDelegateFunction2;\n\n        testDelegateFunction(2, 3);\n\n        testDelegateFunction -&#x3D; MyTestDelegateFunction1;\n\n        testDelegateFunction(2, 3);\n    &#125;\n&#125;\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; 5\n&#x2F;&#x2F; 6\n&#x2F;&#x2F; 6</code></pre>\r\n<p>当然，我们也可以改写上面这个例子：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class Program &#123;\n    public delegate void TestDelegate(int a, int b);\n\n    public static void Main(string[] args) &#123;\n        TestDelegate testDelegateFunction &#x3D; (int i, int t) &#x3D;&gt; &#123; Console.WriteLine(i + t); &#125;;\n        testDelegateFunction +&#x3D; (int x, int y) &#x3D;&gt; &#123; Console.WriteLine(x * y); &#125;;\n\n        testDelegateFunction(2, 3);\n    &#125;\n&#125;</code></pre>\r\n<p>但是使用 Lambda 表达的另一个问题是——由于我们没有函数标识，我们无法从\r\ndelegate 中移除对应的函数了！</p>\r\n<h3 id=\"actionfunc\">Action&amp;Func</h3>\r\n<h4 id=\"一些区别\">一些区别</h4>\r\n<p>首先注意的是，我们这样去创建一个 Action：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Action&lt;float&gt; TestAction;</code></pre>\r\n<p>注意和 Delegate 的区别——是的，这里没有返回值</p>\r\n<p>让我们转向 Func：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Func&lt;bool&gt; TestFunc;</code></pre>\r\n<p>简直是和 Action 如出一辙！那这两者的功能各自又是什么？</p>\r\n<h4 id=\"使用\">使用</h4>\r\n<p>让我们依然使用实例来了解具体细节：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class Program &#123;\n    public static void Main(string[] args) &#123;\n        Action&lt;float, float&gt; testAction;\n        Func&lt;bool&gt; testFunc;\n\n        testAction &#x3D; (float a, float b) &#x3D;&gt; &#123; Console.WriteLine(a * b); &#125;;\n        testFunc &#x3D; () &#x3D;&gt; &#123; return false; &#125;;\n\n        testAction(3, 4);\n        Console.WriteLine(testFunc());\n    &#125;\n&#125;</code></pre>\r\n<p>你可能已经猜到了：Action 是只接受输入的函数委托，Func\r\n则是以输出为主的函数委托。</p>\r\n<p>欸？为什么是“为主”？让我们借用一下这两张图：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic1.zhimg.com/80/v2-7513645d0b2a6d143b0da2f5d7288274_1440w.webp\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"https://pic2.zhimg.com/80/v2-eef6f55eca4cc70575cae8e12f2c5f49_1440w.webp\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>Action: <a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/api/system.action?view=net-7.0\">Action\r\nDelegate (System) | Microsoft Learn</a></p>\r\n<p>Func: <a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/api/system.func-1?view=net-7.0\">Func\r\nDelegate (System) | Microsoft Learn</a></p>\r\n</blockquote>\r\n<h4 id=\"为什么需要-actionfunc\">为什么需要 Action&amp;Func？</h4>\r\n<p>当我们使用 Delegate\r\n时，我们一共做了两部：先显式定义委托本身，然后再用委托实例去完成过程，但是当使用\r\nAction&amp;Func 时，我们的代码结构就可以得到省略：</p>\r\n<pre class=\"line-numbers language-C#\" data-language=\"C#\"><code class=\"language-C#\">&#x2F;&#x2F; From：\npublic class Program &#123;\n    public delegate int explicitDelegate(int a, int b);\n\n    public static void Main(string[] args) &#123;\n        explicitDelegate a &#x3D; (int i, int t) &#x3D;&gt; &#123; return i * t; &#125;;\n        Console.WriteLine(a(3, 4));\n    &#125;\n&#125;\n\n&#x2F;&#x2F; To：\npublic class Program &#123;\n    public static void Main(string[] args) &#123;\n        Func&lt;int, int, int&gt; a &#x3D; (int i, int t) &#x3D;&gt; &#123; return i * t; &#125;;\n        Console.WriteLine(a(3, 4));\n    &#125;\n&#125;</code></pre>\r\n<h4 id=\"什么时候会用到委托\">什么时候会用到委托？</h4>\r\n<p>让我们看向这样一个例子：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using UnityEngine;\n\npublic class ActionOnTimer : MonoBehaviour&#123;\n    private float timer;\n\n    public void SetTimer(float timer) &#123;\n        this.timer &#x3D; timer;\n    &#125;\n\n    private void Update() &#123;\n        timer -&#x3D; Time.deltaTime;\n    &#125;\n\n    public bool IsTimerComplete() &#123;\n        return timer &lt;&#x3D; Of;\n    &#125;\n&#125;</code></pre>\r\n<p>可以看到，这是一个计时器，timer 是我们的定时。如果我们希望 1s\r\n后做点什么？</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using UnityEngine;\n\npublic class Testing : MonoBehaviour&#123;\n    [SerializeField] private ActionOnTimer actionOnTimer;\n    private bool hasTimerElapsed;\n\n    private void start() &#123;\n        actionOnTimer.SetTimer(1f);\n    &#125;\n\n    private void Update() &#123;\n        if (!hasTimerElapsed &amp;&amp; actionOnTimer.IsTimerComplete()) &#123;\n            Debug.Log(&quot;Timer complete!&quot;);\n            hasTimerElapsed &#x3D; true;\n        &#125;\n    &#125;\n&#125;</code></pre>\r\n<p>好，好。我们已经在 1s\r\n后做了点事，不过我们的实现确实称不上好...我们将太多的逻辑延申了出来——如果\r\nActionOnTimer 可以更紧凑就好了。</p>\r\n<p>让我们用 delegate 来改造原始的 ActionOnTimer：</p>\r\n<pre class=\"line-numbers language-C#\" data-language=\"C#\"><code class=\"language-C#\">using UnityEngine;\n\npublic class ActionOnTimer : MonoBehaviour&#123;\n    private Action timeCallback;\n    private float timer;\n\n    public void SetTimer(float timer, Action timeCallback) &#123;\n        this.timeCallback &#x3D; timeCallback;\n        this.timer &#x3D; timer;\n    &#125;\n\n    private void Update() &#123;\n        if (timer &gt; 0f) &#123;\n            timer -&#x3D; Time.deltaTime;\n\n            if (IsTimerComplete()) timerCallback();\n        &#125;\n    &#125;\n\n    public bool IsTimerComplete() &#123;\n        return timer &lt;&#x3D; Of;\n    &#125;\n&#125;</code></pre>\r\n<p>那现在？现在我们的调用就可以相当紧凑了：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using UnityEngine;\n\npublic class Testing : MonoBehaviour&#123;\n    [SerializeField] private ActionOnTimer actionOnTimer;\n    private void start() &#123;\n        actionOnTimer.SetTimer(1f, () &#x3D;&gt; &#123; Debug.Log(&quot;Timer Complete&quot;); &#125;);\n    &#125;\n&#125;</code></pre>\r\n<p>是不是很简单？</p>\r\n<p>特别的，我在这里列举了一些我们在委托中需要注意的事情：</p>\r\n<ul>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/291277405\">多播委托的坑 - 知乎\r\n(zhihu.com)</a></li>\r\n</ul>\r\n<p>另外需要提到的一点是，Unity 里存在一个\r\nUnityAction，你也许会好奇这是什么：</p>\r\n<blockquote>\r\n<p>Actually <code>UnityAction&lt;T&gt;</code> and\r\n<code>System.Action&lt;T&gt;</code> are both the same generic delegate\r\ndeclarations, just seperate reimplementations. AFAIK UnityEvents used\r\nSystem.Actions in the past and just recently switched to their own\r\nversion. Both are not really serializable since they are just plain C#\r\ndelegate which are generally hard up to implossible to serialize. So the\r\nexact reason why they shipped their own version is kinda unclear. For me\r\nthe most sound explanation would be the independence from the System\r\nnamespace / mscorlib implementation. Though that's just speculation.</p>\r\n<p>Be warned that even though both generic delegate are implemented\r\nexactly the same, doesn't make them compatible to each other out of the\r\nbox. A cast should be possible though.</p>\r\n<p><a\r\nhref=\"https://forum.unity.com/threads/whats-the-difference-between-unityaction-and-c-actions.1041184/\">What's\r\nthe difference between UnityAction and C# Actions? - Unity Forum</a></p>\r\n</blockquote>\r\n<p>具体采用则可以参考：<a\r\nhref=\"https://stackoverflow.com/questions/44734580/why-choose-unityevent-over-native-c-sharp-events\">Why\r\nchoose UnityEvent over native C# events? - Stack Overflow</a></p>\r\n<h3 id=\"event\">Event</h3>\r\n<p>那让我们继续，下面是 Event——一种特殊的委托</p>\r\n<blockquote>\r\n<p>Events enable a <a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class\">class</a>\r\nor object to notify other classes or objects when something of interest\r\noccurs. The class that sends (or <em>raises</em>) the event is called\r\nthe <em>publisher</em> and the classes that receive (or <em>handle</em>)\r\nthe event are called <em>subscribers</em>.</p>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/\">Events\r\n- C# Programming Guide - C# | Microsoft Learn</a></p>\r\n</blockquote>\r\n<p>也就是说，Event 下鲜明地存在两种角色：Publishers 和\r\nSubscribers，并且这是一个一对多的关系：由 Publishers 发出事件并且由\r\nSubscribers 接收。有没有想起什么？对，这看上去就和观察者模式很像！</p>\r\n<blockquote>\r\n<p>随便打开电脑中的一个应用，很有可能它就使用了<a\r\nhref=\"http://en.wikipedia.org/wiki/Model–view–controller\">MVC 架构</a>，\r\n而究其根本，是因为观察者模式。 观察者模式应用广泛，Java\r\n甚至将其放到了核心库之中（<a\r\nhref=\"http://docs.oracle.com/javase/7/docs/api/java/util/Observer.html\"><code>java.util.Observer</code></a>），而\r\nC#直接将其嵌入了<em>语法</em>（<a\r\nhref=\"http://msdn.microsoft.com/en-us/library/8627sbea.aspx\"><code>event</code></a>关键字）。</p>\r\n<p><a href=\"https://gpp.tkchu.me/observer.html\">观察者模式 · Design\r\nPatterns Revisited · 游戏设计模式 (tkchu.me)</a></p>\r\n</blockquote>\r\n<p>但是我们这里是 event 的 part，所以让我们回到 event\r\n本身上来——还是看看代码吧：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\nnamespace SimpleEvent &#123;\n  &#x2F;***********发布器类***********&#x2F;\n  public class EventTest &#123;\n    private int value;\n\n    public delegate void NumManipulationHandler();\n    public event NumManipulationHandler ChangeNum;\n\n    protected virtual void OnNumChanged() &#123;\n      if ( ChangeNum !&#x3D; null ) &#123;\n        ChangeNum(); &#x2F;* 事件被触发 *&#x2F;\n      &#125; else &#123;\n        Console.WriteLine( &quot;event not fire&quot; );\n        Console.ReadKey(); &#x2F;* 回车继续 *&#x2F;\n      &#125;\n    &#125;\n\n    public EventTest() &#123;\n      int n &#x3D; 5;\n      SetValue( n );\n    &#125;\n\n    public void SetValue( int n ) &#123;\n      if ( value !&#x3D; n ) &#123;\n        value &#x3D; n;\n        OnNumChanged();\n      &#125;\n    &#125;\n  &#125;\n\n  &#x2F;***********订阅器类***********&#x2F;\n  public class subscribEvent &#123;\n    public void printf() &#123;\n      Console.WriteLine( &quot;event fire&quot; );\n      Console.ReadKey(); &#x2F;* 回车继续 *&#x2F;\n    &#125;\n  &#125;\n\n  &#x2F;***********触发***********&#x2F;\n  public class MainClass &#123;\n    public static void Main() &#123;\n      EventTest e &#x3D; new EventTest(); &#x2F;* 实例化Publisher对象 *&#x2F;\n      subscribEvent v &#x3D; new subscribEvent(); &#x2F;* 实例化Subscriber对象 *&#x2F;\n      e.ChangeNum +&#x3D; new EventTest.NumManipulationHandler( v.printf ); &#x2F;* 注册 *&#x2F;\n      e.SetValue( 7 );\n      e.SetValue( 11 );\n    &#125;\n  &#125;\n&#125;</code></pre>\r\n<p>事实上，event 使用流程都大体如下：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://media.licdn.com/dms/image/C5612AQH4GMt0SAL1dQ/article-inline_image-shrink_1000_1488/0/1624221860036?e=1700697600&amp;v=beta&amp;t=z3qXv19g7LDe7pToTPJCSgeBS6WvvZs3uhwa0YN09Vg\"\r\nalt=\"No alt text provided for this image\" />\r\n<figcaption aria-hidden=\"true\">No alt text provided for this\r\nimage</figcaption>\r\n</figure>\r\n<p>可以发现，event 是对 delegate\r\n的一层额外包装，它在执行上看仍然可以看作是一个 delegate，发挥着 delegate\r\n的功能。那为什么我们还需要 event？</p>\r\n<ul>\r\n<li><a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/csharp/distinguish-delegates-events\">Delegates\r\nvs. events - C# | Microsoft Learn</a></li>\r\n</ul>\r\n<p>另外，这里是存在一些预制的 delegate 的，比如我们将用到的\r\neventHandler</p>\r\n<blockquote>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public delegate void EventHandler(object? sender, EventArgs e);</code></pre>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/api/system.eventhandler?view=net-7.0\">EventHandler\r\nDelegate (System) | Microsoft Learn</a></p>\r\n</blockquote>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F; Publishers\nusing System;\nusing UnityEngine;\n\npublic class TestingEvents : MonoBehaviour &#123;\n    public event EventHandler OnSpacePressed;\n\n    private void Update() &#123;\n        if (Input.GetKeyDown(KeyCode.Space)) &#123;\n            OnSpacePressed?.Invoke(this, EventArgs.Empty);\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Subscribers\nusing System;\nusing UnityEngine;\n\npublic class TestingEventSubscriber : MonoBehaviour &#123;\n    private void Start() &#123;\n        TestingEvents testingEvents &#x3D; GetComponent&lt;TestingEvents&gt;();\n        testingEvents.OnSpacePressed +&#x3D; TestingEvents_OnSpacePressed;\n    &#125;\n\n    &#x2F;&#x2F; We should match the signature of target event\n    private void TestingEvents_OnSpacePressed(object sender, EventArgs e) &#123;\n        Debug.Log(&quot;Space!&quot;);\n    &#125;\n&#125;</code></pre>\r\n<p>另外需要介绍的是 EventHandler 支持的泛型：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F; Publishers\nusing System;\nusing UnityEngine;\n\npublic class TestingEvents : MonoBehaviour &#123;\n    public event EventHandler&lt;OnSpacePressedEventArgs&gt; OnSpacePressed;\n\n    public class OnSpacePressedEventArgs : EventArgs &#123;\n        public int pressedCount;\n    &#125;\n\n    private int pressedCount;\n\n    private void Update() &#123;\n        if (Input.GetKeyDown(KeyCode.Space)) &#123;\n            pressedCount++;\n            OnspacePressed?.Invoke(this, new OnSpacePressedEventArgs&#123; pressedCount &#x3D; pressedCount &#125;);\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Subscribers\nusing System;\nusing UnityEngine;\n\npublic class TestingEventSubscriber : MonoBehaviour &#123;\n    private void Start() &#123;\n        TestingEvents testingEvents &#x3D; GetComponent&lt;TestingEvents&gt;();\n        testingEvents.OnSpacePressed +&#x3D; TestingEvents_OnSpacePressed;\n    &#125;\n\n    &#x2F;&#x2F; We should match the signature of target event\n    private void TestingEvents_OnSpacePressed(object sender, TestingEvents.OnSpacePressedEventArgs e) &#123;\n        Debug.Log(&quot;Space!&quot; + e.pressedCount);\n    &#125;\n&#125;</code></pre>\r\n<blockquote>\r\n<p>The EventHandler&lt;TEventArgs&gt; delegate is a predefined delegate\r\nthat represents an event handler method for an event that generates\r\ndata. The advantage of using EventHandler&lt;TEventArgs&gt; is that you\r\ndo not need to code your own custom delegate if your event generates\r\nevent data. You simply provide the type of the event data object as the\r\ngeneric parameter.</p>\r\n</blockquote>\r\n<h3 id=\"小结\">小结</h3>\r\n<p>就让我们这样归类这三者吧：</p>\r\n<ul>\r\n<li>Delegate：链表形式的、面向对象的函数指针。接收一致参数的函数委托，并同时执行所有受委托的函数输出结果。同时，Delegate\r\n是既接收输入，又能完成输出的类型。</li>\r\n<li>Action&amp;Func：对 Delegate\r\n在不同方面的“简化”，能让代码逻辑更加清晰。</li>\r\n<li>Event：观察者模式的直接实现，Delegate 的特化</li>\r\n</ul>\r\n<h2 id=\"attribute-与-reflection\">Attribute 与 Reflection</h2>\r\n<h3 id=\"元数据\">元数据</h3>\r\n<p>有关程序及其类型的数据被称为<strong>元数据（metadata）</strong>，它们保存在程序的程序集中。可以这样来形象了解元数据：</p>\r\n<blockquote>\r\n<p>我们先假装 C#没有反射吧！我现在要你在 C#上实现一个函数。函数参数是\r\nObject，函数的功能就是执行这个类内所有参数为空的公有成员方法。好了，你写吧！</p>\r\n<p>...</p>\r\n<p>...</p>\r\n<p>\"这怎么可能写的出来啊！！运行时获取类里面的所有成员方法！类里有啥成员方法只有编译器和写类的程序员才知道吧！！\"</p>\r\n<p>没错...那么如果允许你，在类里加点东西，来实现这个功能呢？</p>\r\n<p>那好像就简单了...</p>\r\n<p>我们可以这样:</p>\r\n<ol type=\"1\">\r\n<li>把 C#这个函数的参数限定一下，参数类型改为 MyObject</li>\r\n<li>写一个 class MyObject，让所有类都继承自 class MyObject;MyObject\r\n内只实现一个方法:public FuncData[] getFuncData();</li>\r\n<li>声明 struct FuncData;FuncData\r\n里就几个属性:返回值类型、函数名称、参数列表(参数类型、名称)</li>\r\n<li>给每个类都手写一个 FuncData 的表</li>\r\n</ol>\r\n<p>4\r\n实现起来好像很麻烦，又臭又长又机械...但是到此为止，你基本上就是实现了一个很简单的反射功能了...</p>\r\n<p>好了，然后聪明的你应该就知道了，C#默认就实现了以上功能，也就是说\r\nC#编译器默认就会帮你写好这个 FuncData——和\r\nPropData(类内所有属性的数据表)，他们被合称为 MetaData，元数据。</p>\r\n<p>C#反射呢，就是基于 MetaData\r\n实现的，一个能让代码在执行的时候，知道代码(类)们的属性的一个功能。</p>\r\n<p>https://www.zhihu.com/question/308374020/answer/621704342</p>\r\n<p>另：关于 Type：<a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/api/system.type?view=net-7.0\">Type\r\nClass (System) | Microsoft Learn</a></p>\r\n</blockquote>\r\n<h3 id=\"attribute\">Attribute</h3>\r\n<blockquote>\r\n<p>类 <a\r\nhref=\"https://learn.microsoft.com/zh-cn/dotnet/api/system.attribute?view=net-7.0\">Attribute</a>\r\n将预定义的系统信息或用户定义的自定义信息与目标元素相关联。\r\n目标元素可以是程序集、类、构造函数、委托、枚举、事件、字段、接口、方法、可移植可执行文件模块、参数、属性、返回值、结构或其他属性。</p>\r\n<p>Attribute 提供的信息也称为元数据。\r\n应用程序可以在运行时检查元数据，以控制程序处理数据的方式，或者在运行时之前由外部工具检查元数据，以控制应用程序本身的处理或维护方式。\r\n例如，.NET\r\n预定义并使用属性类型来控制运行时行为，某些编程语言使用属性类型来表示\r\n.NET 通用类型系统不直接支持的语言功能。</p>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/zh-cn/dotnet/api/system.attribute?view=net-7.0\">Attribute\r\n类 (System) | Microsoft Learn</a></p>\r\n</blockquote>\r\n<p>是的，Attribute\r\n是用来添加元数据的，如编译器指令和注释、描述、方法、类等其他信息。.Net\r\n框架提供了两种类型的特性：<em>预定义特性</em>和<em>自定义特性</em>。</p>\r\n<h4 id=\"预定义特性\">预定义特性</h4>\r\n<blockquote>\r\n<p>为了构造自定义特性，我们得先了解一些预定义的</p>\r\n</blockquote>\r\n<p>.Net 框架提供了三种预定义特性：</p>\r\n<ul>\r\n<li>AttributeUsage</li>\r\n<li>Conditional</li>\r\n<li>Obsolete</li>\r\n</ul>\r\n<p>这里列举了两个我们可能会经常见到的：</p>\r\n<h5 id=\"attributeusage\">AttributeUsage</h5>\r\n<p>预定义特性 <code>AttributeUsage</code>\r\n<strong>描述了如何使用一个自定义特性类</strong>。它规定了特性可应用到的项目的类型。</p>\r\n<p>规定该特性的语法如下：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[AttributeUsage(\n   validon,\n   AllowMultiple&#x3D;allowmultiple,\n   Inherited&#x3D;inherited\n)]</code></pre>\r\n<p>其中：</p>\r\n<ul>\r\n<li>参数 validon 规定特性可被放置的语言元素。它是枚举器\r\n<em>AttributeTargets</em> 的值的组合。默认值是\r\n<em>AttributeTargets.All</em>。</li>\r\n<li>参数 <em>allowmultiple</em>（可选的）为该特性的\r\n<em>AllowMultiple</em> 属性（property）提供一个布尔值。如果为\r\ntrue，则该特性是多用的。默认值是 false（单用的）。</li>\r\n<li>参数 <em>inherited</em>（可选的）为该特性的 <em>Inherited</em>\r\n属性（property）提供一个布尔值。如果为\r\ntrue，则该特性可被派生类继承。默认值是 false（不被继承）。</li>\r\n</ul>\r\n<p>我们后方的用例就存在该特性。</p>\r\n<h5 id=\"obsolete\">Obsolete</h5>\r\n<p>这是一个我们经常会见到的特性，它标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为\r\nobsolete（过时的）。</p>\r\n<p>规定该特性的语法如下：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[Obsolete(message, iserror&#x3D;false)]</code></pre>\r\n<p>其中：</p>\r\n<ul>\r\n<li>参数\r\n<em>message</em>，是一个字符串，描述项目为什么过时以及该替代使用什么。</li>\r\n<li>参数 <em>iserror</em>，是一个布尔值。如果该值为\r\ntrue，编译器应把该项目的使用当作一个错误。默认值是\r\nfalse（编译器生成一个警告）。</li>\r\n</ul>\r\n<p>下面的实例演示了该特性：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\npublic class MyClass &#123;\n   [Obsolete(&quot;Don&#39;t use OldMethod, use NewMethod instead&quot;, true)]\n   static void OldMethod() &#123;\n      Console.WriteLine(&quot;It is the old method&quot;);\n   &#125;\n   static void NewMethod() &#123;\n      Console.WriteLine(&quot;It is the new method&quot;);\n   &#125;\n   public static void Main() &#123;\n      OldMethod();\n   &#125;\n&#125;</code></pre>\r\n<p>当尝试编译该程序时，编译器会给出一个错误消息说明：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Don&#39;t use OldMethod, use NewMethod instead</code></pre>\r\n<h4 id=\"自定义特性\">自定义特性</h4>\r\n<blockquote>\r\n<p>在 C# 中，特性是继承自 <code>Attribute</code> 基类的类。</p>\r\n</blockquote>\r\n<p>通过定义继承自 <code>Attribute</code> 基类的新类来创建特性。</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class MySpecialAttribute : Attribute &#123;&#125;</code></pre>\r\n<p>通过上述代码，可在基本代码中的其他位置将 <code>[MySpecial]</code>（或\r\n<code>[MySpecialAttribute]</code>）用作特性。</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[MySpecial]\npublic class SomeOtherClass &#123;&#125;</code></pre>\r\n<p>我们需要继续充实这个自定义特性，才能得到一个真正可用的自定义特性：</p>\r\n<blockquote>\r\n<p>让我们构建一个名为 <em>DeBugInfo</em>\r\n的自定义特性，该特性将存储调试程序获得的信息。它存储下面的信息：</p>\r\n<ul>\r\n<li>bug 的代码编号</li>\r\n<li>辨认该 bug 的开发人员名字</li>\r\n<li>最后一次审查该代码的日期</li>\r\n<li>一个存储了开发人员标记的字符串消息</li>\r\n</ul>\r\n<p>每个特性必须至少有一个构造函数。必需的 <code>定位(positional)</code>\r\n参数应通过构造函数传递。下面的代码演示了 <em>DeBugInfo</em> 类：</p>\r\n</blockquote>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F; 一个自定义特性 BugFix 被赋给类及其成员\n[AttributeUsage(\n    AttributeTargets.Class |\n    AttributeTargets.Constructor |\n    AttributeTargets.Field |\n    AttributeTargets.Method |\n    AttributeTargets.Property,\n    AllowMultiple &#x3D; true)\n]\n\npublic class DeBugInfo : Attribute &#123;\n    private int bugNo;\n    private string developer;\n    private string lastReview;\n    public string message;\n\n    public DeBugInfo(int bg, string dev, string d) &#123;\n        this.bugNo &#x3D; bg;\n        this.developer &#x3D; dev;\n        this.lastReview &#x3D; d;\n    &#125;\n\n    public int BugNo &#123; get &#123; return bugNo; &#125; &#125;\n    public string Developer &#123; get &#123; return developer; &#125; &#125;\n    public string LastReview &#123; get &#123; return lastReview; &#125; &#125;\n    public string Message &#123;\n        get &#123; return message; &#125;\n        set &#123; message &#x3D; value; &#125;\n\t&#125;\n&#125;</code></pre>\r\n<p>还是一样，我们通过把特性放置在紧接着它的目标之前，来应用该特性：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">[DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12&#x2F;8&#x2F;2012&quot;, Message &#x3D; &quot;Return type mismatch&quot;)]\n[DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10&#x2F;10&#x2F;2012&quot;, Message &#x3D; &quot;Unused variable&quot;)]\nclass Rectangle &#123;\n  &#x2F;&#x2F; 成员变量\n  protected double length;\n  protected double width;\n  public Rectangle(double l, double w) &#123;\n      length &#x3D; l;\n      width &#x3D; w;\n  &#125;\n  [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19&#x2F;10&#x2F;2012&quot;, Message &#x3D; &quot;Return type mismatch&quot;)]\n  public double GetArea() &#123;\n      return length * width;\n  &#125;\n  [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19&#x2F;10&#x2F;2012&quot;)]\n  public void Display()&#123;\n      Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);\n      Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);\n      Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());\n  &#125;\n&#125;</code></pre>\r\n<p>可是，我们的特性没有对这段代码产生任何实质性的影响。我们还需要做些什么？</p>\r\n<blockquote>\r\n<p>The fact that you can define custom attributes and place them in your\r\nsource code would be of little value without some way of retrieving that\r\ninformation and acting on it. By using reflection, you can retrieve the\r\ninformation that was defined with custom attributes. The key method is\r\n<code>GetCustomAttributes</code>, which returns an array of objects that\r\nare the run-time equivalents of the source code attributes.</p>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/reflection-and-attributes/accessing-attributes-by-using-reflection\">Access\r\nattributes using reflection - C# | Microsoft Learn</a></p>\r\n</blockquote>\r\n<h3 id=\"reflection\">Reflection</h3>\r\n<blockquote>\r\n<p>反射指程序可以访问、检测和修改它本身状态或行为的一种能力。</p>\r\n</blockquote>\r\n<p>对于一个特性来说，其具体的执行，例如：</p>\r\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">[Author(&quot;P. Ackerman&quot;, Version &#x3D; 1.1)]\nclass SampleClass &#123; &#125;</code></pre>\r\n<p>在概念上等效于以下代码：</p>\r\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">var anonymousAuthorObject &#x3D; new Author(&quot;P. Ackerman&quot;) &#123;\n    Version &#x3D; 1.1\n&#125;;</code></pre>\r\n<p>但是，在为特性查询 <code>SampleClass</code> 之前，代码将不会执行。\r\n而对 <code>SampleClass</code> 调用 <code>GetCustomAttributes</code>\r\n则会导致构造并初始化一个 <code>Author</code> 对象。\r\n如果该类具有其他特性，则将以类似方式构造其他特性对象。 然后\r\n<code>GetCustomAttributes</code> 会以数组形式返回 <code>Author</code>\r\n对象和任何其他特性对象。\r\n之后你便可以循环访问此数组，根据每个数组元素的类型确定所应用的特性，并从特性对象中提取信息。关于\r\n<code>GetCustomAttributes</code>，可见：<a\r\nhref=\"https://learn.microsoft.com/en-us/dotnet/api/system.reflection.memberinfo.getcustomattributes?view=net-7.0#system-reflection-memberinfo-getcustomattributes(system-boolean)\">MemberInfo.GetCustomAttributes\r\nMethod (System.Reflection) | Microsoft Learn</a></p>\r\n<p>下面是完整的示例。\r\n定义自定义特性、将其应用于多个实体，并通过反射对其进行检索：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F; Multiuse attribute.\n[System.AttributeUsage(System.AttributeTargets.Class |\n                       System.AttributeTargets.Struct,\n                       AllowMultiple &#x3D; true)  &#x2F;&#x2F; Multiuse attribute.\n]\npublic class AuthorAttribute : System.Attribute &#123;\n    string Name;\n    public double Version;\n\n    public AuthorAttribute(string name) &#123;\n        Name &#x3D; name;\n        Version &#x3D; 1.0;\n    &#125;\n\n    public string GetName() &#x3D;&gt; Name;\n&#125;\n\n&#x2F;&#x2F; Class with the Author attribute.\n[Author(&quot;P. Ackerman&quot;)]\npublic class FirstClass &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n&#x2F;&#x2F; Class without the Author attribute.\npublic class SecondClass &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n&#x2F;&#x2F; Class with multiple Author attributes.\n[Author(&quot;P. Ackerman&quot;), Author(&quot;R. Koch&quot;, Version &#x3D; 2.0)]\npublic class ThirdClass &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\nclass TestAuthorAttribute &#123;\n    public static void Main(string[] args) &#123;\n        PrintAuthorInfo(typeof(FirstClass));\n        PrintAuthorInfo(typeof(SecondClass));\n        PrintAuthorInfo(typeof(ThirdClass));\n    &#125;\n\n    private static void PrintAuthorInfo(System.Type t) &#123;\n        System.Console.WriteLine($&quot;Author information for &#123;t&#125;&quot;);\n\n        &#x2F;&#x2F; Using reflection.\n        System.Attribute[] attrs &#x3D; System.Attribute.GetCustomAttributes(t);  &#x2F;&#x2F; Reflection.\n\n        &#x2F;&#x2F; Displaying output.\n        foreach (System.Attribute attr in attrs) &#123;\n            if (attr is AuthorAttribute a) &#123; &#x2F;&#x2F; see https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;language-reference&#x2F;operators&#x2F;patterns#declaration-and-type-patterns\n                System.Console.WriteLine($&quot;   &#123;a.GetName()&#125;, version &#123;a.Version:f&#125;&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;* Output:\n    Author information for FirstClass\n       P. Ackerman, version 1.00\n    Author information for SecondClass\n    Author information for ThirdClass\n       R. Koch, version 2.00\n       P. Ackerman, version 1.00\n*&#x2F;</code></pre>\r\n<p>可以看到的是，我们提取出了注解中的全部信息。知道了这一办法后，我们就可以反过来完善\r\nAttribute 的例子了！</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\nusing System.Reflection;\nnamespace BugFixApplication&#123;\n    &#x2F;&#x2F; 一个自定义特性 BugFix\n    [AttributeUsage(AttributeTargets.Class |\n    AttributeTargets.Constructor |\n    AttributeTargets.Field |\n    AttributeTargets.Method |\n    AttributeTargets.Property,\n    AllowMultiple &#x3D; true)]\n    public class DeBugInfo : Attribute &#123;\n        private int bugNo;\n        private string developer;\n        private string lastReview;\n        public string? message;\n\n        public DeBugInfo(int bg, string dev, string d) &#123;\n            this.bugNo &#x3D; bg;\n            this.developer &#x3D; dev;\n            this.lastReview &#x3D; d;\n        &#125;\n\n        public int BugNo &#123; get &#123; return bugNo; &#125; &#125;\n        public string Developer &#123; get &#123; return developer; &#125; &#125;\n        public string LastReview &#123; get &#123; return lastReview; &#125; &#125;\n        public string? Message &#123;\n            get &#123; return message; &#125;\n            set &#123; message &#x3D; value; &#125;\n        &#125;\n\t&#125;\n\n   [DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12&#x2F;8&#x2F;2012&quot;, Message &#x3D; &quot;Return type mismatch&quot;)]\n   [DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10&#x2F;10&#x2F;2012&quot;, Message &#x3D; &quot;Unused variable&quot;)]\n   class Rectangle &#123;\n      &#x2F;&#x2F; 成员变量\n      protected double length;\n      protected double width;\n      public Rectangle(double l, double w) &#123;\n         length &#x3D; l;\n         width &#x3D; w;\n      &#125;\n      [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19&#x2F;10&#x2F;2012&quot;, Message &#x3D; &quot;Return type mismatch&quot;)]\n      public double GetArea() &#123;\n         return length * width;\n      &#125;\n      [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19&#x2F;10&#x2F;2012&quot;)]\n      public void Display() &#123;\n         Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);\n         Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);\n         Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());\n      &#125;\n   &#125;\n   \n   class ExecuteRectangle &#123;\n      static void Main(string[] args) &#123;\n         Rectangle r &#x3D; new Rectangle(4.5, 7.5);\n         r.Display();\n         Type type &#x3D; typeof(Rectangle);\n\n         &#x2F;&#x2F; 遍历 Rectangle 类的特性\n         foreach (Object attributes in type.GetCustomAttributes(false)) &#123;\n            if (attributes is DeBugInfo dbi) &#123;\n               Console.WriteLine(&quot;Bug no: &#123;0&#125;&quot;, dbi.BugNo);\n               Console.WriteLine(&quot;Developer: &#123;0&#125;&quot;, dbi.Developer);\n               Console.WriteLine(&quot;Last Reviewed: &#123;0&#125;&quot;, dbi.LastReview);\n               Console.WriteLine(&quot;Remarks: &#123;0&#125;&quot;, dbi.Message);\n            &#125;\n         &#125;\n         \n         &#x2F;&#x2F; 遍历方法特性\n         foreach (MethodInfo m in type.GetMethods()) &#123;\n            foreach (Attribute a in m.GetCustomAttributes(true)) &#123;\n               if (a is DeBugInfo dbi) &#123;\n                  Console.WriteLine(&quot;Bug no: &#123;0&#125;, for Method: &#123;1&#125;&quot;, dbi.BugNo, m.Name);\n                  Console.WriteLine(&quot;Developer: &#123;0&#125;&quot;, dbi.Developer);\n                  Console.WriteLine(&quot;Last Reviewed: &#123;0&#125;&quot;, dbi.LastReview);\n                  Console.WriteLine(&quot;Remarks: &#123;0&#125;&quot;, dbi.Message);\n               &#125;\n            &#125;\n         &#125;\n      &#125;\n   &#125;\n&#125;\n&#x2F;* Output:\n    Length: 4.5\n    Width: 7.5\n    Area: 33.75\n    Bug No: 49\n    Developer: Nuha Ali\n    Last Reviewed: 10&#x2F;10&#x2F;2012\n    Remarks: Unused variable\n    Bug No: 45\n    Developer: Zara Ali\n    Last Reviewed: 12&#x2F;8&#x2F;2012\n    Remarks: Return type mismatch\n    Bug No: 55, for Method: GetArea\n    Developer: Zara Ali\n    Last Reviewed: 19&#x2F;10&#x2F;2012\n    Remarks: Return type mismatch\n    Bug No: 56, for Method: Display\n    Developer: Zara Ali\n    Last Reviewed: 19&#x2F;10&#x2F;2012\n    Remarks:\n*&#x2F;</code></pre>\r\n<p>更多可见：</p>\r\n<ul>\r\n<li><a\r\nhref=\"https://learn.microsoft.com/zh-cn/dotnet/csharp/advanced-topics/reflection-and-attributes/attribute-tutorial\">教程：定义和读取自定义特性。\r\n- C# | Microsoft Learn</a></li>\r\n<li><a\r\nhref=\"https://www.cnblogs.com/yaozhenfa/p/CSharp_Reflection_1.html\">C#之玩转反射\r\n- y-z-f - 博客园 (cnblogs.com)</a></li>\r\n<li>[<a\r\nhref=\"https://zhuanlan.zhihu.com/p/592698341\">C#]理解和入门依赖注入 -\r\n知乎 (zhihu.com)</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/407070469\">【C#入门详解\r\n16】-反射、依赖注入 - 知乎 (zhihu.com)</a></li>\r\n</ul>\r\n<h2 id=\"is\">?、??、?.、is</h2>\r\n<h3 id=\"section\">??</h3>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">value ?? expression</code></pre>\r\n<p><code>??</code> 会判断 value 是否为 null，如果是则执行\r\nexpression，而不是则返回 value。</p>\r\n<p>另外，<code>??</code>\r\n运算符要求两个操作数都具有相同的类型或可以隐式转换为相同的类型。</p>\r\n<p>因此，这样的书写便是不符合规则的</p>\r\n<pre class=\"line-numbers language-C#\" data-language=\"C#\"><code class=\"language-C#\">class Program &#123;\n    static A ab;\n\n    public static void NewA() &#123;\n        ab &#x3D; new A();\n    &#125;\n\n    public static void Main(string[] args)&#123;\n        ab &#x3D; ab ?? NewA();\n    &#125;\n&#125;\npublic class A &#123;&#125;</code></pre>\r\n<p>应该是这样的：</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Program &#123;\n    static A ab;\n\n    public static A NewA() &#123;\n        return new A();\n    &#125;\n\n    public static void Main(string[] args) &#123;\n        ab &#x3D; ab ?? NewA();\n    &#125;\n&#125;\npublic class A &#123;&#125;</code></pre>\r\n<h3 id=\"invode\">?.invode</h3>\r\n<h2 id=\"多线程\">多线程</h2>\r\n<h3 id=\"线程\">线程</h3>\r\n<p>Task</p>\r\n<h3 id=\"unity-协程-coroutine\">Unity 协程 Coroutine</h3>\r\n<blockquote>\r\n<p>Unity\r\n开发不可避免的要用到协程(Coroutine)，协程能在同步代码中做异步任务，避免了异步操作加回调的\r\n<em>编码</em> 方式</p>\r\n</blockquote>\r\n<ul>\r\n<li><a href=\"https://www.cnblogs.com/iwiniwin/p/14878498.html\">聊一聊\r\nUnity 协程背后的实现原理 - iwiniwin - 博客园 (cnblogs.com)</a></li>\r\n<li><a\r\nhref=\"https://hzd.plus/2019/08/25/C-图解教程之枚举器和迭代器/\">C#图解教程之枚举器和迭代器｜\r\nZhendong's blog (hzd.plus)</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/279383752\">Unity\r\n协程的原理与应用 - 知乎 (zhihu.com)</a></li>\r\n</ul>\r\n<h2 id=\"dots\">DOTS</h2>\r\n<p>DOTS 即 Data Oriented Technology Stack，是 Unity\r\n关于面向数据编程的一系列技术栈</p>\r\n<p>在正式介绍 DOTS\r\n之前，我想你应该先了解一下什么是面向数据编程，你也许需要先读下这篇文章：</p>\r\n","text":"Advanced CSharp Dictionary (microsoft.com) 哈希表、字典、二维数组的区别是什么？ - VTECISBEST的回答 - 知乎 https://www.zhihu.com/question/266414962/answer/308222427...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"24 mins."},"categories":[{"name":"C#","slug":"C","count":2,"path":"api/categories/C.json"},{"name":"Language Learning","slug":"C/Language-Learning","count":2,"path":"api/categories/C/Language-Learning.json"}],"tags":[{"name":"C#","slug":"C","count":2,"path":"api/tags/C.json"},{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#advanced-csharp\"><span class=\"toc-text\">Advanced CSharp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#readonly-const-static\"><span class=\"toc-text\">readonly, const &amp; static</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#virtual-interface-abstract\"><span class=\"toc-text\">Virtual, Interface &amp;\r\nAbstract</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#delegate-action-func-event\"><span class=\"toc-text\">Delegate, Action, Func &amp;\r\nEvent</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#delegate\"><span class=\"toc-text\">Delegate</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#quick-start\"><span class=\"toc-text\">Quick Start</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#delegates-overview\"><span class=\"toc-text\">Delegates Overview</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#actionfunc\"><span class=\"toc-text\">Action&amp;Func</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">一些区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-actionfunc\"><span class=\"toc-text\">为什么需要 Action&amp;Func？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0%E5%A7%94%E6%89%98\"><span class=\"toc-text\">什么时候会用到委托？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#event\"><span class=\"toc-text\">Event</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#attribute-%E4%B8%8E-reflection\"><span class=\"toc-text\">Attribute 与 Reflection</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">元数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#attribute\"><span class=\"toc-text\">Attribute</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">预定义特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#attributeusage\"><span class=\"toc-text\">AttributeUsage</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#obsolete\"><span class=\"toc-text\">Obsolete</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">自定义特性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#reflection\"><span class=\"toc-text\">Reflection</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#is\"><span class=\"toc-text\">?、??、?.、is</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#section\"><span class=\"toc-text\">??</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#invode\"><span class=\"toc-text\">?.invode</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">多线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#unity-%E5%8D%8F%E7%A8%8B-coroutine\"><span class=\"toc-text\">Unity 协程 Coroutine</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dots\"><span class=\"toc-text\">DOTS</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Volumetric Cloud","uid":"43a3ae9eb97a236c0b66c1ff3212a8e3","slug":"Rendering/Volume Rendering/VolumeClouds","date":"2023-03-31T04:23:23.000Z","updated":"2023-10-27T20:15:52.000Z","comments":true,"path":"api/articles/Rendering/Volume Rendering/VolumeClouds.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Volumetric Cloud Based On RayMarching 求包围盒 \"从摄像机发出射线，每次前进一点判断是否在体积雾包围盒范围内然后再采样计算颜色。我们通过计算摄像机与体积雾包围盒相交的点，直接从该交点沿射线方向前进，来减少无效的步进。\" Referece (8...","link":"","photos":[],"count_time":{"symbolsCount":239,"symbolsTime":"1 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Shader Book Github Issue Collections","uid":"41644c3248ea1210fc5e02792aa4d4c9","slug":"Rendering/UnityShaderBook/ProblemCollections","date":"2023-03-08T13:29:45.000Z","updated":"2023-10-27T19:29:31.000Z","comments":true,"path":"api/articles/Rendering/UnityShaderBook/ProblemCollections.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Shader Book Github Issue Collections saturate 和 max · Issue #198 · candycat1992/Unity_Shaders_Book (github.com) 为什么后来从 sature 改到了 max？ Q: 在基...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}