{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/计时器","date":"2023-03-07T16:14:45.658Z","updated":"2022-02-24T13:23:48.000Z","comments":true,"path":"api/articles/Language Learning/Python/计时器.json","keywords":null,"cover":[],"content":"<h1 id=\"python-定时器\"><a href=\"#python-定时器\" class=\"headerlink\" title=\"python 定时器\"></a>python 定时器</h1><p>在工作中，我们有时候会需要定时去做一些操作，比如凌晨更新远程代码，仓库每小时更新一次远程分支。这些操作，我们如果要人工进行，不仅要耗费精力，也更容易出错。</p>\n<p>如果一件事情，具有周期操作的特点，那么把这件事情设置为定时器操作，最合适不过。</p>\n<h2 id=\"不借助第三方插件\"><a href=\"#不借助第三方插件\" class=\"headerlink\" title=\"不借助第三方插件\"></a>不借助第三方插件</h2><p>在不借助第三方插件的情况下，python内部可以有多种方式完成定时器操作，这里介绍一种简单易行的方法：</p>\n<p>利用threading.Timer方法创建一个定时器。</p>\n<p>一个简单的需求，程序启动5s后在屏幕上打印一个hello<br>首先介绍一下threading.Timer的使用方法：</p>\n<p>class threading.Timer(interval, function, args=[], kwargs={})</p>\n<p>创建一个timer，在interval秒过去之后，它将以参数args和关键字参数kwargs运行function 。</p>\n<p>调用该函数回返回一个定时器的句柄，同时也获得了一个定时器实例。</p>\n<p>但是这时，定时器只是被创建，被没有启动，需要调用实例里面的</p>\n<p>start（）方法启动定时器。如果在定时过程中想要取消该定时器，需要使用cancel()函数。</p>\n<p>那么这个小需求，就很简单了，代码可以这么写：</p>\n<p><img src=\"v2-101b5e67e684e26cee924257d3c3e742_r.jpg\"></p>\n<p>定义一个定时时间到了，需要调用的函数，方便Timer函数回调，创建定时器实例，并设置定时时间，或得实例后，启动定时器。</p>\n<p><img src=\"v2-709abdacdf1d7bb69f03d29f01808b1a_r.jpg\"></p>\n<p>但是我们发现，定时器只执行了一次，如何要定时器，能够不停的执行下去呢？</p>\n<p>一种方法是利用while（True），不停的创建定时器并启动，显然这种方法显得笨拙，而且会一直占用线程。</p>\n<p>另外一种方法，就是在回调函数中，创建定时器并启动，形成递归调用。这里着重说下这种方法。</p>\n<p><img src=\"v2-1af2de0b97195d00b232f7d2e2ba2855_r.jpg\"></p>\n<p>运行效果如下：</p>\n<p><img src=\"v2-4e2f19e42708781022542e3e6c0663d9_r.jpg\"></p>\n<p>程序看起来很简单，通过在回调函数里面，重新创建定时器，来使得定时器能够一直工作。</p>\n<p>但是值得注意的是，定时器的句柄需要定义成为一个全局变量，这样做的好处是，创建的定时器进程和实例不会堆积，而是覆盖，避免不必要的内存占用。</p>\n<p>另外利用threading创建的定时器还有一个好处是，每一个定时器的创建都是在一个新的进程里面，所以定时器是不阻塞式的，比如，我们创建两个定时器，让它们分别打印不同的字符串：</p>\n<p><img src=\"v2-16f751cff8befb01fa3bbdbd3b60b8cc_r.jpg\"></p>\n<p>我们运行程序可以看到：</p>\n<p><img src=\"v2-2f1c821b2c8d5bf346980c9e57b0d1b9_r-16395394947952.jpg\" alt=\"结果\"></p>\n<p>这样一个简单的定时器就完成了！</p>\n<p>但是这并不是一个十分健壮的定时器，还有很多问题需要考虑，比如，如何终止定时器？在何时使用cancel（）？如果创建定时器实例失败，应该如何处理？等等。</p>\n<p>不过一个定时器的基本雏形已经完成了，剩下的就是根据需要添加不同的功能。</p>\n<h2 id=\"Schedule插件\"><a href=\"#Schedule插件\" class=\"headerlink\" title=\"Schedule插件\"></a>Schedule插件</h2><p><a href=\"https://pypi.org/project/schedule/\">schedule · PyPI</a></p>\n","text":"python 定时器在工作中，我们有时候会需要定时去做一些操作，比如凌晨更新远程代码，仓库每小时更新一次远程分支。这些操作，我们如果要人工进行，不仅要耗费精力，也更容易出错。 如果一件事情，具有周期操作的特点，那么把这件事情设置为定时器操作，最合适不过。 不借助第三方插件在不借助...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#python-%E5%AE%9A%E6%97%B6%E5%99%A8\"><span class=\"toc-text\">python 定时器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%80%9F%E5%8A%A9%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">不借助第三方插件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Schedule%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">Schedule插件</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/SQLwithMySQL/00.Install MySQL","date":"2023-03-07T16:14:45.741Z","updated":"2022-03-03T04:25:51.000Z","comments":true,"path":"api/articles/Language Learning/SQLwithMySQL/00.Install MySQL.json","keywords":null,"cover":[],"text":"部署MySQLLinux下的MySQL部署0.检验之前的版本请先将你之前已经安装好了的或系统自带的MySQL卸载再进行以下步骤 1. 在线安装（有网络条件下使用输入命令行安装） MySql官网的安装指南：MySQL :: MySQL 8.0 Reference Manual ::...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/相等判断","date":"2023-03-07T16:14:45.652Z","updated":"2022-02-25T14:19:52.000Z","comments":true,"path":"api/articles/Language Learning/Python/相等判断.json","keywords":null,"cover":null,"text":"python的is和==，java的==和equal（相等判断）Python判断对象是否相等（== 和 is）Python中的对象包含三个基本要素，分别是： id：用来唯一标识一个对象，可以理解为内存地址； type：标识对象的类型； value：对象的值； == ：比较两个对象...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}