{"title":"Python装饰器","uid":"7c3d41f90666b48d6b76a1cfaa71f837","slug":"Language Learning/Python/装饰器","date":"2022-02-13T04:07:03.000Z","updated":"2023-10-27T20:01:50.000Z","comments":true,"path":"api/articles/Language Learning/Python/装饰器.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"python装饰器\">Python装饰器</h1>\r\n<h2 id=\"闭包\">1、闭包</h2>\r\n<p>要想了解装饰器，首先要了解一个概念，闭包。</p>\r\n<p>什么是闭包，一句话说就是，在函数中再嵌套一个函数，并且引用外部函数的变量，这就是一个闭包了。光说没有概念，直接上一个例子。</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def outer(x):\n    def inner(y):\n        return x + y\n    return inner\n\nprint(outer(6)(5))\n\n# output: 11</code></pre>\r\n<p>如代码所示，在outer函数内，又定义了一个inner函数，并且inner函数又引用了外部函数outer的变量x，这就是一个闭包了。在输出时，outer(6)(5),第一个括号传进去的值返回inner函数，其实就是返回6\r\n+ y，所以再传第二个参数进去，就可以得到返回值，6 + 5。</p>\r\n<h2 id=\"符号\">2.@符号</h2>\r\n<h3 id=\"含义解释\">含义解释</h3>\r\n<p><span class=\"citation\"\r\ndata-cites=\"符号会使用一个简短的方式来生成一个被装饰的函数\">@符号会使用一个简短的方式来生成一个被装饰的函数</span>，具体过程可以理解为：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 装饰函数：\ndef a_new_decorator(a_func):\n    def wrapTheFunction():\n        print(&quot;I am doing some boring work before executing a_func()&quot;)\n \n        a_func()\n \n        print(&quot;I am doing some boring work after executing a_func()&quot;)\n \n    return wrapTheFunction\n \n# 需要被装饰的目标函数：\ndef a_function_requiring_decoration():\n    print(&quot;I am the function which needs some decoration to remove my foul smell&quot;)\n\n# 当前 a_function_requiring_decoration 函数的执行结果\n# outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;\n\n\n# 可行的装饰方式：\na_function_requiring_decoration &#x3D; a_new_decorator(a_function_requiring_decoration)\n#now a_function_requiring_decoration is wrapped by wrapTheFunction()\n\n#---------或者：\n@a_new_decorator\ndef a_function_requiring_decoration():\n    &quot;&quot;&quot;Now the func is wrapped&quot;&quot;&quot;\n    print(&quot;I am the function which needs some decoration to remove my foul smell&quot;)\n\n# 不管是怎么修饰，都可以在修饰后，执行得到：\na_function_requiring_decoration()\n#outputs:I am doing some boring work before executing a_func()\n#        I am the function which needs some decoration to remove my foul smell\n#        I am doing some boring work after executing a_func()</code></pre>\r\n<p>也就是说：<code>@a_new_decorator</code> 就是\r\n<code>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</code>的简写</p>\r\n<h3 id=\"一个小问题\">一个小问题</h3>\r\n<p>在上方的代码执行完后，如果再打印：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">print(a_function_requiring_decoration.__name__)\n# Output: wrapTheFunction</code></pre>\r\n<p>为啥？</p>\r\n<p>修饰的实际过程是怎么样的吗？-&gt;就上方的例子而言，该装饰器的修饰过程是：<code>a = a_new_decorator(a)</code>，而a实际上只是一个地址的指向，现在a指向的位置是哪里？</p>\r\n<p>是decorator执行结束时，return的wrapTheFunction，也就是说，a所指向的函数被新的a_new_decorator代替了。</p>\r\n<p>为了解决“名字”的问题，我们可以再用一个装饰器<code>functools.wraps</code>：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from functools import wraps\n \ndef a_new_decorator(a_func):\n    @wraps(a_func)\n    def wrapTheFunction():\n        print(&quot;I am doing some boring work before executing a_func()&quot;)\n        a_func()\n        print(&quot;I am doing some boring work after executing a_func()&quot;)\n    return wrapTheFunction\n \n@a_new_decorator\ndef a_function_requiring_decoration():\n    print(&quot;I am the function which needs some decoration to remove my foul smell&quot;)\n \nprint(a_function_requiring_decoration.__name__)\n# Output: a_function_requiring_decoration</code></pre>\r\n<p><strong><span class=\"citation\"\r\ndata-cites=\"wraps\">@wraps</span></strong>接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</p>\r\n<h2 id=\"装饰器\">3、装饰器</h2>\r\n<p>解决了两个前置目标后，我们实际上就已经理解了什么是装饰器了</p>\r\n<p>而python对装饰器的定义是：</p>\r\n<p>接下来就讲装饰器，其实装饰器就是一个闭包，装饰器是闭包的一种应用。什么是装饰器呢，简言之，python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。使用时，再需要的函数前加上@demo即可。</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def debug(func):\n    def wrapper():\n        print(&quot;[DEBUG]: enter &#123;&#125;()&quot;.format(func.__name__))\n        return func()\n    return wrapper\n\n@debug\ndef hello():\n    print(&quot;hello&quot;)\n\nhello()\n-----------------------------\n&gt;&gt;&gt;[DEBUG]: enter hello()\n&gt;&gt;&gt;hello</code></pre>\r\n<p>例子中的装饰器给函数加上一个进入函数的debug模式，不用修改原函数代码就完成了这个功能，可以说是很方便了。</p>\r\n<h2 id=\"带参数的装饰器\">3、带参数的装饰器</h2>\r\n<p>上面例子中的装饰器是不是功能太简单了，那么装饰器可以加一些参数吗，当然是可以的，另外装饰的函数当然也是可以传参数的。</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def logging(level):\n    def outwrapper(func):\n        def wrapper(*args, **kwargs):\n            print(&quot;[&#123;0&#125;]: enter &#123;1&#125;()&quot;.format(level, func.__name__))\n            return func(*args, **kwargs)\n        return wrapper\n    return outwrapper\n\n@logging(level&#x3D;&quot;INFO&quot;)\ndef hello(a, b, c):\n    print(a, b, c)\n\nhello(&quot;hello,&quot;,&quot;good&quot;,&quot;morning&quot;)\n-----------------------------\n&gt;&gt;&gt;[INFO]: enter hello()\n&gt;&gt;&gt;hello, good morning</code></pre>\r\n<p>如上，<strong>装饰器中可以传入参数，先形成一个完整的装饰器，然后再来装饰函数</strong>，当然函数如果需要传入参数也是可以的，用不定长参数符号就可以接收，例子中传入了三个参数。</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@logging(level&#x3D;&quot;INFO&quot;) \n可以看做是 \nhello &#x3D; logging(level&#x3D;&quot;INFO&quot;)(hello)\n\n# 这里的hello是函数对象，python中一切皆是对象，函数也可以像变量一样传递，加括号后hello()才是执行函数。于是这里就变成了hello &#x3D; outwrapper(hello)\n# 而outwrapper() 的返回是 wrapper，hello 就等于 wrapper，执行 hello() 就等价于执行 wrapper()，而等号右边的 hello 已经作为参数传递给 outrapper() 了</code></pre>\r\n<h2 id=\"类装饰器\">4、类装饰器</h2>\r\n<p>装饰器也不一定只能用函数来写，也可以使用类装饰器，用法与函数装饰器并没有太大区别，实质是使用了类方法中的<strong>call</strong>魔法方法来实现类的直接调用。</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class logging(object):\n    def __init__(self, func):\n        self.func &#x3D; func\n\n    def __call__(self, *args, **kwargs):\n        print(&quot;[DEBUG]: enter &#123;&#125;()&quot;.format(self.func.__name__))\n        return self.func(*args, **kwargs)\n\n@logging\ndef hello(a, b, c):\n    print(a, b, c)\n\nhello(&quot;hello,&quot;,&quot;good&quot;,&quot;morning&quot;)\t\n-----------------------------\n&gt;&gt;&gt;[DEBUG]: enter hello()\n&gt;&gt;&gt;hello, good morning</code></pre>\r\n<p>​ 类装饰器也是可以带参数的，如下实现</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class logging(object):\n    def __init__(self, level):\n        self.level &#x3D; level\n\n    def __call__(self, func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            print(&quot;[&#123;0&#125;]: enter &#123;1&#125;()&quot;.format(self.level, func.__name__))\n            return func(*args, **kwargs)\n        return wrapper\n\n@logging(level&#x3D;&quot;TEST&quot;)\ndef hello(a, b, c):\n    print(a, b, c)\n\nhello(&quot;hello,&quot;,&quot;good&quot;,&quot;morning&quot;)\n-----------------------------\n&gt;&gt;&gt;[TEST]: enter hello()\n&gt;&gt;&gt;hello, good morning</code></pre>\r\n<p>好了，如上就是装饰器的一些概念和大致的用法啦，想更深入的了解装饰器还是需要自己在平时的练习和应用中多体会，本篇只是给出一个概念，谢谢~</p>\r\n<h2 id=\"编写装饰器\">编写装饰器</h2>\r\n<h2 id=\"property装饰器\">property装饰器</h2>\r\n<p>既要保护类的封装特性，又要让开发者可以使用“对象.属性”的方式操作操作类属性，除了使用\r\nproperty() 函数，<a href=\"http://c.biancheng.net/python/\">Python</a>\r\n还提供了 <span class=\"citation\" data-cites=\"property\">@property</span>\r\n装饰器。通过 <span class=\"citation\"\r\ndata-cites=\"property\">@property</span>\r\n装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“()”小括号</p>\r\n<p><span class=\"citation\" data-cites=\"property\">@property</span>\r\n的语法格式如下：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@property\ndef 方法名(self)\n  代码块</code></pre>\r\n<p>例如，定义一个矩形类，并定义用 <span class=\"citation\"\r\ndata-cites=\"property\">@property</span> 修饰的方法操作类中的 area\r\n私有属性，代码如下：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Rect:   \n    def __init__(self,area):    \n        self.__area &#x3D; area\n    @property \n    def area(self):    \n        return self.__arearect &#x3D; Rect(30)  # 直接通过方法名来访问 area 方法\nprint(&quot;矩形的面积是：&quot;,rect.area)  # 运行结果: 30</code></pre>\r\n<p>上面程序中，使用 ＠property 修饰了 area()\r\n方法，这样就使得该方法变成了 area 属性的 getter\r\n方法。需要注意的是，如果类中只包含该方法，那么 area\r\n属性将是一个只读属性。</p>\r\n<p>也就是说，在使用 Rect 类时，无法对 area\r\n属性重新赋值，即运行如下代码会报错：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">rect.area &#x3D; 90\nprint(&quot;修改后的面积：&quot;,rect.area)</code></pre>\r\n<p>运行结果为：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Traceback (most recent call last):\nFile &quot;C:\\Users\\mengma\\Desktop\\1.py&quot;, line 10, in &lt;module&gt; rect.area &#x3D; 90\nAttributeError: can&#39;t set attribute</code></pre>\r\n<p>而要想实现修改 area 属性的值，还需要为 area 属性添加 setter\r\n方法，也就需要用到 setter 装饰器</p>\r\n<h2 id=\"setter装饰器\">setter装饰器</h2>\r\n<p>它的语法格式如下：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@方法名.setter\ndef 方法名(self, value):\n    代码块</code></pre>\r\n<p>例如，为 Rect 类中的 area 方法添加 setter 方法，代码如下：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@area.setter\ndef area(self, value):  \n    self.__area &#x3D; value</code></pre>\r\n<p>再次运行如下代码：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">rect.area &#x3D; 90\nprint(&quot;修改后的面积：&quot;,rect.area)  #运行结果 area: 90</code></pre>\r\n<p>这样，area 属性就有了 getter 和 setter\r\n方法，该属性就变成了具有读写功能的属性。</p>\r\n<p>除此之外，还可以使用 deleter 装饰器来删除指定属性</p>\r\n<h2 id=\"deleter装饰器\">deleter装饰器</h2>\r\n<p>语法格式</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@方法名.deleter\ndef 方法名(self):\n  代码块</code></pre>\r\n<p>例如，在 Rect 类中，给 area() 方法添加 deleter\r\n方法，实现代码如下：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@area.deleter\ndef area(self):\n\tself.__area &#x3D; 0</code></pre>\r\n<p>然后运行如下代码：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">del rect.areaprint(&quot;删除后的area值为：&quot;,rect.area)  # 运行结果 area: 0</code></pre>\r\n<h2 id=\"all-in-one-property-函数\">All in one: property() 函数</h2>\r\n<p><strong>property()</strong> 函数的作用是在新式类中返回属性值。</p>\r\n<h3 id=\"语法\">语法</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class property([fget[, fset[, fdel[, doc]]]])</code></pre>\r\n<h3 id=\"参数\">参数</h3>\r\n<ul>\r\n<li>fget -- 获取属性值的函数</li>\r\n<li>fset -- 设置属性值的函数</li>\r\n<li>fdel -- 删除属性值函数</li>\r\n<li>doc -- 属性描述信息</li>\r\n</ul>\r\n<h3 id=\"返回值\">返回值</h3>\r\n<p>返回新式类属性。</p>\r\n<h3 id=\"实例\">实例</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class C(object):\n    def __init__(self):\n        self._x &#x3D; None\n \n    def getx(self):\n        return self._x\n \n    def setx(self, value):\n        self._x &#x3D; value\n \n    def delx(self):\n        del self._x\n \n    x &#x3D; property(getx, setx, delx, &quot;I&#39;m the &#39;x&#39; property.&quot;)</code></pre>\r\n<p>如果 <em>c</em> 是 <em>C</em> 的实例化, then =&gt;</p>\r\n<ul>\r\n<li><p>c.{object} 将触发 getter</p></li>\r\n<li><p>c.{object} = value 将触发 setter</p></li>\r\n<li><p>del c.{object} 触发 deleter</p></li>\r\n</ul>\r\n<p>如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property\r\n函数就会复制 fget 函数的 docstring（如果有的话）</p>\r\n<p><span class=\"citation\" data-cites=\"wraps\">@wraps</span>()\r\n相当于：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def Wraps(fWrap):\n    def TmpWraps(func):\n        def WrapsDecorator(*args, **kwargs):\n            WrapsDecorator.__name__&#x3D;fWrap.__name__\n            WrapsDecorator.__doc__&#x3D;fWrap.__doc__\n            return func(*args, **kwargs)\n        return WrapsDecorator\n    return TmpWraps</code></pre>\r\n<p>示例代码如下：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def Wraps(fWrap):\n    def TmpWraps(func):\n        def WrapsDecorator(*args, **kwargs):\n            WrapsDecorator.__name__&#x3D;fWrap.__name__\n            WrapsDecorator.__doc__&#x3D;fWrap.__doc__\n            return func(*args, **kwargs)\n        return WrapsDecorator\n    return TmpWraps\n\n\ndef NewDecorator(level):\n    def TmpDecorator(func):\n        def anotherFunc():\n            &#39;&#39;&#39;it&#39;s another function&#39;&#39;&#39;\n            pass\n        #from functools import wraps\n        #@wraps(anotherFunc)\n        @Wraps(anotherFunc)\n        def NewFibonacci(*args, **kwargs):\n            print(&#39;[%s]func: %s is called, %s&#39;%(level,func.__name__,NewFibonacci.__doc__))\n            from time import time\n            start &#x3D; time()\n            rst&#x3D;func(*args, **kwargs)\n            end&#x3D;time()\n            print(&#39;cost time: %.2fs&#39;%(end-start))\n            return rst\n        return NewFibonacci\n    return TmpDecorator\n\n\n@NewDecorator(&#39;log&#39;)\ndef Fibonacci_print(num&#x3D;10):\n    if num &lt;&#x3D; 0:\n        return\n    minNum,maxNum&#x3D;0,1\n    while num &gt; 0:\n        tmpNum&#x3D;minNum\n        print(tmpNum, end&#x3D;&#39;,&#39;)\n        minNum&#x3D;maxNum\n        maxNum+&#x3D;tmpNum\n        num-&#x3D;1\n\nFibonacci_print()\nprint(Fibonacci_print.__name__)</code></pre>\r\n<p>输出为：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[log]func: Fibonacci_print is called, it&#39;s another function\n0,1,1,2,3,5,8,13,21,34,cost time: 0.07s\nanotherFunc</code></pre>\r\n<p>再论 <strong><span class=\"citation\"\r\ndata-cites=\"wraps\">@wraps</span>(func)</strong> 装饰器实现原理。</p>\r\n<p>纠正下楼上 <strong><span class=\"citation\"\r\ndata-cites=\"DragonZ\">@DragonZ</span></strong>\r\n描述的基本代码框架，应该是如下：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def Wraps(fWrap):\n    def TmpWraps(func):\n        def WrapsDecorator(*args, **kwargs):\n            return func(*args, **kwargs)\n            WrapsDecorator.__name__&#x3D;fWrap.__name__\n            WrapsDecorator.__doc__&#x3D;fWrap.__doc__\n        return WrapsDecorator\n    return TmpWraps</code></pre>\r\n<p>并且该装饰器不仅仅只是复制了__name__ 和 <strong>doc</strong>\r\n函数元信息，还有更多其他信息，正确的实现代码如下：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">def mywraps(fwrap):\n    def TmpWraps(func):\n        def dec(**args):\n            return func(**args)\n        meta_info&#x3D;[&#39;__module__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;]\n        for meta in meta_info:\n            setattr(dec,meta,getattr(fwrap,meta))\n        #逐个获取fwrap函数的元信息，并复制到dec函数上\n        return dec\n    return TmpWraps</code></pre>\r\n<p>另外，针对类装饰器，可能下面这样解释，会对初学者更加友好：</p>\r\n<p>装饰器还可以通过类来实现，其实主要是利用类的以下特点来变相实现函数装饰器功能：</p>\r\n<p>函数调用语语法f()等同于类的实例化，即调用类的__init__函数创建对象</p>\r\n<p>对象的调用obj()等同于运行对象的__call__魔法函数</p>\r\n<p>通过类实现装饰器，可以避免函数装饰器超过2层的嵌套情况，因为如果有三层的话，最外层函数可以认为是在调用类的__init__函数，这样可以让代码更易读和维护</p>\r\n<p>本质，只要实现类的__init__和__call__魔法函数，并在__init__函数内接受装饰器参数，在__call__函数内实现具体装饰器结构即可</p>\r\n<p>下面举例，用类实现带参装饰器，可以观察下不同</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from functools import wraps \n#定义一个装饰器名称的类\nclass  with_para_decorator: \n    #在类的__init__函数内接受装饰器参数，并赋值给类的实例参数，这样可以让其他函数随时使用\n    #当然，如果装饰器没有参数，此处不转a,b即可，相当于类无参实例化\n    def __init__(self,a,b):    \n        self.a&#x3D;a\n        self.b&#x3D;b\n    #在类的__call__函数内接受被装饰函数，并具体定义装饰器\n    def __call__(self,func):   \n    @wraps(func)   \n    def wrap_function(arg1,arg2):  \n        print(&#39;装饰带参数的函数，函数传的参数为：&#123;0&#125;, &#123;1&#125;&#39;.format(arg1,arg2))\n        print(&#39;带参数的装饰器，装饰器传的参数为：&#123;0&#125;, &#123;1&#125;&#39;.format(self.a,self.b))\n        return func(arg1,arg2)   \n    return wrap_function\n#使用装饰器\n@with_para_decorator(1,2)  \ndef need_decorate(a,b):   \npass\nneed_decorate(4,5) </code></pre>\r\n<p>以上代码具体原理解析如下：</p>\r\n<ul>\r\n<li><span class=\"citation\"\r\ndata-cites=\"with_para_decorator\">@with_para_decorator</span>(1,2)，因为是类的名称，相当于使用(1,2)参数创建并返回该类的一个实例对象，比如是\r\nobj</li>\r\n<li>此时，语法变为@obj，相当于need_decorate=obj(need_decorate)，此时会调用obj.__call__魔法函数，而我们在该魔法函数具体实现了装饰器功能</li>\r\n<li>可以看到，其本质的运行原理，和函数装饰器没区别，只是将三层函数嵌套，变成了一个__init__函数和__call__函数的两层嵌套</li>\r\n<li>对比下来，可以看到，类装饰器，代码更加直观</li>\r\n</ul>\r\n<h2 id=\"link\">Link:</h2>\r\n<ul>\r\n<li><a\r\nhref=\"https://www.runoob.com/w3cnote/python-func-decorators.html\">Python\r\n函数装饰器 | 菜鸟教程 (runoob.com)</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/87353829\">python 装饰器详解 -\r\n知乎 (zhihu.com)</a></li>\r\n<li><a href=\"https://docs.python.org/3/library/functools.html\">functools\r\n— Higher-order functions and operations on callable objects — Python\r\n3.10.7 documentation</a></li>\r\n<li><a\r\nhref=\"https://www.runoob.com/w3cnote/closure-intro.html\">什么是闭包？闭包的优缺点？\r\n| 菜鸟教程 (runoob.com)</a></li>\r\n<li><a\r\nhref=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\">闭包\r\n- JavaScript | MDN (mozilla.org)</a></li>\r\n</ul>\r\n","text":"Python装饰器 1、闭包 要想了解装饰器，首先要了解一个概念，闭包。 什么是闭包，一句话说就是，在函数中再嵌套一个函数，并且引用外部函数的变量，这就是一个闭包了。光说没有概念，直接上一个例子。 def outer(x): def inner(y): return x + y ...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":19,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#python%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">Python装饰器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">1、闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%A6%E5%8F%B7\"><span class=\"toc-text\">2.@符号</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AB%E4%B9%89%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">含义解释</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">一个小问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">3、装饰器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">3、带参数的装饰器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">4、类装饰器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">编写装饰器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#property%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">property装饰器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#setter%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">setter装饰器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#deleter%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">deleter装饰器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#all-in-one-property-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">All in one: property() 函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">返回值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">实例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#link\"><span class=\"toc-text\">Link:</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Setup A Flask Application","uid":"a9c12b026b9f323fd06103f80893c3ae","slug":"Dev/Back End/flask/setup_your_flask","date":"2022-04-23T04:23:23.000Z","updated":"2023-10-27T19:10:26.000Z","comments":true,"path":"api/articles/Dev/Back End/flask/setup_your_flask.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Setup A Flask Application 一个简单但完整的示例 from flask import Flask, jsonify app &#x3D; Flask(__name__) @app.route(&#39;&#x2F;api&#39;) def my_micr...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"},{"name":"flask","slug":"flask","count":1,"path":"api/tags/flask.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"APT、APT-GET与YUM","uid":"ca2444d0b470feb04a7e872fb5786d4a","slug":"Deploy/Linux/compareAPTandYUM","date":"2022-01-16T03:27:03.000Z","updated":"2023-10-27T18:43:44.000Z","comments":true,"path":"api/articles/Deploy/Linux/compareAPTandYUM.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"APT、APT-GET与YUM apt 什么是 apt apt（Advanced Packaging Tool）基于 DEB 包管理，是一个常见于 Debian 和 Ubuntu 中的软件包管理器，也用于 Kali 等系统中 对应着 dpkg apt 和 apt-get 的关系 ...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"Linux","slug":"Linux","count":5,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":12,"path":"api/tags/Linux.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}