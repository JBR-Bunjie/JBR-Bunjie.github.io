{"title":"Python 深浅拷贝概念与使用","uid":"2ae8bf5d7ed3f9dc8f4a04292dc96322","slug":"Language Learning/Python/Python拷贝与赋值","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T20:01:03.000Z","comments":true,"path":"api/articles/Language Learning/Python/Python拷贝与赋值.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"深浅拷贝概念与使用\">深浅拷贝概念与使用</h1>\r\n<h2 id=\"reference\">Reference：</h2>\r\n<ul>\r\n<li><a\r\nhref=\"https://blog.csdn.net/yushuaigee/article/details/96745994\">彻底理解\r\nPython 中的\"指针\"_杰克小麻雀的博客-CSDN 博客_python 有指针吗</a></li>\r\n</ul>\r\n<h2 id=\"deep-copy-and-shallow-copy\">deep copy and shallow copy</h2>\r\n<p>浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用</p>\r\n<p>深拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中</p>\r\n<h2 id=\"examples\">examples</h2>\r\n<h3 id=\"shallow-copy\">shallow copy</h3>\r\n<h4 id=\"code\">code</h4>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">list1 &#x3D; [[1, 2], (30, 40)]\nlist2 &#x3D; list(list1)\n\nlist1.append(100)\nprint(&quot;list1:&quot;,list1)  # [[1, 2], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nlist1[0].append(3)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2, 3], (30, 40)]\n\nlist1[1] +&#x3D; (50, 60)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40, 50, 60), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2, 3], (30, 40)]</code></pre>\r\n<h4 id=\"explanations\">explanations</h4>\r\n<p>in this program, we initial a list: <code>list1</code> first which\r\ncontains two elements: a list and a tuple.然后对 list1 执行浅拷贝，赋予\r\nlist2。因为浅拷贝里的元素是对原对象元素的引用，因此 list2 中的元素和\r\nlist1 指向同一个列表和元组对象。</p>\r\n<p>next，<code>list1.append(100)</code>. 表示对 list1 的列表新增元素\r\n100。这个操作不会对 list2 产生任何影响，因为 list2 和 list1\r\n作为整体是两个不同的对象，并不共享内存地址。操作过后 list2 不变，list1\r\n会发生改变。</p>\r\n<p>then，<code>list1[0].append(3)</code> 表示对 list1\r\n中的第一个列表新增元素 3。因为 list2 是 list1 的浅拷贝，list2\r\n中的第一个元素和 list1 中的第一个元素，共同指向同一个列表，因此 list2\r\n中的第一个列表也会相对应的新增元素 3。</p>\r\n<p>at last,\r\n<code>list1[1] += (50, 60)</code>，因为元组是不可变的，这里表示对 list1\r\n中的第二个元组拼接，然后重新创建了一个新元组作为 list1\r\n中的第二个元素，而 list2 中没有引用新元组，因此 list2 并不受影响。</p>\r\n<h3 id=\"deep-copy\">deep copy</h3>\r\n<h4 id=\"code-1\">code</h4>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import copy\nlist1 &#x3D; [[1, 2], (30, 40)]\nlist2 &#x3D; copy.deepcopy(list1)\n\nlist1.append(100)\nprint(&quot;list1:&quot;,list1)  # [[1, 2], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nlist1[0].append(3)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nlist1[1] +&#x3D; (50, 60)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40, 50, 60), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]</code></pre>\r\n<h4 id=\"explanation\">explanation</h4>\r\n<p>just as the example code above, no matter how the list1 changes,\r\nlist2 remains itself. 因为此时的 list1 和 list2\r\n完全独立，没有任何联系。</p>\r\n<h2 id=\"特例\">特例</h2>\r\n<p>如果被深拷贝对象中存在指向自身的引用会怎么样？</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import copy\nlist1 &#x3D; [1]\nlist1.append(list1)\nprint(list1)  # [1, [...]]\n\nlist2 &#x3D; copy.deepcopy(list1)\nprint(list2)  # [1, [...]]</code></pre>\r\n<p>此例子中，列表 list1 中有指向自身的引用，因此 list1\r\n是一个无限嵌套的列表。但是当深度拷贝 list1 到 list2\r\n后，程序并没有出现栈溢出的现象。这是为什么呢？</p>\r\n<p>-&gt;因为 deepcopy 会自动维护一个字典，记录已经拷贝的对象与其\r\nID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回。通过查看\r\ndeepcopy 函数实现的源码就会明白：</p>\r\n<h2 id=\"赋值与拷贝的关系\">赋值与拷贝的关系</h2>\r\n<h3 id=\"赋值\">赋值</h3>\r\n<p>只是复制了新对象的引用，不会开辟新的内存空间。</p>\r\n<h3 id=\"拷贝\">拷贝</h3>\r\n<p>创建新对象，具体内容视拷贝类型而定（深浅拷贝）</p>\r\n<p>所以赋值并不会产生一个独立的对象单独存在，只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。</p>\r\n<p>请注意区分浅拷贝与赋值——关键在是否有新对象被创建</p>\r\n<h3 id=\"示例\">示例</h3>\r\n<p>赋值操作：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">a &#x3D; [1, 2, 3]\n\nb &#x3D; a\n# a.append(4)\n# print(b) # [1, 2, 3, 4]</code></pre>\r\n<p>三种浅拷贝操作：</p>\r\n<p>切片操作：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">lst1 &#x3D; lst[:] 或者 lst1 &#x3D; [each for each in lst]</code></pre>\r\n<p>工厂函数：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">lst1 &#x3D; list(lst)</code></pre>\r\n<p>copy 函数：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">lst1 &#x3D; copy.copy(lst)</code></pre>\r\n<p>三种，都是浅拷贝</p>\r\n<h3 id=\"连续赋值\">连续赋值</h3>\r\n<p>在 python\r\n中是可以使用连续赋值的方式来一次为多个变量进行赋值的(请注意，仍然是“赋值”！)，比如：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">a &#x3D; b &#x3D; c &#x3D; 1\na, b, c &#x3D; 1, 1, 1</code></pre>\r\n<p>这些都可以完成变量的赋值，但是就有一个问题了，比如：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">a &#x3D; 3\na, b &#x3D; 1, a  # a &#x3D; 1, b &#x3D; 3</code></pre>\r\n<p>如果按照正常的思维逻辑，先进行 a = 1，在进行 b = a，最后 b 应该等于\r\n1，但是这里 b 应该等于\r\n3，因为<strong>在连续赋值语句中等式右边其实都是局部变量，而不是真正的变量值本身</strong>，因此，上面例子中右边的\r\na，在 python 解析的时候，只是把变量 a 的指向的变量 3 赋给 b，而不是 a=1\r\n之后 a 的结果。这里有一个 Leetcode 里链表的例子：</p>\r\n<blockquote>\r\n<p>假如要对一个链表进行翻转，就比如把 1—&gt;2-&gt;3-&gt;4 转化为\r\n4-&gt;3-&gt;2-&gt;1</p>\r\n</blockquote>\r\n<p>对于这个问题很简单，只要反转指针就可以了，假如链表结构为：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class ListNode:\n    def __init__(self, x):\n        self.val &#x3D; x\n        self.next &#x3D; None1234</code></pre>\r\n<p>我们可以用很简单的三行代码完成这个过程：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def reverseList(self, head):\n        L &#x3D; ListNode(float(&quot;-inf&quot;))\n        while head:\n            L.next, head.next, head &#x3D; head, L.next, head.next\n        return L.next12345</code></pre>\r\n<p>这里的 L 是指向一个新建的结点，因为 python\r\n没有指针的概念，所以用一个额外的结点来代替头指针，这里的核心代码就是中间那一行三个变量的连续赋值，如果单独一句句来理解的话，最后肯定是想不通的，在这里，假设\r\nhead 结点是链表串’1-&gt;2-&gt;3-&gt;4’的头结点，先用新的 L 结点的 next\r\n指针指向 head 的第一个结点‘1’，之后将 L.next(第一次也就是空)赋给了 head\r\n的 next 指针，之后再把 head 的 next 指针（注意，这里的 next\r\n指针还是指向‘2’的，而不是空）赋给 head，相当于 next\r\n向前移一位，这一步相当于一个串变成了两个：</p>\r\n<blockquote>\r\n<p>L：‘-inf’-&gt;‘1’</p>\r\n<p>head：‘2’-&gt;‘3’-&gt;‘4’-&gt;‘5’</p>\r\n</blockquote>\r\n","text":"深浅拷贝概念与使用 Reference： 彻底理解 Python 中的\"指针\"_杰克小麻雀的博客-CSDN 博客_python 有指针吗 deep copy and shallow copy 浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">深浅拷贝概念与使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#deep-copy-and-shallow-copy\"><span class=\"toc-text\">deep copy and shallow copy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#examples\"><span class=\"toc-text\">examples</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#shallow-copy\"><span class=\"toc-text\">shallow copy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#code\"><span class=\"toc-text\">code</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#explanations\"><span class=\"toc-text\">explanations</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#deep-copy\"><span class=\"toc-text\">deep copy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#code-1\"><span class=\"toc-text\">code</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#explanation\"><span class=\"toc-text\">explanation</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E4%BE%8B\"><span class=\"toc-text\">特例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">赋值与拷贝的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">拷贝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">连续赋值</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Git Command","uid":"0b5bad59d6c75a685d314a2ae8f6dd4e","slug":"Deploy/GitAndGithub/Git Commmand","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T18:39:25.000Z","comments":true,"path":"api/articles/Deploy/GitAndGithub/Git Commmand.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"git 分区 git 一共有三个分区： 工作区、暂存区和版本库 git 的初始化（自报家门） git config --global user.name \"YOUR NAME\" git config --global user.email \"email@example.com\" ...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"Git","slug":"Git","count":3,"path":"api/categories/Git.json"}],"tags":[{"name":"Git","slug":"Git","count":3,"path":"api/tags/Git.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"selenium自动化爬虫","uid":"46c2c3df1cbb91d145ce37d8e3350c78","slug":"Language Learning/Python/selenium自动化","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T20:03:21.000Z","comments":true,"path":"api/articles/Language Learning/Python/selenium自动化.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"目标：使用 selenium 来解决网页中的大量同质化人工操作内容 零：想好该怎么做： 关于指定网站： 网站是网盘网站，其文件有密码保护，即每个文件都有不同且无规律的受保护地址；同时，这些网页的操作完全重复。 我们可以使用 selenium 来完成自动化代替重复劳动。 关于 se...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}