{"title":"Python 深浅拷贝概念与使用","uid":"2ae8bf5d7ed3f9dc8f4a04292dc96322","slug":"Language Learning/Python/Python拷贝与赋值","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T20:01:03.000Z","comments":true,"path":"api/articles/Language Learning/Python/Python拷贝与赋值.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"深浅拷贝概念与使用\">深浅拷贝概念与使用</h1>\r\n<h2 id=\"reference\">Reference：</h2>\r\n<ul>\r\n<li><a\r\nhref=\"https://blog.csdn.net/yushuaigee/article/details/96745994\">彻底理解\r\nPython 中的\"指针\"_杰克小麻雀的博客-CSDN 博客_python 有指针吗</a></li>\r\n</ul>\r\n<h2 id=\"deep-copy-and-shallow-copy\">deep copy and shallow copy</h2>\r\n<p>浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用</p>\r\n<p>深拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中</p>\r\n<h2 id=\"examples\">examples</h2>\r\n<h3 id=\"shallow-copy\">shallow copy</h3>\r\n<h4 id=\"code\">code</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>], (<span class=\"number\">30</span>, <span class=\"number\">40</span>)]</span><br><span class=\"line\">list2 = <span class=\"built_in\">list</span>(list1)</span><br><span class=\"line\"></span><br><span class=\"line\">list1.append(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list1:&quot;</span>,list1)  <span class=\"comment\"># [[1, 2], (30, 40), 100]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list2:&quot;</span>,list2)  <span class=\"comment\"># [[1, 2], (30, 40)]</span></span><br><span class=\"line\"></span><br><span class=\"line\">list1[<span class=\"number\">0</span>].append(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list1:&quot;</span>,list1)  <span class=\"comment\"># [[1, 2, 3], (30, 40), 100]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list2:&quot;</span>,list2)  <span class=\"comment\"># [[1, 2, 3], (30, 40)]</span></span><br><span class=\"line\"></span><br><span class=\"line\">list1[<span class=\"number\">1</span>] += (<span class=\"number\">50</span>, <span class=\"number\">60</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list1:&quot;</span>,list1)  <span class=\"comment\"># [[1, 2, 3], (30, 40, 50, 60), 100]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list2:&quot;</span>,list2)  <span class=\"comment\"># [[1, 2, 3], (30, 40)]</span></span><br></pre></td></tr></table></figure>\r\n<h4 id=\"explanations\">explanations</h4>\r\n<p>in this program, we initial a list: <code>list1</code> first which\r\ncontains two elements: a list and a tuple.然后对 list1 执行浅拷贝，赋予\r\nlist2。因为浅拷贝里的元素是对原对象元素的引用，因此 list2 中的元素和\r\nlist1 指向同一个列表和元组对象。</p>\r\n<p>next，<code>list1.append(100)</code>. 表示对 list1 的列表新增元素\r\n100。这个操作不会对 list2 产生任何影响，因为 list2 和 list1\r\n作为整体是两个不同的对象，并不共享内存地址。操作过后 list2 不变，list1\r\n会发生改变。</p>\r\n<p>then，<code>list1[0].append(3)</code> 表示对 list1\r\n中的第一个列表新增元素 3。因为 list2 是 list1 的浅拷贝，list2\r\n中的第一个元素和 list1 中的第一个元素，共同指向同一个列表，因此 list2\r\n中的第一个列表也会相对应的新增元素 3。</p>\r\n<p>at last,\r\n<code>list1[1] += (50, 60)</code>，因为元组是不可变的，这里表示对 list1\r\n中的第二个元组拼接，然后重新创建了一个新元组作为 list1\r\n中的第二个元素，而 list2 中没有引用新元组，因此 list2 并不受影响。</p>\r\n<h3 id=\"deep-copy\">deep copy</h3>\r\n<h4 id=\"code-1\">code</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\">list1 = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>], (<span class=\"number\">30</span>, <span class=\"number\">40</span>)]</span><br><span class=\"line\">list2 = copy.deepcopy(list1)</span><br><span class=\"line\"></span><br><span class=\"line\">list1.append(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list1:&quot;</span>,list1)  <span class=\"comment\"># [[1, 2], (30, 40), 100]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list2:&quot;</span>,list2)  <span class=\"comment\"># [[1, 2], (30, 40)]</span></span><br><span class=\"line\"></span><br><span class=\"line\">list1[<span class=\"number\">0</span>].append(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list1:&quot;</span>,list1)  <span class=\"comment\"># [[1, 2, 3], (30, 40), 100]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list2:&quot;</span>,list2)  <span class=\"comment\"># [[1, 2], (30, 40)]</span></span><br><span class=\"line\"></span><br><span class=\"line\">list1[<span class=\"number\">1</span>] += (<span class=\"number\">50</span>, <span class=\"number\">60</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list1:&quot;</span>,list1)  <span class=\"comment\"># [[1, 2, 3], (30, 40, 50, 60), 100]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;list2:&quot;</span>,list2)  <span class=\"comment\"># [[1, 2], (30, 40)]</span></span><br></pre></td></tr></table></figure>\r\n<h4 id=\"explanation\">explanation</h4>\r\n<p>just as the example code above, no matter how the list1 changes,\r\nlist2 remains itself. 因为此时的 list1 和 list2\r\n完全独立，没有任何联系。</p>\r\n<h2 id=\"特例\">特例</h2>\r\n<p>如果被深拷贝对象中存在指向自身的引用会怎么样？</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\">list1 = [<span class=\"number\">1</span>]</span><br><span class=\"line\">list1.append(list1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(list1)  <span class=\"comment\"># [1, [...]]</span></span><br><span class=\"line\"></span><br><span class=\"line\">list2 = copy.deepcopy(list1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(list2)  <span class=\"comment\"># [1, [...]]</span></span><br></pre></td></tr></table></figure>\r\n<p>此例子中，列表 list1 中有指向自身的引用，因此 list1\r\n是一个无限嵌套的列表。但是当深度拷贝 list1 到 list2\r\n后，程序并没有出现栈溢出的现象。这是为什么呢？</p>\r\n<p>-&gt;因为 deepcopy 会自动维护一个字典，记录已经拷贝的对象与其\r\nID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回。通过查看\r\ndeepcopy 函数实现的源码就会明白：</p>\r\n<h2 id=\"赋值与拷贝的关系\">赋值与拷贝的关系</h2>\r\n<h3 id=\"赋值\">赋值</h3>\r\n<p>只是复制了新对象的引用，不会开辟新的内存空间。</p>\r\n<h3 id=\"拷贝\">拷贝</h3>\r\n<p>创建新对象，具体内容视拷贝类型而定（深浅拷贝）</p>\r\n<p>所以赋值并不会产生一个独立的对象单独存在，只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。</p>\r\n<p>请注意区分浅拷贝与赋值——关键在是否有新对象被创建</p>\r\n<h3 id=\"示例\">示例</h3>\r\n<p>赋值操作：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">b = a</span><br><span class=\"line\"><span class=\"comment\"># a.append(4)</span></span><br><span class=\"line\"><span class=\"comment\"># print(b) # [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\r\n<p>三种浅拷贝操作：</p>\r\n<p>切片操作：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lst1 = lst[:] 或者 lst1 = [each <span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> lst]</span><br></pre></td></tr></table></figure>\r\n<p>工厂函数：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lst1 = <span class=\"built_in\">list</span>(lst)</span><br></pre></td></tr></table></figure>\r\n<p>copy 函数：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lst1 = copy.copy(lst)</span><br></pre></td></tr></table></figure>\r\n<p>三种，都是浅拷贝</p>\r\n<h3 id=\"连续赋值\">连续赋值</h3>\r\n<p>在 python\r\n中是可以使用连续赋值的方式来一次为多个变量进行赋值的(请注意，仍然是“赋值”！)，比如：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = b = c = <span class=\"number\">1</span></span><br><span class=\"line\">a, b, c = <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\r\n<p>这些都可以完成变量的赋值，但是就有一个问题了，比如：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">3</span></span><br><span class=\"line\">a, b = <span class=\"number\">1</span>, a  <span class=\"comment\"># a = 1, b = 3</span></span><br></pre></td></tr></table></figure>\r\n<p>如果按照正常的思维逻辑，先进行 a = 1，在进行 b = a，最后 b 应该等于\r\n1，但是这里 b 应该等于\r\n3，因为<strong>在连续赋值语句中等式右边其实都是局部变量，而不是真正的变量值本身</strong>，因此，上面例子中右边的\r\na，在 python 解析的时候，只是把变量 a 的指向的变量 3 赋给 b，而不是 a=1\r\n之后 a 的结果。这里有一个 Leetcode 里链表的例子：</p>\r\n<blockquote>\r\n<p>假如要对一个链表进行翻转，就比如把 1—&gt;2-&gt;3-&gt;4 转化为\r\n4-&gt;3-&gt;2-&gt;1</p>\r\n</blockquote>\r\n<p>对于这个问题很简单，只要反转指针就可以了，假如链表结构为：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ListNode</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        self.val = x</span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = None1234</span><br></pre></td></tr></table></figure>\r\n<p>我们可以用很简单的三行代码完成这个过程：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">reverseList</span>(<span class=\"params\">self, head</span>):</span><br><span class=\"line\">        L = ListNode(<span class=\"built_in\">float</span>(<span class=\"string\">&quot;-inf&quot;</span>))</span><br><span class=\"line\">        <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">            L.<span class=\"built_in\">next</span>, head.<span class=\"built_in\">next</span>, head = head, L.<span class=\"built_in\">next</span>, head.<span class=\"built_in\">next</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> L.next12345</span><br></pre></td></tr></table></figure>\r\n<p>这里的 L 是指向一个新建的结点，因为 python\r\n没有指针的概念，所以用一个额外的结点来代替头指针，这里的核心代码就是中间那一行三个变量的连续赋值，如果单独一句句来理解的话，最后肯定是想不通的，在这里，假设\r\nhead 结点是链表串’1-&gt;2-&gt;3-&gt;4’的头结点，先用新的 L 结点的 next\r\n指针指向 head 的第一个结点‘1’，之后将 L.next(第一次也就是空)赋给了 head\r\n的 next 指针，之后再把 head 的 next 指针（注意，这里的 next\r\n指针还是指向‘2’的，而不是空）赋给 head，相当于 next\r\n向前移一位，这一步相当于一个串变成了两个：</p>\r\n<blockquote>\r\n<p>L：‘-inf’-&gt;‘1’</p>\r\n<p>head：‘2’-&gt;‘3’-&gt;‘4’-&gt;‘5’</p>\r\n</blockquote>\r\n","text":"深浅拷贝概念与使用 Reference： 彻底理解 Python 中的\"指针\"_杰克小麻雀的博客-CSDN 博客_python 有指针吗 deep copy and shallow copy 浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">深浅拷贝概念与使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#deep-copy-and-shallow-copy\"><span class=\"toc-text\">deep copy and shallow copy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#examples\"><span class=\"toc-text\">examples</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#shallow-copy\"><span class=\"toc-text\">shallow copy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#code\"><span class=\"toc-text\">code</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#explanations\"><span class=\"toc-text\">explanations</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#deep-copy\"><span class=\"toc-text\">deep copy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#code-1\"><span class=\"toc-text\">code</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#explanation\"><span class=\"toc-text\">explanation</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E4%BE%8B\"><span class=\"toc-text\">特例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">赋值与拷贝的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">拷贝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">连续赋值</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Birthday Paradox","uid":"b0298187d3b43e42af9c0e2b93f65724","slug":"Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T14:27:36.000Z","comments":true,"path":"api/articles/Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"生日悖论-birthday paradox 一个很简单的概率关系，由于其反直觉而称为“悖论”： 一个房间要多少人，则两个人的生日相同的概率 对应情况 所需人数 大于50%？ 23人 大于70%？ 30人 大于97%？ 50人 大于99%？ 57人 可以发现，概率大于99%所需的人...","link":"","photos":[],"count_time":{"symbolsCount":966,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"requirements.txt in Python project","uid":"9f9ee0afa6efd648aa340428f380e2d6","slug":"Language Learning/Python/Requirements.txt","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T20:03:30.000Z","comments":true,"path":"api/articles/Language Learning/Python/Requirements.txt.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"requirements.txt in Python project 写 python 程序的时候，我们经常的会下载很多外部模块，当我们编写完成后，准备在其他设备上部署的时候，那么新设备上需要安装我当前环境下的所有包——非常麻烦 我们可以利用 pip 来生成一个 requirem...","link":"","photos":[],"count_time":{"symbolsCount":933,"symbolsTime":"1 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}