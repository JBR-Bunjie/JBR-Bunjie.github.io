{"title":"Python 深浅拷贝概念与使用","uid":"2ae8bf5d7ed3f9dc8f4a04292dc96322","slug":"Language Learning/Python/Python拷贝与赋值","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T20:01:03.000Z","comments":true,"path":"api/articles/Language Learning/Python/Python拷贝与赋值.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"深浅拷贝概念与使用\"><a href=\"#深浅拷贝概念与使用\" class=\"headerlink\" title=\"深浅拷贝概念与使用\"></a>深浅拷贝概念与使用</h1><h2 id=\"Reference：\"><a href=\"#Reference：\" class=\"headerlink\" title=\"Reference：\"></a>Reference：</h2><ul>\n<li><a href=\"https://blog.csdn.net/yushuaigee/article/details/96745994\">彻底理解 Python 中的”指针”_杰克小麻雀的博客-CSDN 博客_python 有指针吗</a></li>\n</ul>\n<h2 id=\"deep-copy-and-shallow-copy\"><a href=\"#deep-copy-and-shallow-copy\" class=\"headerlink\" title=\"deep copy and shallow copy\"></a>deep copy and shallow copy</h2><p>浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用</p>\n<p>深拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中</p>\n<h2 id=\"examples\"><a href=\"#examples\" class=\"headerlink\" title=\"examples\"></a>examples</h2><h3 id=\"shallow-copy\"><a href=\"#shallow-copy\" class=\"headerlink\" title=\"shallow copy\"></a>shallow copy</h3><h4 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">list1 &#x3D; [[1, 2], (30, 40)]\nlist2 &#x3D; list(list1)\n\nlist1.append(100)\nprint(&quot;list1:&quot;,list1)  # [[1, 2], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nlist1[0].append(3)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2, 3], (30, 40)]\n\nlist1[1] +&#x3D; (50, 60)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40, 50, 60), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2, 3], (30, 40)]</code></pre>\n\n<h4 id=\"explanations\"><a href=\"#explanations\" class=\"headerlink\" title=\"explanations\"></a>explanations</h4><p>in this program, we initial a list: <code>list1</code> first which contains two elements: a list and a tuple.然后对 list1 执行浅拷贝，赋予 list2。因为浅拷贝里的元素是对原对象元素的引用，因此 list2 中的元素和 list1 指向同一个列表和元组对象。</p>\n<p>next，<code>list1.append(100)</code>. 表示对 list1 的列表新增元素 100。这个操作不会对 list2 产生任何影响，因为 list2 和 list1 作为整体是两个不同的对象，并不共享内存地址。操作过后 list2 不变，list1 会发生改变。</p>\n<p>then，<code>list1[0].append(3)</code> 表示对 list1 中的第一个列表新增元素 3。因为 list2 是 list1 的浅拷贝，list2 中的第一个元素和 list1 中的第一个元素，共同指向同一个列表，因此 list2 中的第一个列表也会相对应的新增元素 3。</p>\n<p>at last, <code>list1[1] += (50, 60)</code>，因为元组是不可变的，这里表示对 list1 中的第二个元组拼接，然后重新创建了一个新元组作为 list1 中的第二个元素，而 list2 中没有引用新元组，因此 list2 并不受影响。</p>\n<h3 id=\"deep-copy\"><a href=\"#deep-copy\" class=\"headerlink\" title=\"deep copy\"></a>deep copy</h3><h4 id=\"code-1\"><a href=\"#code-1\" class=\"headerlink\" title=\"code\"></a>code</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import copy\nlist1 &#x3D; [[1, 2], (30, 40)]\nlist2 &#x3D; copy.deepcopy(list1)\n\nlist1.append(100)\nprint(&quot;list1:&quot;,list1)  # [[1, 2], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nlist1[0].append(3)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nlist1[1] +&#x3D; (50, 60)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40, 50, 60), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]</code></pre>\n\n<h4 id=\"explanation\"><a href=\"#explanation\" class=\"headerlink\" title=\"explanation\"></a>explanation</h4><p>just as the example code above, no matter how the list1 changes, list2 remains itself. 因为此时的 list1 和 list2 完全独立，没有任何联系。</p>\n<h2 id=\"特例\"><a href=\"#特例\" class=\"headerlink\" title=\"特例\"></a>特例</h2><p>如果被深拷贝对象中存在指向自身的引用会怎么样？</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import copy\nlist1 &#x3D; [1]\nlist1.append(list1)\nprint(list1)  # [1, [...]]\n\nlist2 &#x3D; copy.deepcopy(list1)\nprint(list2)  # [1, [...]]</code></pre>\n\n<p>此例子中，列表 list1 中有指向自身的引用，因此 list1 是一个无限嵌套的列表。但是当深度拷贝 list1 到 list2 后，程序并没有出现栈溢出的现象。这是为什么呢？</p>\n<p>-&gt;因为 deepcopy 会自动维护一个字典，记录已经拷贝的对象与其 ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回。通过查看 deepcopy 函数实现的源码就会明白：</p>\n<h2 id=\"赋值与拷贝的关系\"><a href=\"#赋值与拷贝的关系\" class=\"headerlink\" title=\"赋值与拷贝的关系\"></a>赋值与拷贝的关系</h2><h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><p>只是复制了新对象的引用，不会开辟新的内存空间。</p>\n<h3 id=\"拷贝\"><a href=\"#拷贝\" class=\"headerlink\" title=\"拷贝\"></a>拷贝</h3><p>创建新对象，具体内容视拷贝类型而定（深浅拷贝）</p>\n<p>所以赋值并不会产生一个独立的对象单独存在，只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。</p>\n<p>请注意区分浅拷贝与赋值——关键在是否有新对象被创建</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>赋值操作：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">a &#x3D; [1, 2, 3]\n\nb &#x3D; a\n# a.append(4)\n# print(b) # [1, 2, 3, 4]</code></pre>\n\n<p>三种浅拷贝操作：</p>\n<p>切片操作：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">lst1 &#x3D; lst[:] 或者 lst1 &#x3D; [each for each in lst]</code></pre>\n\n<p>工厂函数：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">lst1 &#x3D; list(lst)</code></pre>\n\n<p>copy 函数：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">lst1 &#x3D; copy.copy(lst)</code></pre>\n\n<p>三种，都是浅拷贝</p>\n<h3 id=\"连续赋值\"><a href=\"#连续赋值\" class=\"headerlink\" title=\"连续赋值\"></a>连续赋值</h3><p>在 python 中是可以使用连续赋值的方式来一次为多个变量进行赋值的(请注意，仍然是“赋值”！)，比如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">a &#x3D; b &#x3D; c &#x3D; 1\na, b, c &#x3D; 1, 1, 1</code></pre>\n\n<p>这些都可以完成变量的赋值，但是就有一个问题了，比如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">a &#x3D; 3\na, b &#x3D; 1, a  # a &#x3D; 1, b &#x3D; 3</code></pre>\n\n<p>如果按照正常的思维逻辑，先进行 a &#x3D; 1，在进行 b &#x3D; a，最后 b 应该等于 1，但是这里 b 应该等于 3，因为<strong>在连续赋值语句中等式右边其实都是局部变量，而不是真正的变量值本身</strong>，因此，上面例子中右边的 a，在 python 解析的时候，只是把变量 a 的指向的变量 3 赋给 b，而不是 a&#x3D;1 之后 a 的结果。这里有一个 Leetcode 里链表的例子：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>假如要对一个链表进行翻转，就比如把 1—&gt;2-&gt;3-&gt;4 转化为 4-&gt;3-&gt;2-&gt;1</p></blockquote>\n<p>对于这个问题很简单，只要反转指针就可以了，假如链表结构为：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class ListNode:\n    def __init__(self, x):\n        self.val &#x3D; x\n        self.next &#x3D; None1234</code></pre>\n\n<p>我们可以用很简单的三行代码完成这个过程：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def reverseList(self, head):\n        L &#x3D; ListNode(float(&quot;-inf&quot;))\n        while head:\n            L.next, head.next, head &#x3D; head, L.next, head.next\n        return L.next12345</code></pre>\n\n<p>这里的 L 是指向一个新建的结点，因为 python 没有指针的概念，所以用一个额外的结点来代替头指针，这里的核心代码就是中间那一行三个变量的连续赋值，如果单独一句句来理解的话，最后肯定是想不通的，在这里，假设 head 结点是链表串’1-&gt;2-&gt;3-&gt;4’的头结点，先用新的 L 结点的 next 指针指向 head 的第一个结点‘1’，之后将 L.next(第一次也就是空)赋给了 head 的 next 指针，之后再把 head 的 next 指针（注意，这里的 next 指针还是指向‘2’的，而不是空）赋给 head，相当于 next 向前移一位，这一步相当于一个串变成了两个：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>L：‘-inf’-&gt;‘1’</p>\n<p>head：‘2’-&gt;‘3’-&gt;‘4’-&gt;‘5’</p></blockquote>\n","text":"深浅拷贝概念与使用Reference： 彻底理解 Python 中的”指针”_杰克小麻雀的博客-CSDN 博客_python 有指针吗 deep copy and shallow copy浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用 深...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">深浅拷贝概念与使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reference%EF%BC%9A\"><span class=\"toc-text\">Reference：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#deep-copy-and-shallow-copy\"><span class=\"toc-text\">deep copy and shallow copy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#examples\"><span class=\"toc-text\">examples</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#shallow-copy\"><span class=\"toc-text\">shallow copy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#code\"><span class=\"toc-text\">code</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#explanations\"><span class=\"toc-text\">explanations</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#deep-copy\"><span class=\"toc-text\">deep copy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#code-1\"><span class=\"toc-text\">code</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#explanation\"><span class=\"toc-text\">explanation</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E4%BE%8B\"><span class=\"toc-text\">特例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">赋值与拷贝的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">拷贝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">连续赋值</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"日志格式","uid":"743056c4369a9fa1f8f105370c847ec2","slug":"Dev/Theory/日志规范","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T19:43:25.000Z","comments":true,"path":"api/articles/Dev/Theory/日志规范.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"日志格式通用前缀 class.method LEVEL | KEY | SUB_KEY | param1&#x3D;x;param2&#x3D;x;… | rs&#x3D;JSON | traceId&#x3D;xxx[ | 其它自定义日志] KEY：标示业务领域，如“领券” S...","link":"","photos":[],"count_time":{"symbolsCount":645,"symbolsTime":"1 mins."},"categories":[{"name":"Theroy","slug":"Theroy","count":5,"path":"api/categories/Theroy.json"}],"tags":[{"name":"Theroy","slug":"Theroy","count":5,"path":"api/tags/Theroy.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"selenium自动化爬虫","uid":"46c2c3df1cbb91d145ce37d8e3350c78","slug":"Language Learning/Python/selenium自动化","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T20:03:21.000Z","comments":true,"path":"api/articles/Language Learning/Python/selenium自动化.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"目标：使用 selenium 来解决网页中的大量同质化人工操作内容零：想好该怎么做：关于指定网站：网站是网盘网站，其文件有密码保护，即每个文件都有不同且无规律的受保护地址；同时，这些网页的操作完全重复。 我们可以使用 selenium 来完成自动化代替重复劳动。 关于 selen...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}