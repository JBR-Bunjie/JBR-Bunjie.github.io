{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/selenium自动化","date":"2023-03-07T16:14:45.611Z","updated":"2021-08-22T15:04:16.000Z","comments":true,"path":"api/articles/Language Learning/Python/selenium自动化.json","keywords":null,"cover":null,"content":"<h1 id=\"目标：使用selenium来解决网页中的大量同质化人工操作内容\"><a href=\"#目标：使用selenium来解决网页中的大量同质化人工操作内容\" class=\"headerlink\" title=\"目标：使用selenium来解决网页中的大量同质化人工操作内容\"></a>目标：使用selenium来解决网页中的大量同质化人工操作内容</h1><h2 id=\"零：想好该怎么做：\"><a href=\"#零：想好该怎么做：\" class=\"headerlink\" title=\"零：想好该怎么做：\"></a>零：想好该怎么做：</h2><h3 id=\"关于指定网站：\"><a href=\"#关于指定网站：\" class=\"headerlink\" title=\"关于指定网站：\"></a>关于指定网站：</h3><p>网站是网盘网站，其文件有密码保护，即每个文件都有不同且无规律的受保护地址；同时，这些网页的操作完全重复。</p>\n<p>我们可以使用selenium来完成自动化代替重复劳动。</p>\n<h3 id=\"关于selenium\"><a href=\"#关于selenium\" class=\"headerlink\" title=\"关于selenium\"></a>关于selenium</h3><ul>\n<li>需要使用浏览器的自动化driver</li>\n<li>需要使用键盘输入模拟模块</li>\n<li>需要使用鼠标输入模拟模块</li>\n<li>需要事先了解需要操作的网页元素对象的路径</li>\n</ul>\n<h2 id=\"一、准备工作：将所有需要爬取的地址整合到一个列表里：\"><a href=\"#一、准备工作：将所有需要爬取的地址整合到一个列表里：\" class=\"headerlink\" title=\"一、准备工作：将所有需要爬取的地址整合到一个列表里：\"></a>一、准备工作：将所有需要爬取的地址整合到一个列表里：</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import os\n\npath &#x3D; r&quot;D:\\Project\\Code Trainning\\Learning\\PythonDemo&quot;\nfilename &#x3D; r&quot;addresslist.txt&quot; # 存储所有网址的文件\ncode &#x3D; &quot;849227&quot; # 网站文件的密码\n\nos.chdir(path)\nos.getcwd()\n\nf &#x3D; open(file&#x3D;filename, mode&#x3D;&#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)\nFileContent &#x3D; f.readlines()\nf.close()\n\nAddressList &#x3D; []\nt &#x3D; 1\nfor i in FileContent:\n    if t % 2 &#x3D;&#x3D; 0 and t % 4 !&#x3D; 0:\n        AddressList.append(i)\n    t &#x3D; t + 1\n\n# for i in AddressList:\n#     print(i)</code></pre>\n\n<h2 id=\"二、用selenium来打开这些网页并模拟操作：\"><a href=\"#二、用selenium来打开这些网页并模拟操作：\" class=\"headerlink\" title=\"二、用selenium来打开这些网页并模拟操作：\"></a>二、用selenium来打开这些网页并模拟操作：</h2><h3 id=\"打开网页：\"><a href=\"#打开网页：\" class=\"headerlink\" title=\"打开网页：\"></a>打开网页：</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from selenium import webdriver # selenium.webdriver模块提供了所有WebDriver的实现\nfrom selenium.webdriver.common.keys import Keys # Keys类提供了键盘的代码，用来输入特殊的键盘符（如：回车,ALT,F1等等）\n\t# 比如，在上条语句输入之后，可以使用Keys.ENTER来模拟输入回车符\nimport time\n\nwd &#x3D; webdriver.Edge(r&quot;D:\\language\\EdgeDriver\\msedgedriver.exe&quot;) # 创建一个Edge浏览器的实例\n\ntry:\n    for i in AddressList:\n        wd.get(i)\n        \n        …… # 接第二步\n\n        time.sleep(60)\nexcept Exception as e:\n    print(e)\n\n    # driver.get方法会导向给定的URL的页面，WebDriver会等待页面完全加载完(就是onload函数被触发了)，才把程序的控制权交给你的测试或者脚本。 \n    # 但是！如果 你的页面用了太多的AJAX，那么这个机制将会失效，因为原本完整的页面只占用很小一部分时间，而ajax是“页面完成之后的操作”，selenium根本不知道页面到底是什么时候加载完。就像是requests面对众多ajax存在的网页一样</code></pre>\n\n<h3 id=\"对网页进行操作\"><a href=\"#对网页进行操作\" class=\"headerlink\" title=\"对网页进行操作\"></a>对网页进行操作</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">time.sleep(5) # 最差的实现方式，最好使用隐式等待\n\n\ninput_box1 &#x3D; wd.find_element_by_id(&#39;passcode&#39;) # 找到输入box\ninput_box1.send_keys(code) # 输入验证码，send_keys函数能模拟大部分的键盘输入，其他的需要Keys类来实现\nconfirm_button1 &#x3D; wd.find_element_by_xpath(r&quot;&#x2F;html&#x2F;body&#x2F;main&#x2F;div&#x2F;div[1]&#x2F;div&#x2F;div&#x2F;div&#x2F;div[2]&#x2F;div[2]&#x2F;button&quot;)\nconfirm_button1.click() # 模拟鼠标电机\n\ntime.sleep(5) # 如上\n\nconfirm_button2 &#x3D; wd.find_element_by_xpath(r&quot;&#x2F;html&#x2F;body&#x2F;main&#x2F;div&#x2F;div&#x2F;div[4]&#x2F;div[1]&#x2F;div[2]&#x2F;button&quot;)\nconfirm_button2.click()\n\ntime.sleep(180)\nwd.find_element_by_tag_name(&#39;body&#39;).send_keys(Keys.Control + &#39;t&#39;) # 模拟组合键\n\n&quot;&quot;&quot;\n显式Waits\n\t+ 用WebDriverWait结合ExpectedCondition来实现：\n\t\telement &#x3D; selenium.webdriver.support.ui.WebDriverWait(wd, 10).unitl(\n\t\t\tselenium.webdriver.support.expected_conditions.presence_of_located(By.ID, &quot;anyIDisOK&quot;)\n\t\t) \n\t\t# 这段代码将会等待10秒，并在等待过程中，每0.5s就调用一下ExpectedCondition，如果成功则立即返回，否则持续重试直到超时报错，报出错误TimeoutException\n\t+ 显示Wait中有许多预期条件，这样子就无需自己编写expected_condition（见文档\n\t\n隐式Waits\nplease forget that，but when I understand，I will c\n&quot;&quot;&quot;</code></pre>\n\n\n\n<h3 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">wd.close() # 或者 wb.quit()</code></pre>\n\n","text":"目标：使用selenium来解决网页中的大量同质化人工操作内容零：想好该怎么做：关于指定网站：网站是网盘网站，其文件有密码保护，即每个文件都有不同且无规律的受保护地址；同时，这些网页的操作完全重复。 我们可以使用selenium来完成自动化代替重复劳动。 关于selenium 需...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87%EF%BC%9A%E4%BD%BF%E7%94%A8selenium%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%A4%A7%E9%87%8F%E5%90%8C%E8%B4%A8%E5%8C%96%E4%BA%BA%E5%B7%A5%E6%93%8D%E4%BD%9C%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">目标：使用selenium来解决网页中的大量同质化人工操作内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%B6%EF%BC%9A%E6%83%B3%E5%A5%BD%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9A\"><span class=\"toc-text\">零：想好该怎么做：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%AE%9A%E7%BD%91%E7%AB%99%EF%BC%9A\"><span class=\"toc-text\">关于指定网站：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Eselenium\"><span class=\"toc-text\">关于selenium</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%EF%BC%9A%E5%B0%86%E6%89%80%E6%9C%89%E9%9C%80%E8%A6%81%E7%88%AC%E5%8F%96%E7%9A%84%E5%9C%B0%E5%9D%80%E6%95%B4%E5%90%88%E5%88%B0%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E9%87%8C%EF%BC%9A\"><span class=\"toc-text\">一、准备工作：将所有需要爬取的地址整合到一个列表里：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E7%94%A8selenium%E6%9D%A5%E6%89%93%E5%BC%80%E8%BF%99%E4%BA%9B%E7%BD%91%E9%A1%B5%E5%B9%B6%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%EF%BC%9A\"><span class=\"toc-text\">二、用selenium来打开这些网页并模拟操作：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%EF%BC%9A\"><span class=\"toc-text\">打开网页：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E7%BD%91%E9%A1%B5%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">对网页进行操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9D%9F\"><span class=\"toc-text\">结束</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/使用python解决文件自动化处理的方案","date":"2023-03-07T16:14:45.634Z","updated":"2022-02-24T13:21:28.000Z","comments":true,"path":"api/articles/Language Learning/Python/使用python解决文件自动化处理的方案.json","keywords":null,"cover":null,"text":"使用Python解决文件自动化改名和命名原因：获取压缩文件的实际名称：压缩文件名称使用了随机字符，而原文件夹作为压缩文件的根目录来保存，为了避免打开压缩文件才能知道打开的到底是哪个文件，需要将压缩文件内的文件夹名复制出来为外部压缩文件改名 采用方案：解压缩模块：zipfileof...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/Requirements.txt","date":"2023-03-07T16:14:45.608Z","updated":"2022-02-09T08:50:30.000Z","comments":true,"path":"api/articles/Language Learning/Python/Requirements.txt.json","keywords":null,"cover":[],"text":"requirements.txt in Python project写python程序的时候，我们经常的会下载很多外部模块，当我们编写完成后，准备在其他设备上部署的时候，那么新设备上需要安装我当前环境下的所有包——非常麻烦 我们可以利用pip来生成一个requirements.t...","link":"","photos":[],"count_time":{"symbolsCount":879,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}