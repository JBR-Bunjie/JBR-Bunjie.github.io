{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/使用python解决文件自动化处理的方案及zipfile模块的介绍","date":"2023-03-07T16:14:45.637Z","updated":"2022-02-24T13:21:30.000Z","comments":true,"path":"api/articles/Language Learning/Python/使用python解决文件自动化处理的方案及zipfile模块的介绍.json","keywords":null,"cover":null,"content":"<h2\r\nid=\"使用python解决文件自动化改名和命名\">使用Python解决文件自动化改名和命名</h2>\r\n<h3 id=\"原因获取压缩文件的实际名称\">原因：获取压缩文件的实际名称：</h3>\r\n<p>压缩文件名称使用了随机字符，而原文件夹作为压缩文件的根目录来保存，为了避免打开压缩文件才能知道打开的到底是哪个文件，需要将压缩文件内的文件夹名复制出来为外部压缩文件改名</p>\r\n<h3 id=\"采用方案\">采用方案：</h3>\r\n<h4 id=\"解压缩模块zipfile\">解压缩模块：zipfile</h4>\r\n<p>official site <a\r\nhref=\"https://docs.python.org/3/library/zipfile.html\">zipfile — Work\r\nwith ZIP archives — Python 3.9.6 documentation</a></p>\r\n<ol type=\"1\">\r\n<li>提取所有压缩文件的实际名称</li>\r\n</ol>\r\n<h4 id=\"文件处理模块os\">文件处理模块：os</h4>\r\n<ol type=\"1\">\r\n<li>确定实际工作目录</li>\r\n<li>找到所有需要改名的文件并存储</li>\r\n<li>在压缩文件中提取完实际名称后对源文件进行改名</li>\r\n</ol>\r\n<h4 id=\"文字提取模块正则表达式re\">文字提取模块（正则表达式）：re</h4>\r\n<ol type=\"1\">\r\n<li>对路径使用正则表达式来处理文件</li>\r\n</ol>\r\n<p>程序实例：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import os\nimport zipfile\nimport re\n\nos.getcwd()\t\t\t# 等待结果\npath &#x3D; r&quot;&quot;\t\t\t# 输入要处理文件的路径\nos.chdir(path)\t\t# 进入目标目录\n\nA &#x3D; []\nfor i in os.walk(path):\n    A.append(i)\n    \nB &#x3D; A[0][2] # B按顺序存储了需要修改的所有文件，注意A[0][2]的真正含义！\n\n# 注意，B可能包含已经修改了的文件，这时有两个方案\n\t# 1. （通过操作）规避这些文件，单独处理（费时费力，但是可以在一个文件夹下完成所有操作，也符合我个人直觉，毕竟是存在某些文件没有\n\t# 2. 将这些文件全部复制到新文件夹下保持文件纯净\n# 采用方案2\n\nC &#x3D; [] # 存储真实名称\n\nfor i in B:\n    with zipfile.ZipFile(i, &#39;r&#39;) as z:\n        for i in z.namelist():\n            C.append(i)\n        z.close() # 可能会有几百行？_(:з」∠)_，总之，拿下了就行\n\nget_name_rule &#x3D; re.compile(r&quot; &quot;, re.S) # 正则表达式的筛选规则\nD &#x3D; []\nfor i in C:\n\tif re.findall(get_name_rule, i) !&#x3D; []:\n        D.append(re.findall(get_name_rule, i)[0])\n\n&#39;&#39;&#39;\nE &#x3D; []\nrule_extended &#x3D; re.compile(r&quot; &quot;, re.S)\nfor i in D:\n    if re.findall(rule_extended, i) !&#x3D; []:\n    \tE.append(re.findall(rule_extended, i)[0])\n    else:\n    \tE.append(i)\n补充提取，将所有违规字符如&#39;&#x2F;&#39;，&#39;*&#39;等全部剔除\n&#39;&#39;&#39;\n\ncount &#x3D; 0\nfor i in B:\n    temp &#x3D; E[count] + &quot;.zip&quot; \t# 注意后缀！\n    os.rename(i, temp)\n    count &#x3D; count + 1\n\n    \n    \n    \n    \n以上全部！</code></pre>\r\n<h2 id=\"有关zipfile的常用方法\">有关<code>zipfile</code>的常用方法：</h2>\r\n<ol type=\"1\">\r\n<li><p>一看就懂：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import zipfile\nf &#x3D; zipfile.ZipFile(&#39;filename.zip&#39;, &#39;w&#39; ,zipfile.ZIP_DEFLATED)\nf.write(&#39;file1.txt&#39;)\nf.write(&#39;file2.doc&#39;)\nf.write(&#39;file3.rar&#39;)\nf.close()\nf &#x3D; zipfile.ZipFile(&#39;filename&#39;)\nf.extractall()\nf.close()</code></pre>\r\n<p>1.1 <code>zipfile.</code><strong>ZipFile</strong>(<em>file</em>,\r\n<em>mode='r'</em>, <em>compression=ZIP_STORED</em>,\r\n<em>allowZip64=True</em>, <em>compresslevel=None</em>, **<em>,\r\n</em>strict_timestamps=True*)</p>\r\n<p>Open a ZIP file, where <em>file</em> can be a path to a file (a\r\nstring), a file-like object or a <a\r\nhref=\"https://docs.python.org/3/glossary.html#term-path-like-object\">path-like\r\nobject</a>.</p>\r\n<blockquote>\r\n<p>fileName是没有什么疑问的了。</p>\r\n<p>mode和一般的文件操作一样,'r'表示打开一个存在的只读ZIP文件；'w'表示清空并打开一个只写的ZIP文件，或创建一个只写的ZIP文件；'a'表示打开一个ZIP文件，并添加内容。</p>\r\n</blockquote></li>\r\n</ol>\r\n<blockquote>\r\n<blockquote>\r\n<p>The <em>mode</em> parameter should be <code>'r'</code> to read an\r\nexisting file,</p>\r\n<p><code>'w'</code> to truncate and write a new file,</p>\r\n<p><code>'x'</code> to exclusively create and write a new file.</p>\r\n<blockquote>\r\n<p>If <em>mode</em> is <code>'x'</code> and <em>file</em> refers to an\r\nexisting file, a <a\r\nhref=\"https://docs.python.org/3/library/exceptions.html#FileExistsError\"><code>FileExistsError</code></a>\r\nwill be raised.</p>\r\n</blockquote>\r\n<p><code>'a'</code> to append to an existing file,</p>\r\n<blockquote>\r\n<p>If <em>mode</em> is <code>'a'</code> and <em>file</em> refers to an\r\nexisting ZIP file, then additional files are added to it.</p>\r\n<p>If <em>file</em> does not refer to a ZIP file, then a new ZIP archive\r\nis appended to the file. This is meant for adding a ZIP archive to\r\nanother file (such as <code>python.exe</code>).</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#比如：我有一个new.txt文件\na &#x3D; zipfile.ZipFile(&#39;new.txt&#39;, &#39;a&#39;) # 此时new.txt文件会被归档，new.txt会被改写为zip文件\na.write(&#39;new.txt&#39;)\na.close()\n# 并在外侧改写new.txt的后缀为.zip，发现存在是一个正式的.zip文件且存在一个new.txt</code></pre>\r\n<p>If <em>mode</em> is <code>'a'</code> and the file does not exist at\r\nall, it is created.</p>\r\n</blockquote>\r\n<p>If <em>mode</em> is <code>'r'</code> or <code>'a'</code>, the file\r\nshould be seekable.</p>\r\n</blockquote>\r\n</blockquote>\r\n<blockquote>\r\n<p>compression表示压缩格式，可选的压缩格式只有2个：ZIP_STORE;ZIP_DEFLATED。ZIP_STORE是默认的，表示不压缩；ZIP_DEFLATED表示压缩。</p>\r\n<p>allowZip64为True时，表示支持64位的压缩，一般而言，在所压缩的文件大于2G时，会用到这个选项；默认情况下，该值为False，因为Unix系统不支持。</p>\r\n</blockquote>\r\n<p>1.2 <code>zipfile</code>.<strong>close</strong>()</p>\r\n<blockquote>\r\n<p>你写入的任何文件在关闭之前不会真正写入磁盘。</p>\r\n</blockquote>\r\n<p>1.3 <code>zipfile</code>.<strong>write</strong>(filename[, arcname[,\r\ncompress_type]])</p>\r\n<blockquote>\r\n<p>acrname是压缩文件中该文件的名字，默认情况下和filename一样</p>\r\n<p>compress_type的存在是因为zip文件允许被压缩的文件可以有不同的压缩类型。</p>\r\n</blockquote>\r\n<p>1.4 <code>zipfile</code>.<strong>extractall</strong>([path[, member[,\r\npassword]]])</p>\r\n<blockquote>\r\n<p>path解压缩目录</p>\r\n<p>member需要解压缩的文件名儿列表</p>\r\n<p>password当zip文件有密码时需要该选项</p>\r\n<blockquote>\r\n<p>Extract all members from the archive to the current working\r\ndirectory.</p>\r\n<p><em>path</em> specifies a different directory to extract to.\r\n<em>members</em> is optional and must be a subset of the list returned\r\nby <a\r\nhref=\"https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile.namelist\"><code>namelist()</code></a>.\r\n<em>pwd</em> is the password used for encrypted files.</p>\r\n</blockquote>\r\n</blockquote>\r\n<ol type=\"1\">\r\n<li><p><code>ZipFile.</code><strong>namelist</strong>()</p></li>\r\n<li></li>\r\n</ol>\r\n","text":"使用Python解决文件自动化改名和命名 原因：获取压缩文件的实际名称： 压缩文件名称使用了随机字符，而原文件夹作为压缩文件的根目录来保存，为了避免打开压缩文件才能知道打开的到底是哪个文件，需要将压缩文件内的文件夹名复制出来为外部压缩文件改名 采用方案： 解压缩模块：zipfil...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8python%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E6%94%B9%E5%90%8D%E5%92%8C%E5%91%BD%E5%90%8D\"><span class=\"toc-text\">使用Python解决文件自动化改名和命名</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0%E8%8E%B7%E5%8F%96%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E9%99%85%E5%90%8D%E7%A7%B0\"><span class=\"toc-text\">原因：获取压缩文件的实际名称：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%87%E7%94%A8%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">采用方案：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%A8%A1%E5%9D%97zipfile\"><span class=\"toc-text\">解压缩模块：zipfile</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97os\"><span class=\"toc-text\">文件处理模块：os</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E5%AD%97%E6%8F%90%E5%8F%96%E6%A8%A1%E5%9D%97%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre\"><span class=\"toc-text\">文字提取模块（正则表达式）：re</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%85%B3zipfile%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">有关zipfile的常用方法：</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/依赖项管理","date":"2023-03-07T16:14:45.640Z","updated":"2022-09-14T10:08:28.000Z","comments":true,"path":"api/articles/Language Learning/Python/依赖项管理.json","keywords":null,"cover":null,"text":"依赖项管理：Requirements.txt, Setup.py及更多 Write a setup.py remember what you use, or try to use some tools to control the dependenies efficiently ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Python/使用python解决文件自动化处理的方案","date":"2023-03-07T16:14:45.634Z","updated":"2022-02-24T13:21:28.000Z","comments":true,"path":"api/articles/Language Learning/Python/使用python解决文件自动化处理的方案.json","keywords":null,"cover":null,"text":"使用Python解决文件自动化改名和命名 原因：获取压缩文件的实际名称： 压缩文件名称使用了随机字符，而原文件夹作为压缩文件的根目录来保存，为了避免打开压缩文件才能知道打开的到底是哪个文件，需要将压缩文件内的文件夹名复制出来为外部压缩文件改名 采用方案： 解压缩模块：zipfil...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}