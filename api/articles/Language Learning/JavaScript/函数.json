{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/JavaScript/函数","date":"2023-03-08T00:25:59.867Z","updated":"2022-02-12T09:25:42.000Z","comments":true,"path":"api/articles/Language Learning/JavaScript/函数.json","keywords":null,"cover":null,"content":"<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arrow_functions\">箭头函数 - JavaScript | MDN (mozilla.org)</a></p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p><strong>箭头函数表达式</strong>的语法比<code>函数表达式</code>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>\n<p><strong>注意箭头函数 != 匿名函数</strong></p>\n<p>箭头函数是js对<a href=\"https://en.wikipedia.org/wiki/Anonymous_function\">Anonymous function - Wikipedia</a>的实现，它属于匿名函数的一种。</p>\n<p><del>一般而言匿名函数anonymous function == lambda表达式，但js比较特殊</del></p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">const materials &#x3D; [\n  &#39;Hydrogen&#39;,\n  &#39;Helium&#39;,\n  &#39;Lithium&#39;,\n  &#39;Beryllium&#39;\n];\n\nconsole.log(materials.map(material &#x3D;&gt; material.length));\n&#x2F;&#x2F; expected output: Array [8, 6, 7, 9]</code></pre>\n\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">(param1, param2, …, paramN) &#x3D;&gt; &#123; statements &#125;\n\n(param1, param2, …, paramN) &#x3D;&gt; expression\n&#x2F;&#x2F;相当于：(param1, param2, …, paramN) &#x3D;&gt;&#123; return expression; &#125;\n\n&#x2F;&#x2F; 当只有一个参数时，圆括号是可选的：\n(singleParam) &#x3D;&gt; &#123; statements &#125;\nsingleParam &#x3D;&gt; &#123; statements &#125;\n\n&#x2F;&#x2F; 没有参数的函数应该写成一对圆括号。\n() &#x3D;&gt; &#123; statements &#125;</code></pre>\n\n\n\n<h2 id=\"函数赋值变量\"><a href=\"#函数赋值变量\" class=\"headerlink\" title=\"函数赋值变量\"></a>函数赋值变量</h2><p>就相当于给原函数换了个新名</p>\n<h3 id=\"以函数形式返回\"><a href=\"#以函数形式返回\" class=\"headerlink\" title=\"以函数形式返回\"></a>以函数形式返回</h3><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function print(val) &#123;\n    console.log(&#96;姓名是：$&#123;val&#125;&#96;);\n&#125;\nvar fn &#x3D; print; &#x2F;&#x2F; 将函数赋值给fn\nfn(&#39;angus&#39;); &#x2F;&#x2F; 姓名是：angus</code></pre>\n\n<h3 id=\"以返回值形式\"><a href=\"#以返回值形式\" class=\"headerlink\" title=\"以返回值形式\"></a>以返回值形式</h3><p>将函数返回的值赋值给<code>fn</code>，如果函数<strong>没有返回值</strong>，但又接受了，此时会返回<code>undefined</code></p>\n<p>有返回值：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function print(val) &#123;\n   return &#96;姓名是：$&#123;val&#125;&#96;;\n&#125;\nvar fn &#x3D; print(&#39;angus&#39;);\nconsole.log(fn); &#x2F;&#x2F; 姓名是：angus</code></pre>\n\n<p>无返回值：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function print(val) &#123;\n    &#96;姓名是：$&#123;val&#125;&#96;;\n&#125;\nvar fn &#x3D; print(&#39;angus&#39;);\nconsole.log(fn); &#x2F;&#x2F; undefined</code></pre>\n\n<h3 id=\"返回值可为函数\"><a href=\"#返回值可为函数\" class=\"headerlink\" title=\"返回值可为函数\"></a>返回值可为函数</h3><p>将我们定义的<code>print</code>函数返回给<code>fn</code>：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function sum() &#123;\n    var num &#x3D; 0;\n    \n    function print() &#123;\n        num +&#x3D; 2;\n        return num;\n    &#125;\n    return print; &#x2F;&#x2F; return了print函数体，并非直接return num\n&#125;\nvar fn &#x3D; sum();\nconsole.log(fn()); &#x2F;&#x2F; 2\n\n&#x2F;&#x2F; var a &#x3D; function sum() &#123;...&#125;  &#x2F;&#x2F; &#x3D;&#x3D;&#x3D; var a &#x3D; sum\n&#x2F;&#x2F; a &#x3D;&gt; sum()&#123;...&#125;\n&#x2F;&#x2F; a() &#x3D;&gt; print()&#123;...&#125;\n&#x2F;&#x2F; a()() &#x3D;&gt; 2\n\n&#x2F;&#x2F; var b &#x3D; sum()\n&#x2F;&#x2F; b &#x3D;&gt; print()&#123;...&#125;\n&#x2F;&#x2F; b() &#x3D;&gt; 2</code></pre>\n\n<p>直接执行<code>print</code>函数，没有返回：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function sum() &#123;\n    var num &#x3D; 0;\n    function print() &#123;\n        num +&#x3D; 2;\n        return num;\n    &#125;\n    print();\n&#125;\nvar fn &#x3D; sum();\nconsole.log(fn); &#x2F;&#x2F; undefined</code></pre>\n\n<h2 id=\"函数参数中的括号\"><a href=\"#函数参数中的括号\" class=\"headerlink\" title=\"函数参数中的括号\"></a>函数参数中的括号</h2><p>以此为例：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function computeLinkBreadths(&#123;nodes&#125;)&#123;...&#125;\n\nfunction computeLinkBreadths(nodes)&#123;...&#125;</code></pre>\n\n<p>解释：带大括号是指传递一个参数，参数类型为对象，里面有一个属性nodes，而不带大括号就是传递一个参数<br>这里的大括号不是块级作用域，就是单纯的表示一个对象</p>\n<p>但从使用上讲两种方式没有直接区别，但使用传递对象的方法会使今后的扩展变得很方便<br>比如如果需要增加一个参数，在传递对象的方法中只需要直接向里面添加一个属性就行了，否则就需要在后面添加一个硬性的参数，而参数越来越多，调用的时候就越来越复杂——参数顺序不能乱。</p>\n<p>另外，上面的这种写法是es6的解构赋值，可以看下阮老师的<a href=\"http://es6.ruanyifeng.com/#do...%EF%BC%8C%E5%86%85%E5%AE%B9%E4%B8%8D%E5%A4%9A%E5%85%A8%E4%B9%A6%E7%9C%8B%E4%B8%8B%E6%9D%A5%E8%A6%81%E4%B8%8D%E4%BA%86%E5%A4%9A%E4%B9%85%EF%BC%8C%E4%BD%86%E5%AF%B9%E4%BD%A0%E4%BB%8A%E5%90%8E%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BC%9A%E9%9D%9E%E5%B8%B8%E5%A4%A7%E3%80%82\">http://es6.ruanyifeng.com/#do...，内容不多全书看下来要不了多久，但对你今后的帮助会非常大。</a></p>\n<h2 id=\"arguments对象\"><a href=\"#arguments对象\" class=\"headerlink\" title=\"arguments对象\"></a>arguments对象</h2><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&gt; var b &#x3D; function(a) &#123;\n    return arguments.length ? &#96;$&#123;a&#125;&#96; : &quot;none&quot;&#125;\n&lt; undefined\n\n&gt; b()\n&lt; &#39;none&#39;\n\n&gt; b(&quot;c&quot;)\n&lt; &#39;c&#39;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>arguments</code>对象是所有（非箭头）函数中都可用的<strong>局部变量</strong>。你可以使用<code>arguments</code>对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。</p></blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments\">Arguments 对象 - JavaScript | MDN (mozilla.org)</a></p>\n","text":"箭头函数箭头函数 - JavaScript | MDN (mozilla.org) 说明箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">箭头函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">函数赋值变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A5%E5%87%BD%E6%95%B0%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">以函数形式返回</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A5%E8%BF%94%E5%9B%9E%E5%80%BC%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">以返回值形式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8F%AF%E4%B8%BA%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">返回值可为函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7\"><span class=\"toc-text\">函数参数中的括号</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#arguments%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">arguments对象</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/MARK LANGUAGE/XML","date":"2023-03-08T00:25:59.891Z","updated":"2023-03-08T02:13:05.000Z","comments":true,"path":"api/articles/Language Learning/MARK LANGUAGE/XML.json","keywords":null,"cover":null,"text":"XML 简介 – 什么是 XML？ | 菜鸟教程 (runoob.com) ","link":"","photos":[],"count_time":{"symbolsCount":38,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/JavaScript/特殊运算符","date":"2023-03-08T00:25:59.857Z","updated":"2022-02-10T14:38:11.000Z","comments":true,"path":"api/articles/Language Learning/JavaScript/特殊运算符.json","keywords":null,"cover":null,"text":"条件运算符: ?条件运算符 - JavaScript | MDN (mozilla.org) 说明条件（三元）运算符是 JavaScript 仅有的使用三个操作数的运算符。 一个条件后面会跟一个问号（?），如果条件为 true，则问号后面的表达式A将会执行； 表达式A后面跟着一个...","link":"","photos":[],"count_time":{"symbolsCount":841,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}