{"title":"计算机编码梳理","uid":"5b286fb1e51c3a9c0edf1921a9c938c7","slug":"Language Learning/Endcoding","date":"2021-05-20T18:23:23.000Z","updated":"2023-10-27T20:05:21.000Z","comments":true,"path":"api/articles/Language Learning/Endcoding.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"计算机编码梳理\"><a href=\"#计算机编码梳理\" class=\"headerlink\" title=\"计算机编码梳理\"></a>计算机编码梳理</h1><h2 id=\"ASCII码\"><a href=\"#ASCII码\" class=\"headerlink\" title=\"ASCII码\"></a>ASCII码</h2><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>这是计算机编码发展历程里的第一阶段：ASCII码，即：<code>American Standard Code for Information Interchange</code>，美国信息交换标准代码</p>\n<h4 id=\"设计思路：\"><a href=\"#设计思路：\" class=\"headerlink\" title=\"设计思路：\"></a>设计思路：</h4><p>在计算机内部存储单元的最小单位时Byte。不过Byte仍然可以细分：每一个二进制位是一个bit，有0和1两种状态。8个bit构成一个byte——所有的信息最终都表示为一个二进制的字符串。</p>\n<p>在这个基础上，如果利用0和1各代表一个状态，由于一个byte有8个bit，故总共可以表示2的8次方＝256个状态。若是每个状态对应一个符号，一个byte可以表示256个符号，也就是从0000000到11111111。</p>\n<p>根据这个思路，美国在上个世纪60年代制定了一套字符编码，用于安排控制字符、英语字符、数字等符号与二进制位之间对应的关系，形成了大名鼎鼎的ASCII码。</p>\n<p>但ASCII码一共只规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，而由于使用了8位二进制，故规定最前面的第一位二进制数则为0。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 可以访问：<a href=\"https://www.ascii-code.com/\">ASCII Code - The extended ASCII table (ascii-code.com)</a>了解</p></blockquote>\n<h4 id=\"现状：\"><a href=\"#现状：\" class=\"headerlink\" title=\"现状：\"></a>现状：</h4><p>时至今日，仍然有很多语言采用这一编码作为默认编码，比如Python2等语言</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>Python2的 默认编码是ASCII，不能识别中文字符，需要显式指定字符编码；</code><br><code>而Python3的默认编码改为了Unicode，可以识别中文字符</code></p></blockquote>\n<p>采用ASCII编码主要的字符集：Windows-1252字符集、ISO8859-1字符集</p>\n<h3 id=\"ASCII实现思路\"><a href=\"#ASCII实现思路\" class=\"headerlink\" title=\"ASCII实现思路\"></a>ASCII实现思路</h3><ul>\n<li>所有的控制字符(比如CR回车、DEL删除等)编码在0-31范围以及127中。</li>\n<li>把所有的标点符号，英文大小写全部放在32-126范围中。</li>\n</ul>\n<h3 id=\"ASCII实现形式\"><a href=\"#ASCII实现形式\" class=\"headerlink\" title=\"ASCII实现形式\"></a>ASCII实现形式</h3><ul>\n<li>0xxxx xxxx</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str &#x3D; new String(&quot;华侨永亨银行&quot;);\n&#x2F;&#x2F; 采用UTF-8编码得到字节数组\nbyte[] bytes &#x3D; str.getBytes(&quot;UTF-8&quot;);\n&#x2F;&#x2F; bytes: &#123;e5 8d 8e e4 be a8 e6 b0 b8 e4 ba a8 e9 93 b6 e8 a1 8c&#125;\n&#x2F;&#x2F; 注意第二个字节0x8d，在下面的编解码中被自动转换成了3f\n\n&#x2F;&#x2F; 采用Windows-1252解码得到字符串\nstr &#x3D; new String(bytes, &quot;Windows-1252&quot;);\n&#x2F;&#x2F; 采用windows-1252编码，还原字节数组\nbytes &#x3D; str.getBytes(&quot;Windows-1252&quot;);\n&#x2F;&#x2F; bytes: &#123;e5 3f 8e e4 be a8 e6 b0 b8 e4 ba a8 e9 93 b6 e8 a1 8c&#125;\n\n&#x2F;&#x2F; 采用UTF-8解码，预期得到原字符串\nstr &#x3D; new String(bytes, &quot;UTF-8&quot;);\n&#x2F;&#x2F; str: ???侨永亨银行,第一个字被永久性破坏\n&#x2F;&#x2F; 引自：https:&#x2F;&#x2F;blog.csdn.net&#x2F;zou8944&#x2F;article&#x2F;details&#x2F;79859112</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>不过，这个例子对Python不生效，因为python取了个巧:</p>\n<p>![image-20210910211848379](image-20210910211848379 - copy.png)</p>\n<p>![restsdafa](image-20210910211923507 - Copy.png)</p></blockquote>\n<h2 id=\"GB2312-GBK\"><a href=\"#GB2312-GBK\" class=\"headerlink\" title=\"GB2312&amp;GBK\"></a>GB2312&amp;GBK</h2><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。</p>\n<p>以中文为例，汉字有10万左右，即使是常用字也有六七千，必须得用多个字节来表示。</p>\n<p>最先诞生的是GB2312编码。对于该编码，我们只需要明白以下两点：</p>\n<ul>\n<li><p>该编码可以表示大概7000左右个字符。其中有中文及一些常见的拉丁字母等。基本可以覆盖我们日常打字使用。</p>\n</li>\n<li><p>该编码完全兼容ASCII码，计算机去读的时候首先判断最高位，如果是0，那么这个字符只占用一个字节，表示的内容跟ASCII码表示的一样。如果该字符最高位是1，那么该字节连同下一个字节表示一个中文汉字。所以平常咱们常说的英文一个字节，中文两个字节其实是从这里来的。</p>\n</li>\n</ul>\n<h3 id=\"GB2312实现形式\"><a href=\"#GB2312实现形式\" class=\"headerlink\" title=\"GB2312实现形式\"></a>GB2312实现形式</h3><ul>\n<li>0xxxxxxx：表示为ASCII字符</li>\n<li>1xxxxxxx 1xxxxxxx：表示为汉字</li>\n</ul>\n<h3 id=\"后来？\"><a href=\"#后来？\" class=\"headerlink\" title=\"后来？\"></a>后来？</h3><p>两个字节最多可以表示的字符数是 2^16＝65536，如果要求首位必须是1，那么最多可以表示 32768 个字符，但是GB2312 只用了其中的7000左右的字符。这显然是没有做到物尽其用，而且如果有些特殊的中文，GB2312根本表示不了。所以GBK就应运而生了。</p>\n<p>GBK 就尽量将能用到的状态都表示成中文字符了，当然最终还是有些状态没办法用（具体可以自行查找文档），最终可以表示23940个字符，其中有21003是汉字。</p>\n<p>GBK是完全兼容GB2312的，所以GBK的应用是很广泛的，而且从Windows95开始，Windows的中文版默认中文支持就是GBK编码。你可以通过在cmd下输入<code>chcp</code>命令来查看你当前系统的默认编码</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在GBK后还有<strong>GB18030</strong>等，不再解释</p></blockquote>\n<h3 id=\"GBK实现形式：\"><a href=\"#GBK实现形式：\" class=\"headerlink\" title=\"GBK实现形式：\"></a>GBK实现形式：</h3><ul>\n<li>0xxxxxxx：表示为ASCII字符</li>\n<li>1xxxxxxx xxxxxxxx：表示为汉字</li>\n</ul>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><p>GBK基本解决了中文编码问题，但另外一个大问题随之而来，那就是国际化。</p>\n<p>从我们的视角看，我们按照这种方式来表示简体中文和英文，成了是成了，可是繁体中文怎么表示？日文又怎么表示？</p>\n<p>而又从他们的视角看，当然他们也利用最高位来做文章，发明了big5（台湾繁体），JIS（日文）等兼容ASCII码的编码格式，但是这几种编码之间是并不兼容的。一段GBK编码的文件在台湾友人的电脑里打开就是乱码了。</p>\n<p>这时候，Unicode就诞生了。</p>\n<p><a href=\"https://home.unicode.org/\">Unicode – The World Standard for Text and Emoji</a></p>\n<p>完全弄明白Unicode的细节是非常困难的，我们也是明白以下几点就够了：</p>\n<ol>\n<li><p>Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>\n</li>\n<li><p>Unicode 编码是给世界上所有的符号都分配了一个码。GBK最多也只能表示3万多的汉字，康熙字典里面的大部分汉字都没法用GBK表示，但是Unicode就能，它<del>(大概)</del>可以表示这个星球上所有的符号。</p>\n</li>\n<li><p>Unicode有UCS-2和UCS-4两种编码，2和4都是代表字节的意思，也就是说前者用两个字节表示，后者用4个字节表示。所以，UCS-2的表示范围是65536个字符，而UCS-4则可以表示超过22亿个字符，我想这真的是可以表示所有的字符了。其实日常使用我们用的只是UCS-2，一般说的Unicode编码也是只它。它包含了所有的简体中文，现用的繁体中文，火星文，以及其他国家的现用文字。古籍中的文字就得去UCS-4中去找了。</p>\n</li>\n</ol>\n<p>值得注意的是：Unicode中，中文的编码范围为4E00-9FCF，其中9FC4-9FCF之间的区间没有使用。</p>\n<p>一个比较突出的问题就是这个区间全部都是文字，而中文标点没有包含在其中，反而散落在各个位置。同时，一些特殊的文字和中文部首以及一些特殊符号也不在此范围内，需要特别注意。</p>\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><h3 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>很遗憾，Unicode并不是完美的。不完美的地方主要有两点：</p>\n<p>1）不兼容ASCII码。因为Unicode是用两个字节表示，ASCII码范围内的字符都被扩充成了两个字节，前面又补了8个0。所以，如果你的电脑只支持Unicode编码的话，所有的英文资料全都没法阅读了。</p>\n<p>2）占用的存储变大，如果涉及到传输，所耗费的流量也会变大。中文文本还好，英文就相当明显。纯英文文本所消耗的存储比以前增大了一倍。</p>\n<p>这个时候就出现了诸如UTF-8等实现方式。这里我们只讨论UTF-8，因为它是使用最广泛的。它弥补了Unicode的缺陷，同时主要有以下几个优点。</p>\n<ol>\n<li><p>UTF-8与Unicode是一一对应的。所以UTF-8是国际化的编码方式。</p>\n</li>\n<li><p>UTF-8是针对Unicode的可变长度字符编码，最短一个字节，最长3个字节，1个字节表示的就是ASCII码，所以UTF-8是完全兼容ASCII码的。</p>\n</li>\n<li><p>正是因为UTF-8的变长实现，解决了Unicode的存储多的问题。可能有朋友要问了，UTF-8最多需要用3个字节表示，而Unicode只需要两个，怎么能说UFT-8会省存储呢？因为目前英文是最通用的语言，大部分字符都是ASCII码。</p>\n</li>\n</ol>\n<p>但UTF-8并不是一点缺点也没有，因为变长表示，所以一段UTF-8编码没法一下子算出有多少个字符。而这一点能力对于以上几种编码格式来说是轻而易举的。所以当今世界上没有最完美的字符编码，只有最合适某个场景的编码。</p>\n<h3 id=\"UTF-8具体实现\"><a href=\"#UTF-8具体实现\" class=\"headerlink\" title=\"UTF-8具体实现\"></a>UTF-8具体实现</h3><table>\n<thead>\n<tr>\n<th>范围</th>\n<th>字节数</th>\n<th>存储格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x0000~0x007F (0 ~ 127)</td>\n<td>1字节</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0x0080~0x07FF(128 ~ 2047)</td>\n<td>2字节</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0x0800~FFFF(2048 ~ 65535)</td>\n<td>3字节</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0x10000~1FFFFFF(65536 ~ 2097152)</td>\n<td>4字节</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0x2000000~0x3FFFFFF</td>\n<td>5字节</td>\n<td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0x4000000~0x7FFFFFFF)</td>\n<td>6字节</td>\n<td>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<h2 id=\"番外：多字节编码的一些概念\"><a href=\"#番外：多字节编码的一些概念\" class=\"headerlink\" title=\"番外：多字节编码的一些概念\"></a>番外：多字节编码的一些概念</h2><h3 id=\"大尾-big-endian-和小尾-little-endian\"><a href=\"#大尾-big-endian-和小尾-little-endian\" class=\"headerlink\" title=\"大尾(big endian)和小尾(little endian)\"></a>大尾(big endian)和小尾(little endian)</h3><p>大尾和小尾是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。</p>\n<h3 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h3><p>UTF-8以字节为编码单元，故没有字节序的问题。而UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？</p>\n<p>Unicode规范中推荐的标记字节顺序的方法是BOM，即Byte Order Mark。BOM是一个有点小聪明的想法：</p>\n<p>在UCS编码中有一个叫做<code>&quot;ZERO WIDTH NO-BREAK SPACE&quot;</code>的字符，它的编码是<code>FEFF</code>。而<code>FFFE</code>在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符<code>&quot;ZERO WIDTH NO-BREAK SPACE&quot;</code>。这样如果接收者收到<code>FEFF</code>，就表明这个字节流是Big-Endian的；如果收到<code>FFFE</code>，就表明这个字节流是Little-Endian的。因此字符<code>&quot;ZERO WIDTH NO-BREAK SPACE&quot;</code>又被称作BOM。</p>\n<p>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符<code>&quot;ZERO WIDTH NO-BREAK SPACE&quot;</code>的UTF-8编码是<code>EF BB BF</code>（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以<code>EF BB BF</code>开头的字节流，就知道这是UTF-8编码了。</p>\n<p>不过话又说回来：理论上说，UTF-8并没有大小尾的困扰，所以并不需要BOM。但是一些Windows应用会指定大小尾，比如Notepad，而且Excel在没有指定BOM的UTF-8文件进行读取时会使用Windows的codepage，从而出现错误。 </p>\n","text":"计算机编码梳理ASCII码描述这是计算机编码发展历程里的第一阶段：ASCII码，即：American Standard Code for Information Interchange，美国信息交换标准代码 设计思路：在计算机内部存储单元的最小单位时Byte。不过Byte仍然可以...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"Encoding","slug":"Encoding","count":1,"path":"api/categories/Encoding.json"}],"tags":[{"name":"Encoding","slug":"Encoding","count":1,"path":"api/tags/Encoding.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81%E6%A2%B3%E7%90%86\"><span class=\"toc-text\">计算机编码梳理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ASCII%E7%A0%81\"><span class=\"toc-text\">ASCII码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">描述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">设计思路：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8E%B0%E7%8A%B6%EF%BC%9A\"><span class=\"toc-text\">现状：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ASCII%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">ASCII实现思路</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ASCII%E5%AE%9E%E7%8E%B0%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">ASCII实现形式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GB2312-GBK\"><span class=\"toc-text\">GB2312&amp;GBK</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GB2312%E5%AE%9E%E7%8E%B0%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">GB2312实现形式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8E%E6%9D%A5%EF%BC%9F\"><span class=\"toc-text\">后来？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GBK%E5%AE%9E%E7%8E%B0%E5%BD%A2%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">GBK实现形式：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Unicode\"><span class=\"toc-text\">Unicode</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UTF-8\"><span class=\"toc-text\">UTF-8</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E-1\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#UTF-8%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">UTF-8具体实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%95%AA%E5%A4%96%EF%BC%9A%E5%A4%9A%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">番外：多字节编码的一些概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E5%B0%BE-big-endian-%E5%92%8C%E5%B0%8F%E5%B0%BE-little-endian\"><span class=\"toc-text\">大尾(big endian)和小尾(little endian)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BOM\"><span class=\"toc-text\">BOM</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"线程、进程、协程、与 CPU 多核","uid":"3be3467b821b2606f2e2f4a1380f6410","slug":"Dev/Theory/线程进程协程与CPU","date":"2021-05-23T04:23:23.000Z","updated":"2023-10-27T19:44:22.000Z","comments":true,"path":"api/articles/Dev/Theory/线程进程协程与CPU.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"线程、进程、协程、与 CPU 多核一、进程、线程、协程的概念进程： 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。 线程： 是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。 协...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"Theroy","slug":"Theroy","count":5,"path":"api/categories/Theroy.json"}],"tags":[{"name":"Theroy","slug":"Theroy","count":5,"path":"api/tags/Theroy.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{}}