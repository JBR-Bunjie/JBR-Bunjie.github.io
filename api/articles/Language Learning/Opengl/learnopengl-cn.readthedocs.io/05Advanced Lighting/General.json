{"title":"高级光照","uid":"8f44e2f23c42716c29e08931dd66d3e9","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/05Advanced Lighting/General","date":"2023-03-08T02:34:08.000Z","updated":"2023-10-27T19:57:07.000Z","comments":true,"path":"api/articles/Language Learning/Opengl/learnopengl-cn.readthedocs.io/05Advanced Lighting/General.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"shadow-mapping\">Shadow Mapping</h1>\r\n<h2 id=\"基本的-shadow-算法思想\">基本的 Shadow 算法思想：</h2>\r\n<p>阴影就是光所不及的地方，也就是说，我只要能获取到哪些地方是光照不到的，那么就能推断出阴影位置。</p>\r\n<p>而一般来说，物体间产生的遮挡关系就是阴影的直接来源，而这个遮挡关系，正好可以用深度关系推测出来。</p>\r\n<p>也就是说，我们以各个光源为原点建立空间系，生成深度图。一个区域如果能被照亮，那么他一定会被记录深度，而没有被记录深度的地方，要么是被裁剪了，要么是被遮挡了。</p>\r\n<h2 id=\"生成-shadow-map-的大致流程\">生成 Shadow Map 的大致流程</h2>\r\n<p>从上面可以看出来，Shadow Map 是一种 RT，并且是 Per Light 的，并且这种\r\nRT 的生成还和 Light Type 有一定的关联</p>\r\n<h3 id=\"directional-light-的-shadow-map\">Directional Light 的 Shadow\r\nMap</h3>\r\n<h4 id=\"生成\">生成</h4>\r\n<ol type=\"1\">\r\n<li>顶点着色器：对于所有的 Directional\r\nLight，我们在渲染物体时，我们得建立特殊的 view 及 proj 矩阵：\r\n<ul>\r\n<li>view 和 proj 矩阵不再以摄像机为主，我们会以 Light\r\n为关键建立矩阵，以得到独特的 Light Space</li>\r\n</ul></li>\r\n<li>Fragment：由于我们已经指定了 Depth 的输出对象是一张\r\nRT，并且又没必要处理仍何颜色计算，我们大可以直接将 Fragment\r\n的处理过程空着。GPU 会默认帮我们在完成 Fragment\r\n后设置深度缓冲，当然我们也可以自己在 Frag 中去设置，但是没必要，还会破坏\r\nEarly-z</li>\r\n</ol>\r\n<p>当这么一个 Prepass 执行完后，我们就可以得到一张 RT 了，直接将这张 RT\r\n汇入下一个 Pass 中，就可以使用了</p>\r\n<h4 id=\"使用\">使用</h4>\r\n<p>在使用 Shadow Map 时，也是 Per Light 的，因为我们得重新计算一次顶点的\r\nLight Space 坐标，以确认这个顶点是否被照亮</p>\r\n<ol type=\"1\">\r\n<li>顶点着色器：在正常的顶点属性设置与输出中，必须要增加一条 Light Space\r\n下 Vertex Pos 的输出。我们在 Vertex Shader 阶段完成坐标系的转换以减少\r\nFragment 阶段的运算量</li>\r\n<li>Fragment：对 Shadow Map 进行采样并与当前的 Light Space\r\n坐标进行比对，只有 Equal 才能通过。\r\n<ul>\r\n<li>关于取样：可预见的，我们可以使用 Screen Pos 下的 LigthPos.xy\r\n对深度图进行取样，如结果与 LightPos.z 不符则可认为在阴影中</li>\r\n<li></li>\r\n</ul></li>\r\n</ol>\r\n<p>对于我们初步生成的 Shadow Map，我们一般会遇到这些问题：</p>\r\n<ol type=\"1\">\r\n<li><p>阴影失真：</p>\r\n<blockquote>\r\n<p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<strong>阴影失真(Shadow\r\nAcne)</strong></p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n</blockquote></li>\r\n<li><p>由于使用 Shadow Bias 来解决 Shadow Acne，导致阴影悬浮</p>\r\n<blockquote>\r\n<p>使用阴影偏移的直接导致我们对物体的实际深度应用了平移。如果偏移足够大，就可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_peter_panning.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>使用普通的偏移值通常就能避免 peter panning。</p>\r\n</blockquote>\r\n</blockquote></li>\r\n<li><p>光的视锥不可见的区域的处理：</p>\r\n<p>这事实上包含两个部分：一个是由于 Shadow Map\r\n的大小限制导致的采样超出问题；另一部分则是生成 Shadow Map 时，由于 Near\r\n与 Far 值的设计导致的视锥大小问题</p>\r\n<blockquote>\r\n<p><img\r\nsrc=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_outside_frustum.png\"\r\nalt=\"img\" /> 未解决任何问题的情况</p>\r\n<p><img\r\nsrc=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_clamp_edge.png\"\r\nalt=\"img\" /> 解决了采样问题，现在如果我们采样深度贴图 0 到 1\r\n坐标范围以外的区域，纹理函数总会返回一个 1.0 的深度值，阴影值为\r\n0.0。但是，仍有一部分是黑暗区域。那里的坐标超出了光的正交视锥的远平面。你可以看到这片黑色区域总是出现在光源视锥的极远处。</p>\r\n<p><img\r\nsrc=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_over_sampling_fixed.png\"\r\nalt=\"img\" />\r\n解决全部问题：检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能“解决”深度贴图采样超出的问题</p>\r\n</blockquote></li>\r\n<li><p>阴影的锯齿问题：</p>\r\n<p>这是一个大问题，让我们从 LearnOpenGL\r\n里所给出的解决方案开始，一步步推进：</p>\r\n<blockquote>\r\n<p>阴影现在已经附着到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影映射对分辨率的依赖很快变得很明显。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_zoom.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会产生锯齿边。</p>\r\n<p>你可以通过增加深度贴图的分辨率的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p>\r\n</blockquote>\r\n<p><strong>PCF</strong></p>\r\n<blockquote>\r\n<p>...一个（并不完整的）解决方案叫做 PCF（percentage-closer\r\nfiltering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。</p>\r\n<p>一个简单的 PCF\r\n的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p>\r\n</blockquote>\r\n<p>代码：</p>\r\n<pre class=\"line-numbers language-glsl\" data-language=\"glsl\"><code class=\"language-glsl\">&#x2F;&#x2F; 最初的shadow值直接来自于深度取样值：\nfloat shadow &#x3D; currentDepth - bias &gt; closestDepth  ? 1.0 : 0.0;\n&#x2F;&#x2F; 现在，我们在一个frag上，对其对应的贴图纹素及周围8个纹素一同采样，并混合结果：\nfloat shadow &#x3D; 0.0;\nvec2 texelSize &#x3D; 1.0 &#x2F; textureSize(shadowMap, 0);\nfor (int x &#x3D; -1; x &lt;&#x3D; 1; ++x) &#123;\n    for (int y &#x3D; -1; y &lt;&#x3D; 1; ++y) &#123;\n        float pcfDepth &#x3D; texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;\n        shadow +&#x3D; currentDepth - bias &gt; pcfDepth ? 1.0 : 0.0;\n    &#125;\n&#125;\nshadow &#x2F;&#x3D; 9.0;</code></pre></li>\r\n</ol>\r\n<h3 id=\"point-light-的-shadow-map\">Point Light 的 Shadow Map</h3>\r\n<h4 id=\"生成-1\">生成</h4>\r\n<h4 id=\"使用-1\">使用</h4>\r\n<h2 id=\"hdr\">HDR</h2>\r\n","text":"Shadow Mapping 基本的 Shadow 算法思想： 阴影就是光所不及的地方，也就是说，我只要能获取到哪些地方是光照不到的，那么就能推断出阴影位置。 而一般来说，物体间产生的遮挡关系就是阴影的直接来源，而这个遮挡关系，正好可以用深度关系推测出来。 也就是说，我们以各个光...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Opengl","slug":"Opengl","count":16,"path":"api/categories/Opengl.json"},{"name":"Shader","slug":"Opengl/Shader","count":16,"path":"api/categories/Opengl/Shader.json"}],"tags":[{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":16,"path":"api/tags/Opengl.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#shadow-mapping\"><span class=\"toc-text\">Shadow Mapping</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%9A%84-shadow-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">基本的 Shadow 算法思想：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90-shadow-map-%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">生成 Shadow Map 的大致流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#directional-light-%E7%9A%84-shadow-map\"><span class=\"toc-text\">Directional Light 的 Shadow\r\nMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90\"><span class=\"toc-text\">生成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#point-light-%E7%9A%84-shadow-map\"><span class=\"toc-text\">Point Light 的 Shadow Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90-1\"><span class=\"toc-text\">生成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-1\"><span class=\"toc-text\">使用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#hdr\"><span class=\"toc-text\">HDR</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Unity Shader入门精要笔记 - Chapter0. 在一切开始之前！","uid":"3db882bf7fb70ea2d6999c8bcc582857","slug":"Rendering/UnityShaderBook/Chapter0","date":"2023-03-08T13:27:04.000Z","updated":"2023-10-27T20:22:33.000Z","comments":true,"path":"api/articles/Rendering/UnityShaderBook/Chapter0.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Chapter 0: 开始 - 准备工作 在开始阅读本书之前可以提前准备的资料： 彩图：《Unity Shader入门精要》随书彩色插图 (candycat1992.github.io) 实例工程仓库：candycat1992/Unity_Shaders_Book: 书籍《Uni...","link":"","photos":[],"count_time":{"symbolsCount":344,"symbolsTime":"1 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"高级 OpenGL","uid":"c50f04e3270f35cd6ea407c3d7483e86","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/04Advanced OpenGL/General","date":"2023-03-08T02:33:08.000Z","updated":"2023-10-27T19:57:02.000Z","comments":true,"path":"api/articles/Language Learning/Opengl/learnopengl-cn.readthedocs.io/04Advanced OpenGL/General.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"高级 OpenGL 先简单回顾一下一般性的渲染管线： img 入门精要里的管线是这样的： 渲染流水线中的三个概念阶段 GPU 的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流...","link":"","photos":[],"count_time":{"symbolsCount":"86k","symbolsTime":"1:18"},"categories":[{"name":"Opengl","slug":"Opengl","count":16,"path":"api/categories/Opengl.json"},{"name":"Shader","slug":"Opengl/Shader","count":16,"path":"api/categories/Opengl/Shader.json"}],"tags":[{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":16,"path":"api/tags/Opengl.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}