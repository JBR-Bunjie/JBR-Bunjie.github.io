{"title":"高级光照","uid":"8f44e2f23c42716c29e08931dd66d3e9","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/05Advanced Lighting/General","date":"2023-03-08T02:34:08.000Z","updated":"2023-10-27T19:57:07.000Z","comments":true,"path":"api/articles/Language Learning/Opengl/learnopengl-cn.readthedocs.io/05Advanced Lighting/General.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h1><h2 id=\"基本的-Shadow-算法思想：\"><a href=\"#基本的-Shadow-算法思想：\" class=\"headerlink\" title=\"基本的 Shadow 算法思想：\"></a>基本的 Shadow 算法思想：</h2><p>阴影就是光所不及的地方，也就是说，我只要能获取到哪些地方是光照不到的，那么就能推断出阴影位置。</p>\n<p>而一般来说，物体间产生的遮挡关系就是阴影的直接来源，而这个遮挡关系，正好可以用深度关系推测出来。</p>\n<p>也就是说，我们以各个光源为原点建立空间系，生成深度图。一个区域如果能被照亮，那么他一定会被记录深度，而没有被记录深度的地方，要么是被裁剪了，要么是被遮挡了。</p>\n<h2 id=\"生成-Shadow-Map-的大致流程\"><a href=\"#生成-Shadow-Map-的大致流程\" class=\"headerlink\" title=\"生成 Shadow Map 的大致流程\"></a>生成 Shadow Map 的大致流程</h2><p>从上面可以看出来，Shadow Map 是一种 RT，并且是 Per Light 的，并且这种 RT 的生成还和 Light Type 有一定的关联</p>\n<h3 id=\"Directional-Light-的-Shadow-Map\"><a href=\"#Directional-Light-的-Shadow-Map\" class=\"headerlink\" title=\"Directional Light 的 Shadow Map\"></a>Directional Light 的 Shadow Map</h3><h4 id=\"生成\"><a href=\"#生成\" class=\"headerlink\" title=\"生成\"></a>生成</h4><ol>\n<li>顶点着色器：对于所有的 Directional Light，我们在渲染物体时，我们得建立特殊的 view 及 proj 矩阵：<ul>\n<li>view 和 proj 矩阵不再以摄像机为主，我们会以 Light 为关键建立矩阵，以得到独特的 Light Space</li>\n</ul>\n</li>\n<li>Fragment：由于我们已经指定了 Depth 的输出对象是一张 RT，并且又没必要处理仍何颜色计算，我们大可以直接将 Fragment 的处理过程空着。GPU 会默认帮我们在完成 Fragment 后设置深度缓冲，当然我们也可以自己在 Frag 中去设置，但是没必要，还会破坏 Early-z</li>\n</ol>\n<p>当这么一个 Prepass 执行完后，我们就可以得到一张 RT 了，直接将这张 RT 汇入下一个 Pass 中，就可以使用了</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>在使用 Shadow Map 时，也是 Per Light 的，因为我们得重新计算一次顶点的 Light Space 坐标，以确认这个顶点是否被照亮</p>\n<ol>\n<li>顶点着色器：在正常的顶点属性设置与输出中，必须要增加一条 Light Space 下 Vertex Pos 的输出。我们在 Vertex Shader 阶段完成坐标系的转换以减少 Fragment 阶段的运算量</li>\n<li><h2 id=\"Fragment：对-Shadow-Map-进行采样并与当前的-Light-Space-坐标进行比对，只有-Equal-才能通过。-关于取样：可预见的，我们可以使用-Screen-Pos-下的-LigthPos-xy-对深度图进行取样，如结果与-LightPos-z-不符则可认为在阴影中\"><a href=\"#Fragment：对-Shadow-Map-进行采样并与当前的-Light-Space-坐标进行比对，只有-Equal-才能通过。-关于取样：可预见的，我们可以使用-Screen-Pos-下的-LigthPos-xy-对深度图进行取样，如结果与-LightPos-z-不符则可认为在阴影中\" class=\"headerlink\" title=\"Fragment：对 Shadow Map 进行采样并与当前的 Light Space 坐标进行比对，只有 Equal 才能通过。- 关于取样：可预见的，我们可以使用 Screen Pos 下的 LigthPos.xy 对深度图进行取样，如结果与 LightPos.z 不符则可认为在阴影中\"></a>Fragment：对 Shadow Map 进行采样并与当前的 Light Space 坐标进行比对，只有 Equal 才能通过。<br>- 关于取样：可预见的，我们可以使用 Screen Pos 下的 LigthPos.xy 对深度图进行取样，如结果与 LightPos.z 不符则可认为在阴影中</h2></li>\n</ol>\n<p>对于我们初步生成的 Shadow Map，我们一般会遇到这些问题：</p>\n<ol>\n<li><p>阴影失真：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<strong>阴影失真(Shadow Acne)</strong></p>\n<p><img src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne.png\" alt=\"img\"></p></blockquote>\n</li>\n<li><p>由于使用 Shadow Bias 来解决 Shadow Acne，导致阴影悬浮</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>使用阴影偏移的直接导致我们对物体的实际深度应用了平移。如果偏移足够大，就可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>\n<p><img src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_peter_panning.png\" alt=\"img\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>使用普通的偏移值通常就能避免 peter panning。</p></blockquote></blockquote>\n</li>\n<li><p>光的视锥不可见的区域的处理：</p>\n<p>这事实上包含两个部分：一个是由于 Shadow Map 的大小限制导致的采样超出问题；另一部分则是生成 Shadow Map 时，由于 Near 与 Far 值的设计导致的视锥大小问题</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><img src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_outside_frustum.png\" alt=\"img\"><br>未解决任何问题的情况</p>\n<p><img src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_clamp_edge.png\" alt=\"img\"><br>解决了采样问题，现在如果我们采样深度贴图 0 到 1 坐标范围以外的区域，纹理函数总会返回一个 1.0 的深度值，阴影值为 0.0。但是，仍有一部分是黑暗区域。那里的坐标超出了光的正交视锥的远平面。你可以看到这片黑色区域总是出现在光源视锥的极远处。</p>\n<p><img src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_over_sampling_fixed.png\" alt=\"img\"><br>解决全部问题：检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能“解决”深度贴图采样超出的问题</p></blockquote>\n</li>\n<li><p>阴影的锯齿问题：</p>\n<p>这是一个大问题，让我们从 LearnOpenGL 里所给出的解决方案开始，一步步推进：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>阴影现在已经附着到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影映射对分辨率的依赖很快变得很明显。</p>\n<p><img src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_zoom.png\" alt=\"img\"></p>\n<p>因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会产生锯齿边。</p>\n<p>你可以通过增加深度贴图的分辨率的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p></blockquote>\n<p><strong>PCF</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>…一个（并不完整的）解决方案叫做 PCF（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。</p>\n<p>一个简单的 PCF 的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p></blockquote>\n<p>代码：</p>\n<pre class=\"line-numbers language-glsl\" data-language=\"glsl\"><code class=\"language-glsl\">&#x2F;&#x2F; 最初的shadow值直接来自于深度取样值：\nfloat shadow &#x3D; currentDepth - bias &gt; closestDepth  ? 1.0 : 0.0;\n&#x2F;&#x2F; 现在，我们在一个frag上，对其对应的贴图纹素及周围8个纹素一同采样，并混合结果：\nfloat shadow &#x3D; 0.0;\nvec2 texelSize &#x3D; 1.0 &#x2F; textureSize(shadowMap, 0);\nfor (int x &#x3D; -1; x &lt;&#x3D; 1; ++x) &#123;\n    for (int y &#x3D; -1; y &lt;&#x3D; 1; ++y) &#123;\n        float pcfDepth &#x3D; texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;\n        shadow +&#x3D; currentDepth - bias &gt; pcfDepth ? 1.0 : 0.0;\n    &#125;\n&#125;\nshadow &#x2F;&#x3D; 9.0;</code></pre></li>\n</ol>\n<h3 id=\"Point-Light-的-Shadow-Map\"><a href=\"#Point-Light-的-Shadow-Map\" class=\"headerlink\" title=\"Point Light 的 Shadow Map\"></a>Point Light 的 Shadow Map</h3><h4 id=\"生成-1\"><a href=\"#生成-1\" class=\"headerlink\" title=\"生成\"></a>生成</h4><h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><h2 id=\"HDR\"><a href=\"#HDR\" class=\"headerlink\" title=\"HDR\"></a>HDR</h2>","text":"Shadow Mapping基本的 Shadow 算法思想：阴影就是光所不及的地方，也就是说，我只要能获取到哪些地方是光照不到的，那么就能推断出阴影位置。 而一般来说，物体间产生的遮挡关系就是阴影的直接来源，而这个遮挡关系，正好可以用深度关系推测出来。 也就是说，我们以各个光源为...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Opengl","slug":"Opengl","count":16,"path":"api/categories/Opengl.json"},{"name":"Shader","slug":"Opengl/Shader","count":16,"path":"api/categories/Opengl/Shader.json"}],"tags":[{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":16,"path":"api/tags/Opengl.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Shadow-Mapping\"><span class=\"toc-text\">Shadow Mapping</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%9A%84-Shadow-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A\"><span class=\"toc-text\">基本的 Shadow 算法思想：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90-Shadow-Map-%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">生成 Shadow Map 的大致流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Directional-Light-%E7%9A%84-Shadow-Map\"><span class=\"toc-text\">Directional Light 的 Shadow Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90\"><span class=\"toc-text\">生成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Fragment%EF%BC%9A%E5%AF%B9-Shadow-Map-%E8%BF%9B%E8%A1%8C%E9%87%87%E6%A0%B7%E5%B9%B6%E4%B8%8E%E5%BD%93%E5%89%8D%E7%9A%84-Light-Space-%E5%9D%90%E6%A0%87%E8%BF%9B%E8%A1%8C%E6%AF%94%E5%AF%B9%EF%BC%8C%E5%8F%AA%E6%9C%89-Equal-%E6%89%8D%E8%83%BD%E9%80%9A%E8%BF%87%E3%80%82-%E5%85%B3%E4%BA%8E%E5%8F%96%E6%A0%B7%EF%BC%9A%E5%8F%AF%E9%A2%84%E8%A7%81%E7%9A%84%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-Screen-Pos-%E4%B8%8B%E7%9A%84-LigthPos-xy-%E5%AF%B9%E6%B7%B1%E5%BA%A6%E5%9B%BE%E8%BF%9B%E8%A1%8C%E5%8F%96%E6%A0%B7%EF%BC%8C%E5%A6%82%E7%BB%93%E6%9E%9C%E4%B8%8E-LightPos-z-%E4%B8%8D%E7%AC%A6%E5%88%99%E5%8F%AF%E8%AE%A4%E4%B8%BA%E5%9C%A8%E9%98%B4%E5%BD%B1%E4%B8%AD\"><span class=\"toc-text\">Fragment：对 Shadow Map 进行采样并与当前的 Light Space 坐标进行比对，只有 Equal 才能通过。- 关于取样：可预见的，我们可以使用 Screen Pos 下的 LigthPos.xy 对深度图进行取样，如结果与 LightPos.z 不符则可认为在阴影中</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Point-Light-%E7%9A%84-Shadow-Map\"><span class=\"toc-text\">Point Light 的 Shadow Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90-1\"><span class=\"toc-text\">生成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-1\"><span class=\"toc-text\">使用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HDR\"><span class=\"toc-text\">HDR</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Unity Shader入门精要笔记 - Chapter0. 在一切开始之前！","uid":"3db882bf7fb70ea2d6999c8bcc582857","slug":"Rendering/UnityShaderBook/Chapter0","date":"2023-03-08T13:27:04.000Z","updated":"2023-10-27T20:22:33.000Z","comments":true,"path":"api/articles/Rendering/UnityShaderBook/Chapter0.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Chapter 0: 开始 - 准备工作在开始阅读本书之前可以提前准备的资料： 彩图：《Unity Shader入门精要》随书彩色插图 (candycat1992.github.io) 实例工程仓库：candycat1992&#x2F;Unity_Shaders_Book: 书籍...","link":"","photos":[],"count_time":{"symbolsCount":307,"symbolsTime":"1 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"高级 OpenGL","uid":"c50f04e3270f35cd6ea407c3d7483e86","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/04Advanced OpenGL/General","date":"2023-03-08T02:33:08.000Z","updated":"2023-10-27T19:57:02.000Z","comments":true,"path":"api/articles/Language Learning/Opengl/learnopengl-cn.readthedocs.io/04Advanced OpenGL/General.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"高级 OpenGL先简单回顾一下一般性的渲染管线： 入门精要里的管线是这样的： 渲染流水线中的三个概念阶段 GPU 的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是...","link":"","photos":[],"count_time":{"symbolsCount":"85k","symbolsTime":"1:17"},"categories":[{"name":"Opengl","slug":"Opengl","count":16,"path":"api/categories/Opengl.json"},{"name":"Shader","slug":"Opengl/Shader","count":16,"path":"api/categories/Opengl/Shader.json"}],"tags":[{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":16,"path":"api/tags/Opengl.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}