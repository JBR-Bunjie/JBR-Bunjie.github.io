{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Java/JavaProject/module_info文件有什么用","date":"2023-03-07T16:14:45.500Z","updated":"2021-10-02T16:49:38.000Z","comments":true,"path":"api/articles/Language Learning/Java/JavaProject/module_info文件有什么用.json","keywords":null,"cover":null,"content":"<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module 本模块的名称&#123;\n\texports 对外暴露的包路径;\n\trequires 需要依赖的其他模块名称;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"一、什么是Java-module？\"><a href=\"#一、什么是Java-module？\" class=\"headerlink\" title=\"一、什么是Java module？\"></a>一、什么是Java module？</h2><p>与Java 中的package有些类似，module引入了Java代码分组的另一个级别。每个这样的分组（module）都包含许多子package包。通过在一个模块的源代码文件package的根部，添加文件module-info.java来声明该文件夹及其子文件夹为一个模块。该文件语法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module xxx.yyy&#123;\n \t....\n&#125;</code></pre>\n\n<p>其中xxx.yyy是模块module声明的名称，不是package名称。</p>\n<h2 id=\"二、模块导出package\"><a href=\"#二、模块导出package\" class=\"headerlink\" title=\"二、模块导出package\"></a>二、模块导出package</h2><p>文件module-info.java可以指定该模块下面的哪些package对外可见、可访问。通过一个新的关键字<code>exports</code>来实现该功能。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module xxx.yyy&#123;\n\texports com.zimug.java9;\n&#125;</code></pre>\n\n<p><code>com.zimug.java9</code>代表一个package。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>需要注意的是：即使给定package包中的类是public的，如果未通过’exports’显式导出其程序包，则它们在模块外部也是不可见的（在编译时和运行时都是如此）。</p></blockquote>\n<h2 id=\"三、模块导入package\"><a href=\"#三、模块导入package\" class=\"headerlink\" title=\"三、模块导入package\"></a>三、模块导入package</h2><p>如果另一个模块想要使用被导出的package包中的类，可以用<code>requires</code>关键字在其module-info.java文件中来导入（读取）目标模块的package包。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module def.stu&#123;\n\trequires xxx.yyy;\n&#125;</code></pre>\n\n<h2 id=\"四、Java-module的意义\"><a href=\"#四、Java-module的意义\" class=\"headerlink\" title=\"四、Java module的意义\"></a>四、Java module的意义</h2><p>在笔者看来，Java 9引入module 模块化管理系统，更多的是从安全性的角度考虑。Java 代码中90%以上的漏洞都是由反射和访问权限控制粒度不足引起的，Java 9的模块化系统正好能解决这个问题。Java 9 module提供另一个级别的Java 代码可见性、可访问性的控制。</p>\n<p>比如说：我们都知道当一个class被修饰为private的时候，意味着这个类是内部类。对于顶级类(外部类)来说，只有两种修饰符：public和默认(default)。这也就意味着一个问题，有些public class我们本来是打算在jar包定义的范围内使用的，但是结果却是任何引入了这个jar的项目都可以使用这个jar里面所有的public class代码。</p>\n<p>也就是我们的原意是在有限范围内提供公开访问，结果却是无限制的对外公开。在引入Java 9模块化之后，可以实现<strong>有限范围内的代码public访问权限</strong>，将代码公开区分为：<strong>模块外部有限范围的公开访问</strong>和<strong>模块内部的公开访问</strong>。</p>\n<h2 id=\"五、实例\"><a href=\"#五、实例\" class=\"headerlink\" title=\"五、实例\"></a>五、实例</h2><p>在此示例中，我将创建两个模块“ common.widget”和“ data.widget”，并将它们放置在单个文件夹“ modules-examples/src”下。文件“ module-info.java”将放置在每个模块的根文件夹下。<br>文件及目录格式如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">D:\\modules-example&gt;tree &#x2F;F &#x2F;A\n\\---src\n    +---common.widget\n    |   |   module-info.java\n    |   |   \n    |   +---com\n    |   |   \\---zimug\n    |   |           RendererSupport.java\n    |   |           \n    |   \\---org\n    |       \\---jwidgets\n    |               SimpleRenderer.java\n    |               \n    \\---data.widget\n        |   module-info.java\n        |   \n        \\---com\n            \\---example\n                    Component.java</code></pre>\n\n<h3 id=\"第一个模块\"><a href=\"#第一个模块\" class=\"headerlink\" title=\"第一个模块\"></a>第一个模块</h3><p>本代码文件目录：modules-example/src/common.widget/org/jwidgets/SimpleRenderer.java。这个package在后文中没有被exports。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package org.jwidgets;\n\npublic class SimpleRenderer &#123;\n  public void renderAsString(Object object) &#123;\n      System.out.println(object);\n  &#125;\n&#125;</code></pre>\n\n<p>本代码文件目录：modules-example/src/common.widget/com/zimug/RendererSupport.java。这个package在后文中被exports了。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.zimug;\n\nimport org.jwidgets.SimpleRenderer;\n\npublic class RendererSupport &#123;\n\tpublic void render(Object object) &#123;\n        new SimpleRenderer().renderAsString(object);\n  \t&#125;\n&#125;</code></pre>\n\n<p>模块导出，本代码文件目录：modules-example/src/common.widget/module-info.java。只导出<code>com.zimug</code>包,没有导出 <code>org.jwidgets</code>包。导出的模块名称为<code>common.widget</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module common.widget&#123;\n  \texports com.zimug;\n&#125;</code></pre>\n\n<h3 id=\"第二个模块\"><a href=\"#第二个模块\" class=\"headerlink\" title=\"第二个模块\"></a>第二个模块</h3><p>模块导入<code>common.widget</code>，本代码文件目录：modules-example/src/data.widget/module-info.java</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module data.widget &#123;\n\trequires common.widget;\n&#125;</code></pre>\n\n<p>使用导入模块<code>common.widget</code>中的package:<code>com.zimug</code>。本代码文件路径： modules-example/src/data.widget/com/example/Component.java</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.example;\n\nimport com.zimug.RendererSupport;\n\npublic class Component &#123;\n  \tpublic static void main(String[] args) &#123;\n     \tRendererSupport support &#x3D; new RendererSupport();\n      \tsupport.render(&quot;Test Object&quot;);\n  \t&#125;\n&#125;</code></pre>\n\n<p>正常编译执行，结果如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Test Object</code></pre>\n\n<h3 id=\"尝试使用未被exports的package代码\"><a href=\"#尝试使用未被exports的package代码\" class=\"headerlink\" title=\"尝试使用未被exports的package代码\"></a>尝试使用未被exports的package代码</h3><p>由于包“ org.jwidgets”尚未通过“ common.widget”模块导出，因此另一个模块“ data.widget”无法使用该package包下的类<code>SimpleRenderer</code>。我们做一个反例，看看会发生什么：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.example;\nimport org.jwidgets.SimpleRenderer;\n\npublic class Component &#123;\n  \tpublic static void main(String[] args) &#123;\n    \tSimpleRenderer simpleRenderer &#x3D; new SimpleRenderer(); \n    \tsimpleRenderer.renderAsString(&quot;Test Object&quot;);\n  \t&#125;\n&#125;</code></pre>\n\n<p>编译报错信息如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">D:\\modules-example\\src\\data.widget\\com\\example\\Component.java:3: error: package org.jwidgets is not visible\nimport org.jwidgets.SimpleRenderer;\n          ^\n  (package org.jwidgets is declared in module common.widget, which does not export it)\n1 error</code></pre>\n\n<p>正如我们所看到的，未被exports的package下面的class即使是public的也不能被访问。</p>\n","text":"module 本模块的名称&#123; exports 对外暴露的包路径; requires 需要依赖的其他模块名称; &#125; 一、什么是Java module？与Java 中的package有些类似，module引入了Java代码分组的另一个级别。每个这样的分组（modu...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJava-module%EF%BC%9F\"><span class=\"toc-text\">一、什么是Java module？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%87%BApackage\"><span class=\"toc-text\">二、模块导出package</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5package\"><span class=\"toc-text\">三、模块导入package</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81Java-module%E7%9A%84%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">四、Java module的意义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">五、实例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">第一个模块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">第二个模块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8%E6%9C%AA%E8%A2%ABexports%E7%9A%84package%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">尝试使用未被exports的package代码</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/JavaScript/formdata使用攻略","date":"2023-03-07T16:14:45.510Z","updated":"2022-05-22T08:53:57.000Z","comments":true,"path":"api/articles/Language Learning/JavaScript/formdata使用攻略.json","keywords":null,"cover":null,"text":"FormData 对象的使用 - Web API 接口参考 | MDN (mozilla.org) FormData对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Language Learning/Java/JavaProject/eclipse","date":"2023-03-07T16:14:45.497Z","updated":"2021-10-02T17:00:16.000Z","comments":true,"path":"api/articles/Language Learning/Java/JavaProject/eclipse.json","keywords":null,"cover":null,"text":"Eclipse中有如下一些和运行调试相关的快捷键。 【Ctrl+Shift+B】：在当前行设置断点或取消设置的断点。 【F11】：调试最后一次执行的程序。 【Ctrl+F11】：运行最后一次执行的程序。 【F5】：跟踪到方法中，当程序执行到某方法时，可以按【F5】键跟踪到方法中。...","link":"","photos":[],"count_time":{"symbolsCount":147,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}