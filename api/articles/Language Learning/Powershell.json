{"title":"垃圾回收 - Garbage Collection","uid":"1a0cb69df3f16f58729d7e68901c943f","slug":"Language Learning/Powershell","date":"2023-12-08T13:52:53.000Z","updated":"2023-12-08T18:31:47.199Z","comments":true,"path":"api/articles/Language Learning/Powershell.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"powershell\">Powershell</h1>\r\n<blockquote>\r\n<p>Main References: <a\r\nhref=\"https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/01-getting-started?view=powershell-7.4\">Getting\r\nStarted with PowerShell - PowerShell | Microsoft Learn</a></p>\r\n</blockquote>\r\n<h2 id=\"execution-policy\">Execution Policy</h2>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.4\">about\r\nExecution Policies - PowerShell | Microsoft Learn</a></p>\r\n</blockquote>\r\n<blockquote>\r\n<p>Contrary to popular belief, the execution policy in PowerShell is not\r\na security boundary. It's designed to prevent a user from unknowingly\r\nrunning a script. A determined user can easily bypass the execution\r\npolicy in PowerShell.</p>\r\n</blockquote>\r\n<p>非 Windows 计算机的固定策略是 <code>Unrestricted</code>，而 Windows\r\n10 的默认策略是 <code>Restricted</code>，\r\n该策略不会影响交互式命令的执行，但是会阻止脚本执行：</p>\r\n<blockquote>\r\n<p>PowerShell scripts can't be run at all when the execution policy is\r\nset to <strong>Restricted</strong>. This is the default setting on all\r\nWindows client operating systems.</p>\r\n</blockquote>\r\n<p>为了改变它，可以使用以下命令</p>\r\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># Get-ExecutionPolicy # 获取当前策略\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned</code></pre>\r\n<h2 id=\"discoverability\">Discoverability</h2>\r\n<blockquote>\r\n<p>Compiled commands in PowerShell are called cmdlets. Cmdlet is\r\npronounced \"command-let\" (not CMD-let).</p>\r\n<p><strong>Cmdlets names have the form of singular \"Verb-Noun\" commands\r\nto make them easily discoverable.</strong> For example, the cmdlet for\r\ndetermining what processes are running is <code>Get-Process</code> and\r\nthe cmdlet for retrieving a list of services and their statuses is\r\n<code>Get-Service</code>.</p>\r\n<p>There are other types of commands in PowerShell such as aliases and\r\nfunctions that will be covered later in this book. The term PowerShell\r\ncommand is a generic term that's often used to refer to any type of\r\ncommand in PowerShell, regardless of whether or not it's a cmdlet,\r\nfunction, or alias.</p>\r\n</blockquote>\r\n<h2 id=\"the-three-core-cmdlets-in-powershell\">The Three Core Cmdlets in\r\nPowerShell</h2>\r\n<ul>\r\n<li><code>Get-Command</code></li>\r\n<li><code>Get-Help</code></li>\r\n<li><code>Get-Member</code></li>\r\n</ul>\r\n<blockquote>\r\n<p>One question I'm often asked is how do you figure out what the\r\ncommands are in PowerShell? Both <code>Get-Command</code> and\r\n<code>Get-Help</code> can be used to determine the commands.</p>\r\n</blockquote>\r\n<h3 id=\"get-help\">Get-Help</h3>\r\n<blockquote>\r\n<p><code>Get-Help</code> is a multipurpose command.\r\n<code>Get-Help</code> helps you learn how to use commands once you find\r\nthem. <code>Get-Help</code> can also be used to help locate commands,\r\nbut in a different and more indirect way when compared to\r\n<code>Get-Command</code>.</p>\r\n</blockquote>\r\n<p>在使用上：</p>\r\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">Get-Help -Name &quot;Target_Command_Name&quot;</code></pre>\r\n<h2 id=\"一份示例\">一份示例</h2>\r\n<p>一份留档的Powershell脚本，作用为将image文件夹下的内容全部上移一级，留在这里用作示例：</p>\r\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\"># --------------------------------------\n# 请确保在实际操作前备份文件，以免意外操作导致文件丢失。\n# --------------------------------------\n\n# 开启Debug模式\n# $DebugPreference &#x3D; &quot;Continue&quot;\n\n# Solve CodeRunner&#39;s Garbled Characters\n# https:&#x2F;&#x2F;github.com&#x2F;formulahendry&#x2F;vscode-code-runner&#x2F;issues&#x2F;887\n[Console]::OutputEncoding &#x3D; [Text.UTF8Encoding]::UTF8\n$PSDefaultParameterValues[&#39;*:Encoding&#39;] &#x3D; &#39;utf8&#39;\n$PSDefaultParameterValues[&#39;Out-File:Encoding&#39;] &#x3D; &#39;utf8&#39;\n\nfunction RecursivelyMoveFiles($targetFolder) &#123;\n    $errCount &#x3D; 0\n    $subFolders &#x3D; Get-ChildItem -LiteralPath $targetFolder -Directory -Recurse\n    # Write-Output $subFolders\n\n    foreach ($folder in $subFolders) &#123;\n        if ($folder.Name -eq &quot;image&quot;) &#123;\n            $header &#x3D; Split-Path -Path $folder.FullName -Parent\n            Write-Output &quot;&quot;\n            Write-Debug &quot;Enter Place: $($header)&quot;\n\n            $filesToMove &#x3D; Get-ChildItem -LiteralPath $folder.FullName -File\n\n            try &#123;\n                foreach ($file in $filesToMove) &#123;\n                    $destination &#x3D; Join-Path -Path $header -ChildPath $file.Name\n                    Move-Item -LiteralPath $file.FullName -Destination $destination\n                    Write-Debug &quot;Find File: $($file.FullName)&quot;\n                    Write-Debug &quot;Destination: $&#123;destination&#125;&quot;\n                &#125;\n                \n                # Remove useless &quot;image&quot; Folder\n                Remove-Item -LiteralPath $folder.FullName -Force -Recurse\n                Write-Debug &quot;Remove Place: $($folder.FullName)&quot;\n                Write-Output &quot;$($folder.FullName)&#39;s Processing Completed!&quot;\n            &#125;\n            catch &#123;\n                $errCount +&#x3D; 1\n                New-Item -Path $targetFolder -Name &quot;$($errCount).err&quot; -Value $folder.FullName\n            &#125;\n        &#125;\n    &#125;\n\n    Write-Debug &quot;Error Numbers: $($errCount)&quot;\n&#125;\n\nWrite-Output &quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#96;n&quot;\nWrite-Output $PSScriptRoot\n\nRecursivelyMoveFiles -targetFolder $PSScriptRoot\n\nWrite-Output &quot;&#96;n &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Finish &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#96;n&quot;\n# Pause</code></pre>\r\n","text":"Powershell Main References: Getting Started with PowerShell - PowerShell | Microsoft Learn Execution Policy about Execution Policies - Power...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"Powershell","slug":"Powershell","count":1,"path":"api/categories/Powershell.json"},{"name":"Language Learning","slug":"Powershell/Language-Learning","count":1,"path":"api/categories/Powershell/Language-Learning.json"}],"tags":[{"name":"Powershell","slug":"Powershell","count":2,"path":"api/tags/Powershell.json"},{"name":"Language Learning","slug":"Language-Learning","count":19,"path":"api/tags/Language-Learning.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#powershell\"><span class=\"toc-text\">Powershell</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#execution-policy\"><span class=\"toc-text\">Execution Policy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#discoverability\"><span class=\"toc-text\">Discoverability</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#the-three-core-cmdlets-in-powershell\"><span class=\"toc-text\">The Three Core Cmdlets in\r\nPowerShell</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#get-help\"><span class=\"toc-text\">Get-Help</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BB%BD%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">一份示例</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"RESTful规范 - 如何写API","uid":"a92e2fc05670d2982e0ff2c87e209a38","slug":"Dev/Theory/MVVM","date":"2023-12-09T13:32:32.000Z","updated":"2023-12-10T16:48:30.543Z","comments":true,"path":"api/articles/Dev/Theory/MVVM.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"MVVM https://zh.wikipedia.org/zh-cn/MVVM img MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的视图模型是一个值转换器， 这意味着视图模型负责从模型中暴露（转...","link":"","photos":[],"count_time":{"symbolsCount":337,"symbolsTime":"1 mins."},"categories":[{"name":"Theroy","slug":"Theroy","count":6,"path":"api/categories/Theroy.json"}],"tags":[{"name":"Theroy","slug":"Theroy","count":6,"path":"api/tags/Theroy.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Advanced CSharp","uid":"36e65544b0ba9be0c7ba1f8cd3f769cc","slug":"Language Learning/C#/Dotnet","date":"2023-12-03T14:35:34.000Z","updated":"2023-12-03T15:49:16.524Z","comments":true,"path":"api/articles/Language Learning/C#/Dotnet.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Dotnet .NET - 维基百科，自由的百科全书 (wikipedia.org) .NET框架 - 维基百科，自由的百科全书 (wikipedia.org) 语言功能与库类型之间的关系 - C# | Microsoft Learn 首先是Dotnet Framework： 微...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"C#","slug":"C","count":3,"path":"api/categories/C.json"},{"name":"Language Learning","slug":"C/Language-Learning","count":3,"path":"api/categories/C/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":19,"path":"api/tags/Language-Learning.json"},{"name":"C#","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}