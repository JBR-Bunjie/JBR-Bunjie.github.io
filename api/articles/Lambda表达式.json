{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Lambda表达式","date":"2023-03-07T16:14:44.658Z","updated":"2021-09-29T00:25:47.000Z","comments":true,"path":"api/articles/Lambda表达式.json","keywords":null,"cover":null,"content":"<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><h2 id=\"一、Lambda表达式简介\"><a href=\"#一、Lambda表达式简介\" class=\"headerlink\" title=\"一、Lambda表达式简介\"></a>一、Lambda表达式简介</h2><h3 id=\"什么是Lambda？\"><a href=\"#什么是Lambda？\" class=\"headerlink\" title=\"什么是Lambda？\"></a>什么是Lambda？</h3><p>Lambda是JAVA 8添加的新特性，说白了，Lambda是一个匿名函数</p>\n<h3 id=\"为什么使用Lambda\"><a href=\"#为什么使用Lambda\" class=\"headerlink\" title=\"为什么使用Lambda\"></a>为什么使用Lambda</h3><p>使用Lambda表达式可以对一个接口的方法进行非常简洁的实现</p>\n<h3 id=\"Lambda对接口的要求\"><a href=\"#Lambda对接口的要求\" class=\"headerlink\" title=\"Lambda对接口的要求\"></a>Lambda对接口的要求</h3><p>虽然可以使用Lambda表达式对某些接口进行简单的实现，但是并不是所有的接口都可以用Lambda表达式来实现，要求接口中定义的<strong>必须要实现的抽象方法只能是一个</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">在JAVA8中 ，对接口加了一个新特性：default\n可以使用default对接口方法进行修饰，被修饰的方法在接口中可以默认实现</code></pre>\n\n<h3 id=\"FunctionalInterface\"><a href=\"#FunctionalInterface\" class=\"headerlink\" title=\"@FunctionalInterface\"></a>@FunctionalInterface</h3><p>修饰函数式接口的，接口中的抽象方法只有一个</p>\n<h2 id=\"二、Lambda的基础语法\"><a href=\"#二、Lambda的基础语法\" class=\"headerlink\" title=\"二、Lambda的基础语法\"></a>二、Lambda的基础语法</h2><h3 id=\"1-语法\"><a href=\"#1-语法\" class=\"headerlink\" title=\"1.语法\"></a>1.语法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 1.Lambda表达式的基础语法\n&#x2F;&#x2F; Lambda是一个匿名函数 一般关注的是以下两个重点\n&#x2F;&#x2F; 参数列表 方法体\n\n&#x2F;**\n* （）：用来描述参数列表\n*  &#123;&#125;：用来描述方法体 有时可以省略\n*  -&gt;: Lambda运算符 读作goes to\n*  例 Test t&#x3D;()-&gt;&#123;System.out.println(&quot;hello word&quot;)&#125;; 大括号可省略\n*&#x2F;</code></pre>\n\n\n\n<h3 id=\"2-创建多个接口\"><a href=\"#2-创建多个接口\" class=\"headerlink\" title=\"2.创建多个接口\"></a>2.创建多个接口</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 无参数无返回值接口\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 10:24\n *&#x2F;\n@FunctionalInterface\npublic interface LambdaNoneReturnNoneParmeter &#123;\n    void test();\n&#125;\n\n&#x2F;**\n * 无返回值有单个参数\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 10:26\n *&#x2F;\n@FunctionalInterface\npublic interface LambdaNoneReturnSingleParmeter &#123;\n    void test(int n);\n&#125;\n\n&#x2F;**\n * 无返回值 多个参数的接口\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 10:27\n *&#x2F;\n@FunctionalInterface\npublic interface LambdaNoneReturnMutipleParmeter &#123;\n    void test(int a,int b);\n&#125;\n\n&#x2F;**\n * 有返回值 无参数接口\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 10:28\n *&#x2F;\n@FunctionalInterface\npublic interface LambdaSingleReturnNoneParmeter &#123;\n    int test();\n&#125;\n\n&#x2F;**\n * 有返回值 有单个参数的接口\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 10:29\n *&#x2F;\n@FunctionalInterface\npublic interface LambdaSingleReturnSingleParmeter &#123;\n    int test(int n);\n&#125;\n\n&#x2F;**\n * 有返回值 有多个参数的接口\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 10:30\n *&#x2F;\n@FunctionalInterface\npublic interface LambdaSingleReturnMutipleParmeter &#123;\n    int test(int a,int b);\n&#125;</code></pre>\n\n<h3 id=\"3-创建测试类\"><a href=\"#3-创建测试类\" class=\"headerlink\" title=\"3.创建测试类\"></a>3.创建测试类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.alan.learn.syntax;\n\nimport com.alan.learn.interfaces.*;\n\n&#x2F;**\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 10:33\n *&#x2F;\npublic class Syntax1 &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1.Lambda表达式的基础语法\n        &#x2F;&#x2F; Lambda是一个匿名函数 一般关注的是以下两个重点\n        &#x2F;&#x2F; 参数列表 方法体\n\n        &#x2F;**\n         * （）：用来描述参数列表\n         *  &#123;&#125;：用来描述方法体\n         *  -&gt;: Lambda运算符 读作goes to\n         *&#x2F;\n\n        &#x2F;&#x2F; 无参无返回  \n        LambdaNoneReturnNoneParmeter lambda1&#x3D;()-&gt;&#123;\n            System.out.println(&quot;hello word&quot;);\n        &#125;;\n        lambda1.test();\n\n        &#x2F;&#x2F; 无返回值 单个参数 \n        LambdaNoneReturnSingleParmeter lambda2&#x3D;(int n)-&gt;&#123;\n            System.out.println(&quot;参数是：&quot;+n);\n        &#125;;\n        lambda2.test(10);\n\n        &#x2F;&#x2F; 无返回值 多个参数\n        LambdaNoneReturnMutipleParmeter lambda3&#x3D;(int a,int b)-&gt;&#123;\n            System.out.println(&quot;参数和是：&quot;+(a+b));\n        &#125;;\n        lambda3.test(10,12);\n\n        &#x2F;&#x2F; 有返回值 无参数\n        LambdaSingleReturnNoneParmeter lambda4&#x3D;()-&gt;&#123;\n            System.out.println(&quot;lambda4：&quot;);\n            return 100;\n        &#125;;\n        int ret&#x3D;lambda4.test();\n        System.out.println(&quot;返回值是：&quot;+ret);\n\n        &#x2F;&#x2F; 有返回值 单个参数\n        LambdaSingleReturnSingleParmeter lambda5&#x3D;(int a)-&gt;&#123;\n            return a*2;\n        &#125;;\n        int ret2&#x3D; lambda5.test(3);\n        System.out.println(&quot;单个参数，lambda5返回值是:&quot;+ret2);\n\n        &#x2F;&#x2F;有返回值 多个参数\n        LambdaSingleReturnMutipleParmeter lambda6&#x3D;(int a,int b)-&gt;&#123;\n            return a+b;\n        &#125;;\n        int ret3&#x3D;lambda6.test(12,14);\n        System.out.println(&quot;多个参数，lambda6返回值是：&quot;+ret3);\n    &#125;\n&#125;\n\n输出结果：\n    hello word\n\t参数是：10\n\t参数和是：22\n\tlambda4：\n\t返回值是：100\n\t单个参数，lambda5返回值是:6\n    多个参数，lambda6返回值是：26</code></pre>\n\n<h2 id=\"三、语法精简\"><a href=\"#三、语法精简\" class=\"headerlink\" title=\"三、语法精简\"></a>三、语法精简</h2><p>针对上述基础语法的精简</p>\n<h3 id=\"1-参数类型精简\"><a href=\"#1-参数类型精简\" class=\"headerlink\" title=\"1.参数类型精简\"></a>1.参数类型精简</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* 语法精简\n* 1.参数类型\n* 由于在接口的抽象方法中，已经定义了参数的数量类型 所以在Lambda表达式中参数的类型可以省略\n* 备注：如果需要省略类型，则每一个参数的类型都要省略，千万不要一个省略一个不省略\n*&#x2F;\nLambdaNoneReturnMutipleParmeter lambda1&#x3D;(int a,int b)-&gt; &#123;\n    System.out.println(&quot;hello world&quot;); \n&#125;;    \n可以精简为:\nLambdaNoneReturnMutipleParmeter lambda1&#x3D;(a,b)-&gt; &#123;\n    System.out.println(&quot;hello world&quot;);\n&#125;;</code></pre>\n\n<h3 id=\"2-参数小括号精简\"><a href=\"#2-参数小括号精简\" class=\"headerlink\" title=\"2.参数小括号精简\"></a>2.参数小括号精简</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* 2.参数小括号\n* 如果参数列表中，参数的数量只有一个 此时小括号可以省略\n*&#x2F;\nLambdaNoneReturnSingleParmeter lambda2&#x3D;(a)-&gt;&#123;\n    System.out.println(&quot;hello world&quot;);\n&#125;;\n可以精简为:\nLambdaNoneReturnSingleParmeter lambda2&#x3D; a-&gt;&#123;\n    System.out.println(&quot;hello world&quot;);\n&#125;;</code></pre>\n\n<h3 id=\"3-方法大括号精简\"><a href=\"#3-方法大括号精简\" class=\"headerlink\" title=\"3.方法大括号精简\"></a>3.方法大括号精简</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* 3.方法大括号\n* 如果方法体中只有一条语句，此时大括号可以省略\n*&#x2F;\nLambdaNoneReturnSingleParmeter lambda3&#x3D;a-&gt;&#123;\n    System.out.println(&quot;hello world&quot;);\n&#125;;\n可以精简为:\nLambdaNoneReturnSingleParmeter lambda3&#x3D;a-&gt;System.out.println(&quot;hello world&quot;);</code></pre>\n\n<h3 id=\"4-大括号精简补充\"><a href=\"#4-大括号精简补充\" class=\"headerlink\" title=\"4.大括号精简补充\"></a>4.大括号精简补充</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* 4.如果方法体中唯一的一条语句是一个返回语句\n* 贼省略大括号的同时 也必须省略return\n*&#x2F;\nLambdaSingleReturnNoneParmeter lambda4&#x3D;()-&gt;&#123;\n    return 10;\n&#125;;\n可以精简为:\nLambdaSingleReturnNoneParmeter lambda4&#x3D;()-&gt;10;</code></pre>\n\n<h3 id=\"5-多参数，有返回值-精简\"><a href=\"#5-多参数，有返回值-精简\" class=\"headerlink\" title=\"5.多参数，有返回值 精简\"></a>5.多参数，有返回值 精简</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">LambdaSingleReturnNoneParmeter lambda4&#x3D;(a,b)-&gt;&#123;\n    return a+b;\n&#125;;\n可以精简为:\nLambdaSingleReturnMutipleParmeter lambda5&#x3D;(a,b)-&gt;a+b;</code></pre>\n\n<h2 id=\"四、Lambda语法进阶\"><a href=\"#四、Lambda语法进阶\" class=\"headerlink\" title=\"四、Lambda语法进阶\"></a>四、Lambda语法进阶</h2><h3 id=\"1-方法引用-普通方法与静态方法\"><a href=\"#1-方法引用-普通方法与静态方法\" class=\"headerlink\" title=\"1.方法引用(普通方法与静态方法)\"></a>1.方法引用(普通方法与静态方法)</h3><p>在实际应用过程中，一个接口在很多地方都会调用同一个实现，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">LambdaSingleReturnMutipleParmeter lambda1&#x3D;(a,b)-&gt;a+b;\nLambdaSingleReturnMutipleParmeter lambda2&#x3D;(a,b)-&gt;a+b;</code></pre>\n\n<p>这样一来每次都要写上具体的实现方法 a+b，如果需求变更，则每一处实现都需要更改，基于这种情况，可以将后续的是实现更改为已定义的 方法，需要时直接调用就行</p>\n<h4 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n*方法引用：\n* 可以快速的将一个Lambda表达式的实现指向一个已经实现的方法\n* 方法的隶属者 如果是静态方法 隶属的就是一个类  其他的话就是隶属对象\n* 语法：方法的隶属者::方法名\n* 注意：\n*  1.引用的方法中，参数数量和类型一定要和接口中定义的方法一致\n*  2.返回值的类型也一定要和接口中的方法一致\n*&#x2F;</code></pre>\n\n<h4 id=\"例：\"><a href=\"#例：\" class=\"headerlink\" title=\"例：\"></a>例：</h4><ul>\n<li>```java<br>package com.alan.learn.syntax;import com.alan.learn.interfaces.LambdaSingleReturnSingleParmeter;/**<ul>\n<li><p>@author Alan</p>\n</li>\n<li><p>@version 1.0</p>\n</li>\n<li><p>@date 2020-05-27 11:48</p>\n</li>\n<li><p>/<br>public class Syntax3 {</p>\n<p>  public static void main(String[] args) {</p>\n<pre><code>  LambdaSingleReturnSingleParmeter lambda1=a-&gt;a*2;\n  LambdaSingleReturnSingleParmeter lambda2=a-&gt;a*2;\n  LambdaSingleReturnSingleParmeter lambda3=a-&gt;a*2;\n\n  //简化\n  LambdaSingleReturnSingleParmeter lambda4=a-&gt;change(a);\n\n  //方法引用\n  LambdaSingleReturnSingleParmeter lambda5=Syntax3::change;\n</code></pre>\n<p>  }</p>\n<p>  /**</p>\n<ul>\n<li>自定义的实现方法</li>\n<li>/<br>private static int change(int a){<br>   return a*2;<br>}<br>}</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n### 2.方法引用(构造方法) ###\n\n目前有一个实体类\n\n&#96;&#96;&#96;java\npublic class Person &#123;\n    public String name;\n    public int age;\n\n    public Person() &#123;\n        System.out.println(&quot;Person的无参构造方法执行&quot;);\n    &#125;\n\n    public Person(String name, int age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n        System.out.println(&quot;Person的有参构造方法执行&quot;);\n    &#125;\n&#125;</code></pre></li>\n</ul>\n<p>需求</p>\n<p>两个接口，各有一个方法，一个接口的方法需要引用Person的无参构造，一个接口的方法需要引用Person的有参构造 用于返回两个Person对象，例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">interface PersonCreater&#123;\n    &#x2F;&#x2F;通过Person的无参构造实现\n    Person getPerson();\n&#125;\n\ninterface PersonCreater2&#123;\n    &#x2F;&#x2F;通过Person的有参构造实现\n    Person getPerson(String name,int age);\n&#125;</code></pre>\n\n<p>那么可以写作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Syntax4 &#123;\n    public static void main(String[] args) &#123;\n\n        PersonCreater creater&#x3D;()-&gt;new Person();\n\n        &#x2F;&#x2F;引用的是Person的无参构造\n         &#x2F;&#x2F;PersonCreater接口的方法指向的是Person的方法\n        PersonCreater creater1&#x3D;Person::new; &#x2F;&#x2F;等价于上面的()-&gt;new Person()\n        &#x2F;&#x2F;实际调用的是Person的无参构造 相当于把接口里的getPerson()重写成new Person()。\n        Person a&#x3D;creater1.getPerson(); \n\n        &#x2F;&#x2F;引用的是Person的有参构造\n        PersonCreater2 creater2&#x3D;Person::new;\n        Person b&#x3D;creater2.getPerson(&quot;张三&quot;,18);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>注意：是引用无参构造还是引用有参构造 在于接口定义的方法参数</strong></p>\n<h2 id=\"五、综合练习\"><a href=\"#五、综合练习\" class=\"headerlink\" title=\"五、综合练习\"></a>五、综合练习</h2><h3 id=\"1-集合排序案例\"><a href=\"#1-集合排序案例\" class=\"headerlink\" title=\"1.集合排序案例\"></a>1.集合排序案例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.alan.exercise;\n\nimport com.alan.learn.data.Person;\n\nimport java.util.ArrayList;\n\n&#x2F;**\n * 集合排序案例\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 15:08\n *&#x2F;\npublic class Exercise1 &#123;\n\n    public static void main(String[] args) &#123;\n\n        &#x2F;&#x2F;需求：已知在一个ArrayList中有若干各Person对象，将这些Person对象按照年龄进行降序排列\n        ArrayList&lt;Person&gt; list&#x3D;new ArrayList&lt;&gt;();\n\n\n        list.add(new Person(&quot;张三&quot;,10));\n        list.add(new Person(&quot;李四&quot;,12));\n        list.add(new Person(&quot;王五&quot;,13));\n        list.add(new Person(&quot;赵六&quot;,14));\n        list.add(new Person(&quot;李雷&quot;,11));\n        list.add(new Person(&quot;韩梅梅&quot;,8));\n        list.add(new Person(&quot;jack&quot;,10));\n\n        System.out.println(&quot;排序前：&quot;+list);\n\n        &#x2F;&#x2F;将排列的依据传入 具体的方法指向的是 内部元素的age相减 sort会依据结果的正负进行降序排列\n        &#x2F;&#x2F;sort 使用提供的 Comparator对此列表进行排序以比较元素。\n        list.sort((o1, o2) -&gt; o2.age-o1.age);\n\n        System.out.println(&quot;排序后：&quot;+list);\n    &#125;\n&#125;\n</code></pre>\n\n<h3 id=\"2-Treeset排序案例\"><a href=\"#2-Treeset排序案例\" class=\"headerlink\" title=\"2.Treeset排序案例\"></a>2.Treeset排序案例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.alan.exercise;\n\nimport com.alan.learn.data.Person;\n\nimport java.util.TreeSet;\n\n&#x2F;**\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 15:37\n *&#x2F;\npublic class Exercise2 &#123;\n    public static void main(String[] args) &#123;\n\n        &#x2F;**Treeset 自带排序\n         * 但是现在不知道Person谁大谁小无法排序\n         * 解决方法：\n         * 使用Lambda表达式实现Comparator接口，并实例化一个TreeSet对象\n         * 注意：在TreeSet中如果Comparator返回值是 0 会判断这是两个元素是相同的 会进行去重\n         * TreeSet&lt;Person&gt; set&#x3D;new TreeSet&lt;&gt;((o1, o2) -&gt; o2.age-o1.age); \n         * 这个获取的对象打印会少一个Person\n         * 此时我们将方法修改\n        *&#x2F;\n        TreeSet&lt;Person&gt; set&#x3D;new TreeSet&lt;&gt;((o1, o2) -&gt;&#123;\n            if(o1.age&gt;&#x3D;o2.age)&#123;\n                return -1;\n            &#125;else &#123;\n                return 1;\n            &#125;\n        &#125;);\n\n        set.add(new Person(&quot;张三&quot;,10));\n        set.add(new Person(&quot;李四&quot;,12));\n        set.add(new Person(&quot;王五&quot;,13));\n        set.add(new Person(&quot;赵六&quot;,14));\n        set.add(new Person(&quot;李雷&quot;,11));\n        set.add(new Person(&quot;韩梅梅&quot;,8));\n        set.add(new Person(&quot;jack&quot;,10));\n\n        System.out.println(set);\n    &#125;\n&#125;\n</code></pre>\n\n<h3 id=\"3-集合的遍历\"><a href=\"#3-集合的遍历\" class=\"headerlink\" title=\"3.集合的遍历\"></a>3.集合的遍历</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.alan.exercise;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n&#x2F;**\n * 集合的遍历\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 15:52\n *&#x2F;\npublic class Exercise3 &#123;\n\n    public static void main(String[] args) &#123;\n        ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();\n\n        Collections.addAll(list,1,2,3,4,5,6,7,8,9);\n        &#x2F;**\n         * list.forEach(Consumer&lt;? super E&gt; action) \n         * api文档解释： 对 集合中的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。\n         * 将集合中的每一个元素都带入到接口Consumer的方法accept中  然后方法accept指向我们的引用\n         * 输出集合中的所有元素\n         * list.forEach(System.out::println);\n        *&#x2F;\n\n        &#x2F;&#x2F;输出集合中所有的偶数\n        list.forEach(ele-&gt;&#123;\n            if(ele%2&#x3D;&#x3D;0)&#123;\n                System.out.println(ele);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n</code></pre>\n\n<h3 id=\"4-删除集合中满足条件的元素\"><a href=\"#4-删除集合中满足条件的元素\" class=\"headerlink\" title=\"4.删除集合中满足条件的元素\"></a>4.删除集合中满足条件的元素</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.alan.exercise;\n\nimport com.alan.learn.data.Person;\n\nimport java.util.ArrayList;\n\n&#x2F;**\n * 删除集合中满足条件的元素\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 16:05\n *&#x2F;\npublic class Exercise4 &#123;\n\n    public static void main(String[] args) &#123;\n        ArrayList&lt;Person&gt; list&#x3D;new ArrayList&lt;&gt;();\n\n        list.add(new Person(&quot;张三&quot;,10));\n        list.add(new Person(&quot;李四&quot;,12));\n        list.add(new Person(&quot;王五&quot;,13));\n        list.add(new Person(&quot;赵六&quot;,14));\n        list.add(new Person(&quot;李雷&quot;,11));\n        list.add(new Person(&quot;韩梅梅&quot;,8));\n        list.add(new Person(&quot;jack&quot;,10));\n\n        &#x2F;&#x2F;删除集合中年龄大于12的元素\n        &#x2F;**\n         * 之前迭代器的做法\n         * ListIterator&lt;Person&gt; it &#x3D; list.listIterator();\n         * while (it.hasNext())&#123;\n         *   Person ele&#x3D;it.next();\n         *   if(ele.age&gt;12)&#123;\n         *         it.remove();\n         *   &#125;\n         * &#125;\n         *&#x2F;\n\n        &#x2F;**\n         * lambda实现\n         * 逻辑\n         * 将集合中的每一个元素都带入到接口Predicate的test方法中，\n         * 如果返回值是true，则删除这个元素\n        *&#x2F;\n        list.removeIf(ele-&gt;ele.age&gt;10);\n        System.out.println(list);\n    &#125;\n&#125;\n</code></pre>\n\n<h3 id=\"5-开辟一条线程-做一个数字的输出\"><a href=\"#5-开辟一条线程-做一个数字的输出\" class=\"headerlink\" title=\"5.开辟一条线程 做一个数字的输出\"></a>5.开辟一条线程 做一个数字的输出</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.alan.exercise;\n\n&#x2F;**\n * 需求：\n * 开辟一条线程 做一个数字的输出\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 16:17\n *&#x2F;\npublic class Exercise5 &#123;\n    public static void main(String[] args) &#123;\n\n        &#x2F;**\n         * 通过Runnable 来实例化线程\n         *&#x2F;\n        Thread t&#x3D;new Thread(()-&gt;&#123;\n            for(int i&#x3D;0;i&lt;100;i++)&#123;\n                System.out.println(i);\n            &#125;\n        &#125;);\n        t.start();\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"六、系统内置的函数式接口\"><a href=\"#六、系统内置的函数式接口\" class=\"headerlink\" title=\"六、系统内置的函数式接口\"></a>六、系统内置的函数式接口</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.alan.functional;\n\nimport java.util.function.*;\n\n&#x2F;**\n * 系统内置的一些函数式接口\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 16:23\n *&#x2F;\npublic class FunctionalInterface &#123;\n    public static void main(String[] args) &#123;\n\n        &#x2F;&#x2F; Predicate&lt;T&gt;              ：     参数是T 返回值boolean  \n        &#x2F;&#x2F; 在后续如果一个接口需要指定类型的参数，返回boolean时可以指向 Predicate\n        &#x2F;&#x2F;          IntPredicate            int -&gt; boolean\n        &#x2F;&#x2F;          LongPredicate           long -&gt; boolean\n        &#x2F;&#x2F;          DoublePredicate         double -&gt; boolean\n\n        &#x2F;&#x2F; Consumer&lt;T&gt;               :      参数是T 无返回值(void)\n        &#x2F;&#x2F;          IntConsumer             int -&gt;void\n        &#x2F;&#x2F;          LongConsumer            long -&gt;void\n        &#x2F;&#x2F;          DoubleConsumer          double -&gt;void\n\n        &#x2F;&#x2F; Function&lt;T,R&gt;             :      参数类型T  返回值R\n        &#x2F;&#x2F;          IntFunction&lt;R&gt;          int -&gt; R\n        &#x2F;&#x2F;          LongFunction&lt;R&gt;         long -&gt; R\n        &#x2F;&#x2F;          DoubleFunction&lt;R&gt;       double -&gt; R\n        &#x2F;&#x2F;          IntToLongFunction       int -&gt; long\n        &#x2F;&#x2F;          IntToDoubleFunction     int -&gt; double\n        &#x2F;&#x2F;          LongToIntFunction       long -&gt; int\n        &#x2F;&#x2F;          LongToDoubleFunction    long -&gt; double\n        &#x2F;&#x2F;          DoubleToLongFunction    double -&gt; long\n        &#x2F;&#x2F;          DoubleToIntFunction     double -&gt; int\n\n        &#x2F;&#x2F; Supplier&lt;T&gt; : 参数 无 返回值T\n        &#x2F;&#x2F; UnaryOperator&lt;T&gt; :参数T 返回值 T\n        &#x2F;&#x2F; BiFunction&lt;T,U,R&gt; : 参数 T、U 返回值 R\n        &#x2F;&#x2F; BinaryOperator&lt;T&gt; ：参数 T、T 返回值 T\n        &#x2F;&#x2F; BiPredicate&lt;T,U&gt; :  参数T、U  返回值 boolean\n        &#x2F;&#x2F; BiConsumer&lt;T,U&gt; :    参数T、U 无返回值\n\n        &#x2F;**\n         * 常用的 函数式接口\n         * Predicate&lt;T&gt;、Consumer&lt;T&gt;、Function&lt;T,R&gt;、Supplier&lt;T&gt;\n         *&#x2F;\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"七、Lambda闭包\"><a href=\"#七、Lambda闭包\" class=\"headerlink\" title=\"七、Lambda闭包\"></a>七、Lambda闭包</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.alan.closure;\n\nimport java.util.function.Supplier;\n\n&#x2F;**\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 16:59\n *&#x2F;\npublic class ClosureDemo &#123;\n    public static void main(String[] args) &#123;\n\n        &#x2F;**\n         * lambda的闭包会提升包围变量的生命周期\n         * 所以局部变量 num在getNumber()方法内被 get()引用 不会在getNumber()方法执行后销毁\n         * 这种方法可以在外部获取到某一个方法的局部变量\n         *&#x2F;\n        int n&#x3D;getNumber().get();\n        System.out.println(n);\n    &#125;\n    private static Supplier&lt;Integer&gt; getNumber()&#123;\n        int num&#x3D;10;\n        &#x2F;**\n         * Supplier supplier&#x3D;()-&gt;num;\n         * return supplier;\n         *&#x2F;\n        return ()-&gt;&#123;\n            return num;\n        &#125;;\n    &#125;\n&#125;\n*************************************************************************\n    \npackage com.alan.closure;\n\nimport java.util.function.Consumer;\n\n&#x2F;**\n * @author Alan\n * @version 1.0\n * @date 2020-05-27 17:20\n *&#x2F;\npublic class ClosureDemo2 &#123;\n    public static void main(String[] args) &#123;\n        int a&#x3D;10;\n        Consumer&lt;Integer&gt; c&#x3D;ele-&gt;&#123;\n            System.out.println(a+1);\n            &#x2F;&#x2F;System.out.println(ele);\n            &#x2F;&#x2F;System.out.println(a++); 会报错\n            &#x2F;&#x2F;在lambda中引用局部变量 这个变量必须是一个常量\n        &#125;;\n        &#x2F;&#x2F;a++; 这样也会导致内部报错\n        &#x2F;&#x2F;如果在内部已经引用局部变量 参数传递后 打印的还是 10\n        c.accept(1);\n    &#125;\n&#125;\n</code></pre>\n\n","text":"Lambda表达式一、Lambda表达式简介什么是Lambda？Lambda是JAVA 8添加的新特性，说白了，Lambda是一个匿名函数 为什么使用Lambda使用Lambda表达式可以对一个接口的方法进行非常简洁的实现 Lambda对接口的要求虽然可以使用Lambda表达式对...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">Lambda表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">一、Lambda表达式简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFLambda%EF%BC%9F\"><span class=\"toc-text\">什么是Lambda？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Lambda\"><span class=\"toc-text\">为什么使用Lambda</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Lambda%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">Lambda对接口的要求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#FunctionalInterface\"><span class=\"toc-text\">@FunctionalInterface</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81Lambda%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">二、Lambda的基础语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">1.语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2.创建多个接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB\"><span class=\"toc-text\">3.创建测试类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E8%AF%AD%E6%B3%95%E7%B2%BE%E7%AE%80\"><span class=\"toc-text\">三、语法精简</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%B2%BE%E7%AE%80\"><span class=\"toc-text\">1.参数类型精简</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%82%E6%95%B0%E5%B0%8F%E6%8B%AC%E5%8F%B7%E7%B2%BE%E7%AE%80\"><span class=\"toc-text\">2.参数小括号精简</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%96%B9%E6%B3%95%E5%A4%A7%E6%8B%AC%E5%8F%B7%E7%B2%BE%E7%AE%80\"><span class=\"toc-text\">3.方法大括号精简</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E7%B2%BE%E7%AE%80%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">4.大括号精简补充</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%A4%9A%E5%8F%82%E6%95%B0%EF%BC%8C%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC-%E7%B2%BE%E7%AE%80\"><span class=\"toc-text\">5.多参数，有返回值 精简</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81Lambda%E8%AF%AD%E6%B3%95%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">四、Lambda语法进阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8-%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.方法引用(普通方法与静态方法)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">语法：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">例：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">五、综合练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">1.集合排序案例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Treeset%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2.Treeset排序案例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">3.集合的遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88%E4%B8%AD%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">4.删除集合中满足条件的元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%BC%80%E8%BE%9F%E4%B8%80%E6%9D%A1%E7%BA%BF%E7%A8%8B-%E5%81%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">5.开辟一条线程 做一个数字的输出</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E7%B3%BB%E7%BB%9F%E5%86%85%E7%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">六、系统内置的函数式接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81Lambda%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">七、Lambda闭包</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Live2dWeb实现","date":"2023-03-07T16:14:44.661Z","updated":"2021-09-18T00:28:02.000Z","comments":true,"path":"api/articles/Live2dWeb实现.json","keywords":null,"cover":null,"text":"Search · Live2D Viewer (github.com) guansss/live2d-viewer-web: Web implementation of Live2D Viewer. (github.com) alg-wiki/magireco-live2d-vi...","link":"","photos":[],"count_time":{"symbolsCount":274,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"E-Mail Format and Explanation","date":"2023-03-07T16:14:44.597Z","updated":"2022-02-08T08:06:10.000Z","comments":true,"path":"api/articles/E-Mail Format and Explanation.json","keywords":null,"cover":null,"text":"e-mail的格式主要包括4项： To：即这个e-mail发给谁，通常是接受者的电子邮件信箱。 From：即这个e-mail是谁发的，通常是发送者的电子邮件信箱。 CC: carbon copy 的缩写，愿意是用复写纸预写副本，在e-mail 中为“抄送”之意，即可同时把此邮件发...","link":"","photos":[],"count_time":{"symbolsCount":194,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}