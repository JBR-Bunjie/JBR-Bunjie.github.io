{"title":"实现一个视差体积雾吧！","uid":"71fbc7ff44065d31551c0ea05fc7175a","slug":"Rendering/ParallaxCloud","date":"2023-03-02T04:23:23.000Z","updated":"2023-10-27T20:20:43.000Z","comments":true,"path":"api/articles/Rendering/ParallaxCloud.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"实现一个视差体积雾吧！\"><a href=\"#实现一个视差体积雾吧！\" class=\"headerlink\" title=\"实现一个视差体积雾吧！\"></a>实现一个视差体积雾吧！</h1><h2 id=\"原理说明\"><a href=\"#原理说明\" class=\"headerlink\" title=\"原理说明\"></a>原理说明</h2><p>核心思路：基于一张噪点图，基于切线空间下的视线方向，不断偏移 uv 来取样其中的内容，由于 Texture 下暗处的 rgb 三值都会急速下降并趋于 0，因此让 uv 偏移到暗处即可形成自然的颜色渐变——我们的视差体积雾即以该内容来伪装“高度”。在完成采样后，将最终采样与初始采样做合并来让暗部更暗以增强对比。</p>\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><h3 id=\"Vertex-Shader\"><a href=\"#Vertex-Shader\" class=\"headerlink\" title=\"Vertex Shader\"></a>Vertex Shader</h3><p>构建 <code>rotation</code> 矩阵，并利用该矩阵将 ObjectSpace 下的 viewDir 转换到 Tangent 空间下。在切线空间，顶点和像素成为原点，xy 轴与 uv 同向——此时就可以利用 ViewDir 来代表了一种对 uv 进行抽象的渐进取样方向与步长，当然，这里只有方向是可以直接使用的，对于具体的步长内容，我们应该将它们的控制变量利用属性以暴露出来。</p>\n<h3 id=\"Fragment-Shader\"><a href=\"#Fragment-Shader\" class=\"headerlink\" title=\"Fragment Shader\"></a>Fragment Shader</h3><h4 id=\"步长\"><a href=\"#步长\" class=\"headerlink\" title=\"步长\"></a>步长</h4><p>首先我们将 viewDir 分为 xy 和 z 两个维度，分别利用外置暴露的属性来进行控制，这有两个目的：</p>\n<ul>\n<li>xy 控制了对 uv 的最大偏移量</li>\n<li>而对 z 进行控制，则是为了控制单次偏移的步长</li>\n</ul>\n<p>最终计算步长：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">float3 minOffset &#x3D; viewDir &#x2F; (viewDir.z * _Layers)</code></pre>\n\n<h4 id=\"初始采样\"><a href=\"#初始采样\" class=\"headerlink\" title=\"初始采样\"></a>初始采样</h4><p>之后，我们先利用初始的 uv 来对 texture 进行取样，这是可选的，但我们利用它来作为一个底层，并将之后的计算结果全部都叠加与这之上，这会：</p>\n<ul>\n<li>加快取样 uv 的偏移过程</li>\n<li>增加暗部与亮部的对比来增强立体感</li>\n</ul>\n<h4 id=\"uv-偏移过程\"><a href=\"#uv-偏移过程\" class=\"headerlink\" title=\"uv 偏移过程\"></a>uv 偏移过程</h4><p>uv 偏移结束是基于两个内容的：finiNoise 的减小与 minOffset 上 z 分量的逐步叠加，其中 finiNoise 会减小是因为其数据的直接来源——Texture，在黑色上，其 rgb 值是趋于 0 的——这会让 finiNoise 急速衰减，因此，我们实际使用的 Texture 实际上是由要求的——它的黑色部分应该受到相当程度的限制，否则实际上的偏移量会过小导致视差的体积云失效。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">float finiNoise &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv.xy).r * MainTex.r;  &#x2F;&#x2F; 只作为加快偏移结束的变量\nfloat3 prev_uv &#x3D; uv;\n\nwhile (finiNoise &gt; uv.z) &#123;\n    uv +&#x3D; minOffset;\n    finiNoise &#x3D; SAMPLE_TEXTURE2D_LOD(_MainTex, sampler_MainTex, uv.xy, 0).r * MainTex.r;\n    &#x2F;&#x2F; finiNoise &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv.xy).r * MainTex.r;\n    &#x2F;&#x2F; 此处不能使用寻常的SAMPLE_TEXTURE2D函数，原因见&#96;tex2Dlod&#96; 与 &#96;SAMPLE_TEXTURE2D_LOD&#96;一节\n&#125;</code></pre>\n\n<h4 id=\"最终取样\"><a href=\"#最终取样\" class=\"headerlink\" title=\"最终取样\"></a>最终取样</h4><p>在初始 uv 和最终 uv 间进行插值，这样使我们最终获得的结果更加平滑，减少画面的突变</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 可选\nfloat d1 &#x3D; finiNoise - uv.z;\nfloat d2 &#x3D; finiNoise - prev_uv.z;\nfloat w &#x3D; d1 &#x2F; (d1 - d2 + 0.0000001);\nuv &#x3D; lerp(uv, prev_uv, w);\n\n&#x2F;&#x2F; 利用最终完成变换的uv来进行取样\nhalf4 resultColor &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv.xy) * MainTex;</code></pre>\n\n<h4 id=\"返回结果\"><a href=\"#返回结果\" class=\"headerlink\" title=\"返回结果\"></a>返回结果</h4><p>暴露_Alpha 属性来控制云层密度</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">half rangeClt &#x3D; MainTex.a * resultColor.r + _Alpha * 0.75;\nhalf Alpha &#x3D; abs(smoothstep(rangeClt, _Alpha, 1.0));\nAlpha &#x3D; pow(Alpha, 5);\n\n&#x2F;&#x2F; Light light &#x3D; GetMainLight();\n\nreturn half4(resultColor.rgb * _Color.rgb, Alpha); &#x2F;&#x2F;* light.color.rgb</code></pre>\n\n<h2 id=\"代码讲解\"><a href=\"#代码讲解\" class=\"headerlink\" title=\"代码讲解\"></a>代码讲解</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>具体代码已在<a href=\"#code\">Reference</a>中给出</p></blockquote>\n<h3 id=\"tex2Dlod-与-SAMPLE-TEXTURE2D-LOD\"><a href=\"#tex2Dlod-与-SAMPLE-TEXTURE2D-LOD\" class=\"headerlink\" title=\"tex2Dlod 与 SAMPLE_TEXTURE2D_LOD\"></a><code>tex2Dlod</code> 与 <code>SAMPLE_TEXTURE2D_LOD</code></h3><p><code>tex2Dlod</code> 与 <code>SAMPLE_TEXTURE2D_LOD</code> 是两个同能相同的取样函数，分别对应了 <code>Built-in</code> 和 <code>urp</code> 两种渲染管线。不过，这并非意味着这两个函数分别对应了 <code>CG</code> 与 <code>HLSL</code> 中的不同的实现——事实上，<code>CG</code> 与 <code>HLSL</code> 中所定义的都是 <code>tex2Dlod</code>，<code>urp</code> 中采用新的 API，大概只是为了与原 <code>Built-in</code> 管线作出区分。</p>\n<p>那么，首先先来了解 <code>tex2Dlod</code> 函数：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Samples a 2D texture with mipmaps. The mipmap LOD is specified in t.w.<br><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod\">tex2Dlod - Win32 apps | Microsoft Learn</a></p></blockquote>\n<p>着我我们平常见到的 <code>tex2D</code> 函数是不同的——<code>tex2D</code> 仅采样当前纹理本身：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Samples a 2D texture.<br><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2d\">tex2D (HLSL reference) - Win32 apps | Microsoft Learn</a></p></blockquote>\n<p>当然，这也意味着我们使用该函数时，应确保加入的 texture 的 <code>Generate Mip Maps</code> 选项是勾选上的(当我们加入一张图片时，Unity 会帮我们默认勾选该内容:)</p>\n<p><img src=\"/....%5Cimages%5CDev%5CUnity%5CArchives%5CVolumeCloud%5C001.png\" alt=\"image-20230331190104741\"><br><em>Generate Mip Maps 选项</em></p>\n<p>当做好准备后，我们就可以利用 <code>tex2Dlod</code> 来对预生成的 <code>Mip Maps</code> 进行采样了：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>ret tex2Dlod(s, t)</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Name</th>\n<th align=\"left\">In&#x2F;Out</th>\n<th align=\"left\"><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>Template Type</strong></a></th>\n<th align=\"left\"><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>Component Type</strong></a></th>\n<th align=\"left\">Size</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">s</td>\n<td align=\"left\">in</td>\n<td align=\"left\"><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>object</strong></a></td>\n<td align=\"left\"><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-sampler\">sampler2D</a></td>\n<td align=\"left\">1</td>\n</tr>\n<tr>\n<td align=\"left\">t</td>\n<td align=\"left\">in</td>\n<td align=\"left\"><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>vector</strong></a></td>\n<td align=\"left\"><a href=\"https://learn.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types\"><strong>float</strong></a></td>\n<td align=\"left\">4</td>\n</tr>\n<tr>\n<td align=\"left\">ret</td>\n<td align=\"left\">out</td>\n<td align=\"left\"><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>vector</strong></a></td>\n<td align=\"left\"><a href=\"https://learn.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types\"><strong>float</strong></a></td>\n<td align=\"left\">4</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod\">tex2Dlod - Win32 apps | Microsoft Learn</a></p></blockquote>\n<p>可以发现，当前的 <code>tex2Dlod</code> 函数相较于 <code>tex2D</code>，本来为 <code>float2</code> 类型的 UV 变为了 <code>float4</code> 类型——新增加了 zw 两位，而其中的 w 位代表了当前 LOD 值，而 z 没有实际意义，常保持为 0：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://developer.download.nvidia.com/cg/tex2Dlod.html\">tex2Dlod (nvidia.com)</a></p></blockquote>\n<p>我们可以进行一些小小的实验，比和上方展示的结果做对比：</p>\n<p><img src=\"/....%5Cimages%5CRendering%5CArchives%5CVolumeCloud%5C002.png\" alt=\"image-20230331194548990\"><br><em>t.z==5000, t.w==0，可以发现结果并没有任何变化</em></p>\n<p><img src=\"/....%5Cimages%5CRendering%5CArchives%5CVolumeCloud%5C002dot5.png\" alt=\"image-20230331195527727\"><br><em>t.z==5000, t.w==4，高度感仍然比较明显，同时锯齿的感觉也有所减缓</em></p>\n<p><img src=\"/....%5Cimages%5CRendering%5CArchives%5CVolumeCloud%5C003.png\" alt=\"image-20230331195108808\"><br><em>t.z==5000, t.w==7，可以发现云层的高度起伏已经很不明显了</em></p>\n<p><img src=\"/....%5Cimages%5CRendering%5CArchives%5CVolumeCloud%5C004.png\" alt=\"image-20230331194932555\"><br><em>t.z==5000, t.w==100，可以说，云层完全失去了高度起伏的感觉并且模糊不堪</em></p>\n<p>通过以上的对比我们可以发现：当我们不断的增大 LOD 时，云层开始变得越来越模糊，并在 LOD 过大时变得缺乏高度感——也就是说，我们。</p>\n<p>不过，tex2Dlod 这样的函数，其逻辑本确实特别直观——在 HLSL 文档的最后，有这样的说明：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Starting with Direct3D 10, you can use new HLSL syntax to access textures and other resources. You can replace intrinsic-style texture lookup functions, such as tex2Dlod, with a more object-oriented style. In this object-oriented style, textures are decoupled from samplers and have methods for loading and sampling.</p></blockquote>\n<p>HLSL 的解决方案是换用面向对象的 <code>SampleLevel</code> 函数，而它的使用方法几乎和 URP 下的 <code>SAMPLE_TEXTURE2D_LOD</code> 函数一致：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)</code></pre>\n\n<p>其区别在于，HLSL 中的 <code>SampleLevel</code> 函数是 <code>Texture2D</code> 类型变量的属性，而 <code>SAMPLER_TEXTURE2D_LOD</code> 则更加类似于定义于 <code>D3D11.hlsl</code> 中的 <code>&#39;static&#39;</code> 类型的函数。而对于其中的参数，则可以理解为 <code>tex2Dlod</code> 中对应的 <code>float4 t</code> 被拆分了，而 LOD 作为独立的参数被写进了函数中。</p>\n<p>特别的，<code>tex2Dlod</code> 和 <code>SAMPLER_TEXTURE2D_LOD</code> 会被专门用在循环当中，例如在本案例中，如果使用 <code>tex2D</code> 和 <code>SAMPLER_TEXTURE2D</code> 则会报错：</p>\n<p><img src=\"/....%5Cimages%5CRendering%5CArchives%5CVolumeCloud%5C005.png\" alt=\"image-20230331201010767\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>该问题的出现原因可以参考该回答：<a href=\"https://stackoverflow.com/questions/57994423/why-i-cant-use-tex2d-inside-a-loop-in-unity-shaderlab\">unity3d - Why I can’t use tex2D inside a loop in Unity ShaderLab? - Stack Overflow</a><br>不严谨地简化解释为：循环中的计算单元不能预测采样的 LOD 值导致了单元间独立而庞大的计算，使循环不能及时地退出进而导致错误</p></blockquote>\n<p>因此，我们需要使用 <code>tex2Dlod</code> 类函数来显式地对 <code>Mip Maps</code> 进行采样以解决此类问题。Unity Manual 中也提及了这种因为导数计算而需要使用 <code>tex2Dlod</code> 类函数的情况：[Unity - Manual: Writing shaders for different graphics APIs (unity3d.com)](<a href=\"https://docs.unity3d.com/Manual/SL-PlatformDifferences.html#Direct3D\">https://docs.unity3d.com/Manual/SL-PlatformDifferences.html#Direct3D</a> Shader compiler syntax)</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li>缘起：<a href=\"https://www.bilibili.com/video/BV1yK4y1U7ow/?vd_source=c8eda79dd90c30ff02e09fb39906ac54\">【百人计划先行版】5 分钟教你用视差搓体积云_哔哩哔哩_bilibili</a></li>\n<li>原理参考：[视差贴图 - LearnOpenGL CN (learnopengl-cn.github.io)](<a href=\"https://learnopengl-cn.github.io/05\">https://learnopengl-cn.github.io/05</a> Advanced Lighting&#x2F;05 Parallax Mapping&#x2F;)</li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod\">tex2Dlod - Win32 apps | Microsoft Learn</a></li>\n<li><span id=\"code\"><a href=\"https://github.com/JBR-Bunjie/UnityShaderLearningPath/tree/URP_LearningPath/Assets/Shaders/VolumeCloud\">Code - VolumeCloud at URP_LearningPath</a></span></li>\n</ul>\n","text":"实现一个视差体积雾吧！原理说明核心思路：基于一张噪点图，基于切线空间下的视线方向，不断偏移 uv 来取样其中的内容，由于 Texture 下暗处的 rgb 三值都会急速下降并趋于 0，因此让 uv 偏移到暗处即可形成自然的颜色渐变——我们的视差体积雾即以该内容来伪装“高度”。在完...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%A7%86%E5%B7%AE%E4%BD%93%E7%A7%AF%E9%9B%BE%E5%90%A7%EF%BC%81\"><span class=\"toc-text\">实现一个视差体积雾吧！</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">原理说明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">实现思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Vertex-Shader\"><span class=\"toc-text\">Vertex Shader</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fragment-Shader\"><span class=\"toc-text\">Fragment Shader</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%95%BF\"><span class=\"toc-text\">步长</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E9%87%87%E6%A0%B7\"><span class=\"toc-text\">初始采样</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#uv-%E5%81%8F%E7%A7%BB%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">uv 偏移过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%BB%88%E5%8F%96%E6%A0%B7\"><span class=\"toc-text\">最终取样</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">返回结果</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3\"><span class=\"toc-text\">代码讲解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#tex2Dlod-%E4%B8%8E-SAMPLE-TEXTURE2D-LOD\"><span class=\"toc-text\">tex2Dlod 与 SAMPLE_TEXTURE2D_LOD</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"learningOpenGl 0","uid":"d309579445aab8e475b1a200f76bbffc","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/ReadMe","date":"2023-03-08T02:18:08.000Z","updated":"2023-10-27T19:57:22.000Z","comments":true,"path":"api/articles/Language Learning/Opengl/learnopengl-cn.readthedocs.io/ReadMe.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"OpenGL学习记录这份笔记对应的教程来自网站：LearnOpenGL-CN，是Learn OpenGL, extensive tutorial resource for learning Modern OpenGL的早期译文 同时辅以视频教程： [傅老師&#x2F;OpenGL...","link":"","photos":[],"count_time":{"symbolsCount":422,"symbolsTime":"1 mins."},"categories":[{"name":"Opengl","slug":"Opengl","count":16,"path":"api/categories/Opengl.json"},{"name":"Shader","slug":"Opengl/Shader","count":16,"path":"api/categories/Opengl/Shader.json"}],"tags":[{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":16,"path":"api/tags/Opengl.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"主流 Anti-Aliasing 算法及原理概览","uid":"bbf9542302ac0838c1965dd8fababb22","slug":"Rendering/主流AA算法及原理","date":"2023-02-25T04:23:23.000Z","updated":"2023-11-03T16:37:07.373Z","comments":true,"path":"api/articles/Rendering/主流AA算法及原理.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"主流 Anti-Aliasing 算法及原理概览 https://zhuanlan.zhihu.com/p/57503957 Spatial Anti-AliasingSSAASSAA，即 Super sampling anti-aliasing，有时也称为 full-scene...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"},{"name":"Rendering","slug":"Algorithm/Rendering","count":1,"path":"api/categories/Algorithm/Rendering.json"},{"name":"AA","slug":"Algorithm/Rendering/AA","count":1,"path":"api/categories/Algorithm/Rendering/AA.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"Rendering","slug":"Rendering","count":3,"path":"api/tags/Rendering.json"},{"name":"AA","slug":"AA","count":1,"path":"api/tags/AA.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}