{"title":"实现一个视差体积雾吧！","uid":"71fbc7ff44065d31551c0ea05fc7175a","slug":"Rendering/ParallaxCloud","date":"2023-03-02T04:23:23.000Z","updated":"2023-11-07T12:45:16.580Z","comments":true,"path":"api/articles/Rendering/ParallaxCloud.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"实现一个视差体积雾吧\">实现一个视差体积雾吧！</h1>\r\n<h2 id=\"原理说明\">原理说明</h2>\r\n<p>核心思路：基于一张噪点图，基于切线空间下的视线方向，不断偏移 uv\r\n来取样其中的内容，由于 Texture 下暗处的 rgb 三值都会急速下降并趋于\r\n0，因此让 uv\r\n偏移到暗处即可形成自然的颜色渐变——我们的视差体积雾即以该内容来伪装“高度”。在完成采样后，将最终采样与初始采样做合并来让暗部更暗以增强对比。</p>\r\n<h2 id=\"实现思路\">实现思路</h2>\r\n<h3 id=\"vertex-shader\">Vertex Shader</h3>\r\n<p>构建 <code>rotation</code> 矩阵，并利用该矩阵将 ObjectSpace 下的\r\nviewDir 转换到 Tangent 空间下。在切线空间，顶点和像素成为原点，xy 轴与\r\nuv 同向——此时就可以利用 ViewDir 来代表了一种对 uv\r\n进行抽象的渐进取样方向与步长，当然，这里只有方向是可以直接使用的，对于具体的步长内容，我们应该将它们的控制变量利用属性以暴露出来。</p>\r\n<h3 id=\"fragment-shader\">Fragment Shader</h3>\r\n<h4 id=\"步长\">步长</h4>\r\n<p>首先我们将 viewDir 分为 xy 和 z\r\n两个维度，分别利用外置暴露的属性来进行控制，这有两个目的：</p>\r\n<ul>\r\n<li>xy 控制了对 uv 的最大偏移量</li>\r\n<li>而对 z 进行控制，则是为了控制单次偏移的步长</li>\r\n</ul>\r\n<p>最终计算步长：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">float3 minOffset &#x3D; viewDir &#x2F; (viewDir.z * _Layers)</code></pre>\r\n<h4 id=\"初始采样\">初始采样</h4>\r\n<p>之后，我们先利用初始的 uv 来对 texture\r\n进行取样，这是可选的，但我们利用它来作为一个底层，并将之后的计算结果全部都叠加与这之上，这会：</p>\r\n<ul>\r\n<li>加快取样 uv 的偏移过程</li>\r\n<li>增加暗部与亮部的对比来增强立体感</li>\r\n</ul>\r\n<h4 id=\"uv-偏移过程\">uv 偏移过程</h4>\r\n<p>uv 偏移结束是基于两个内容的：finiNoise 的减小与 minOffset 上 z\r\n分量的逐步叠加，其中 finiNoise\r\n会减小是因为其数据的直接来源——Texture，在黑色上，其 rgb 值是趋于 0\r\n的——这会让 finiNoise 急速衰减，因此，我们实际使用的 Texture\r\n实际上是由要求的——它的黑色部分应该受到相当程度的限制，否则实际上的偏移量会过小导致视差的体积云失效。</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">float finiNoise &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv.xy).r * MainTex.r;  &#x2F;&#x2F; 只作为加快偏移结束的变量\nfloat3 prev_uv &#x3D; uv;\n\nwhile (finiNoise &gt; uv.z) &#123;\n    uv +&#x3D; minOffset;\n    finiNoise &#x3D; SAMPLE_TEXTURE2D_LOD(_MainTex, sampler_MainTex, uv.xy, 0).r * MainTex.r;\n    &#x2F;&#x2F; finiNoise &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv.xy).r * MainTex.r;\n    &#x2F;&#x2F; 此处不能使用寻常的SAMPLE_TEXTURE2D函数，原因见&#96;tex2Dlod&#96; 与 &#96;SAMPLE_TEXTURE2D_LOD&#96;一节\n&#125;</code></pre>\r\n<h4 id=\"最终取样\">最终取样</h4>\r\n<p>在初始 uv 和最终 uv\r\n间进行插值，这样使我们最终获得的结果更加平滑，减少画面的突变</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 可选\nfloat d1 &#x3D; finiNoise - uv.z;\nfloat d2 &#x3D; finiNoise - prev_uv.z;\nfloat w &#x3D; d1 &#x2F; (d1 - d2 + 0.0000001);\nuv &#x3D; lerp(uv, prev_uv, w);\n\n&#x2F;&#x2F; 利用最终完成变换的uv来进行取样\nhalf4 resultColor &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv.xy) * MainTex;</code></pre>\r\n<h4 id=\"返回结果\">返回结果</h4>\r\n<p>暴露_Alpha 属性来控制云层密度</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">half rangeClt &#x3D; MainTex.a * resultColor.r + _Alpha * 0.75;\nhalf Alpha &#x3D; abs(smoothstep(rangeClt, _Alpha, 1.0));\nAlpha &#x3D; pow(Alpha, 5);\n\n&#x2F;&#x2F; Light light &#x3D; GetMainLight();\n\nreturn half4(resultColor.rgb * _Color.rgb, Alpha); &#x2F;&#x2F;* light.color.rgb</code></pre>\r\n<h2 id=\"代码讲解\">代码讲解</h2>\r\n<blockquote>\r\n<p>具体代码已在<a href=\"#code\">Reference</a>中给出</p>\r\n</blockquote>\r\n<h3 id=\"tex2dlod-与-sample_texture2d_lod\"><code>tex2Dlod</code> 与\r\n<code>SAMPLE_TEXTURE2D_LOD</code></h3>\r\n<p><code>tex2Dlod</code> 与 <code>SAMPLE_TEXTURE2D_LOD</code>\r\n是两个同能相同的取样函数，分别对应了 <code>Built-in</code> 和\r\n<code>urp</code> 两种渲染管线。不过，这并非意味着这两个函数分别对应了\r\n<code>CG</code> 与 <code>HLSL</code>\r\n中的不同的实现——事实上，<code>CG</code> 与 <code>HLSL</code>\r\n中所定义的都是 <code>tex2Dlod</code>，<code>urp</code> 中采用新的\r\nAPI，大概只是为了与原 <code>Built-in</code> 管线作出区分。</p>\r\n<p>那么，首先先来了解 <code>tex2Dlod</code> 函数：</p>\r\n<blockquote>\r\n<p>Samples a 2D texture with mipmaps. The mipmap LOD is specified in\r\nt.w. <a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod\">tex2Dlod\r\n- Win32 apps | Microsoft Learn</a></p>\r\n</blockquote>\r\n<p>着我我们平常见到的 <code>tex2D</code>\r\n函数是不同的——<code>tex2D</code> 仅采样当前纹理本身：</p>\r\n<blockquote>\r\n<p>Samples a 2D texture. <a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2d\">tex2D\r\n(HLSL reference) - Win32 apps | Microsoft Learn</a></p>\r\n</blockquote>\r\n<p>当然，这也意味着我们使用该函数时，应确保加入的 texture 的\r\n<code>Generate Mip Maps</code>\r\n选项是勾选上的(当我们加入一张图片时，Unity 会帮我们默认勾选该内容:)</p>\r\n<p><img src=\"../../images\\Dev\\Unity\\Archives\\VolumeCloud\\001.png\"\r\nalt=\"image-20230331190104741\" /> <em>Generate Mip Maps 选项</em></p>\r\n<p>当做好准备后，我们就可以利用 <code>tex2Dlod</code> 来对预生成的\r\n<code>Mip Maps</code> 进行采样了：</p>\r\n<blockquote>\r\n<p><strong>ret tex2Dlod(s, t)</strong></p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 1%\" />\r\n<col style=\"width: 2%\" />\r\n<col style=\"width: 47%\" />\r\n<col style=\"width: 47%\" />\r\n<col style=\"width: 1%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: left;\">Name</th>\r\n<th style=\"text-align: left;\">In/Out</th>\r\n<th style=\"text-align: left;\"><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>Template\r\nType</strong></a></th>\r\n<th style=\"text-align: left;\"><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>Component\r\nType</strong></a></th>\r\n<th style=\"text-align: left;\">Size</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">s</td>\r\n<td style=\"text-align: left;\">in</td>\r\n<td style=\"text-align: left;\"><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>object</strong></a></td>\r\n<td style=\"text-align: left;\"><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-sampler\">sampler2D</a></td>\r\n<td style=\"text-align: left;\">1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">t</td>\r\n<td style=\"text-align: left;\">in</td>\r\n<td style=\"text-align: left;\"><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>vector</strong></a></td>\r\n<td style=\"text-align: left;\"><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types\"><strong>float</strong></a></td>\r\n<td style=\"text-align: left;\">4</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">ret</td>\r\n<td style=\"text-align: left;\">out</td>\r\n<td style=\"text-align: left;\"><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions\"><strong>vector</strong></a></td>\r\n<td style=\"text-align: left;\"><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types\"><strong>float</strong></a></td>\r\n<td style=\"text-align: left;\">4</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod\">tex2Dlod\r\n- Win32 apps | Microsoft Learn</a></p>\r\n</blockquote>\r\n<p>可以发现，当前的 <code>tex2Dlod</code> 函数相较于\r\n<code>tex2D</code>，本来为 <code>float2</code> 类型的 UV 变为了\r\n<code>float4</code> 类型——新增加了 zw 两位，而其中的 w 位代表了当前 LOD\r\n值，而 z 没有实际意义，常保持为 0：</p>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://developer.download.nvidia.com/cg/tex2Dlod.html\">tex2Dlod\r\n(nvidia.com)</a></p>\r\n</blockquote>\r\n<p>我们可以进行一些小小的实验，比和上方展示的结果做对比：</p>\r\n<p><img src=\"../../images\\Rendering\\Archives\\VolumeCloud\\002.png\"\r\nalt=\"image-20230331194548990\" /> <em>t.z==5000,\r\nt.w==0，可以发现结果并没有任何变化</em></p>\r\n<p><img src=\"../../images\\Rendering\\Archives\\VolumeCloud\\002dot5.png\"\r\nalt=\"image-20230331195527727\" /> <em>t.z==5000,\r\nt.w==4，高度感仍然比较明显，同时锯齿的感觉也有所减缓</em></p>\r\n<p><img src=\"../../images\\Rendering\\Archives\\VolumeCloud\\003.png\"\r\nalt=\"image-20230331195108808\" /> <em>t.z==5000,\r\nt.w==7，可以发现云层的高度起伏已经很不明显了</em></p>\r\n<p><img src=\"../../images\\Rendering\\Archives\\VolumeCloud\\004.png\"\r\nalt=\"image-20230331194932555\" /> <em>t.z==5000,\r\nt.w==100，可以说，云层完全失去了高度起伏的感觉并且模糊不堪</em></p>\r\n<p>通过以上的对比我们可以发现：当我们不断的增大 LOD\r\n时，云层开始变得越来越模糊，并在 LOD\r\n过大时变得缺乏高度感——也就是说，我们。</p>\r\n<p>不过，tex2Dlod 这样的函数，其逻辑本确实特别直观——在 HLSL\r\n文档的最后，有这样的说明：</p>\r\n<blockquote>\r\n<p>Starting with Direct3D 10, you can use new HLSL syntax to access\r\ntextures and other resources. You can replace intrinsic-style texture\r\nlookup functions, such as tex2Dlod, with a more object-oriented style.\r\nIn this object-oriented style, textures are decoupled from samplers and\r\nhave methods for loading and sampling.</p>\r\n</blockquote>\r\n<p>HLSL 的解决方案是换用面向对象的 <code>SampleLevel</code>\r\n函数，而它的使用方法几乎和 URP 下的 <code>SAMPLE_TEXTURE2D_LOD</code>\r\n函数一致：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)</code></pre>\r\n<p>其区别在于，HLSL 中的 <code>SampleLevel</code> 函数是\r\n<code>Texture2D</code> 类型变量的属性，而\r\n<code>SAMPLER_TEXTURE2D_LOD</code> 则更加类似于定义于\r\n<code>D3D11.hlsl</code> 中的 <code>'static'</code>\r\n类型的函数。而对于其中的参数，则可以理解为 <code>tex2Dlod</code>\r\n中对应的 <code>float4 t</code> 被拆分了，而 LOD\r\n作为独立的参数被写进了函数中。</p>\r\n<p>特别的，<code>tex2Dlod</code> 和 <code>SAMPLER_TEXTURE2D_LOD</code>\r\n会被专门用在循环当中，例如在本案例中，如果使用 <code>tex2D</code> 和\r\n<code>SAMPLER_TEXTURE2D</code> 则会报错：</p>\r\n<figure>\r\n<img src=\"../../images\\Rendering\\Archives\\VolumeCloud\\005.png\"\r\nalt=\"image-20230331201010767\" />\r\n<figcaption aria-hidden=\"true\">image-20230331201010767</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>该问题的出现原因可以参考该回答：<a\r\nhref=\"https://stackoverflow.com/questions/57994423/why-i-cant-use-tex2d-inside-a-loop-in-unity-shaderlab\">unity3d\r\n- Why I can't use tex2D inside a loop in Unity ShaderLab? - Stack\r\nOverflow</a> 不严谨地简化解释为：循环中的计算单元不能预测采样的 LOD\r\n值导致了单元间独立而庞大的计算，使循环不能及时地退出进而导致错误</p>\r\n</blockquote>\r\n<p>因此，我们需要使用 <code>tex2Dlod</code> 类函数来显式地对\r\n<code>Mip Maps</code> 进行采样以解决此类问题。Unity Manual\r\n中也提及了这种因为导数计算而需要使用 <code>tex2Dlod</code>\r\n类函数的情况：<a\r\nhref=\"https://docs.unity3d.com/Manual/SL-PlatformDifferences.html#Direct3D%20Shader%20compiler%20syntax\">Unity\r\n- Manual: Writing shaders for different graphics APIs\r\n(unity3d.com)</a></p>\r\n<h2 id=\"reference\">Reference</h2>\r\n<ul>\r\n<li>缘起：<a\r\nhref=\"https://www.bilibili.com/video/BV1yK4y1U7ow/?vd_source=c8eda79dd90c30ff02e09fb39906ac54\">【百人计划先行版】5\r\n分钟教你用视差搓体积云_哔哩哔哩_bilibili</a></li>\r\n<li>原理参考：<a\r\nhref=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/\">视差贴图\r\n- LearnOpenGL CN (learnopengl-cn.github.io)</a></li>\r\n<li><a\r\nhref=\"https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-tex2dlod\">tex2Dlod\r\n- Win32 apps | Microsoft Learn</a></li>\r\n<li><span id=\"code\"><a\r\nhref=\"https://github.com/JBR-Bunjie/UnityShaderLearningPath/tree/URP_LearningPath/Assets/Shaders/VolumeCloud\">Code\r\n- VolumeCloud at URP_LearningPath</a></span></li>\r\n</ul>\r\n","text":"实现一个视差体积雾吧！ 原理说明 核心思路：基于一张噪点图，基于切线空间下的视线方向，不断偏移 uv 来取样其中的内容，由于 Texture 下暗处的 rgb 三值都会急速下降并趋于 0，因此让 uv 偏移到暗处即可形成自然的颜色渐变——我们的视差体积雾即以该内容来伪装“高度”。...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"Unity","slug":"Unity","count":18,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":18,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%A7%86%E5%B7%AE%E4%BD%93%E7%A7%AF%E9%9B%BE%E5%90%A7\"><span class=\"toc-text\">实现一个视差体积雾吧！</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">原理说明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">实现思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vertex-shader\"><span class=\"toc-text\">Vertex Shader</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fragment-shader\"><span class=\"toc-text\">Fragment Shader</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%95%BF\"><span class=\"toc-text\">步长</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E9%87%87%E6%A0%B7\"><span class=\"toc-text\">初始采样</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#uv-%E5%81%8F%E7%A7%BB%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">uv 偏移过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%BB%88%E5%8F%96%E6%A0%B7\"><span class=\"toc-text\">最终取样</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">返回结果</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3\"><span class=\"toc-text\">代码讲解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#tex2dlod-%E4%B8%8E-sample_texture2d_lod\"><span class=\"toc-text\">tex2Dlod 与\r\nSAMPLE_TEXTURE2D_LOD</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"learningOpenGl 0","uid":"d309579445aab8e475b1a200f76bbffc","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/ReadMe","date":"2023-03-08T02:18:08.000Z","updated":"2023-10-27T19:57:22.000Z","comments":true,"path":"api/articles/Language Learning/Opengl/learnopengl-cn.readthedocs.io/ReadMe.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"OpenGL学习记录 这份笔记对应的教程来自网站：LearnOpenGL-CN，是Learn OpenGL, extensive tutorial resource for learning Modern OpenGL的早期译文 同时辅以视频教程： [傅老師/OpenGL教學 第...","link":"","photos":[],"count_time":{"symbolsCount":403,"symbolsTime":"1 mins."},"categories":[{"name":"Opengl","slug":"Opengl","count":16,"path":"api/categories/Opengl.json"},{"name":"Shader","slug":"Opengl/Shader","count":16,"path":"api/categories/Opengl/Shader.json"}],"tags":[{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":16,"path":"api/tags/Opengl.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"主流 Anti-Aliasing 算法及原理概览","uid":"bbf9542302ac0838c1965dd8fababb22","slug":"Rendering/主流AA算法及原理","date":"2023-02-25T04:23:23.000Z","updated":"2023-11-07T12:45:24.496Z","comments":true,"path":"api/articles/Rendering/主流AA算法及原理.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"主流 Anti-Aliasing 算法及原理概览 https://zhuanlan.zhihu.com/p/57503957 Spatial Anti-Aliasing SSAA SSAA，即 Super sampling anti-aliasing，有时也称为 full-sce...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"},{"name":"Rendering","slug":"Algorithm/Rendering","count":1,"path":"api/categories/Algorithm/Rendering.json"},{"name":"AA","slug":"Algorithm/Rendering/AA","count":1,"path":"api/categories/Algorithm/Rendering/AA.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"Rendering","slug":"Rendering","count":3,"path":"api/tags/Rendering.json"},{"name":"AA","slug":"AA","count":1,"path":"api/tags/AA.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}