{"title":"定制一个SRP管线 Step0. 从了解URP的结构开始","uid":"67b0bf49c55b287c9032b8260a2585ec","slug":"Rendering/SRP/SRP0","date":"2023-11-09T12:42:16.000Z","updated":"2024-02-15T05:39:28.000Z","comments":true,"path":"api/articles/Rendering/SRP/SRP0.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"定制一个srp管线-step0.-从了解gpu的结构开始\">定制一个SRP管线\r\nStep0. 从了解GPU的结构开始</h1>\r\n<blockquote>\r\n<p>\"通用\"，通常也意味着\"冗余\"，这是定制管线的理由之一</p>\r\n</blockquote>\r\n<h2 id=\"g-结构总览\">G 结构总览</h2>\r\n<h3 id=\"框架结构总览\">框架结构总览</h3>\r\n<p>我们可以从这样一张图入手去了解URP管线的具体结构：</p>\r\n<p><img src=\"../../../images\\NewCluster\\image-20231110185052543.png\"\r\nalt=\"image-20231110185052543\" /> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/380969365\">从零开始的SRP - 知乎\r\n(zhihu.com)</a></p>\r\n<p>如图所示，图中类的主要功能分别为：</p>\r\n<ul>\r\n<li>入口文件：UniversalRenderPipelineAsset.cs与UniversalRenderPipeline.cs，Pipeline会定义整个渲染管线，而Asset则会调用Pipeline的创建</li>\r\n<li></li>\r\n<li>重要的基类：\r\n<ul>\r\n<li>ScriptableRenderer.cs</li>\r\n<li>ScriptableRendererFeature.cs</li>\r\n<li>ScriptableRenderPass.cs</li>\r\n</ul></li>\r\n</ul>\r\n<p>由此，URP大致可以分为三层：</p>\r\n<ul>\r\n<li>驱动层：SRP的入口，由引擎侧直接驱动。我们自定义的SRP也就是从继承这两个内容开始，构建整个框架。</li>\r\n<li>框架层：URP提供的一套管线设计方案。是自定义SRP需要重点实现的内容。</li>\r\n<li>应用层：具体实现的管线流程，如URP提供了一套向前渲染的方案，当然，新版本的URP也补上了延迟渲染。</li>\r\n</ul>\r\n<p>简单划分URP核心结构的话，大概为：Renderer -&gt; RendererFeature -&gt;\r\nPass Execution：</p>\r\n<ul>\r\n<li>Renderer核心方法：Setup()、Execute()</li>\r\n<li>RendererFeature核心方法：Create()、AddRenderPasses()</li>\r\n<li>Pass核心方法：Configure()、Execute()</li>\r\n</ul>\r\n<p>最终的框架脉络如下：</p>\r\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Render()\n\tBeginFrameRendering()\n\t\tSortCameras()\n\t\tBeginCameraRendering() x n\n\t\t\tRenderSingleCamera()\n\t\t\t\trenderer.Clear()\n\t\t\t\trenderer.SetupCullingParameters()\n\t\t\t\tcontext.ExecuteCommandBuffer(cmd)\n\t\t\t\tcmd.Clear()\n\t\t\t\tcontext.Cull()\n\t\t\t\tInitializeRenderingData()\n\t\t\t\trenderer.Setup()\n\t\t\t\t\tpass.Setup() x m\n\t\t\t\t\tEnqueuePass(pass) x m\n\t\t\t\trenderer.Execute()\n\t\t\t\t\tSetupLights()\n\t\t\t\t\t\tm_ForwardLights.Setup()\n\t\t\t\t\t\tm_DeferredLights.SetupLights()\n\t\t\t\t\tExecuteBlock() x 4\n\t\t\t\t\t\tExecuteRenderPass()\n\t\t\t\t\t\t\tpass.Configure() or ConfigureNative()\n\t\t\t\t\t\t\tpass.Execute() or ExecuteNative()\n\t\t\t\tcontext.ExecuteCommandBuffer(cmd)\n\t\t\t\tCommandBufferPool.Release(cmd)\n\t\t\t\tcontext.Submit()\n\t\tEndCameraRendering() x n\n\tEndFrameRendering()</code></pre>\r\n<h2 id=\"关于gpu\">关于GPU</h2>\r\n<h3 id=\"gpu的片下内存off-chip-memory\">GPU的片下内存（off-chip\r\nmemory）</h3>\r\n<blockquote>\r\n<p>移动端没有独立显存</p>\r\n</blockquote>\r\n<p><strong>在移动端的集成芯片中会在 <em>系统内存</em>\r\n中分配一片区域作为GPU的存储，同时会对这些内存进行一分化，而适应不同数据的读写效率。</strong>分化分类如下：</p>\r\n<ul>\r\n<li>GlobalMemory(可读可写); 这部分属于通用存储部分自由度很高，允许读写,\r\n但是读写速度优势不大。其中存储内容包括UAV资源(unordered access\r\nview)，StructureBuffer，Mesh，着色器程序等。</li>\r\n<li>ConstantMemory(只读): shader 中 ConstantBuffer，Uniform\r\n变量存在在这里，在同一 Warp\r\n的多个线程由于执行指令相同，在访问同一变量时，如果该变量存储在一个物理地址上则会产生访问冲突。ConstantMemory\r\n就是解决该问题，ConstantMemory\r\n会将该变量拷贝多份，允许warp内的线程同时访问来提高并行性，至于怎么拷贝或者为什么会冲突没有找到相关资料，在Unity中，自带instance实现有使用到\r\nConstantBuffer，会比 StructureBuffer 快一些，但是由于 ConstantMemory\r\n属于只读存储所以无法使用 ComputeShader 对Buffer进行初始化。</li>\r\n<li>TextureMemory（只读）<strong>：</strong>纹理存储，这部分通常只读，但是对于\r\nRenderTexture 这种特殊格纹理是允许读写操作的。</li>\r\n<li>LocalMemory：寄存器不够时会用使用LocalMemory，属于线程私有。</li>\r\n</ul>\r\n<h3 id=\"gpu片上片内存储on-chip-memory\">GPU片上(片内)存储(on-chip\r\nmemory)：</h3>\r\n<p><img\r\nsrc=\"https://pic1.zhimg.com/80/v2-e0fc20b7a3b26ef538e11ab63ba20344_1440w.webp\"\r\nalt=\"img\" /> Fermi的SM结构</p>\r\n<p>SM中的片上储存分成三种，一部分是寄存器，一部分是L1，一部分是L2</p>\r\n<h4 id=\"寄存器\">寄存器：</h4>\r\n<p>寄存器的访问通常在1个时钟周期即可完成。</p>\r\n<p>寄存用于存储线程计算过程中的变量以及状态，属于线程私有。</p>\r\n<p>相对于CPU寄存器，GPU寄存器通常数量庞大，在几千或者几万个。庞大的寄存器空间允许SM存储多个Warp的变量以及状态，这就使在Warp访问<strong>存储</strong>时（通常一次访问设计几十到几百个时钟周期）可以以非常小的成本进行Warp切换从而更好的实现<strong>延迟隐藏</strong>。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic3.zhimg.com/80/v2-178fc2404c6ad1299e1d575bb84b5d22_1440w.webp\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h4 id=\"l1cache\">L1Cache:</h4>\r\n<p>GPU上有L1Cache用来存储从 GlobalMemory 和 localMemory 来内容，不过\r\nTextureCache，ConstantCache，ShareMemory 也可以看成L1缓存的分化</p>\r\n<ul>\r\n<li>TextureCache: TextureCache\r\n是GPU纹理的缓存硬件，当Core执行着色器程序访问纹理像素时，会先确定在\r\nTextureCache 这一硬件结构中是否命中，如果命中这从 TextureCache\r\n进行获取，这一过程通常会在几十个时钟周期内完成。如果未命中，则会请求\r\nTextureMemory 进行获取，但是这一操作会涉及上百个时钟周期</li>\r\n<li>ConstantCache：常量缓存，用来缓冲 ConstantMemory 数据，ConstCache\r\n有一定大小限制，Unity 中，单个 ContantBuffer 内存占用在64KB以下，Unity\r\nInstance 由于使用了 ConstantBuffer 所以绘制数量会受到限制。另外在定义\r\nShader 的 Uniform 变量时，需要注意到内存对齐，在OpenGL\r\nstd140标准，ConstantBuffer\r\n是128位对齐的也就是4个float值，所以对于下面两种情况，第一段实际占用12\r\nfloat空间，而第二个只会占用8个float空间。 <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">CBUFFER_START(UnityPerMaterial)\nfloat2 a;\nfloat4 b;\nfloat2 c;\nCBUFFER_END\n\t\nCBUFFER_START(UnityPerMaterial)\nfloat4 b;\nfloat2 a;\nfloat2 c;\nCBUFFER_END</code></pre></li>\r\n<li>SharedMemory:\r\n这部分是可读可写的块共享存储，这部分没有找到太多资料，在GPU泛用化上应用可能会比较多。对于块的在CUDA编程和\r\nComputeShader 中通常会定义块属性，即一个三维数组，在 ComputeShader\r\n中Kernel方法可以使用 <code>[numthreads(x, y, z)]</code>\r\n来定义线程块（block），一个线程块可以包含多个Warp，使用一个SM执行。SharedMemory\r\n即是块内共享存储，相对与Cache读写速度会更快， shared\r\n关键字允许我们自定Share存储空间（shared float\r\ndata[1024]）。但是需要保证Block内的线程不要产生访问冲突，这就意味着尽量每个线程都有独有\r\nSharedMemory 空间。</li>\r\n</ul>\r\n<h4 id=\"l2cache\">L2Cache：</h4>\r\n<p>整个GPU共享缓存。</p>\r\n<h4 id=\"关于sm中的非存储结构\">关于SM中的非存储结构</h4>\r\n<p>SM中的非存储结构包括：</p>\r\n<ul>\r\n<li>PolyMorph\r\nEngine：用于处理几何处理，用于顶点数据生成和三角形剪裁、变化、输出等，这里要和RasterEngine进行区分，RasterEngine用于光栅化和插值。PolyMorphEngine\r\n和VertexShader，GeometryShader，曲面细分需要配合进行，所以该架构每个SM都配备一个PolyMorphEngine。</li>\r\n<li>WarpScheduler/DispatchUnit:warp调度和计算驱动</li>\r\n<li>Core：计算单元</li>\r\n<li>SFU：特殊函数计算单元，如三角函数，log</li>\r\n<li>LD/ST：用于从存储结构将数据加载寄存器，或从寄存器保存到其他可写存储结构</li>\r\n<li>Tex：纹理单元，用于纹理访问，纹理采样和过滤。</li>\r\n</ul>\r\n<h3 id=\"各区域速度比较\">各区域速度比较</h3>\r\n<table style=\"width:100%;\">\r\n<colgroup>\r\n<col style=\"width: 10%\" />\r\n<col style=\"width: 10%\" />\r\n<col style=\"width: 16%\" />\r\n<col style=\"width: 10%\" />\r\n<col style=\"width: 10%\" />\r\n<col style=\"width: 25%\" />\r\n<col style=\"width: 16%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>存储类型</th>\r\n<th>Register</th>\r\n<th>Shared Memory</th>\r\n<th>L1 Cache</th>\r\n<th>L2 Cache</th>\r\n<th>Texture/Const Memory</th>\r\n<th>Global Memory</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>时钟周期</td>\r\n<td>1</td>\r\n<td>1-32</td>\r\n<td>1-32</td>\r\n<td>32-64</td>\r\n<td>400-600</td>\r\n<td>400-600</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"关于带宽\">关于带宽：</h3>\r\n<blockquote>\r\n<p>移动端更加重视带宽，因为带宽不仅会影响计算时间，还对直接导致高功耗的出现。</p>\r\n</blockquote>\r\n<p>对于GPU而言，把GPU抽象成工厂非常合适。计算核心就是流水线工人，带宽就行工厂的运输系统。为了使工人尽可能不停的生成产品，就需要规划运输系统的方案，来取得最大的产品吞吐量。</p>\r\n<p>对于带宽影响最大的通常是纹理，\r\n从下面这几张图可以很好的理解纹理影响带宽的方式：</p>\r\n<p><img\r\nsrc=\"https://pic3.zhimg.com/80/v2-79dcc220c541103f9264cbc6284317e6_1440w.webp\"\r\nalt=\"img\" />\r\n每一个色块大小为16*16，颜色代表SM的ID，图中有32个色阶，也就是GPU存在32个SM</p>\r\n<p><img\r\nsrc=\"https://pic2.zhimg.com/v2-ed07aecd69b2f69c7d6df14b340f99ad_r.jpg\"\r\nalt=\"img\" />\r\n每一个色块为4*8，颜色代表SM中的WarpID，同样有32个色阶，说明单个SM最多有32个warp</p>\r\n<p><img\r\nsrc=\"https://pic3.zhimg.com/v2-43fa588015f86c606df7057802056c9a_r.jpg\"\r\nalt=\"img\" />\r\n每个色块为1*1，颜色为warp内的线程ID，依然是32个色阶，说明一个warp内有32个线程</p>\r\n<p>上图都是基于IMR GPU架构的渲染结果，移动端通常是TBR、TBDR\r\nGPU架构,但是TBR每个渲染块通常也是16*16的导致调度块可能和IMR会比较相似。TBR相关内容也比较有意思，感兴趣可以再去查看一些资料，对于TBR，TBR的设计相比于IMR会有更多可能性，尤其在对于同一个tile块中，由于可以拿到一批绘制的所有在此块中不透明三角面，所以TBR架构更有可能在硬件层面解决OverDraw的问题。</p>\r\n<p>由图1开始，我们可以看到渲染单个三角形会以16*16的块为单位调度SM，每个SM会有多个块需要执行，这里的16*16我们的可以理解为是一个block，一个block会存在多个warp，图2可以看出16*16的block内分成了4*2个warp，每个warp为执行4*8\r\n32个像素。图3有可以看出来一个warp内有32个线程，每个线程都会处理一个像素。</p>\r\n<p>那么再理一下一个三角形是如何进行像素着色：</p>\r\n<ol type=\"1\">\r\n<li>三角形光栅化后会将光栅化结果分成多个16*16的block（图1），调度GPU上SM执行Block的着色。</li>\r\n<li>当一个SM拿到16*16的block时，block内会分成4*2个Warp（图2）然后使用WarpScheduler硬件调度Warp执行。</li>\r\n<li>当SM开始执行一个Warp，使用DispatchUnit调度线程执行着色程序。</li>\r\n</ol>\r\n<h4 id=\"纹理采样\">纹理采样：</h4>\r\n<p>纹理采样是带宽的核心部分，也是着色器编写过程中令人头痛的内容，对于大面积的物体，每次采样都会有心里负担。所以这里尽可能解释采样到底发生了什么。</p>\r\n<p>纹理在片下存储TextureMemory中是以tile的方式存储的，由此来增强纹理存储的局部性，每一个tile占用1个或多个CacheLine的空间也就是n\r\n*（64或128字节），这样的存储方式，在向TextureMemory请求纹理时，可以快速请求到一块纹理数据，而提高采样命中率。另外纹理压缩是以块的方式压缩的，对于Astc的格式，Astc存在12X12，8X8，6X6，5X5...多种压缩状态，对于一个n*n的像素块，固定存储量是16字节，那么对于64字节的CacheLine可以容纳4个压缩块。那么在每次纹理请求时TextureMemory到Cache的传送量，针对不同压缩格是不同的。所以选择合适压缩格式一定程度上可以减少带宽。</p>\r\n<p>纹理在片上cache中，L1的TextureCache通常只会有几十KB，但是一张图片在TextureMemory也就是系统内存中是压缩状态，但是读取到Cache是则是非压缩状态,这就导致纹理块在cache中是比较大的，那么在渲染一个物体的过程中，TextureCache内的纹理块并不会存储很长时间，很快会被切换出去。所以我们尽可能希望SM在一批像素的处理中尽可能少地从TextureMemory读取纹理块。这里一批也就是是一个Block，通过图1可以看出来，在同一个SM上渲染的不同的block的通常是不连续的，不同的Block对应的采样的纹理区域差别会比较大，所以命中通常是在单个block内分析的。</p>\r\n<p>这样在着色器在渲染一个Block的过程中，假设block内的一个warp（4*8像素块）的所有线程向TexUnit请求纹理数据，我们可以知道这些请求的UV会映射在纹理的一块区域内，所以一定程度上我们可以预估这个Warp采样使用的纹理范围的大概矩形区域，来判断Texmory的请求次数。如果希望Warp每个线程命中率近可能的高，那么最优情况，在渲染这个warp所属的block的过程中，第一次未命中时，向L2Cache或者TextureMemory请求纹理块时，该纹理块包含了block渲染需要的所有纹理数据，在16*16\r\n256次的采样只有一次未命中，命中率会达到99以上。到这里再回想一下TBR架构设计也是这样，在对ColorBuffer，DepthStencilBuffer进行读写时会保证block的绘制只访问一次Tile块，所以命中率会非常高，从而极大减少与系统内存的交互，而减少功耗。</p>\r\n<ul>\r\n<li><strong>if else：</strong> 这个也是写着色器时经常要考虑的事情，if\r\nelse到底做了什么基本上很多文章都有介绍，大致的逻辑就是再同一个warp中的线程并非全部走同一分支，那么这个Warp会分别执行两个分支，执行时间也就变成了两个分支的执行时间。至于对于一个warp是否会执行同一分支，一定程度上也可以判断，上图图2中warp是4*8的像素块，那么在像素着色时，如果大部分的像素块会选择只执行一个分支，则if\r\nelse的影响并不会很大。在顶点着色时，一个warp32个线程同时执行32个顶点着色，如果保证大部分32为一组的顶点组只会执行一个分支，则if\r\nelse的影响依然不会很大。</li>\r\n</ul>\r\n<h3 id=\"关于显存\">关于显存</h3>\r\n<p>GDDR（Graphics Double Data Rate,\r\nSDRAM）是一种针对显卡的存储介质。了解GDDR可以用DDR作为参考对比。</p>\r\n<p>目前主存的主流介质是DDR，常见的有DDR3 / DDR4 /\r\nDDR5。除此之外还有傲腾的3D Xpoint等</p>\r\n<p>DDR作为一个为CPU服务的RAM，满足CPU运算的特点，针对的场景是：<strong>小数据、多操作</strong>，因此DDR的内存条一般设计为时延小，不太计较是否有大的带宽（bandwidth）；而GPU的特点是<strong>数据大、操作少</strong>，或者说单个操作内要进行大批量数据处理，所以在普通的DDR基础上，GDDR增加了带宽。</p>\r\n<p>比较而言，GDDR的带宽更大，但是操作延迟更高，一般为百纳秒级。</p>\r\n<blockquote>\r\n<p><img\r\nsrc=\"https://pic2.zhimg.com/80/v2-1523566aaf4d0977843f9a80acaf80c9_1440w.webp\"\r\nalt=\"img\" /> <img\r\nsrc=\"https://pic3.zhimg.com/80/v2-784d72bebfde52418bc3c9cfcc3cb8de_1440w.webp\"\r\nalt=\"img\" /></p>\r\n</blockquote>\r\n<p>另外一种显存介质是HBM(High Bandwidth\r\nMemory，高带宽存储)。顾名思义这个存储介质有着\"High Bandwidth\"</p>\r\n<blockquote>\r\n<p>参考NVIDIA\r\nP100所用的HBM来说明，该系列的显卡采用HBM第二代存储芯片，如下图是P100的硬质电路侧面视图，其中许多HBM2存储介质堆叠在基板（BASE\r\nDIE）上，且基板位置通过无源硅板（passive silicon\r\ninterposer）紧邻P100芯片。</p>\r\n<p><img\r\nsrc=\"https://pic3.zhimg.com/80/v2-f620c3d85aff0a570b811960840ede02_1440w.webp\"\r\nalt=\"img\" /> HBM应用电路示意</p>\r\n<p>这种3D设计空间堆叠方式将存储介质（HBM，DRAM)层层拼接起来，这样的3D结构更能<strong>接近芯片</strong>单元，同时<strong>空间占比相对较小</strong>。该设计使得HBM的带宽和存储量都得到了提升，对比GDDR：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic1.zhimg.com/80/v2-28627f51bed9ee91f013ae0c42ab2554_1440w.webp\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>注：HBM做显存的优势这么明显，为什么没有完全取代GDDR？因为生产一个3D结构的HBM的难度相比于生产一个平面结构的GDDR难度更大，所以HBM一般价格高。</p>\r\n</blockquote>\r\n<h2 id=\"references\">References</h2>\r\n<ul>\r\n<li><a\r\nhref=\"https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/universalrp-asset.html\">通用渲染管线资源\r\n| Universal RP | 12.1.1 (unity3d.com)</a></li>\r\n<li><a\r\nhref=\"https://zhuanlan.zhihu.com/p/641666619\">URP源码学习：速通框架，只讲重点（含URP后处理例子）\r\n- 知乎 (zhihu.com)</a></li>\r\n<li><a\r\nhref=\"https://zhuanlan.zhihu.com/p/629678819\">URP代码结构以及GPU架构（万字长文）\r\n- 知乎 (zhihu.com)</a></li>\r\n<li><a\r\nhref=\"https://www.bilibili.com/video/BV1P44y1V7bu/?vd_source=c8eda79dd90c30ff02e09fb39906ac54\">上帝视角看GPU（1）：图形流水线基础_哔哩哔哩_bilibili</a></li>\r\n</ul>\r\n","text":"定制一个SRP管线 Step0. 从了解GPU的结构开始 \"通用\"，通常也意味着\"冗余\"，这是定制管线的理由之一 G 结构总览 框架结构总览 我们可以从这样一张图入手去了解URP管线的具体结构： 从零开始的SRP - 知乎 (zhihu.com) 如图所示，图中类的主要功能分别为...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"Unity","slug":"Unity","count":21,"path":"api/categories/Unity.json"},{"name":"SRP","slug":"Unity/SRP","count":2,"path":"api/categories/Unity/SRP.json"},{"name":"URP","slug":"Unity/SRP/URP","count":1,"path":"api/categories/Unity/SRP/URP.json"}],"tags":[{"name":"Unity","slug":"Unity","count":22,"path":"api/tags/Unity.json"},{"name":"SRP","slug":"SRP","count":2,"path":"api/tags/SRP.json"},{"name":"URP","slug":"URP","count":2,"path":"api/tags/URP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E5%88%B6%E4%B8%80%E4%B8%AAsrp%E7%AE%A1%E7%BA%BF-step0.-%E4%BB%8E%E4%BA%86%E8%A7%A3gpu%E7%9A%84%E7%BB%93%E6%9E%84%E5%BC%80%E5%A7%8B\"><span class=\"toc-text\">定制一个SRP管线\r\nStep0. 从了解GPU的结构开始</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#g-%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88\"><span class=\"toc-text\">G 结构总览</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88\"><span class=\"toc-text\">框架结构总览</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Egpu\"><span class=\"toc-text\">关于GPU</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gpu%E7%9A%84%E7%89%87%E4%B8%8B%E5%86%85%E5%AD%98off-chip-memory\"><span class=\"toc-text\">GPU的片下内存（off-chip\r\nmemory）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gpu%E7%89%87%E4%B8%8A%E7%89%87%E5%86%85%E5%AD%98%E5%82%A8on-chip-memory\"><span class=\"toc-text\">GPU片上(片内)存储(on-chip\r\nmemory)：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">寄存器：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#l1cache\"><span class=\"toc-text\">L1Cache:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#l2cache\"><span class=\"toc-text\">L2Cache：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Esm%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">关于SM中的非存储结构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%84%E5%8C%BA%E5%9F%9F%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">各区域速度比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E5%B8%A6%E5%AE%BD\"><span class=\"toc-text\">关于带宽：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7\"><span class=\"toc-text\">纹理采样：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%98%BE%E5%AD%98\"><span class=\"toc-text\">关于显存</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#references\"><span class=\"toc-text\">References</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"定制一个SRP管线 Step 1","uid":"5d88bbec78b43b21461c0aea1be3a295","slug":"Rendering/SRP/SRP1","date":"2023-11-10T12:42:16.000Z","updated":"2023-11-09T12:53:08.577Z","comments":true,"path":"api/articles/Rendering/SRP/SRP1.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"定制一个SRP管线 Step 1 Reference Unity的URP HDRP等SRP管线详解（包含源码分析） - 知乎 (zhihu.com) 从零开始的SRP - 知乎 (zhihu.com) Unity SRP 实战（一）延迟渲染与 PBR - 知乎 (zhihu.co...","link":"","photos":[],"count_time":{"symbolsCount":155,"symbolsTime":"1 mins."},"categories":[{"name":"Unity","slug":"Unity","count":21,"path":"api/categories/Unity.json"},{"name":"SRP","slug":"Unity/SRP","count":2,"path":"api/categories/Unity/SRP.json"}],"tags":[{"name":"Unity","slug":"Unity","count":22,"path":"api/tags/Unity.json"},{"name":"SRP","slug":"SRP","count":2,"path":"api/tags/SRP.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Unity中的网络请求","uid":"ad6a784d75030aa79c31d7b5036418a0","slug":"Dev/Theory/Unity中的网络请求","date":"2023-11-05T15:59:48.000Z","updated":"2023-11-07T12:36:35.994Z","comments":true,"path":"api/articles/Dev/Theory/Unity中的网络请求.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Unity中的网络请求 从网络结构开始： 关于网络模型 其中，TCP/IP模型是实际的使用规则，HTTP协议就运作在应用层里 从HTTP协议开始 什么是HTTP HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80 HTTP 是无连接无状态的 HTT...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"Unity","slug":"Unity","count":21,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity","slug":"Unity","count":22,"path":"api/tags/Unity.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}