{"title":"Shader Book Github Issue Collections","uid":"41644c3248ea1210fc5e02792aa4d4c9","slug":"Rendering/UnityShaderBook/ProblemCollections","date":"2023-03-08T13:29:45.000Z","updated":"2023-10-27T19:29:31.000Z","comments":true,"path":"api/articles/Rendering/UnityShaderBook/ProblemCollections.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"shader-book-github-issue-collections\">Shader Book Github Issue\r\nCollections</h1>\r\n<p><a\r\nhref=\"https://github.com/candycat1992/Unity_Shaders_Book/issues/198\">saturate\r\n和 max · Issue #198 · candycat1992/Unity_Shaders_Book\r\n(github.com)</a></p>\r\n<p>为什么后来从 sature 改到了 max？</p>\r\n<blockquote>\r\n<blockquote>\r\n<p>Q: 在基础光照那一章中，我看到计算 worldNormal 与 worldLightDir\r\n的时候用的是 saturate，而后面章节使用的是\r\nmax（0，…），这两个方法在计算结果上会产生什么差异吗？</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>A: 对于那些值范围在-1 到 1\r\n的变量，两个方法在计算结果上没有区别。不过，saturate 在 Unity\r\n里通常会编译成两个指令，大致是 min(max(val, 0.0),\r\n1.0)，如果自己知道值的范围可以直接使用 max 来节省一条运算指令。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>AQ: 我在 Unity 里面，点 Shader 属性中 “Compile and show\r\ncode”按钮，看到</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">u_xlat0.x &#x3D; dot(u_xlat1.xyz, u_xlat0.xyz);\nu_xlat0.x &#x3D; clamp(u_xlat0.x, 0.0, 1.0);</code></pre>\r\n<p>对应的是\r\n<code>saturate(dot(lightDir, worldNormal));</code>。所以应该不是解析成\r\n<code>min(max(val, 0.0), 1.0)</code>吧？</p>\r\n<p>因为今天看到《Real-time Rendering 3rd》5.5 节 115 页 中提到</p>\r\n<blockquote>\r\n<p><strong>staturate</strong> is faster than the more general\r\n<strong>max</strong> function on most hardware.</p>\r\n</blockquote>\r\n<p>所以有点奇怪。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>AA: <a href=\"https://github.com/alasja\"><span class=\"citation\"\r\ndata-cites=\"alasja\">@alasja</span></a>\r\n我之前的回答的确说得很模糊，这里补充下。</p>\r\n<p>在 Unity 里，同一份 ShaderLab\r\n代码在不同目标平台上、甚至不同设备上编译结果都是不同的。比如同样一份\r\nfragment shader：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">fixed4 frag (v2f i) : SV_Target\n&#123;\n\tfixed4 col &#x3D; i.uv.xyxy;\n\tcol &#x3D; saturate(col);\n\treturn col;\n&#125;</code></pre>\r\n<p>在 DX9 下，编译出来就是：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-- Fragment shader for &quot;d3d9&quot;:\n&#x2F;&#x2F; Stats: 1 math\nShader Disassembly:\n&#x2F;&#x2F;\n&#x2F;&#x2F; Generated by Microsoft (R) HLSL Shader Compiler 10.1\n    ps_3_0\n    dcl_texcoord_pp v0.xy\n    mov_sat_pp oC0, v0.xyxy\n\n&#x2F;&#x2F; approximately 1 instruction slot used</code></pre>\r\n<p>DX11 下就是：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-- Fragment shader for &quot;d3d11&quot;:\nShader Disassembly:\n&#x2F;&#x2F;\n&#x2F;&#x2F; Generated by Microsoft (R) D3D Shader Disassembler\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F; Input signature:\n&#x2F;&#x2F;\n&#x2F;&#x2F; Name                 Index   Mask Register SysValue  Format   Used\n&#x2F;&#x2F; -------------------- ----- ------ -------- -------- ------- ------\n&#x2F;&#x2F; TEXCOORD                 0   xy          0     NONE   float   xy\n&#x2F;&#x2F; SV_POSITION              0   xyzw        1      POS   float\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F; Output signature:\n&#x2F;&#x2F;\n&#x2F;&#x2F; Name                 Index   Mask Register SysValue  Format   Used\n&#x2F;&#x2F; -------------------- ----- ------ -------- -------- ------- ------\n&#x2F;&#x2F; SV_Target                0   xyzw        0   TARGET   float   xyzw\n&#x2F;&#x2F;\n      ps_4_0\n      dcl_input_ps linear v0.xy\n      dcl_output o0.xyzw\n   0: mov_sat o0.xyzw, v0.xyxy\n   1: ret\n&#x2F;&#x2F; Approximately 0 instruction slots used</code></pre>\r\n<p>OpenGL ES2.0 下是：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#ifdef FRAGMENT\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main ()\n&#123;\n  lowp vec4 col_1;\n  highp vec4 tmpvar_2;\n  tmpvar_2 &#x3D; xlv_TEXCOORD0.xyxy;\n  col_1 &#x3D; tmpvar_2;\n  lowp vec4 tmpvar_3;\n  tmpvar_3 &#x3D; clamp (col_1, 0.0, 1.0);\n  col_1 &#x3D; tmpvar_3;\n  gl_FragData[0] &#x3D; tmpvar_3;\n&#125;</code></pre>\r\n<p>OpenGLES 3.0 下是：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#ifdef FRAGMENT\n#version 300 es\n\nprecision highp int;\nin highp vec2 vs_TEXCOORD0;\nlayout(location &#x3D; 0) out mediump vec4 SV_Target0;\nvoid main()\n&#123;\n    SV_Target0 &#x3D; vs_TEXCOORD0.xyxy;\n#ifdef UNITY_ADRENO_ES3\n    SV_Target0 &#x3D; min(max(SV_Target0, 0.0), 1.0);\n#else\n    SV_Target0 &#x3D; clamp(SV_Target0, 0.0, 1.0);\n#endif\n    return;\n&#125;\n\n#endif</code></pre>\r\n<p>Metal 下是：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-- Fragment shader for &quot;metal&quot;:\nShader Disassembly:\n#include &lt;metal_stdlib&gt;\n#include &lt;metal_texture&gt;\nusing namespace metal;\nstruct Mtl_FragmentIn\n&#123;\n    float2 TEXCOORD0 [[ user(TEXCOORD0) ]] ;\n&#125;;\n\nstruct Mtl_FragmentOut\n&#123;\n    float4 SV_Target0 [[ color(0) ]];\n&#125;;\n\nfragment Mtl_FragmentOut xlatMtlMain(\n    Mtl_FragmentIn input [[ stage_in ]])\n&#123;\n    Mtl_FragmentOut output;\n    output.SV_Target0 &#x3D; input.TEXCOORD0.xyxy;\n    output.SV_Target0 &#x3D; clamp(output.SV_Target0, 0.0f, 1.0f);\n    return output;\n&#125;</code></pre>\r\n<p>Vulkan 太长了我就不粘贴了……</p>\r\n<p>你可以看出来在一些平台下，比如 DX9、DX11 下，编译出来的确是使用真正的\r\nsaturate 运算操作，而在大多数移动平台上，比如 ES 2.0、Metal\r\n等，是编译成了 clamp，而在 ES 3.0\r\n下跟设备还有关系。至于为什么要分这么多种情况，Unity\r\n应该是根据各个平台每种操作耗时的平衡，<strong>选择同等运算结果下最优的等价操作来代替\r\nsaturate</strong>。</p>\r\n</blockquote>\r\n</blockquote>\r\n<p><a\r\nhref=\"https://github.com/candycat1992/Unity_Shaders_Book/issues/59\">关于屏幕后处理效果的疑问\r\n· Issue #59 · candycat1992/Unity_Shaders_Book (github.com)</a></p>\r\n<blockquote>\r\n<p>的确，屏幕后处理本身本质上是在近裁剪平面处又渲染了一个四边形，这个四边形使用的是我们自定义的材质和\r\nshader，它的确本身会走一遍流水管线。</p>\r\n<p>网上说的它是“流水线的最后阶段”，是想指明我们操作的顺序，也就是说我们会在进行完其他物体的渲染后，最后进行这个操作。</p>\r\n</blockquote>\r\n<p><a\r\nhref=\"https://github.com/candycat1992/Unity_Shaders_Book/issues/194\">高斯模糊代码化简建议\r\n· Issue #194 · candycat1992/Unity_Shaders_Book (github.com)</a></p>\r\n","text":"Shader Book Github Issue Collections saturate 和 max · Issue #198 · candycat1992/Unity_Shaders_Book (github.com) 为什么后来从 sature 改到了 max？ Q: 在基...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#shader-book-github-issue-collections\"><span class=\"toc-text\">Shader Book Github Issue\r\nCollections</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Advanced CSharp","uid":"36e65544b0ba9be0c7ba1f8cd3f769cc","slug":"Language Learning/AdvancedCSharp","date":"2023-03-19T04:23:23.000Z","updated":"2023-10-27T20:05:51.000Z","comments":true,"path":"api/articles/Language Learning/AdvancedCSharp.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Advanced CSharp readonly, const &amp; static Virtual, Interface &amp; Abstract Delegate, Action, Func &amp; Event Delegate Quick Start 用实例快速...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"C#","slug":"C","count":2,"path":"api/categories/C.json"},{"name":"Language Learning","slug":"C/Language-Learning","count":2,"path":"api/categories/C/Language-Learning.json"}],"tags":[{"name":"C#","slug":"C","count":2,"path":"api/tags/C.json"},{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Unity Shader入门精要笔记 - Chapter12","uid":"2451d72464fab185c69a4d12737f61d9","slug":"Rendering/UnityShaderBook/Chapter12","date":"2023-03-08T13:29:25.000Z","updated":"2023-10-27T19:27:32.000Z","comments":true,"path":"api/articles/Rendering/UnityShaderBook/Chapter12.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Unity Shader入门精要笔记 - Chapter12 If you are doing a series of post-processing \"blits\", it's best for performance to get and release a temporar...","link":"","photos":[],"count_time":{"symbolsCount":473,"symbolsTime":"1 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}