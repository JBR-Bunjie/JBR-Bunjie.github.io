{"title":"UnityURPToonLitShaderExample 源码分析","uid":"b0e884d72c7c6bc5c7d44e3b4aa33541","slug":"Rendering/SimpleToonShader","date":"2023-05-03T04:23:23.000Z","updated":"2023-10-27T20:13:22.000Z","comments":true,"path":"api/articles/Rendering/SimpleToonShader.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1\r\nid=\"最简的-toon-shader-的源码分析---unityurptoonlitshaderexample\">最简的\r\nToon Shader 的源码分析 - UnityURPToonLitShaderExample</h1>\r\n<blockquote>\r\n<p><strong>What is included in this \"simplified version\" toon lit shader\r\nrepository?</strong></p>\r\n<p>This repository contains a very simple toon lit shader example, to\r\nhelp people writing their first custom toon lit shader in URP. This\r\nexample shader's default result(without editing material params) = the\r\nfollowing picture</p>\r\n<figure>\r\n<img\r\nsrc=\"....\\images\\Dev\\Unity\\SourceCodeAnalysis\\SimpleToonShaderCodeAnalysis\\001.png\"\r\nalt=\"screenshot\" />\r\n<figcaption aria-hidden=\"true\">screenshot</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p><strong>About this repository</strong></p>\r\n<p>This repository is NOT the full version NiloToonURP. This repository\r\nonly contains a very simple and short URP toon shader example, only for\r\ntutorial purposes, it is under MIT license so you can do whatever you\r\nwant with the code. If you want to keep the current tutorial shader,\r\nplease fork it or download a copy now since it may be removed in the\r\nfuture.</p>\r\n</blockquote>\r\n<p><a\r\nhref=\"https://github.com/ColinLeung-NiloCat/UnityURPToonLitShaderExample\">ColinLeung-NiloCat/UnityURPToonLitShaderExample:\r\nA very simple toon lit shader example, for you to learn writing custom\r\nlit shader in Unity URP (github.com)</a></p>\r\n</blockquote>\r\n<blockquote>\r\n<p>如其所说，这实际上是一个过度简化的 Toon\r\nShader，基本不具有太强的可用性，但这也同样意味着，这是一个不错的起点。</p>\r\n<p><del>虽然我们看到上面的结果还算不错，但是基本上不太可能复现出来</del></p>\r\n</blockquote>\r\n<h2 id=\"项目结构\">项目结构：</h2>\r\n<p>容易看出，该项目一共仅包含 8 份文件，而实际在项目中生效的文件为：</p>\r\n<ul>\r\n<li><strong>SimpleURPToonLitOutlineExample.shader</strong></li>\r\n<li>SimpleURPToonLitOutlineExample_Shared.hlsl</li>\r\n<li>NiloOutlineUtil.hlsl</li>\r\n<li>NiloZOffset.hlsl</li>\r\n<li>NiloInvLerpRemap.hlsl</li>\r\n<li>SimpleURPToonLitOutlineExample_LightingEquation.hlsl</li>\r\n</ul>\r\n<p>这是一个组织上还算不赖的项目，不过考虑到未来扩建的可能性，可以考虑将\r\n<code>SimpleURPToonLitOutlineExample_Shared.hlsl</code>\r\n进行进一步的拆分：将该文件拆分为 <code>Input</code> 和\r\n<code>SharedFunction</code> 两个文件</p>\r\n<p>让我们从 <code>SimpleURPToonLitOutlineExample.shader</code>\r\n开始进行代码的分析：</p>\r\n<h2 id=\"代码与效果分析\">代码与效果分析：</h2>\r\n<h3 id=\"shader-文件主体结构\">shader 文件主体结构</h3>\r\n<p>从头看起，首先在 9~14 行的注释中，有提到该 Shader 的 5 个\r\nPasses：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 3%\" />\r\n<col style=\"width: 1%\" />\r\n<col style=\"width: 94%\" />\r\n</colgroup>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><em>ForwardLit</em></td>\r\n<td><em>pass</em></td>\r\n<td><em>(this pass will always render to the color buffer\r\n_CameraColorTexture)</em></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><em>Outline</em></td>\r\n<td><em>pass</em></td>\r\n<td><em>(this pass will always render to the color buffer\r\n_CameraColorTexture)</em></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><em>ShadowCaster</em></td>\r\n<td><em>pass</em></td>\r\n<td><em>(only for URP's shadow mapping, this pass won't render at all if\r\nyour character don't cast shadow)</em></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><em>DepthOnly</em></td>\r\n<td><em>pass</em></td>\r\n<td><em>(only for URP's depth texture _CameraDepthTexture's rendering,\r\nthis pass won't render at all if your project don't render URP's\r\noffscreen depth prepass)</em></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><del><em>DepthNormals</em></del></td>\r\n<td><del><em>pass</em></del></td>\r\n<td><del><em>(only for URP's normal texture _CameraNormalsTexture's\r\nrendering)</em></del><br />实际上项目并没有对这个 Pass 做出实现<br />当\r\nPass\r\n的<strong>LightMode</strong>为<strong>DepthNormals</strong>时，(且在\r\nAssert 中勾选 Depth Texture 时)Unity 会生成_CameraDepthTexture\r\n与_CameraNormalsTexture, 最终传入到 Shader\r\n中的_CameraDepthNormalsTexture，关于_CamerDepthTexture，可见：<br />-\r\nhttps://docs.unity3d.com/Manual/SL-CameraDepthTexture.html<br />-\r\nhttps://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/universalrp-asset.html</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><a\r\nhref=\"https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/universalrp-asset.html\">Universal\r\nRender Pipeline Asset | Universal RP | 12.1.11 (unity3d.com)</a></p>\r\n<p>我们需要处理的环节：</p>\r\n<p>一个 high level setting：_IsFace</p>\r\n<p>https://www.bilibili.com/read/cv6504414/</p>\r\n<h3 id=\"渲染流程\">渲染流程</h3>\r\n<h4 id=\"shader-file\">Shader file</h4>\r\n<p>第一个 Pass 从 117 开始，到 171 行结束。这是 Shader 中的第一个\r\nPass，该 Pass 完成了从间接光到直接光的计算.\r\n这里对间接光的定义是，而直接光则是 MainLight 和 AdditionalLight\r\n的作用集合</p>\r\n<p>先进行光照的运算，这意味着模型的正面最早被渲染，这样可以最大程度地减少\r\nOverDraw 的情况。</p>\r\n<p>整个 Shader file 的四个 Pass 的流程都差不太多，所以针对 Shader\r\n内的各个 Pass 的流程仅作一次说明：</p>\r\n<ul>\r\n<li>在 123 行，定义 Pass 的 Name</li>\r\n<li>在 124~131 行，是 Pass Tags，这里定义了 Pass 的\r\nLightMode：<code>\"LightMode\" = \"UniversalForward\"</code>，这意味这个\r\nPass\r\n应该：<code>Render object geometry and evaluate all light contributions</code></li>\r\n<li>在 135~138 行，设置 Pass State</li>\r\n<li>在 140~170 行，HLSLPROGRAM 2 ENDHLSL\r\n<ul>\r\n<li>142~159 行，设置关键字以获取 Shader 变体</li>\r\n<li>161~162 行，设置 Vertex 和 fragment 函数</li>\r\n<li>168 行，引入实在代码\r\n<code>SimpleURPToonLitOutlineExample_Shared.hlsl</code></li>\r\n</ul></li>\r\n</ul>\r\n<p>深入 <code>SimpleURPToonLitOutlineExample_Shared.hlsl</code>\r\n文件：</p>\r\n<h4 id=\"hlsl-entities\">HLSL Entities</h4>\r\n<h5 id=\"vertex-function-vertexshaderwork\">Vertex Function:\r\nVertexShaderWork</h5>\r\n<p><code>SimpleURPToonLitOutlineExample_Shared.hlsl</code> 文件的\r\n153~217 行是我们的 Vertex Shader：</p>\r\n<p>而由于在单纯的 UniversalForward 中没有定义任何控制用的宏，所以我们\r\nVertex Shader 只会执行最基本的代码，内容仅包括：</p>\r\n<ul>\r\n<li>坐标系转换</li>\r\n<li>uv 计算</li>\r\n</ul>\r\n<p>去掉注释后的代码如下：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Varyings VertexShaderWork(Attributes input) &#123;\n    Varyings output;\n\n    VertexPositionInputs vertexInput &#x3D; GetVertexPositionInputs(input.positionOS);\n    VertexNormalInputs vertexNormalInput &#x3D; GetVertexNormalInputs(input.normalOS, input.tangentOS);\n\n    float3 positionWS &#x3D; vertexInput.positionWS;\n\n    &#x2F;&#x2F; Computes fog factor per-vertex.\n    float fogFactor &#x3D; ComputeFogFactor(vertexInput.positionCS.z);\n\n    &#x2F;&#x2F; TRANSFORM_TEX is the same as the old shader library.\n    output.uv &#x3D; TRANSFORM_TEX(input.uv,_BaseMap);\n\n    &#x2F;&#x2F; packing positionWS(xyz) &amp; fog(w) into a vector4\n    output.positionWSAndFogFactor &#x3D; float4(positionWS, fogFactor);\n    output.normalWS &#x3D; vertexNormalInput.normalWS; &#x2F;&#x2F;normlaized already by GetVertexNormalInputs(...)\n\n    output.positionCS &#x3D; TransformWorldToHClip(positionWS);\n\n    return output;\n&#125;</code></pre>\r\n<h6 id=\"坐标转换过程\">坐标转换过程</h6>\r\n<p>我们只使用了 vertexInput 中的 positionWS，这里用两个原因：</p>\r\n<p>首先，如果我们对模型的顶点作出修改后，我们应该将这种变化同步到所有别的空间下。而\r\nFragment Shader 中会同时用到世界坐标与裁剪坐标，这意味着 Vertex Shader\r\n中需要将“最终的世界坐标与裁剪坐标”上载到 v2f\r\n中。为了简化流程，我们直接在世界空间下操作，而后对完成处理的世界坐标再另做一次坐标转换得到裁剪坐标。</p>\r\n<h6 id=\"雾效\">雾效</h6>\r\n<p>关于 Unity 的内置雾效：</p>\r\n<blockquote>\r\n<p>雾效(Fog)是游戏里经常使用的一种效果。Unity\r\n内置的雾效可以产生基于距离的线性或指数雾效。然而，要想在自己编写的顶点/片元着色器中实现这些雾效，我们需要在\r\nShader 中添加 #pragma multi_compile_fog\r\n指令，同时还需要使用相关的内置宏，例如\r\nUNITY_FOG_COORD、UNITY_TRANSFER_FOG 和 UNTTY_APPLY_FOG\r\n等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。<strong>当我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用\r\nUnity 内置的雾效就变得不再可行</strong></p>\r\n</blockquote>\r\n<p><img\r\nsrc=\"....\\images\\Dev\\Unity\\SourceCodeAnalysis\\SimpleToonShaderCodeAnalysis\\002.png\"\r\nalt=\"image-20230418220205577\" /> Unity Built-in Fog</p>\r\n<p>关于 Unity Built-in Fog，可参考：<a\r\nhref=\"https://catlikecoding.com/unity/tutorials/rendering/part-14/\">Rendering\r\n14 (catlikecoding.com)</a></p>\r\n<h5 id=\"fragment\">Fragment</h5>\r\n<p>等到了 Fragment Shader 中，我们就开始正式计算光源对物体的影响了：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">half4 ShadeFinalColor(Varyings input) : SV_TARGET &#123;\n    &#x2F;&#x2F; fillin ToonSurfaceData struct:\n    ToonSurfaceData surfaceData &#x3D; InitializeSurfaceData(input);\n\n    &#x2F;&#x2F; fillin ToonLightingData struct:\n    ToonLightingData lightingData &#x3D; InitializeLightingData(input);\n\n    &#x2F;&#x2F; apply all lighting calculation\n    half3 color &#x3D; ShadeAllLights(surfaceData, lightingData);\n\n    return half4(color, surfaceData.alpha);\n&#125;</code></pre>\r\n<p>可以看到的是，Fragment Shader\r\n中首先仍然是对数据的准备：利用我们传入的 Varyings 数据定义了两个结构体：\r\n<code>ToonSurfaceData</code> 和 <code>ToonLightingData</code>：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">struct ToonSurfaceData &#123;\n    half3   albedo;\n    half    alpha;\n    half3   emission;\n    half    occlusion;\n&#125;;\nstruct ToonLightingData &#123;\n    half3   normalWS;\n    float3  positionWS;\n    half3   viewDirectionWS;\n    float4  shadowCoord;\n&#125;;</code></pre>\r\n<p>它们分别对应了一个初始化函数：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">ToonSurfaceData InitializeSurfaceData(Varyings input) &#123;\n    ToonSurfaceData output;\n\n    &#x2F;&#x2F; albedo &amp; alpha\n    float4 baseColorFinal &#x3D; GetFinalBaseColor(input);\n    output.albedo &#x3D; baseColorFinal.rgb;\n    output.alpha &#x3D; baseColorFinal.a;\n    DoClipTestToTargetAlphaValue(output.alpha);&#x2F;&#x2F; early exit if possible\n\n    &#x2F;&#x2F; emission\n    output.emission &#x3D; GetFinalEmissionColor(input);\n\n    &#x2F;&#x2F; occlusion\n    output.occlusion &#x3D; GetFinalOcculsion(input);\n\n    return output;\n&#125;\n\nToonLightingData InitializeLightingData(Varyings input) &#123;\n    ToonLightingData lightingData;\n    lightingData.positionWS &#x3D; input.positionWSAndFogFactor.xyz;\n    lightingData.viewDirectionWS &#x3D; SafeNormalize(GetCameraPositionWS() - lightingData.positionWS);\n    lightingData.normalWS &#x3D; normalize(input.normalWS); &#x2F;&#x2F;interpolated normal is NOT unit vector, we need to normalize it\n\n    return lightingData;\n&#125;</code></pre>\r\n<p>在完成初始化后，利用所得的信息，计算光照影响：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">half3 color &#x3D; ShadeAllLights(surfaceData, lightingData);\ncolor &#x3D; ApplyFog(color, input);</code></pre>\r\n<p>最后将 color 作为结果进行返回，完成一次渲染</p>\r\n<p>这其中的 ShadeAllLights 必须考虑全部的 Light 的影响，</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">half3 ShadeAllLights(ToonSurfaceData surfaceData, ToonLightingData lightingData)\n&#123;\n    &#x2F;&#x2F; Indirect lighting\n    half3 indirectResult &#x3D; ShadeGI(surfaceData, lightingData);\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    &#x2F;&#x2F; Light struct is provided by URP to abstract light shader variables.\n    &#x2F;&#x2F; It contains light&#39;s\n    &#x2F;&#x2F; - direction\n    &#x2F;&#x2F; - color\n    &#x2F;&#x2F; - distanceAttenuation\n    &#x2F;&#x2F; - shadowAttenuation\n    &#x2F;&#x2F;\n    &#x2F;&#x2F; URP take different shading approaches depending on light and platform.\n    &#x2F;&#x2F; You should never reference light shader variables in your shader, instead use the\n    &#x2F;&#x2F; -GetMainLight()\n    &#x2F;&#x2F; -GetLight()\n    &#x2F;&#x2F; funcitons to fill this Light struct.\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    &#x2F;&#x2F; Main light is the brightest directional light.\n    &#x2F;&#x2F; It is shaded outside the light loop and it has a specific set of variables and shading path\n    &#x2F;&#x2F; so we can be as fast as possible in the case when there&#39;s only a single directional light\n    &#x2F;&#x2F; You can pass optionally a shadowCoord. If so, shadowAttenuation will be computed.\n    Light mainLight &#x3D; GetMainLight();\n\n    float3 shadowTestPosWS &#x3D; lightingData.positionWS + mainLight.direction * (_ReceiveShadowMappingPosOffset + _IsFace);\n#ifdef _MAIN_LIGHT_SHADOWS\n    &#x2F;&#x2F; compute the shadow coords in the fragment shader now due to this change\n    &#x2F;&#x2F; https:&#x2F;&#x2F;forum.unity.com&#x2F;threads&#x2F;shadow-cascades-weird-since-7-2-0.828453&#x2F;#post-5516425\n\n    &#x2F;&#x2F; _ReceiveShadowMappingPosOffset will control the offset the shadow comparsion position,\n    &#x2F;&#x2F; doing this is usually for hide ugly self shadow for shadow sensitive area like face\n    float4 shadowCoord &#x3D; TransformWorldToShadowCoord(shadowTestPosWS);\n    mainLight.shadowAttenuation &#x3D; MainLightRealtimeShadow(shadowCoord);\n#endif\n\n    &#x2F;&#x2F; Main light\n    half3 mainLightResult &#x3D; ShadeSingleLight(surfaceData, lightingData, mainLight, false);\n\n    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    &#x2F;&#x2F; All additional lights\n\n    half3 additionalLightSumResult &#x3D; 0;\n\n#ifdef _ADDITIONAL_LIGHTS\n    &#x2F;&#x2F; Returns the amount of lights affecting the object being renderer.\n    &#x2F;&#x2F; These lights are culled per-object in the forward renderer of URP.\n    int additionalLightsCount &#x3D; GetAdditionalLightsCount();\n    for (int i &#x3D; 0; i &lt; additionalLightsCount; ++i)\n    &#123;\n        &#x2F;&#x2F; Similar to GetMainLight(), but it takes a for-loop index. This figures out the\n        &#x2F;&#x2F; per-object light index and samples the light buffer accordingly to initialized the\n        &#x2F;&#x2F; Light struct. If ADDITIONAL_LIGHT_CALCULATE_SHADOWS is defined it will also compute shadows.\n        int perObjectLightIndex &#x3D; GetPerObjectLightIndex(i);\n        Light light &#x3D; GetAdditionalPerObjectLight(perObjectLightIndex, lightingData.positionWS); &#x2F;&#x2F; use original positionWS for lighting\n        light.shadowAttenuation &#x3D; AdditionalLightRealtimeShadow(perObjectLightIndex, shadowTestPosWS); &#x2F;&#x2F; use offseted positionWS for shadow test\n\n        &#x2F;&#x2F; Different function used to shade additional lights.\n        additionalLightSumResult +&#x3D; ShadeSingleLight(surfaceData, lightingData, light, true);\n    &#125;\n#endif\n    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n    &#x2F;&#x2F; emission\n    half3 emissionResult &#x3D; ShadeEmission(surfaceData, lightingData);\n\n    return CompositeAllLightResults(indirectResult, mainLightResult, additionalLightSumResult, emissionResult, surfaceData, lightingData);\n&#125;</code></pre>\r\n<h4 id=\"小结\">小结</h4>\r\n<h3 id=\"描边流程\">描边流程</h3>\r\n<h4 id=\"基本思路\">基本思路：</h4>\r\n<p>描边的基本思路：顶点扩张。利用</p>\r\n<p><span class=\"math display\">\\[\r\nVertexPos\\_Outline = VertexPos + NormalDir * ControlVariable\r\n\\]</span></p>\r\n<p>来计算 Outline Pass\r\n下的受到扩张的顶点坐标。再裁剪掉正面的三角形即可。</p>\r\n<h4 id=\"实现过程\">实现过程：</h4>\r\n<p>Shader 的 173 行到 223 行对应了 Outline\r\n的流程，这里做的事情包括：</p>\r\n<ul>\r\n<li>180 行：设置 Pass 的 Name</li>\r\n<li>181~196 行：用于设置 Pass Tags，这里的注释指出，我们可以通过为当前\r\nPass 设置一个我们自定义的\r\nLightMode：<code>\"LightMode\"==\"YourCustomPassTag\"</code>，通过这种方式，我们可以利用\r\nURP 的 RenderFeature 以及\r\ncmd.DrawRenderers()来控制我们的渲染来最大化利用 SRP 批处理。关于\r\nRenderFeature，可参考： <a\r\nhref=\"https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/renderer-features/create-custom-renderer-feature.html\">How\r\nto create a custom Renderer Feature | Universal RP | 12.1.11\r\n(unity3d.com)</a> <a\r\nhref=\"https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Rendering.CommandBuffer.html\">Unity\r\n- Scripting API: CommandBuffer (unity3d.com)</a></li>\r\n<li>198 行，<code>Cull Front</code></li>\r\n<li>200~222 行，HLSLPROGRAM 2 ENDHLSL\r\n<ul>\r\n<li>202 行到 211 行，继承了 ForwardLit 的关键字</li>\r\n<li>213~214 行，设置 vertex 和 fragment 函数</li>\r\n<li>217 行，定义宏 <code>ToonShaderIsOutline</code>\r\n来控制渲染流程——这是我们整个渲染中，相当重要的一环</li>\r\n<li>220 行，引入实在代码\r\n<code>SimpleURPToonLitOutlineExample_Shared.hlsl</code></li>\r\n</ul></li>\r\n</ul>\r\n<p>让我们继续深入\r\n<code>SimpleURPToonLitOutlineExample_Shared.hlsl</code> 文件</p>\r\n<h4 id=\"hlsl-entities-1\">HLSL Entities</h4>\r\n<h5 id=\"vertex\">Vertex</h5>\r\n<h5 id=\"fragment-1\">Fragment</h5>\r\n<p>为什么描边需要 fov 和 Distance？</p>\r\n<h2 id=\"shader-变体\">Shader 变体：</h2>\r\n<h2 id=\"后记\">后记</h2>\r\n<blockquote>\r\n<p><strong>What is NOT included in this simplified example\r\nshader?</strong></p>\r\n<p>For simplicity reason, I removed most of the features from the\r\nNiloToonURP (deleted 90% of the original shader), else this example\r\nshader will be way too complex for reading &amp; learning. The removed\r\nfeatures are:</p>\r\n<ul>\r\n<li>face anime lighting (auto-fix face ugly lighting due to vertex\r\nnormal without modifying .fbx, very important)</li>\r\n<li>smooth outline normal auto baking (fix ugly outlines without\r\nmodifying .fbx once you attach a script on character, very\r\nimportant)</li>\r\n<li>auto 2D hair shadow on face (very important, it is very difficult to\r\nproduce good looking shadow result using shadowmap)</li>\r\n<li>sharp const width rim light (Blue Protocol / Genshin Impact)</li>\r\n<li>tricks to render eye/eyebrow over hair</li>\r\n<li>hair \"angel ring\" reflection</li>\r\n<li>PBR specular lighting (GGX)</li>\r\n<li>HSV control shadow &amp; outline color</li>\r\n<li>2D mouth renderer</li>\r\n<li>almost all the extra texture input options like roughness, specular,\r\nnormal map, detail map...</li>\r\n<li>LOTS of sliders to control lighting, final color &amp; outline</li>\r\n<li>per character \"dither fadeinout / rim light / tint / lerp...\"\r\ncontrol script</li>\r\n<li>volume override control of global \"dither fadeinout / rim light /\r\ntint / lerp...\"</li>\r\n<li>anime postprocessing</li>\r\n<li>auto phong tessellation</li>\r\n<li>perspective removal per character</li>\r\n<li>***just too much for me to write all removed feature here, the full\r\n/ lite version shader is a totally different level product</li>\r\n</ul>\r\n</blockquote>\r\n<h2 id=\"reference\">Reference</h2>\r\n<ul>\r\n<li><a\r\nhref=\"https://github.com/ColinLeung-NiloCat/UnityURPToonLitShaderExample\">ColinLeung-NiloCat/UnityURPToonLitShaderExample:\r\nA very simple toon lit shader example, for you to learn writing custom\r\nlit shader in Unity URP (github.com)</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/555291588\">【Unity】URP\r\n源码分析(Pass 篇) - 知乎 (zhihu.com)</a></li>\r\n<li><a\r\nhref=\"https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/universalrp-asset.html\">Universal\r\nRender Pipeline Asset | Universal RP | 12.1.11 (unity3d.com)</a></li>\r\n<li><a\r\nhref=\"https://docs.unity3d.com/Manual/SL-CameraDepthTexture.html\">Unity\r\n- Manual: Cameras and depth textures (unity3d.com)</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/144845123\">【浅入浅出】Unity\r\n雾效 - 知乎 (zhihu.com)</a></li>\r\n</ul>\r\n","text":"最简的 Toon Shader 的源码分析 - UnityURPToonLitShaderExample What is included in this \"simplified version\" toon lit shader repository? This reposito...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%AE%80%E7%9A%84-toon-shader-%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---unityurptoonlitshaderexample\"><span class=\"toc-text\">最简的\r\nToon Shader 的源码分析 - UnityURPToonLitShaderExample</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">项目结构：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%95%88%E6%9E%9C%E5%88%86%E6%9E%90\"><span class=\"toc-text\">代码与效果分析：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#shader-%E6%96%87%E4%BB%B6%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">shader 文件主体结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">渲染流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shader-file\"><span class=\"toc-text\">Shader file</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#hlsl-entities\"><span class=\"toc-text\">HLSL Entities</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#vertex-function-vertexshaderwork\"><span class=\"toc-text\">Vertex Function:\r\nVertexShaderWork</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">坐标转换过程</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%9B%BE%E6%95%88\"><span class=\"toc-text\">雾效</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#fragment\"><span class=\"toc-text\">Fragment</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BE%B9%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">描边流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">基本思路：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">实现过程：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#hlsl-entities-1\"><span class=\"toc-text\">HLSL Entities</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#vertex\"><span class=\"toc-text\">Vertex</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#fragment-1\"><span class=\"toc-text\">Fragment</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shader-%E5%8F%98%E4%BD%93\"><span class=\"toc-text\">Shader 变体：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8E%E8%AE%B0\"><span class=\"toc-text\">后记</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"计算机编码梳理","uid":"5b286fb1e51c3a9c0edf1921a9c938c7","slug":"Language Learning/GC","date":"2023-05-05T18:52:23.000Z","updated":"2023-10-27T20:05:44.000Z","comments":true,"path":"api/articles/Language Learning/GC.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"垃圾回收 - Garbage Collection 为什么需要GC 方便 为何主流游戏引擎的对象需要有GC机制？ - 霍姚远的回答 - 知乎 https://www.zhihu.com/question/518026433/answer/2488730232 为何主流游戏引擎的对...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"C#","slug":"C","count":2,"path":"api/categories/C.json"},{"name":"Language Learning","slug":"C/Language-Learning","count":2,"path":"api/categories/C/Language-Learning.json"}],"tags":[{"name":"C#","slug":"C","count":2,"path":"api/tags/C.json"},{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Shaderlab 总览及其基本执行逻辑","uid":"3efe5f95488e956915246e267ac83bb6","slug":"Rendering/Shaderlab","date":"2023-05-02T04:23:23.000Z","updated":"2023-10-27T20:14:20.000Z","comments":true,"path":"api/articles/Rendering/Shaderlab.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Shaderlab 总览及其基本执行逻辑 Shaderlab 结构总览 Shaderlab 是 Unity 所使用的，独立的着色器语言。这是一种跨平台的语言体系，大体包含四部分： ShaderLab Text ShaderLab Compiler ShaderLab Asset ...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}