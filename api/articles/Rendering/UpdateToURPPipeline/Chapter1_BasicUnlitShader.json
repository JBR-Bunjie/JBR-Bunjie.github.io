{"title":"URP Chapter1 - 从官方示例开始","uid":"db175e84108ce0ad0ee0d7331217eb60","slug":"Rendering/UpdateToURPPipeline/Chapter1_BasicUnlitShader","date":"2023-04-04T13:32:05.000Z","updated":"2023-11-07T12:44:48.516Z","comments":true,"path":"api/articles/Rendering/UpdateToURPPipeline/Chapter1_BasicUnlitShader.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"chapter1---从官方示例开始\">Chapter1 - 从官方示例开始</h1>\r\n<blockquote>\r\n<p>本章涵盖内容：</p>\r\n<ul>\r\n<li>官方 <code>URP Pipeline Custom Shader</code> 部分的教程与示例</li>\r\n</ul>\r\n</blockquote>\r\n<h2 id=\"曾今的第一个shader程序\">曾今的第一个Shader程序</h2>\r\n<p>回想一下，我们在入门精要中的第一个unlit shader是什么？</p>\r\n<p>是不是像下面这样的直接输出颜色的shader？</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;BeforeURPTutorialShaderBasic&quot;&#123;\n    &#x2F;*一个最基础的着色器*&#x2F;\n    Properties&#123;\n        _Color(&quot;Color Tint&quot;, Color) &#x3D; (1, 1, 1, 1)\n    &#125;\n    SubShader&#123;\n        pass&#123;\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            \n            fixed4 _Color;\n            \n            struct appdata &#123;\n                float4 vertex : POSITION;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n            &#125;;\n            \n            float4 vert(app_data o):SV_POSITION&#123;\n                v2f v;\n                v.pos &#x3D; UnityObjectToClipPos(o.vertex)\n                return v;\n            &#125;\n            \n            fixed4 frag(v2f i):SV_TARGET&#123;\n                return _BaseColor;\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n&#125;</code></pre>\r\n<p>是的，这就是我们曾经使用过的，最最基础的Shader。从大体上看，我们定义了：</p>\r\n<ul>\r\n<li>外部汇入Shader的属性</li>\r\n<li>CG代码块\r\n<ul>\r\n<li>自定义vertex和fragment Shader名称</li>\r\n<li>构造输入输出数据结构体</li>\r\n<li>使用CG语义编写具体的vertex和fragment Shader内容</li>\r\n</ul></li>\r\n</ul>\r\n<p>通过实现以上的内容，我们完成了built-in管线下的，Shader的编写。</p>\r\n<p>那么，相对的，我们在URP管线中则应该构造这样子的shader来实现对应功能：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;URPTutorialShaderBasic&quot; &#123;\n    Properties &#123;\n        _Color(&quot;Color Tint&quot;, Color) &#x3D; (1, 1, 1, 1)\n    &#125;\n    SubShader &#123;\n        &#x2F;&#x2F; Place.01\n        Tags &#123;\n            &quot;RenderPipline&quot;&#x3D;&quot;UniversalPipline&quot;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n\n        Pass &#123;\n        \t&#x2F;&#x2F; Place.02\n            HLSLPROGRAM\n\n            #pragma vertex vert\n            #pragma fragment frag\n        \n        \t&#x2F;&#x2F; Place.03\n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;\n\n            struct appdata &#123;\n                float4 vertex : POSITION;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n            &#125;;\n\n            sampler2D _MainTex;\n            float4 _MainTex_ST;\n            half4 _Color;\n\n            v2f vert(appdata v) &#123;\n                v2f o;\n                        \n        \t\t&#x2F;&#x2F; Place.04\n        \t\to.pos &#x3D; TransformObjectToHClip(v.vertex.xyz);\n                &#x2F;&#x2F; or: o.pos &#x3D; mul(UNITY_MATRIX_MVP, v.vertex);\n                \n                return o;\n            &#125;\n\n            half4 frag(v2f i) : SV_Target &#123;\n                return _Color;\n            &#125;\n            ENDHLSL\n        &#125;\n    &#125;\n&#125;</code></pre>\r\n<p>可以看到，换用URP管线后，有这些变化：</p>\r\n<ul>\r\n<li>Place.01：我们得明确地声明该Shader需要使用\r\n<code>UniversalPipline</code> 了</li>\r\n<li>原来书写的 <code>CG</code> 代码块变成了 <code>HLSL</code>\r\n代码块</li>\r\n<li>原来引入的 <code>CG</code> 头文件也变成了对应的 <code>HLSL</code>\r\n文件</li>\r\n<li>基于我们的头文件的更替，我们换用了一套和CG几乎完全不同的\r\n<code>API</code>。</li>\r\n</ul>\r\n<p>是的，原先在入门精要里用了一整本书的那些CG函数，现在我们都不能用了——我们得重新熟悉这些“换了个马甲”的HLSL函数。</p>\r\n<h2 id=\"为什么是hlsl\">为什么是HLSL</h2>\r\n<p>CG已经是一个停止更新很久(2012年Nvidia就已经停止了维护)的语言了，而HLSL则一直更新到了现在(截至3/25/2023)，虽然HLSL本身并非一门跨平台的语言(DirextX专用语言)，但是请注意，我们事实上书写的是Shaderlab语言——只是采用了HLSL语法(标准)</p>\r\n<h2 id=\"绘制纹理\">绘制纹理</h2>\r\n<h3 id=\"代码\">代码</h3>\r\n<blockquote>\r\n<p>请注意打上 <code>// Place.0x</code> 的全部内容</p>\r\n</blockquote>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;URPTutorialTextureShader&quot; &#123;\n \t&#x2F;&#x2F; Place.01\n    Properties &#123;\n        [MainTexture] _MainTex (&quot;Basic Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n \t\t\t&#x2F;&#x2F; Place.02\n            &quot;RenderPipline&quot;&#x3D;&quot;UniversalRenderPipeline&quot;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n\n        Pass &#123;\n            HLSLPROGRAM\n\n            #pragma vertex vert\n            #pragma fragment frag\n        \n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;\n            \n            struct appdata &#123;\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n                float2 uv : TEXCOORD0;\n            &#125;;\n\n \t\t\t&#x2F;&#x2F; Place.03\n            TEXTURE2D(_MainTex);\n            SAMPLER(sampler_MainTex);\n\n            CBUFFER_START(UnityPerMaterial)\n                float4 _MainTex_ST;\n            CBUFFER_END\n            \n            v2f vert(appdata v) &#123;\n                v2f o;\n                        \n        \t\to.pos &#x3D; TransformObjectToHClip(v.vertex.xyz);\n                o.uv &#x3D; TRANSFORM_TEX(v.uv, _MainTex);\n                \n                return o;\n            &#125;\n\n            half4 frag(v2f i) : SV_Target &#123;\n \t\t\t\t&#x2F;&#x2F; Place.04\n                float4 color &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);\n                return color;\n            &#125;\n            ENDHLSL\n        &#125;\n    &#125;\n&#125;</code></pre>\r\n<p>回想我们读取在 <code>CGPROGRAM</code> 中读取 <code>Texture</code>\r\n的主要步骤：</p>\r\n<ul>\r\n<li>建立采样器 <code>sampler2D</code></li>\r\n<li>获取材质面板上的 <code>Tiling</code> 与 <code>Offset</code></li>\r\n<li>利用 <code>tex2D</code> 来进行最终的取样过程</li>\r\n</ul>\r\n<p>而我们现在在URP管线的 <code>HLSLPROGRAM</code>\r\n中改写的这些内容，就主要集中在以上代码部分中的各个 <code>Place</code>\r\n部分：</p>\r\n<ol type=\"1\">\r\n<li>设置 <code>[MainTexture]</code>，这会方便我们在脚本中调用：</li>\r\n</ol>\r\n<blockquote>\r\n<blockquote>\r\n<p><strong>Material.mainTexture</strong></p>\r\n<p>By default, Unity considers a texture with the property name\r\n<code>\"_MainTex\"</code> to be the main texture. Use the\r\n<code>[MainTexture]</code> <a\r\nhref=\"https://docs.unity3d.com/Manual/SL-Properties.html\">ShaderLab\r\nProperties attribute</a> to make Unity consider a texture with a\r\ndifferent property name to be the main texture. When the main texture is\r\nset using the <code>[MainTexture]</code> attribute, it is not visible in\r\nthe Game view when you use the texture streaming <a\r\nhref=\"https://docs.unity3d.com/Manual/TextureStreaming-API#DebuggingAPI.html\">debugging\r\nview mode</a> or a custom debug tool.</p>\r\n</blockquote>\r\n<p><a\r\nhref=\"https://docs.unity3d.com/ScriptReference/Material-mainTexture.html\">Unity\r\n- Scripting API: Material.mainTexture (unity3d.com)</a></p>\r\n</blockquote>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>改写 <code>UniversalPipeline</code> 为\r\n<code>UniversalRenderPipeline</code>：事实上这两种写法好像都有效，Unity\r\n2021.3版本的文档也在左右互博：</p>\r\n<blockquote>\r\n<ul>\r\n<li><p>在中文URP 12.1.1文档中的 <code>编写自定义着色器</code>\r\n一章中，所有对应内容皆为 <code>UniversalPipeline</code> <a\r\nhref=\"https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/writing-custom-shaders-urp.html\">编写自定义着色器\r\n| Universal RP | 12.1.1 (unity3d.com)</a></p></li>\r\n<li><p>在英文URP 12.1.10文档中的 <code>Writing custom shaders</code>\r\n一章中同样如此 <a\r\nhref=\"https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/writing-custom-shaders-urp.html\">Writing\r\ncustom shaders | Universal RP | 12.1.10 (unity3d.com)</a></p></li>\r\n<li><p>但是在 <code>Unity Manual</code> 中则是这样的：</p>\r\n<blockquote>\r\n<p><strong>RenderPipeline tag</strong></p>\r\n<p>The <code>RenderPipeline</code> tag tells Unity whether a SubShader\r\nis compatible with the Universal Render Pipeline (URP) or the High\r\nDefinition Render Pipeline (HDRP).</p>\r\n<p><strong>Syntax and valid values</strong></p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 31%\" />\r\n<col style=\"width: 68%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: left;\"><strong>Signature</strong></th>\r\n<th style=\"text-align: left;\"><strong>Function</strong></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">“RenderPipeline” = “[name]”</td>\r\n<td style=\"text-align: left;\">Tells Unity whether this SubShader is\r\ncompatible with URP or HDRP.</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table style=\"width:100%;\">\r\n<colgroup>\r\n<col style=\"width: 13%\" />\r\n<col style=\"width: 35%\" />\r\n<col style=\"width: 51%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: left;\"><strong>Parameter</strong></th>\r\n<th style=\"text-align: left;\"><strong>Value</strong></th>\r\n<th style=\"text-align: left;\"><strong>Function</strong></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">[name]</td>\r\n<td style=\"text-align: left;\">UniversalRenderPipeline</td>\r\n<td style=\"text-align: left;\">This SubShader is compatible with URP\r\nonly.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\"></td>\r\n<td style=\"text-align: left;\">HighDefinitionRenderPipeline</td>\r\n<td style=\"text-align: left;\">This SubShader is compatible with HDRP\r\nonly.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\"></td>\r\n<td style=\"text-align: left;\">(any other value, or not declared)</td>\r\n<td style=\"text-align: left;\">This SubShader is not compatible with URP\r\nor HDRP.</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><a\r\nhref=\"https://docs.unity3d.com/2021.3/Documentation/Manual/SL-SubShaderTags.html\">Unity\r\n- Manual: ShaderLab: assigning tags to a SubShader (unity3d.com)</a></p>\r\n</blockquote></li>\r\n</ul>\r\n<p>这样明显的左右互搏...所以应该是可以通用的</p>\r\n</blockquote></li>\r\n<li><p>相较于CG中直接声明sample2D，HLSL中将 <code>Sampler</code> 与\r\n<code>Texture</code>\r\n区分开来——我们得先声明一个纹理，然后才能为其指定采样器。而之后的，我们在CBUFFER代码块中像\r\n<code>CGPROGRAM</code> 中一样，使用 <code>_ST</code>\r\n后缀来声明纹理属性</p></li>\r\n<li><p>API改变——原来的 <code>tex2D</code> 变为\r\n<code>SAMPLE_TEXTURE2D</code></p></li>\r\n</ol>\r\n<h3 id=\"关于-hlslprogram-中的-cbuffer-语句块与采样器\">关于\r\n<code>HLSLPROGRAM</code> 中的 <code>CBuffer</code> 语句块与采样器</h3>\r\n<h2 id=\"获取深度缓冲及重建其世界坐标\">获取深度缓冲及重建其世界坐标</h2>\r\n<blockquote>\r\n<p>此示例中的 Unity 着色器使用深度纹理和屏幕空间 UV\r\n坐标来重建像素的世界空间位置。该着色器在网格上绘制棋盘图案，使位置可视化。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>本节中的代码较官方示例中的代码有所不同：我们额外设置了渲染队列，修改了RenderType</p>\r\n</blockquote>\r\n<p>在URP中，我们可以直接在Shader中拿到\r\n<code>Depth Texture</code>：通过在 URP 资源的 General 部分中，启用\r\n<code>Depth Texture</code>，我们可以直接在ShaderLab中拿到当前的深度缓冲，并利用它来重建世界坐标：</p>\r\n<p><img\r\nsrc=\"../../../images\\Dev\\Unity\\UpdateToURPPipeline\\Chapter1_BasicUnlitShader\\001.png\"\r\nalt=\"在 URP 资源中，启用 Depth Texture\" /> <em>启用深度缓冲</em></p>\r\n<p>具体步骤可以参考以下代码，需要说明的内容已经在注释中注明</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;URPTutorialReconstructWorldPos&quot; &#123;\n    Properties &#123;&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderPipeline&quot;&#x3D;&quot;UniversalRenderPipeline&quot;\n            &quot;Queue&quot;&#x3D;&quot;Transparent&quot;\n            &quot;RenderType&quot;&#x3D;&quot;Transparent&quot;\n        &#125;\n\n        Pass &#123;\n            HLSLPROGRAM\n            \n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;\n            \n            &#x2F;&#x2F; 我们在这里引入了重要的着色器头文件，DeclareDepthTexture.hlsl，它包含了用于对摄像机深度纹理进行采样的函数 SampleSceneDepth\n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;DeclareDepthTexture.hlsl&quot;\n            \n            struct appdata &#123;\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n            &#125;;\n\n            &#x2F;&#x2F; 可以发现，我们并没有像入门精要那样显式地去声明我们需要使用的深度纹理，因为我们这里并不是后处理步骤\n            v2f vert(appdata v) &#123;\n                v2f o;\n                o.pos &#x3D; TransformObjectToHClip(v.vertex.xyz);\n                \n                return o;\n            &#125;\n\n            &#x2F;&#x2F; 我们所需要实现的功能集中在Fragment Shader中\n            half4 frag(v2f i) : SV_Target &#123;\n                &#x2F;&#x2F; 由于深度纹理对应的应是屏幕空间，而 i.pos 则对应裁剪空间，那么我们就可以通过继续对 i.pos 进行后续变换来方便我们采样\n                &#x2F;&#x2F; 首先，采样深度缓冲区的 UV 坐标，由像素位置除以渲染目标分辨率 _ScaledScreenParams 得到(透视除法)\n                float2 uv &#x3D; i.pos.xy &#x2F; _ScaledScreenParams.xy;\n                \n                &#x2F;&#x2F; 开始采样，并根据不同的情况调整z值\n                #if UNITY_REVERSED_Z\n                    real depth &#x3D; SampleSceneDepth(uv);\n                \t&#x2F;&#x2F; 这里我们使用了real类型，这是unity所定义的类型，可参看：https:&#x2F;&#x2F;forum.unity.com&#x2F;threads&#x2F;what-does-real-in-shaders-of-lightweight-pipeline-means-it-seems-some-sort-of-number.547402&#x2F;\n                #else\n                \t&#x2F;&#x2F; 匹配 opengl 的 NDC\n                    real depth &#x3D; lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(uv));\n                #endif\n                &#x2F;&#x2F;要使重建函数正常工作，深度值必须位于归一化设备坐标 (NDC) 空间中。在 D3D 中，Z 处于 [0,1] 范围内，而在 OpenGL 中，Z 处于 [-1, 1] 范围内\n\n                &#x2F;&#x2F; 使用 ComputeWorldSpacePosition 函数开始重建，我们呢现在已经具有：NDC 下 xy，NDC 下 z\n                float3 worldPos &#x3D; ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);\n\n                &#x2F;&#x2F; 可视化世界空间\n                uint scale &#x3D; 10;\n                uint3 worldIntPos &#x3D; uint3(abs(worldPos.xyz * scale));\n\n                bool white &#x3D; (worldIntPos.x &amp; 1) ^ (worldIntPos.y &amp; 1) ^ (worldIntPos.z &amp; 1);\n                &#x2F;&#x2F; ^ 异或\n\n                half4 color &#x3D; white ? half4(1, 1, 1, 1) : half4(0, 0, 0, 1);\n                \n                #if UNITY_REVERSED_Z\n                    &#x2F;&#x2F; 具有 REVERSED_Z 的平台（如 D3D）的情况。\n                    if(depth &lt; 0.0001)\n                        return half4(0,0,0,1);\n                #else\n                    &#x2F;&#x2F; 没有 REVERSED_Z 的平台（如 OpenGL）的情况。\n                    if(depth &gt; 0.9999)\n                        return half4(0,0,0,1);\n                #endif\n                \n                return color;\n            &#125;\n            ENDHLSL\n        &#125;\n    &#125;\n&#125;</code></pre>\r\n<h2 id=\"小结\">小结</h2>\r\n<p>In this chapter, we have finished the short official tutorial of\r\nUnity,</p>\r\n<p>Thank God, there are not so many challenges and changes. You can see\r\nthe example below, you can find out that it's almost as same as\r\n<code>CGPROGRAM</code> we wrote before.</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;URPTutorialVisualizingNormalShader&quot; &#123;\n    Properties &#123;&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderPipeline&quot;&#x3D;&quot;UniversalPipeline&quot;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n\n        Pass &#123;\n            HLSLPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;\n\n            struct appdata &#123;\n                float4 vertex : POSITION;\n                float3 normal : NORMAL;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n                float3 worldNormal : TEXCOORD0;\n            &#125;;\n\n            v2f vert(appdata v) &#123;\n                v2f o;\n                o.pos &#x3D; TransformObjectToHClip(v.vertex);\n                o.worldNormal &#x3D; TransformObjectToWorldNormal(v.normal);\n                return o;\n            &#125;\n\n            half4 frag(v2f i) : SV_Target &#123;\n                return half4(i.worldNormal * 0.5 + 0.5, 1.0);\n            &#125;\n            ENDHLSL\n        &#125;\n    &#125;\n&#125;</code></pre>\r\n","text":"Chapter1 - 从官方示例开始 本章涵盖内容： 官方 URP Pipeline Custom Shader 部分的教程与示例 曾今的第一个Shader程序 回想一下，我们在入门精要中的第一个unlit shader是什么？ 是不是像下面这样的直接输出颜色的shader？ S...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Unity","slug":"Unity","count":21,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity","slug":"Unity","count":22,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"URP Pipeline","slug":"URP-Pipeline","count":1,"path":"api/tags/URP-Pipeline.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#chapter1---%E4%BB%8E%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E5%BC%80%E5%A7%8B\"><span class=\"toc-text\">Chapter1 - 从官方示例开始</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%BE%E4%BB%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAshader%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">曾今的第一个Shader程序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFhlsl\"><span class=\"toc-text\">为什么是HLSL</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%98%E5%88%B6%E7%BA%B9%E7%90%86\"><span class=\"toc-text\">绘制纹理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E-hlslprogram-%E4%B8%AD%E7%9A%84-cbuffer-%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%8E%E9%87%87%E6%A0%B7%E5%99%A8\"><span class=\"toc-text\">关于\r\nHLSLPROGRAM 中的 CBuffer 语句块与采样器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%8F%8A%E9%87%8D%E5%BB%BA%E5%85%B6%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87\"><span class=\"toc-text\">获取深度缓冲及重建其世界坐标</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"URP Chapter 3 - Lit","uid":"82ff1fb81877d21689ef75c8cb4f38fd","slug":"Rendering/UpdateToURPPipeline/Chapter3_Lit","date":"2023-04-05T13:32:05.000Z","updated":"2023-11-07T12:44:54.631Z","comments":true,"path":"api/articles/Rendering/UpdateToURPPipeline/Chapter3_Lit.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Chapter 3 - Lit 在 URP 管线下，所有我们新创建的材质会默认使用 Universal Render Pipeline/Lit 作为当前材质的 Shader，这个 Shader 是 unity 对 PBR 的基本实现，而本章将对该 Shader 作深入分析，本章所...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Chapter0 - URP 管线分析系列概览","uid":"edde6f65aa71985a04dfce2cbb091e0c","slug":"Rendering/UpdateToURPPipeline/Chapter0","date":"2023-04-03T13:32:05.000Z","updated":"2023-10-27T20:16:07.000Z","comments":true,"path":"api/articles/Rendering/UpdateToURPPipeline/Chapter0.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Chapter0 - URP 管线分析系列概览 章节安排 Chapter 1：Unity URP 管线 自定义Shader 小节全内容 Chapter 2：了解 URP 管线下的光与影 Chapter 3：URP 管线默认 Shader：Lit.shader 分析 Chapter...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}