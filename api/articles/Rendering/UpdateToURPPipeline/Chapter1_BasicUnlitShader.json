{"title":"URP Chapter1 - 从官方示例开始","uid":"db175e84108ce0ad0ee0d7331217eb60","slug":"Rendering/UpdateToURPPipeline/Chapter1_BasicUnlitShader","date":"2023-04-04T13:32:05.000Z","updated":"2023-10-27T20:17:56.000Z","comments":true,"path":"api/articles/Rendering/UpdateToURPPipeline/Chapter1_BasicUnlitShader.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"Chapter1-从官方示例开始\"><a href=\"#Chapter1-从官方示例开始\" class=\"headerlink\" title=\"Chapter1 - 从官方示例开始\"></a>Chapter1 - 从官方示例开始</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本章涵盖内容：</p>\n<ul>\n<li>官方 <code>URP Pipeline Custom Shader</code> 部分的教程与示例</li>\n</ul></blockquote>\n<h2 id=\"曾今的第一个Shader程序\"><a href=\"#曾今的第一个Shader程序\" class=\"headerlink\" title=\"曾今的第一个Shader程序\"></a>曾今的第一个Shader程序</h2><p>回想一下，我们在入门精要中的第一个unlit shader是什么？</p>\n<p>是不是像下面这样的直接输出颜色的shader？</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;BeforeURPTutorialShaderBasic&quot;&#123;\n    &#x2F;*一个最基础的着色器*&#x2F;\n    Properties&#123;\n        _Color(&quot;Color Tint&quot;, Color) &#x3D; (1, 1, 1, 1)\n    &#125;\n    SubShader&#123;\n        pass&#123;\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            \n            fixed4 _Color;\n            \n            struct appdata &#123;\n                float4 vertex : POSITION;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n            &#125;;\n            \n            float4 vert(app_data o):SV_POSITION&#123;\n                v2f v;\n                v.pos &#x3D; UnityObjectToClipPos(o.vertex)\n                return v;\n            &#125;\n            \n            fixed4 frag(v2f i):SV_TARGET&#123;\n                return _BaseColor;\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>是的，这就是我们曾经使用过的，最最基础的Shader。从大体上看，我们定义了：</p>\n<ul>\n<li>外部汇入Shader的属性</li>\n<li>CG代码块<ul>\n<li>自定义vertex和fragment Shader名称</li>\n<li>构造输入输出数据结构体</li>\n<li>使用CG语义编写具体的vertex和fragment Shader内容</li>\n</ul>\n</li>\n</ul>\n<p>通过实现以上的内容，我们完成了built-in管线下的，Shader的编写。</p>\n<p>那么，相对的，我们在URP管线中则应该构造这样子的shader来实现对应功能：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;URPTutorialShaderBasic&quot; &#123;\n    Properties &#123;\n        _Color(&quot;Color Tint&quot;, Color) &#x3D; (1, 1, 1, 1)\n    &#125;\n    SubShader &#123;\n        &#x2F;&#x2F; Place.01\n        Tags &#123;\n            &quot;RenderPipline&quot;&#x3D;&quot;UniversalPipline&quot;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n\n        Pass &#123;\n        \t&#x2F;&#x2F; Place.02\n            HLSLPROGRAM\n\n            #pragma vertex vert\n            #pragma fragment frag\n        \n        \t&#x2F;&#x2F; Place.03\n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;\n\n            struct appdata &#123;\n                float4 vertex : POSITION;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n            &#125;;\n\n            sampler2D _MainTex;\n            float4 _MainTex_ST;\n            half4 _Color;\n\n            v2f vert(appdata v) &#123;\n                v2f o;\n                        \n        \t\t&#x2F;&#x2F; Place.04\n        \t\to.pos &#x3D; TransformObjectToHClip(v.vertex.xyz);\n                &#x2F;&#x2F; or: o.pos &#x3D; mul(UNITY_MATRIX_MVP, v.vertex);\n                \n                return o;\n            &#125;\n\n            half4 frag(v2f i) : SV_Target &#123;\n                return _Color;\n            &#125;\n            ENDHLSL\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>可以看到，换用URP管线后，有这些变化：</p>\n<ul>\n<li>Place.01：我们得明确地声明该Shader需要使用 <code>UniversalPipline</code> 了</li>\n<li>原来书写的 <code>CG</code> 代码块变成了 <code>HLSL</code> 代码块</li>\n<li>原来引入的 <code>CG</code> 头文件也变成了对应的 <code>HLSL</code> 文件</li>\n<li>基于我们的头文件的更替，我们换用了一套和CG几乎完全不同的 <code>API</code>。</li>\n</ul>\n<p>是的，原先在入门精要里用了一整本书的那些CG函数，现在我们都不能用了——我们得重新熟悉这些“换了个马甲”的HLSL函数。</p>\n<h2 id=\"为什么是HLSL\"><a href=\"#为什么是HLSL\" class=\"headerlink\" title=\"为什么是HLSL\"></a>为什么是HLSL</h2><p>CG已经是一个停止更新很久(2012年Nvidia就已经停止了维护)的语言了，而HLSL则一直更新到了现在(截至3&#x2F;25&#x2F;2023)，虽然HLSL本身并非一门跨平台的语言(DirextX专用语言)，但是请注意，我们事实上书写的是Shaderlab语言——只是采用了HLSL语法(标准)</p>\n<h2 id=\"绘制纹理\"><a href=\"#绘制纹理\" class=\"headerlink\" title=\"绘制纹理\"></a>绘制纹理</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>请注意打上 <code>// Place.0x</code> 的全部内容</p></blockquote>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;URPTutorialTextureShader&quot; &#123;\n \t&#x2F;&#x2F; Place.01\n    Properties &#123;\n        [MainTexture] _MainTex (&quot;Basic Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n    &#125;\n    SubShader &#123;\n        Tags &#123;\n \t\t\t&#x2F;&#x2F; Place.02\n            &quot;RenderPipline&quot;&#x3D;&quot;UniversalRenderPipeline&quot;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n\n        Pass &#123;\n            HLSLPROGRAM\n\n            #pragma vertex vert\n            #pragma fragment frag\n        \n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;\n            \n            struct appdata &#123;\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n                float2 uv : TEXCOORD0;\n            &#125;;\n\n \t\t\t&#x2F;&#x2F; Place.03\n            TEXTURE2D(_MainTex);\n            SAMPLER(sampler_MainTex);\n\n            CBUFFER_START(UnityPerMaterial)\n                float4 _MainTex_ST;\n            CBUFFER_END\n            \n            v2f vert(appdata v) &#123;\n                v2f o;\n                        \n        \t\to.pos &#x3D; TransformObjectToHClip(v.vertex.xyz);\n                o.uv &#x3D; TRANSFORM_TEX(v.uv, _MainTex);\n                \n                return o;\n            &#125;\n\n            half4 frag(v2f i) : SV_Target &#123;\n \t\t\t\t&#x2F;&#x2F; Place.04\n                float4 color &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);\n                return color;\n            &#125;\n            ENDHLSL\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>回想我们读取在 <code>CGPROGRAM</code> 中读取 <code>Texture</code> 的主要步骤：</p>\n<ul>\n<li>建立采样器 <code>sampler2D</code></li>\n<li>获取材质面板上的 <code>Tiling</code> 与 <code>Offset</code></li>\n<li>利用 <code>tex2D</code> 来进行最终的取样过程</li>\n</ul>\n<p>而我们现在在URP管线的 <code>HLSLPROGRAM</code> 中改写的这些内容，就主要集中在以上代码部分中的各个 <code>Place</code> 部分：</p>\n<ol>\n<li>设置 <code>[MainTexture]</code>，这会方便我们在脚本中调用：</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>Material.mainTexture</strong></p>\n<p>By default, Unity considers a texture with the property name <code>&quot;_MainTex&quot;</code> to be the main texture. Use the <code>[MainTexture]</code> <a href=\"https://docs.unity3d.com/Manual/SL-Properties.html\">ShaderLab Properties attribute</a> to make Unity consider a texture with a different property name to be the main texture. When the main texture is set using the <code>[MainTexture]</code> attribute, it is not visible in the Game view when you use the texture streaming <a href=\"https://docs.unity3d.com/Manual/TextureStreaming-API#DebuggingAPI.html\">debugging view mode</a> or a custom debug tool.</p></blockquote>\n<p><a href=\"https://docs.unity3d.com/ScriptReference/Material-mainTexture.html\">Unity - Scripting API: Material.mainTexture (unity3d.com)</a></p></blockquote>\n<ol start=\"2\">\n<li><p>改写 <code>UniversalPipeline</code> 为 <code>UniversalRenderPipeline</code>：事实上这两种写法好像都有效，Unity 2021.3版本的文档也在左右互博：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li><p>在中文URP 12.1.1文档中的 <code>编写自定义着色器</code> 一章中，所有对应内容皆为 <code>UniversalPipeline</code><br><a href=\"https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/writing-custom-shaders-urp.html\">编写自定义着色器 | Universal RP | 12.1.1 (unity3d.com)</a></p>\n</li>\n<li><p>在英文URP 12.1.10文档中的 <code>Writing custom shaders</code> 一章中同样如此<br><a href=\"https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/writing-custom-shaders-urp.html\">Writing custom shaders | Universal RP | 12.1.10 (unity3d.com)</a></p>\n</li>\n<li><p>但是在 <code>Unity Manual</code> 中则是这样的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>RenderPipeline tag</strong></p>\n<p>The <code>RenderPipeline</code> tag tells Unity whether a SubShader is compatible with the Universal Render Pipeline (URP) or the High Definition Render Pipeline (HDRP).</p>\n<p><strong>Syntax and valid values</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>Signature</strong></th>\n<th align=\"left\"><strong>Function</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">“RenderPipeline” &#x3D; “[name]”</td>\n<td align=\"left\">Tells Unity whether this SubShader is compatible with URP or HDRP.</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>Parameter</strong></th>\n<th align=\"left\"><strong>Value</strong></th>\n<th align=\"left\"><strong>Function</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">[name]</td>\n<td align=\"left\">UniversalRenderPipeline</td>\n<td align=\"left\">This SubShader is compatible with URP only.</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">HighDefinitionRenderPipeline</td>\n<td align=\"left\">This SubShader is compatible with HDRP only.</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">(any other value, or not declared)</td>\n<td align=\"left\">This SubShader is not compatible with URP or HDRP.</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://docs.unity3d.com/2021.3/Documentation/Manual/SL-SubShaderTags.html\">Unity - Manual: ShaderLab: assigning tags to a SubShader (unity3d.com)</a></p></blockquote>\n</li>\n</ul>\n<p>这样明显的左右互搏…所以应该是可以通用的</p></blockquote>\n</li>\n<li><p>相较于CG中直接声明sample2D，HLSL中将 <code>Sampler</code> 与 <code>Texture</code> 区分开来——我们得先声明一个纹理，然后才能为其指定采样器。而之后的，我们在CBUFFER代码块中像 <code>CGPROGRAM</code> 中一样，使用 <code>_ST</code> 后缀来声明纹理属性</p>\n</li>\n<li><p>API改变——原来的 <code>tex2D</code> 变为 <code>SAMPLE_TEXTURE2D</code></p>\n</li>\n</ol>\n<h3 id=\"关于-HLSLPROGRAM-中的-CBuffer-语句块与采样器\"><a href=\"#关于-HLSLPROGRAM-中的-CBuffer-语句块与采样器\" class=\"headerlink\" title=\"关于 HLSLPROGRAM 中的 CBuffer 语句块与采样器\"></a>关于 <code>HLSLPROGRAM</code> 中的 <code>CBuffer</code> 语句块与采样器</h3><h2 id=\"获取深度缓冲及重建其世界坐标\"><a href=\"#获取深度缓冲及重建其世界坐标\" class=\"headerlink\" title=\"获取深度缓冲及重建其世界坐标\"></a>获取深度缓冲及重建其世界坐标</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>此示例中的 Unity 着色器使用深度纹理和屏幕空间 UV 坐标来重建像素的世界空间位置。该着色器在网格上绘制棋盘图案，使位置可视化。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本节中的代码较官方示例中的代码有所不同：我们额外设置了渲染队列，修改了RenderType</p></blockquote>\n<p>在URP中，我们可以直接在Shader中拿到 <code>Depth Texture</code>：通过在 URP 资源的 General 部分中，启用 <code>Depth Texture</code>，我们可以直接在ShaderLab中拿到当前的深度缓冲，并利用它来重建世界坐标：</p>\n<p><img src=\"/......%5Cimages%5CDev%5CUnity%5CUpdateToURPPipeline%5CChapter1_BasicUnlitShader%5C001.png\" alt=\"在 URP 资源中，启用 Depth Texture\"><br><em>启用深度缓冲</em></p>\n<p>具体步骤可以参考以下代码，需要说明的内容已经在注释中注明</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;URPTutorialReconstructWorldPos&quot; &#123;\n    Properties &#123;&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderPipeline&quot;&#x3D;&quot;UniversalRenderPipeline&quot;\n            &quot;Queue&quot;&#x3D;&quot;Transparent&quot;\n            &quot;RenderType&quot;&#x3D;&quot;Transparent&quot;\n        &#125;\n\n        Pass &#123;\n            HLSLPROGRAM\n            \n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;\n            \n            &#x2F;&#x2F; 我们在这里引入了重要的着色器头文件，DeclareDepthTexture.hlsl，它包含了用于对摄像机深度纹理进行采样的函数 SampleSceneDepth\n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;DeclareDepthTexture.hlsl&quot;\n            \n            struct appdata &#123;\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n            &#125;;\n\n            &#x2F;&#x2F; 可以发现，我们并没有像入门精要那样显式地去声明我们需要使用的深度纹理，因为我们这里并不是后处理步骤\n            v2f vert(appdata v) &#123;\n                v2f o;\n                o.pos &#x3D; TransformObjectToHClip(v.vertex.xyz);\n                \n                return o;\n            &#125;\n\n            &#x2F;&#x2F; 我们所需要实现的功能集中在Fragment Shader中\n            half4 frag(v2f i) : SV_Target &#123;\n                &#x2F;&#x2F; 由于深度纹理对应的应是屏幕空间，而 i.pos 则对应裁剪空间，那么我们就可以通过继续对 i.pos 进行后续变换来方便我们采样\n                &#x2F;&#x2F; 首先，采样深度缓冲区的 UV 坐标，由像素位置除以渲染目标分辨率 _ScaledScreenParams 得到(透视除法)\n                float2 uv &#x3D; i.pos.xy &#x2F; _ScaledScreenParams.xy;\n                \n                &#x2F;&#x2F; 开始采样，并根据不同的情况调整z值\n                #if UNITY_REVERSED_Z\n                    real depth &#x3D; SampleSceneDepth(uv);\n                \t&#x2F;&#x2F; 这里我们使用了real类型，这是unity所定义的类型，可参看：https:&#x2F;&#x2F;forum.unity.com&#x2F;threads&#x2F;what-does-real-in-shaders-of-lightweight-pipeline-means-it-seems-some-sort-of-number.547402&#x2F;\n                #else\n                \t&#x2F;&#x2F; 匹配 opengl 的 NDC\n                    real depth &#x3D; lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(uv));\n                #endif\n                &#x2F;&#x2F;要使重建函数正常工作，深度值必须位于归一化设备坐标 (NDC) 空间中。在 D3D 中，Z 处于 [0,1] 范围内，而在 OpenGL 中，Z 处于 [-1, 1] 范围内\n\n                &#x2F;&#x2F; 使用 ComputeWorldSpacePosition 函数开始重建，我们呢现在已经具有：NDC 下 xy，NDC 下 z\n                float3 worldPos &#x3D; ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);\n\n                &#x2F;&#x2F; 可视化世界空间\n                uint scale &#x3D; 10;\n                uint3 worldIntPos &#x3D; uint3(abs(worldPos.xyz * scale));\n\n                bool white &#x3D; (worldIntPos.x &amp; 1) ^ (worldIntPos.y &amp; 1) ^ (worldIntPos.z &amp; 1);\n                &#x2F;&#x2F; ^ 异或\n\n                half4 color &#x3D; white ? half4(1, 1, 1, 1) : half4(0, 0, 0, 1);\n                \n                #if UNITY_REVERSED_Z\n                    &#x2F;&#x2F; 具有 REVERSED_Z 的平台（如 D3D）的情况。\n                    if(depth &lt; 0.0001)\n                        return half4(0,0,0,1);\n                #else\n                    &#x2F;&#x2F; 没有 REVERSED_Z 的平台（如 OpenGL）的情况。\n                    if(depth &gt; 0.9999)\n                        return half4(0,0,0,1);\n                #endif\n                \n                return color;\n            &#125;\n            ENDHLSL\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>In this chapter, we have finished the short official tutorial of Unity,</p>\n<p>Thank God, there are not so many challenges and changes. You can see the example below, you can find out that it’s almost as same as <code>CGPROGRAM</code> we wrote before.</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Shader &quot;Example&#x2F;URPTutorialVisualizingNormalShader&quot; &#123;\n    Properties &#123;&#125;\n    SubShader &#123;\n        Tags &#123;\n            &quot;RenderPipeline&quot;&#x3D;&quot;UniversalPipeline&quot;\n            &quot;RenderType&quot;&#x3D;&quot;Opaque&quot;\n        &#125;\n\n        Pass &#123;\n            HLSLPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;\n\n            struct appdata &#123;\n                float4 vertex : POSITION;\n                float3 normal : NORMAL;\n            &#125;;\n\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n                float3 worldNormal : TEXCOORD0;\n            &#125;;\n\n            v2f vert(appdata v) &#123;\n                v2f o;\n                o.pos &#x3D; TransformObjectToHClip(v.vertex);\n                o.worldNormal &#x3D; TransformObjectToWorldNormal(v.normal);\n                return o;\n            &#125;\n\n            half4 frag(v2f i) : SV_Target &#123;\n                return half4(i.worldNormal * 0.5 + 0.5, 1.0);\n            &#125;\n            ENDHLSL\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n","text":"Chapter1 - 从官方示例开始 本章涵盖内容： 官方 URP Pipeline Custom Shader 部分的教程与示例 曾今的第一个Shader程序回想一下，我们在入门精要中的第一个unlit shader是什么？ 是不是像下面这样的直接输出颜色的shader？ Sh...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"URP Pipeline","slug":"URP-Pipeline","count":1,"path":"api/tags/URP-Pipeline.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chapter1-%E4%BB%8E%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E5%BC%80%E5%A7%8B\"><span class=\"toc-text\">Chapter1 - 从官方示例开始</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%BE%E4%BB%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAShader%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">曾今的第一个Shader程序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFHLSL\"><span class=\"toc-text\">为什么是HLSL</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%98%E5%88%B6%E7%BA%B9%E7%90%86\"><span class=\"toc-text\">绘制纹理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E-HLSLPROGRAM-%E4%B8%AD%E7%9A%84-CBuffer-%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%8E%E9%87%87%E6%A0%B7%E5%99%A8\"><span class=\"toc-text\">关于 HLSLPROGRAM 中的 CBuffer 语句块与采样器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%8F%8A%E9%87%8D%E5%BB%BA%E5%85%B6%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87\"><span class=\"toc-text\">获取深度缓冲及重建其世界坐标</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"URP Chapter 3 - Lit","uid":"82ff1fb81877d21689ef75c8cb4f38fd","slug":"Rendering/UpdateToURPPipeline/Chapter3_Lit","date":"2023-04-05T13:32:05.000Z","updated":"2023-10-27T20:18:48.000Z","comments":true,"path":"api/articles/Rendering/UpdateToURPPipeline/Chapter3_Lit.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Chapter 3 - Lit在 URP 管线下，所有我们新创建的材质会默认使用 Universal Render Pipeline/Lit 作为当前材质的 Shader，这个 Shader 是 unity 对 PBR 的基本实现，而本章将对该 Shader 作深入分析，本章所用...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Chapter0 - URP 管线分析系列概览","uid":"edde6f65aa71985a04dfce2cbb091e0c","slug":"Rendering/UpdateToURPPipeline/Chapter0","date":"2023-04-03T13:32:05.000Z","updated":"2023-10-27T20:16:07.000Z","comments":true,"path":"api/articles/Rendering/UpdateToURPPipeline/Chapter0.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Chapter0 - URP 管线分析系列概览章节安排 Chapter 1：Unity URP 管线 自定义Shader 小节全内容 Chapter 2：了解 URP 管线下的光与影 Chapter 3：URP 管线默认 Shader：Lit.shader 分析 Chapter ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}