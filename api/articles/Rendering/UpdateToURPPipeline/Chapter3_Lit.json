{"title":"URP Chapter 3 - Lit","uid":"82ff1fb81877d21689ef75c8cb4f38fd","slug":"Rendering/UpdateToURPPipeline/Chapter3_Lit","date":"2023-04-05T13:32:05.000Z","updated":"2023-10-27T20:18:48.000Z","comments":true,"path":"api/articles/Rendering/UpdateToURPPipeline/Chapter3_Lit.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"chapter-3---lit\">Chapter 3 - Lit</h1>\r\n<p>在 URP 管线下，所有我们新创建的材质会默认使用\r\n<code>Universal Render Pipeline/Lit</code> 作为当前材质的 Shader，这个\r\nShader 是 unity 对 PBR 的基本实现，而本章将对该 Shader\r\n作深入分析，本章所用的 Lit.shader 可以在其 Github 页面找到</p>\r\n<h2 id=\"从-lit.shader-的-properties-开始\">从 Lit.shader 的 Properties\r\n开始</h2>\r\n<h3 id=\"范围\">范围</h3>\r\n<p><code>Properties</code> 代码块位于 <code>Lit.shader</code> 文件中的\r\n<code>3~70</code> 行，具体代码如下：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Properties\n&#123;\n    &#x2F;&#x2F; Specular vs Metallic workflow\n    _WorkflowMode(&quot;WorkflowMode&quot;, Float) &#x3D; 1.0\n\n    [MainTexture] _BaseMap(&quot;Albedo&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n    [MainColor] _BaseColor(&quot;Color&quot;, Color) &#x3D; (1,1,1,1)\n\n    _Cutoff(&quot;Alpha Cutoff&quot;, Range(0.0, 1.0)) &#x3D; 0.5\n\n    _Smoothness(&quot;Smoothness&quot;, Range(0.0, 1.0)) &#x3D; 0.5\n    _SmoothnessTextureChannel(&quot;Smoothness texture channel&quot;, Float) &#x3D; 0\n\n    _Metallic(&quot;Metallic&quot;, Range(0.0, 1.0)) &#x3D; 0.0\n    _MetallicGlossMap(&quot;Metallic&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n\n    _SpecColor(&quot;Specular&quot;, Color) &#x3D; (0.2, 0.2, 0.2)\n    _SpecGlossMap(&quot;Specular&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n\n    [ToggleOff] _SpecularHighlights(&quot;Specular Highlights&quot;, Float) &#x3D; 1.0\n    [ToggleOff] _EnvironmentReflections(&quot;Environment Reflections&quot;, Float) &#x3D; 1.0\n\n    _BumpScale(&quot;Scale&quot;, Float) &#x3D; 1.0\n    _BumpMap(&quot;Normal Map&quot;, 2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\n    _Parallax(&quot;Scale&quot;, Range(0.005, 0.08)) &#x3D; 0.005\n    _ParallaxMap(&quot;Height Map&quot;, 2D) &#x3D; &quot;black&quot; &#123;&#125;\n\n    _OcclusionStrength(&quot;Strength&quot;, Range(0.0, 1.0)) &#x3D; 1.0\n    _OcclusionMap(&quot;Occlusion&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n\n    [HDR] _EmissionColor(&quot;Color&quot;, Color) &#x3D; (0,0,0)\n    _EmissionMap(&quot;Emission&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n\n    _DetailMask(&quot;Detail Mask&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n    _DetailAlbedoMapScale(&quot;Scale&quot;, Range(0.0, 2.0)) &#x3D; 1.0\n    _DetailAlbedoMap(&quot;Detail Albedo x2&quot;, 2D) &#x3D; &quot;linearGrey&quot; &#123;&#125;\n    _DetailNormalMapScale(&quot;Scale&quot;, Range(0.0, 2.0)) &#x3D; 1.0\n    [Normal] _DetailNormalMap(&quot;Normal Map&quot;, 2D) &#x3D; &quot;bump&quot; &#123;&#125;\n\n    &#x2F;&#x2F; SRP batching compatibility for Clear Coat (Not used in Lit)\n    [HideInInspector] _ClearCoatMask(&quot;_ClearCoatMask&quot;, Float) &#x3D; 0.0\n    [HideInInspector] _ClearCoatSmoothness(&quot;_ClearCoatSmoothness&quot;, Float) &#x3D; 0.0\n\n    &#x2F;&#x2F; Blending state\n    _Surface(&quot;__surface&quot;, Float) &#x3D; 0.0\n    _Blend(&quot;__blend&quot;, Float) &#x3D; 0.0\n    _Cull(&quot;__cull&quot;, Float) &#x3D; 2.0\n    [ToggleUI] _AlphaClip(&quot;__clip&quot;, Float) &#x3D; 0.0\n    [HideInInspector] _SrcBlend(&quot;__src&quot;, Float) &#x3D; 1.0\n    [HideInInspector] _DstBlend(&quot;__dst&quot;, Float) &#x3D; 0.0\n    [HideInInspector] _ZWrite(&quot;__zw&quot;, Float) &#x3D; 1.0\n\n    [ToggleUI] _ReceiveShadows(&quot;Receive Shadows&quot;, Float) &#x3D; 1.0\n    &#x2F;&#x2F; Editmode props\n    _QueueOffset(&quot;Queue offset&quot;, Float) &#x3D; 0.0\n\n    &#x2F;&#x2F; ObsoleteProperties\n    [HideInInspector] _MainTex(&quot;BaseMap&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n    [HideInInspector] _Color(&quot;Base Color&quot;, Color) &#x3D; (1, 1, 1, 1)\n    [HideInInspector] _GlossMapScale(&quot;Smoothness&quot;, Float) &#x3D; 0.0\n    [HideInInspector] _Glossiness(&quot;Smoothness&quot;, Float) &#x3D; 0.0\n    [HideInInspector] _GlossyReflections(&quot;EnvironmentReflections&quot;, Float) &#x3D; 0.0\n\n    [HideInInspector][NoScaleOffset]unity_Lightmaps(&quot;unity_Lightmaps&quot;, 2DArray) &#x3D; &quot;&quot; &#123;&#125;\n    [HideInInspector][NoScaleOffset]unity_LightmapsInd(&quot;unity_LightmapsInd&quot;, 2DArray) &#x3D; &quot;&quot; &#123;&#125;\n    [HideInInspector][NoScaleOffset]unity_ShadowMasks(&quot;unity_ShadowMasks&quot;, 2DArray) &#x3D; &quot;&quot; &#123;&#125;\n&#125;</code></pre>\r\n<p>可以看到，<code>Lit.shader</code> 中同时定义了 Unity 所实现的、两种\r\nPBR 工作流中所需要的全部属性。</p>\r\n<p>接下来，我们将试对属性定义中代码的书写逻辑，及同下方的部分逻辑一起，作大致说明：</p>\r\n<h3 id=\"定义工作流\">定义工作流</h3>\r\n<p>可以看到，Properties\r\n中开头第一段代码就是用于工作流类型定义的代码：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">_WorkflowMode(&quot;WorkflowMode&quot;, Float) &#x3D; 1.0</code></pre>\r\n<p>但是奇怪的是，我们的面板上所实在展示的并不是浮点数——是字符串：</p>\r\n<p><img\r\nsrc=\"......\\images\\Dev\\Unity\\UpdateToURPPipeline\\Chapter3_Lit\\001.png\"\r\nalt=\"image-20230328205013593\" /> <em>面板上的 <code>WorkflowMode</code>\r\n属性对应的并不是浮点是而是字符文字</em></p>\r\n<p>这些我们</p>\r\n<p>定义工作流后，我们的 Inspector\r\n面板会发生变化，两种工作流对应的面板如下：</p>\r\n<p><img\r\nsrc=\"......\\images\\Dev\\Unity\\UpdateToURPPipeline\\Chapter3_Lit\\002.png\"\r\nalt=\"image-20230328205839615\" /> <em>Specular 工作流下的 Inspector\r\n面板</em></p>\r\n<p><img\r\nsrc=\"......\\images\\Dev\\Unity\\UpdateToURPPipeline\\Chapter3_Lit\\003.png\"\r\nalt=\"image-20230328205732177\" /> <em>Metallic 工作流下的 Inspector\r\n面板</em></p>\r\n<p>可以看到当对应的工作流不同时，我们的 <code>Surface Input</code>\r\n下的数据会发生变化。关于 <code>Surface Input</code>\r\n，我们后面还会再次看到。</p>\r\n<h3 id=\"其他-suface-options-内容与-advanced-options-内容\">其他 Suface\r\nOptions 内容与 Advanced Options 内容</h3>\r\n<h2 id=\"第一个-passforwardlit\">第一个 Pass：ForwardLit</h2>\r\n<p>80~150</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; ------------------------------------------------------------------\n      &#x2F;&#x2F;  Forward pass. Shades all light in a single pass. GI + emission + Fog\n      Pass\n      &#123;\n          &#x2F;&#x2F; Lightmode matches the ShaderPassName set in UniversalRenderPipeline.cs. SRPDefaultUnlit and passes with\n          &#x2F;&#x2F; no LightMode tag are also rendered by Universal Render Pipeline\n          Name &quot;ForwardLit&quot;\n          Tags&#123;&quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot;&#125;\n\n          Blend[_SrcBlend][_DstBlend]\n          ZWrite[_ZWrite]\n          Cull[_Cull]\n\n          HLSLPROGRAM\n          #pragma exclude_renderers gles gles3 glcore\n          #pragma target 4.5\n\n          &#x2F;&#x2F; -------------------------------------\n          &#x2F;&#x2F; Material Keywords\n          #pragma shader_feature_local _NORMALMAP\n          #pragma shader_feature_local _PARALLAXMAP\n          #pragma shader_feature_local _RECEIVE_SHADOWS_OFF\n          #pragma shader_feature_local _ _DETAIL_MULX2 _DETAIL_SCALED\n          #pragma shader_feature_local_fragment _SURFACE_TYPE_TRANSPARENT\n          #pragma shader_feature_local_fragment _ALPHATEST_ON\n          #pragma shader_feature_local_fragment _ALPHAPREMULTIPLY_ON\n          #pragma shader_feature_local_fragment _EMISSION\n          #pragma shader_feature_local_fragment _METALLICSPECGLOSSMAP\n          #pragma shader_feature_local_fragment _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A\n          #pragma shader_feature_local_fragment _OCCLUSIONMAP\n          #pragma shader_feature_local_fragment _SPECULARHIGHLIGHTS_OFF\n          #pragma shader_feature_local_fragment _ENVIRONMENTREFLECTIONS_OFF\n          #pragma shader_feature_local_fragment _SPECULAR_SETUP\n\n          &#x2F;&#x2F; -------------------------------------\n          &#x2F;&#x2F; Universal Pipeline keywords\n          #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN\n          #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS\n          #pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS\n          #pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING\n          #pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION\n          #pragma multi_compile_fragment _ _SHADOWS_SOFT\n          #pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION\n          #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3\n          #pragma multi_compile_fragment _ _LIGHT_LAYERS\n          #pragma multi_compile_fragment _ _LIGHT_COOKIES\n          #pragma multi_compile _ _CLUSTERED_RENDERING\n\n          &#x2F;&#x2F; -------------------------------------\n          &#x2F;&#x2F; Unity defined keywords\n          #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING\n          #pragma multi_compile _ SHADOWS_SHADOWMASK\n          #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n          #pragma multi_compile _ LIGHTMAP_ON\n          #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n          #pragma multi_compile_fog\n          #pragma multi_compile_fragment _ DEBUG_DISPLAY\n\n          &#x2F;&#x2F;--------------------------------------\n          &#x2F;&#x2F; GPU Instancing\n          #pragma multi_compile_instancing\n          #pragma instancing_options renderinglayer\n          #pragma multi_compile _ DOTS_INSTANCING_ON\n\n          #pragma vertex LitPassVertex\n          #pragma fragment LitPassFragment\n\n          #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;Shaders&#x2F;LitInput.hlsl&quot;\n          #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;Shaders&#x2F;LitForwardPass.hlsl&quot;\n          ENDHLSL\n      &#125;</code></pre>\r\n<h3 id=\"litforwardpass.hlsl\">LitForwardPass.hlsl</h3>\r\n<p>外部实现：为了更清晰的代码</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#ifndef UNIVERSAL_FORWARD_LIT_PASS_INCLUDED\n#define UNIVERSAL_FORWARD_LIT_PASS_INCLUDED\n\n#include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;\n\n&#x2F;&#x2F; GLES2 has limited amount of interpolators\n#if defined(_PARALLAXMAP) &amp;&amp; !defined(SHADER_API_GLES)\n#define REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR\n#endif\n\n#if (defined(_NORMALMAP) || (defined(_PARALLAXMAP) &amp;&amp; !defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR))) || defined(_DETAIL)\n#define REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR\n#endif\n\n&#x2F;&#x2F; keep this file in sync with LitGBufferPass.hlsl\n\nstruct Attributes\n&#123;\n    float4 positionOS   : POSITION;\n    float3 normalOS     : NORMAL;\n    float4 tangentOS    : TANGENT;\n    float2 texcoord     : TEXCOORD0;\n    float2 staticLightmapUV   : TEXCOORD1;\n    float2 dynamicLightmapUV  : TEXCOORD2;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n&#125;;\n\nstruct Varyings\n&#123;\n    float2 uv                       : TEXCOORD0;\n\n#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)\n    float3 positionWS               : TEXCOORD1;\n#endif\n\n    float3 normalWS                 : TEXCOORD2;\n#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR)\n    half4 tangentWS                : TEXCOORD3;    &#x2F;&#x2F; xyz: tangent, w: sign\n#endif\n    float3 viewDirWS                : TEXCOORD4;\n\n#ifdef _ADDITIONAL_LIGHTS_VERTEX\n    half4 fogFactorAndVertexLight   : TEXCOORD5; &#x2F;&#x2F; x: fogFactor, yzw: vertex light\n#else\n    half  fogFactor                 : TEXCOORD5;\n#endif\n\n#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n    float4 shadowCoord              : TEXCOORD6;\n#endif\n\n#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)\n    half3 viewDirTS                : TEXCOORD7;\n#endif\n\n    DECLARE_LIGHTMAP_OR_SH(staticLightmapUV, vertexSH, 8);\n#ifdef DYNAMICLIGHTMAP_ON\n    float2  dynamicLightmapUV : TEXCOORD9; &#x2F;&#x2F; Dynamic lightmap UVs\n#endif\n\n    float4 positionCS               : SV_POSITION;\n    UNITY_VERTEX_INPUT_INSTANCE_ID\n    UNITY_VERTEX_OUTPUT_STEREO\n&#125;;\n\nvoid InitializeInputData(Varyings input, half3 normalTS, out InputData inputData)\n&#123;\n    inputData &#x3D; (InputData)0;\n\n#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)\n    inputData.positionWS &#x3D; input.positionWS;\n#endif\n\n    half3 viewDirWS &#x3D; GetWorldSpaceNormalizeViewDir(input.positionWS);\n#if defined(_NORMALMAP) || defined(_DETAIL)\n    float sgn &#x3D; input.tangentWS.w;      &#x2F;&#x2F; should be either +1 or -1\n    float3 bitangent &#x3D; sgn * cross(input.normalWS.xyz, input.tangentWS.xyz);\n    half3x3 tangentToWorld &#x3D; half3x3(input.tangentWS.xyz, bitangent.xyz, input.normalWS.xyz);\n\n    #if defined(_NORMALMAP)\n    inputData.tangentToWorld &#x3D; tangentToWorld;\n    #endif\n    inputData.normalWS &#x3D; TransformTangentToWorld(normalTS, tangentToWorld);\n#else\n    inputData.normalWS &#x3D; input.normalWS;\n#endif\n\n    inputData.normalWS &#x3D; NormalizeNormalPerPixel(inputData.normalWS);\n    inputData.viewDirectionWS &#x3D; viewDirWS;\n\n#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n    inputData.shadowCoord &#x3D; input.shadowCoord;\n#elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n    inputData.shadowCoord &#x3D; TransformWorldToShadowCoord(inputData.positionWS);\n#else\n    inputData.shadowCoord &#x3D; float4(0, 0, 0, 0);\n#endif\n#ifdef _ADDITIONAL_LIGHTS_VERTEX\n    inputData.fogCoord &#x3D; InitializeInputDataFog(float4(input.positionWS, 1.0), input.fogFactorAndVertexLight.x);\n    inputData.vertexLighting &#x3D; input.fogFactorAndVertexLight.yzw;\n#else\n    inputData.fogCoord &#x3D; InitializeInputDataFog(float4(input.positionWS, 1.0), input.fogFactor);\n#endif\n\n#if defined(DYNAMICLIGHTMAP_ON)\n    inputData.bakedGI &#x3D; SAMPLE_GI(input.staticLightmapUV, input.dynamicLightmapUV, input.vertexSH, inputData.normalWS);\n#else\n    inputData.bakedGI &#x3D; SAMPLE_GI(input.staticLightmapUV, input.vertexSH, inputData.normalWS);\n#endif\n\n    inputData.normalizedScreenSpaceUV &#x3D; GetNormalizedScreenSpaceUV(input.positionCS);\n    inputData.shadowMask &#x3D; SAMPLE_SHADOWMASK(input.staticLightmapUV);\n\n    #if defined(DEBUG_DISPLAY)\n    #if defined(DYNAMICLIGHTMAP_ON)\n    inputData.dynamicLightmapUV &#x3D; input.dynamicLightmapUV;\n    #endif\n    #if defined(LIGHTMAP_ON)\n    inputData.staticLightmapUV &#x3D; input.staticLightmapUV;\n    #else\n    inputData.vertexSH &#x3D; input.vertexSH;\n    #endif\n    #endif\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;                  Vertex and Fragment functions                            &#x2F;&#x2F;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n&#x2F;&#x2F; Used in Standard (Physically Based) shader\nVaryings LitPassVertex(Attributes input)\n&#123;\n    Varyings output &#x3D; (Varyings)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n    VertexPositionInputs vertexInput &#x3D; GetVertexPositionInputs(input.positionOS.xyz);\n\n    &#x2F;&#x2F; normalWS and tangentWS already normalize.\n    &#x2F;&#x2F; this is required to avoid skewing the direction during interpolation\n    &#x2F;&#x2F; also required for per-vertex lighting and SH evaluation\n    VertexNormalInputs normalInput &#x3D; GetVertexNormalInputs(input.normalOS, input.tangentOS);\n\n    half3 vertexLight &#x3D; VertexLighting(vertexInput.positionWS, normalInput.normalWS);\n\n    half fogFactor &#x3D; 0;\n    #if !defined(_FOG_FRAGMENT)\n        fogFactor &#x3D; ComputeFogFactor(vertexInput.positionCS.z);\n    #endif\n\n    output.uv &#x3D; TRANSFORM_TEX(input.texcoord, _BaseMap);\n\n    &#x2F;&#x2F; already normalized from normal transform to WS.\n    output.normalWS &#x3D; normalInput.normalWS;\n#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR) || defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)\n    real sign &#x3D; input.tangentOS.w * GetOddNegativeScale();\n    half4 tangentWS &#x3D; half4(normalInput.tangentWS.xyz, sign);\n#endif\n#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR)\n    output.tangentWS &#x3D; tangentWS;\n#endif\n\n#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)\n    half3 viewDirWS &#x3D; GetWorldSpaceNormalizeViewDir(vertexInput.positionWS);\n    half3 viewDirTS &#x3D; GetViewDirectionTangentSpace(tangentWS, output.normalWS, viewDirWS);\n    output.viewDirTS &#x3D; viewDirTS;\n#endif\n\n    OUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV);\n#ifdef DYNAMICLIGHTMAP_ON\n    output.dynamicLightmapUV &#x3D; input.dynamicLightmapUV.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#endif\n    OUTPUT_SH(output.normalWS.xyz, output.vertexSH);\n#ifdef _ADDITIONAL_LIGHTS_VERTEX\n    output.fogFactorAndVertexLight &#x3D; half4(fogFactor, vertexLight);\n#else\n    output.fogFactor &#x3D; fogFactor;\n#endif\n\n#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)\n    output.positionWS &#x3D; vertexInput.positionWS;\n#endif\n\n#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n    output.shadowCoord &#x3D; GetShadowCoord(vertexInput);\n#endif\n\n    output.positionCS &#x3D; vertexInput.positionCS;\n\n    return output;\n&#125;\n\n&#x2F;&#x2F; Used in Standard (Physically Based) shader\nhalf4 LitPassFragment(Varyings input) : SV_Target\n&#123;\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);\n\n#if defined(_PARALLAXMAP)\n#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)\n    half3 viewDirTS &#x3D; input.viewDirTS;\n#else\n    half3 viewDirWS &#x3D; GetWorldSpaceNormalizeViewDir(input.positionWS);\n    half3 viewDirTS &#x3D; GetViewDirectionTangentSpace(input.tangentWS, input.normalWS, viewDirWS);\n#endif\n    ApplyPerPixelDisplacement(viewDirTS, input.uv);\n#endif\n\n    SurfaceData surfaceData;\n    InitializeStandardLitSurfaceData(input.uv, surfaceData);\n\n    InputData inputData;\n    InitializeInputData(input, surfaceData.normalTS, inputData);\n    SETUP_DEBUG_TEXTURE_DATA(inputData, input.uv, _BaseMap);\n\n#ifdef _DBUFFER\n    ApplyDecalToSurfaceData(input.positionCS, surfaceData, inputData);\n#endif\n\n    half4 color &#x3D; UniversalFragmentPBR(inputData, surfaceData);\n\n    color.rgb &#x3D; MixFog(color.rgb, inputData.fogCoord);\n    color.a &#x3D; OutputAlpha(color.a, _Surface);\n\n    return color;\n&#125;\n\n#endif\n</code></pre>\r\n<h2 id=\"统一的-input\">统一的 input：</h2>\r\n<h3 id=\"保证相同的-cbuffer\">保证相同的 CBUFFER</h3>\r\n<h2 id=\"reference\">Reference</h2>\r\n<ul>\r\n<li>Lit.shader 源代码：<a\r\nhref=\"https://github.com/Unity-Technologies/Graphics/blob/2021.3/HDRP/templates/add-hdrp-blank/Packages/com.unity.render-pipelines.universal/Shaders/Lit.shader\">Graphics/Lit.shader\r\nat 2021.3/HDRP/templates/add-hdrp-blank · Unity-Technologies/Graphics\r\n(github.com)</a></li>\r\n<li><a\r\nhref=\"https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/lit-shader.html\">Lit\r\nShader | Universal RP | 12.1.10 (unity3d.com)</a></li>\r\n</ul>\r\n","text":"Chapter 3 - Lit 在 URP 管线下，所有我们新创建的材质会默认使用 Universal Render Pipeline/Lit 作为当前材质的 Shader，这个 Shader 是 unity 对 PBR 的基本实现，而本章将对该 Shader 作深入分析，本章所...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#chapter-3---lit\"><span class=\"toc-text\">Chapter 3 - Lit</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E-lit.shader-%E7%9A%84-properties-%E5%BC%80%E5%A7%8B\"><span class=\"toc-text\">从 Lit.shader 的 Properties\r\n开始</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%9B%B4\"><span class=\"toc-text\">范围</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E6%B5%81\"><span class=\"toc-text\">定义工作流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96-suface-options-%E5%86%85%E5%AE%B9%E4%B8%8E-advanced-options-%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">其他 Suface\r\nOptions 内容与 Advanced Options 内容</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AA-passforwardlit\"><span class=\"toc-text\">第一个 Pass：ForwardLit</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#litforwardpass.hlsl\"><span class=\"toc-text\">LitForwardPass.hlsl</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%9F%E4%B8%80%E7%9A%84-input\"><span class=\"toc-text\">统一的 input：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%9D%E8%AF%81%E7%9B%B8%E5%90%8C%E7%9A%84-cbuffer\"><span class=\"toc-text\">保证相同的 CBUFFER</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"URP Chapter2 - 光与影","uid":"d9fb18f440aa390dd7a583e8d02caf3f","slug":"Rendering/UpdateToURPPipeline/Chapter2_ShadowAndLight","date":"2023-04-05T13:32:05.000Z","updated":"2023-10-27T20:18:26.000Z","comments":true,"path":"api/articles/Rendering/UpdateToURPPipeline/Chapter2_ShadowAndLight.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Chapter2 - 光与影 这一章节我们开始研究 URP 管线中的光照与阴影函数，让我们从光照开始 使用空项目 这一次我们不再使用 Unity 下的示例工程——让我们现从 Hub 重新创建一个 URP Core 的新项目，并以其为基础进行接下来的工作 image-2023032...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"URP Chapter1 - 从官方示例开始","uid":"db175e84108ce0ad0ee0d7331217eb60","slug":"Rendering/UpdateToURPPipeline/Chapter1_BasicUnlitShader","date":"2023-04-04T13:32:05.000Z","updated":"2023-10-27T20:17:56.000Z","comments":true,"path":"api/articles/Rendering/UpdateToURPPipeline/Chapter1_BasicUnlitShader.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Chapter1 - 从官方示例开始 本章涵盖内容： 官方 URP Pipeline Custom Shader 部分的教程与示例 曾今的第一个Shader程序 回想一下，我们在入门精要中的第一个unlit shader是什么？ 是不是像下面这样的直接输出颜色的shader？ S...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"},{"name":"URP Pipeline","slug":"URP-Pipeline","count":1,"path":"api/tags/URP-Pipeline.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}