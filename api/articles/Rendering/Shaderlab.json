{"title":"Shaderlab 总览及其基本执行逻辑","uid":"3efe5f95488e956915246e267ac83bb6","slug":"Rendering/Shaderlab","date":"2023-05-02T04:23:23.000Z","updated":"2023-10-27T20:14:20.000Z","comments":true,"path":"api/articles/Rendering/Shaderlab.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"Shaderlab-总览及其基本执行逻辑\"><a href=\"#Shaderlab-总览及其基本执行逻辑\" class=\"headerlink\" title=\"Shaderlab 总览及其基本执行逻辑\"></a>Shaderlab 总览及其基本执行逻辑</h1><h2 id=\"Shaderlab-结构总览\"><a href=\"#Shaderlab-结构总览\" class=\"headerlink\" title=\"Shaderlab 结构总览\"></a>Shaderlab 结构总览</h2><p>Shaderlab 是 Unity 所使用的，独立的着色器语言。这是一种跨平台的语言体系，大体包含四部分：</p>\n<ul>\n<li>ShaderLab Text</li>\n<li>ShaderLab Compiler</li>\n<li>ShaderLab Asset</li>\n<li>ShaderLab Runtime</li>\n</ul>\n<p>我们将一一解释：</p>\n<h2 id=\"Shaderlab-Text\"><a href=\"#Shaderlab-Text\" class=\"headerlink\" title=\"Shaderlab Text\"></a>Shaderlab Text</h2><p>ShaderLab Text 指的是在 <code>.shader</code> 文件中，由我们所定义的那些代码。它们需要使用或 <code>CG</code> 或 <code>HLSL</code> 等的语法规则来编写。官方文档可见：<a href=\"#ShaderlabManual\">Reference</a></p>\n<p>而 ShaderLab Text 的基本结构如下：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">Shader &quot;&lt;name&gt;&quot; &#123;\n    &lt;optional: Material properties&gt; # 暴露在外的材质属性\n    &lt;One or more SubShader definitions&gt; # Subshader块是必选的，这是Shader中的实在代码\n    &lt;optional: fallback&gt; # 回调Shader\n    &lt;optional: custom editor&gt; #指定该Shader需要采用的editor，比如Amplify Shader Editor等\n&#125;</code></pre>\n\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><p>我们利用 <code>Material properties</code> 可选项来可以定义在应用了当前 <code>Shader</code> 的 <code>Material</code> 上显示的数据，而中的格式如下：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">Properties &#123;\n    [optional: attribute] name(&quot;display text in Inspector&quot;, type name) &#x3D; default value\n    [optional: attribute] name(&quot;display text in Inspector&quot;, type name) &#x3D; default value\n    ......\n&#125;</code></pre>\n\n<p>在我们日常编写中，我们不太长见到 <code>attribute</code> 的使用，但事实上 <code>Properties</code> 中是存在很多类型的 <code>attribute</code> 的，注明这些 <code>attribute</code> 能让我们在脚本中实时控制 <code>Properties</code> 更加方便</p>\n<p>特别的，如果使用的是 SRP，想使用 <strong><code>SRP Batcher compatibility</code></strong> 特性，我们像下方这样必须把每个 Properties 里的变量放到在 HLSL 代码中的 <strong>CBUFFER</strong> 中：<br>特殊的，贴图和采样器本身不需要再 CBUFFER 中声明，但是其相关参数 <code>Texel_size</code> 及 <code>ST</code> 则需要</p>\n<pre class=\"line-numbers language-shaderlab\" data-language=\"shaderlab\"><code class=\"language-shaderlab\">Properties &#123;\n    _Color (&quot;Colot Tint&quot;, Color) &#x3D; (1, 1, 1, 1)\n    _MainTex (&quot;Main Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;\n    _Layers (&quot;Cloud Level&quot;, Range(8, 128)) &#x3D; 16\n    _SpeedX (&quot;Speed X&quot;, float) &#x3D; 0.05\n    _SpeedY (&quot;Speed Y&quot;, float) &#x3D; 0.05\n    _Alpha (&quot;Cloud Alpha Value&quot;, Range(0, 1)) &#x3D; 0.6\n    _HeightOffset (&quot;Height Offset&quot;, float) &#x3D; 5\n&#125;\n\nSubShader &#123;\n\t...\n    HLSLINCLUDE\n\n    TEXTURE2D(_MainTex);\n    SAMPLER(sampler_MainTex);\n\n    CBUFFER_START(UnityPerMaterial)\n        half4 _Color;\n        float4 _MainTex_ST;\n        float _Layers;\n        float _SpeedX;\n        float _SpeedY;\n        half _Alpha;\n        half _HeightOffset;\n        CBUFFER_END\n    ENDHLSL\n    ...\n&#125;</code></pre>\n\n<h3 id=\"SubShader\"><a href=\"#SubShader\" class=\"headerlink\" title=\"SubShader\"></a>SubShader</h3><p>SubShader 是主要逻辑的实现部分，它又可以再次细分：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">SubShader &#123;\n    &lt;optional: LOD&gt;\n    # Level Of Detial，这个值越小，意味着当前Shader的细节越少，也就是说这个Shader越容易被执行，不过当多个SubShader的LOD都比要求的LOD小时，会从上到下地(第一行代码到最后一行地)执行第一个符合条件的SubShader\n\n    &lt;optional: tags&gt;\n    # SubShader Tags，形式为键值对，Unity会根据它们决定何时、如何使用SubShader\n\n    &lt;optional: commands&gt;\n    # 诸如Blend、ZTest等命令\n\n    &lt;One or more Pass definitions&gt;\n&#125;</code></pre>\n\n<p>而最后的 Pass 则是我们实在代码中，具体渲染过程所在的部分了。对于 Pass 本身的结构，可以概括为：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">Pass &#123;\n    &lt;optional: name&gt;\n    # 给Pass设置一个名字，以后可以用这个名字在别的Shader中使用UsePass Command来调用这个名字的Pass\n\n    &lt;optional: tags&gt;\n    # 和SubShader中的tags大同小异，但工作方式并不一样，具体来看就是所管理的键值对并不相同。下方的commands也是如此，请注意，#pragma这样的语句，不是Command\n\n    &lt;optional: commands&gt;\n\n    &lt;optional: shader code&gt;\n    # 最终的Shader Code落脚的地方，包裹在HLSLPROGRAM之类的命令中\n&#125;</code></pre>\n\n<h2 id=\"ShaderLab-Compiler\"><a href=\"#ShaderLab-Compiler\" class=\"headerlink\" title=\"ShaderLab Compiler\"></a>ShaderLab Compiler</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>光有文本是不行的，就如同你写 C++，如果只是写了一堆 CPP 文件，依然是无法被计算机认可并执行的。中间需要有翻译的过程，就是 shader Compiler 的过程。</p></blockquote>\n<p>简单来说，Unity 会在后台提供的一种服务，用来帮助我们去把写好的 ShaderLab 语言翻译为目标机器能够认可并执行的语言</p>\n<p>这事实上包含两层：</p>\n<ul>\n<li>首先，对于我们的电脑本机来说：<code>HLSL</code> 及 <code>CG</code> 等代码是不能直接运行在 DirectX 设备上的，而 Unity 的编译器会把我们写好的这些代码编译成可执行的机器语言</li>\n<li>其次，我们所编写的 <code>HLSL</code> 等语言是不能直接运行在 <code>OpenGL</code>，<code>Vulkan</code> 等平台上的，我们得把代码转译为目标平台山的语言</li>\n</ul>\n<p>也就是说，ShaderLab Compiler 的实际行为是：把 ShaderLab Text 翻译成最终目标机器上能够认可和执行的语言，对应的编译代码，我们可以通过点击 Inspect 面板下的 <code>Compile and show code</code> 来查看</p>\n<p><a href=\"https://docs.unity.cn/2021.3/Documentation/Manual/shader-compilation.html\">Unity - Manual: Shader compilation</a></p>\n<h2 id=\"ShaderLab-Asset\"><a href=\"#ShaderLab-Asset\" class=\"headerlink\" title=\"ShaderLab Asset\"></a>ShaderLab Asset</h2><p>我们已经知道，ShaderLab 里面有很多东西都是不能直接使用的，需要进行翻译。而加工之后得到的东西就叫做 ShaderLab Asset。Asset 比较常见的地方有两个：</p>\n<p>一个就是由 Shader 打成的 AssetBundle。另一个是我们打出来的包里面的 level 或 sharedassets 包。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference:\"></a>Reference:</h2><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/400470713\">【Unity 笔记】ShaderLab 与其底层原理浅谈 - 知乎 (zhihu.com)</a></p>\n</li>\n<li><p><span id=\"ShaderlabManual\"><a href=\"https://docs.unity3d.com/2021.3/Documentation/Manual/SL-Reference.html\">Unity - Manual: ShaderLab (unity3d.com)</a></span></p>\n</li>\n</ul>\n","text":"Shaderlab 总览及其基本执行逻辑Shaderlab 结构总览Shaderlab 是 Unity 所使用的，独立的着色器语言。这是一种跨平台的语言体系，大体包含四部分： ShaderLab Text ShaderLab Compiler ShaderLab Asset Sh...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Shaderlab-%E6%80%BB%E8%A7%88%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">Shaderlab 总览及其基本执行逻辑</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Shaderlab-%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88\"><span class=\"toc-text\">Shaderlab 结构总览</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Shaderlab-Text\"><span class=\"toc-text\">Shaderlab Text</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Properties\"><span class=\"toc-text\">Properties</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SubShader\"><span class=\"toc-text\">SubShader</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ShaderLab-Compiler\"><span class=\"toc-text\">ShaderLab Compiler</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ShaderLab-Asset\"><span class=\"toc-text\">ShaderLab Asset</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reference\"><span class=\"toc-text\">Reference:</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"UnityURPToonLitShaderExample 源码分析","uid":"b0e884d72c7c6bc5c7d44e3b4aa33541","slug":"Rendering/SimpleToonShader","date":"2023-05-03T04:23:23.000Z","updated":"2023-10-27T20:13:22.000Z","comments":true,"path":"api/articles/Rendering/SimpleToonShader.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"最简的 Toon Shader 的源码分析 - UnityURPToonLitShaderExample What is included in this “simplified version” toon lit shader repository? This reposito...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"PBR","uid":"db4c4d4811d5722c3a2acb135b7ca20d","slug":"Rendering/PBR","date":"2023-05-01T04:23:23.000Z","updated":"2023-11-01T04:34:31.875Z","comments":true,"path":"api/articles/Rendering/PBR.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"PBR PBR，或者用更通俗一些的称呼是指基于物理的渲染(Physically Based Rendering)，它指的是一些在不同程度上都基于与现实世界的物理原理更相符的基本理论所构成的渲染技术的集合。 PBR 综述PBR 是基于物理的渲染，具体表现为使用一种更符合物理学规律的...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}