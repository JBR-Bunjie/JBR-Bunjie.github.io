{"title":"PBR","uid":"db4c4d4811d5722c3a2acb135b7ca20d","slug":"Rendering/PBR","date":"2023-05-01T04:23:23.000Z","updated":"2023-10-27T20:21:54.000Z","comments":true,"path":"api/articles/Rendering/PBR.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"pbr\">PBR</h1>\r\n<blockquote>\r\n<p>PBR，或者用更通俗一些的称呼是指基于物理的渲染(Physically Based\r\nRendering)，它指的是一些在不同程度上都基于与现实世界的物理原理更相符的基本理论所构成的渲染技术的集合。</p>\r\n</blockquote>\r\n<h2 id=\"pbr-综述\">PBR 综述</h2>\r\n<p><strong>PBR\r\n是基于物理的渲染，具体表现为使用一种更符合物理学规律的方式来模拟光线</strong>，这种渲染方式与我们原来的\r\nPhong 或者 Blinn-Phong\r\n光照算法相比总体上看起来要更真实一些。除了看起来更好些以外，由于它与物理性质非常接近，因此我们可以直接以物理参数为依据来编写表面材质，而不必依靠粗劣的修改与调整来让光照效果看上去正常。使用基于物理参数的方法来编写材质还有一个更大的好处，就是不论光照条件如何，这些材质看上去都会是正确的，而在非\r\nPBR 的渲染管线当中有些东西就不会那么真实了。</p>\r\n<p>关于 PBR，有些有趣的东西：<a\r\nhref=\"https://www.zhihu.com/question/425289490\">在 PBR 出现之前，3d\r\n界如何做”真实感“渲染的？ - 知乎 (zhihu.com)</a>，其中的这条<a\r\nhref=\"https://www.zhihu.com/question/425289490/answer/1522232868\">回答</a>比较有意思：</p>\r\n<p>一个误区是 PBR\r\n一定是真实感的渲染，这当然是不完全正确的：比如迪士尼的电影中大量使用\r\nPBR，但是这些动画电影很难说得上是什么“真实感渲染”的结果</p>\r\n<blockquote>\r\n<p>PBS 是为了对光和材质之间的行为进行更加真实的建模。</p>\r\n<p>...</p>\r\n<p>在把 PBS\r\n入当前的游戏项目之前我们需要权衡一下它的优缺点。<strong>需要再次提醒读者的是，PBS\r\n并不意味着游戏画面需要追求和照片一样真实的效果。</strong>事实上，很多游戏都不需要刻意去追求与照片一样的真实感，玩家眼中的真实感大多也并不是如此\r\nPBS 优点在于 我们只需要个万能的 shader\r\n就可以渲染相当一大部分类型的材质而不是使用传统的做法为每种材质写特定的\r\nshader。同时，<strong>PBS\r\n可以保证在各种光照条件下，材质都可以自然地和光源进行交互，而不需要我们反复地调整材质参数。</strong></p>\r\n<p>然而，在使用 PBS 时我们也需要考虑到它带来的代价。如上面提到的，PBS\r\n往往需要更复杂的光照配合，例如大量使用光照探针和反射探针等。而且 PBS\r\n需要开启 HDR 以及一些必不可少的屏幕特效，例如抗锯齿、Bloom\r\n和色调映射，如果这些屏幕特效对当前游戏来说需要消耗过多的性能，那么 PBS\r\n就不适合当前的游戏，我们应该使用传统的 shader 来渲染游戏。使用 PBS\r\n对美工人员来说同样是个挑战。美术资源的制作过程和使用传统的 shader\r\n有很大不同，普通的法\r\n线纹理＋高光反射纹理的组合不再适用，我们需要创建更细腻复杂的纹理集，包括金属值纹理、高光反射纹理、粗糙度纹理、遮挡纹理，有些还需要使用额外的细节纹理来给材质添加更多的细节表面。除了使用图片扫描的传统辅助方法外，这些纹理的制作通常还需要更专业的工具来绘制例如\r\nAllegorithmic Substance Painter Quixel Suite</p>\r\n<p>——Unity Shader 入门精要</p>\r\n</blockquote>\r\n<p>不过，即使是“基于物理的渲染”，其本质上仍然只是对基于物理原理的现实世界的一种近似(我们稍后就会法线，PBR\r\n流程中依然存在着很多妥协)，这也就是为什么它被称为<strong>基于</strong>物理的着色(Physically\r\nbased Shading) 而非物理着色(Physical Shading)的原因。</p>\r\n<p>判断一种光照模型是否是基于物理的，必须满足以下三个条件（不用担心，我们很快就会了解它们的）：</p>\r\n<ol type=\"1\">\r\n<li>基于微平面(Microfacet)的表面模型。</li>\r\n<li>能量守恒。</li>\r\n<li>应用基于物理的 BRDF。</li>\r\n</ol>\r\n<p>我们可以反过来说：PBR\r\n并不是某一种特指的算法，而是一类算法的统称。只要一种着色算法满足一定的物理规律（能量守恒等），我们就认为它属于\r\nPBR 算法，反之，则不属于 PBR 算法。</p>\r\n<h2 id=\"pbr-理论\">PBR 理论</h2>\r\n<h3 id=\"微平面理论\">微平面理论</h3>\r\n<p><strong>所有的 PBR\r\n技术都基于微平面理论。</strong>这项理论认为，达到微观尺度之后任何平面都可以用被称为微平面(Microfacets)的细小镜面来进行描绘。根据平面粗糙程度的不同，这些细小镜面的取向排列可以相当不一致：</p>\r\n<p><img\r\nsrc=\"http://static.zybuluo.com/candycat/zmrvmeo27ach7kjpxm1grnwb/rought_smooth.png\"\r\nalt=\"rought_smooth.png-64.6kB\" />\r\n左图：光滑表面的微平面的法线变化较小，反射光线的方向变化也更小\r\n右图：粗糙表面的微平面的法线变化较大，反射光线的方向变化也更大</p>\r\n<p>这些微小镜面这样无序取向排列的影响就是：一个平面越是粗糙，这个平面上的微平面的排列就越混乱，法线变化也就越频繁且混乱，这样一来，当我们特指镜面光/镜面反射时，入射光线更趋向于向完全不同的方向发散(Scatter)开来，进而产生出分布范围更广泛的镜面反射，其结果也就越”钝“；相对的，对于一个光滑的平面，光线大体上会更趋向于向同一个方向反射，造成更小更锐利的反射。</p>\r\n<p>在这样的微观尺度下，我们认为没有任何平面是完全光滑的。然而由于这些微平面已经微小到无法逐像素地继续对其进行区分，因此我们假设一个粗糙度(Roughness)参数，然后用统计学的方法来估计微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出众多微平面中，朝向方向沿着某个向量\r\n<span class=\"math inline\">\\(h\\)</span> 方向的比例。这个向量 <span\r\nclass=\"math inline\">\\(h\\)</span> 便是位于光线向量 <span\r\nclass=\"math inline\">\\(l\\)</span> 和视线向量 <span\r\nclass=\"math inline\">\\(v\\)</span> 之间的半程向量(Halfway Vector)。</p>\r\n<p>而微平面的朝向方向与半程向量的方向越是一致，镜面反射的效果就越是强烈越是锐利。通过使用一个介于\r\n0 到 1 之间的粗糙度参数，我们就能概略地估算微平面的取向情况了：</p>\r\n<figure>\r\n<img src=\"https://learnopengl-cn.github.io/img/07/01/ndf.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>我们可以看到，较高的粗糙度显示出来的镜面反射的轮廓要更大一些。与之相反，较小的粗糙度显示出的镜面反射轮廓则更小更锐利。</p>\r\n<h3 id=\"能量守恒\">能量守恒</h3>\r\n<p><strong>微平面近似法使用了这样一种形式的能量守恒(Energy\r\nConservation)：出射光线的能量永远不能超过入射光线的能量（发光面除外）</strong></p>\r\n<p>如上图我们可以看到，随着粗糙度的上升，镜面反射区域会增加，但是镜面反射的亮度却会下降。如果每个像素的镜面反射强度都一样（不管反射轮廓的大小），那么粗糙的平面就会放射出过多的能量，而这样就违背了能量守恒定律。这也就是为什么正如我们看到的一样，光滑平面的镜面反射更强烈而粗糙平面的反射更昏暗。</p>\r\n<p><strong>为了遵守能量守恒定律，我们需要对漫反射光和镜面反射光做出明确的区分。</strong></p>\r\n<p><em>当一束光线碰撞到一个表面的时候，它就会分离成一个折射部分和一个反射部分</em>：反射部分就是会直接反射开而不进入平面的那部分光线，也就是我们所说的镜面光照。而折射部分就是余下的会进入表面并被吸收的那部分光线，也就是我们所说的漫反射光照。</p>\r\n<p>这里还有一些细节需要处理，因为当光线接触到一个表面的时候折射光是不会立即就被吸收的。通过物理学我们可以得知，光线实际上可以被认为是一束没有耗尽就不停向前运动的能量，而光束是通过碰撞的方式来消耗能量。每一种材料都是由无数微小的粒子所组成，这些粒子都能如下图所示一样与光线发生碰撞。这些粒子在每次的碰撞中都可以吸收光线所携带的一部分或者是全部的能量而后转变成为热量。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/07/01/surface_reaction.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>一般来说，并非全部能量都会被吸收，而光线也会继续沿着（基本上）随机的方向发散，然后再和其他的粒子碰撞直至能量完全耗尽或者再次离开这个表面。而光线脱离物体表面后将会协同构成该表面的（漫反射）颜色。不过在基于物理的渲染之中我们进行了简化，假设对平面上的每一点所有的折射光都会被完全吸收而不会散开。而有一些被称为\r\n<code>次表面散射(Subsurface Scattering)</code>\r\n技术的着色器技术将这个问题考虑了进去，它们显著地提升了一些诸如皮肤，大理石或者蜡质这样材质的视觉效果，不过伴随而来的代价是性能的下降。</p>\r\n<p>对于金属(Metallic)表面，当讨论到反射与折射的时候还有一个细节需要注意。金属表面对光的反应与非金属（也被称为介电质(Dielectrics)）表面相比是不同的。它们遵从的反射与折射原理是相同的，但是<strong>所有的</strong>折射光都会被直接吸收而不会散开，只留下反射光或者说镜面反射光。亦即是说，金属表面只会显示镜面反射颜色，而不会显示出漫反射颜色。由于金属与电介质之间存在这样明显的区别，因此它们两者在\r\nPBR\r\n渲染管线中被区别处理，而我们将在文章的后面进一步详细探讨这个问题。</p>\r\n<p>反射光与折射光之间的这个区别使我们得到了另一条关于能量守恒的经验结论：反射光与折射光它们二者之间是<strong>互斥</strong>的关系。无论何种光线，其被材质表面所反射的能量将无法再被材质吸收。因此，诸如折射光这样的余下的进入表面之中的能量正好就是我们计算完反射之后余下的能量。</p>\r\n<p>我们按照能量守恒的关系，首先计算镜面反射部分，它的值等于入射光线被反射的能量所占的百分比。然后折射光部分就可以直接由镜面反射部分计算得出：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> kS = <span class=\"built_in\">calculateSpecularComponent</span>(...); <span class=\"comment\">// 反射/镜面 部分</span></span><br><span class=\"line\"><span class=\"type\">float</span> kD = <span class=\"number\">1.0</span> - ks;                        <span class=\"comment\">// 折射/漫反射 部分</span></span><br></pre></td></tr></table></figure>\r\n<p>这样我们就能在遵守能量守恒定律的前提下知道入射光线的反射部分与折射部分所占的总量了。按照这种方法折射/漫反射与反射/镜面反射所占的份额都不会超过\r\n1.0，如此就能保证它们的能量总和永远不会超过入射光线的能量。而这些都是我们在前面的光照教程中没有考虑的问题。</p>\r\n<h2 id=\"反射率方程\">反射率方程</h2>\r\n<p>在这里我们引入了一种被称为<a\r\nhref=\"https://learnopengl.com/wiki-rendereuqation\">渲染方程</a>(Render\r\nEquation)的东西。它是某些聪明绝顶的人所构想出来的一个精妙的方程式，是如今我们所拥有的用来模拟光的视觉效果最好的模型。基于物理的渲染所坚定遵循的是一种被称为反射率方程(The\r\nReflectance Equation)的渲染方程的特化版本。要正确地理解\r\nPBR，很重要的一点就是要首先透彻地理解反射率方程</p>\r\n<p>反射率方程简写：</p>\r\n<p><span class=\"math display\">\\[\r\nL_0(p,w_0)=\\int_Ωf_r(p,w_i,w_0)Li(p,w_i)n \\cdot w_idw_i\r\n\\]</span></p>\r\n<p>如果补全绝大多数内容的话，我们能得到一个较为完整的式子：</p>\r\n<p><span class=\"math display\">\\[\r\nL_0(p,w_0)=\\int_Ω(k_d*\\frac{c}{\\pi}+k_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i\r\n\\cdot n)}*Li(p,w_i)*n \\cdot w_i*dw_i\r\n\\]</span></p>\r\n<p>其中的构建思路</p>\r\n<p><span class=\"math display\">\\[\r\n输出颜色=(漫反射比例\\frac{纹理颜色}{\\pi}+镜面反射比例*\\frac{镜面高光\\times几何遮蔽\\times菲涅尔效应}{4(viewDir\\cdot\r\nnormal)(lightDir\\cdot normal)光源颜色})(lightDir\\cdot normal)\r\n\\]</span></p>\r\n<p>我们可以逐步细分这个方程：</p>\r\n<h3 id=\"关于能量\">关于能量</h3>\r\n<h3 id=\"brdf\">BRDF</h3>\r\n<figure>\r\n<img\r\nsrc=\"https://github.com/QianMo/PBR-White-Paper/raw/master/content/part%201/media/8c60f94b8b6f430fc5dcb41068770454.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h4 id=\"cook-torrance-反射率方程\">Cook-Torrance 反射率方程</h4>\r\n<h5\r\nid=\"d法线分布函数normal-distribution-functionndf\">D：法线分布函数(Normal\r\nDistribution Function，NDF)</h5>\r\n<blockquote>\r\n<p>法线分布函数 <code>D</code>，从统计学上近似地表示了与某些（半程）向量\r\nh 取向一致的微平面的比率。举例来说，假设给定向量 h，如果我们的微平面中有\r\n35%与向量 h 取向一致，则法线分布函数或者说 NDF 将会返回\r\n0.35。目前有很多种 NDF\r\n都可以从统计学上来估算微平面的总体取向度，只要给定一些粗糙度的参数。我们马上将要用到的是\r\nTrowbridge-Reitz GGX</p>\r\n</blockquote>\r\n<p>若用 h 表示用来与平面上微平面做比较用的半程向量，a\r\n表示表面粗糙度，则可以有 NDF 方程如下：</p>\r\n<p><span class=\"math display\">\\[\r\nNDF_{GGXTR}(n, h, \\alpha) = \\frac{\\alpha^{2}}{\\pi((n\\cdot\r\nh)^{2}(\\alpha^{2}-1)+1)^2}\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://learnopengl-cn.github.io/img/07/01/ndf.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>当粗糙度很低（也就是说表面很光滑）的时候，与半程向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF\r\n最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与\r\nhℎ\r\n向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。</p>\r\n<p>实现：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> DistributionGGX(<span class=\"type\">vec3</span> N, <span class=\"type\">vec3</span> H, <span class=\"type\">float</span> roughness) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> a      = roughness * roughness; <span class=\"comment\">// 注意这里，a并非是纯粹的粗糙度</span></span><br><span class=\"line\">    <span class=\"type\">float</span> a2     = a * a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> NdotH  = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, H), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotH2 = NdotH*NdotH;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> num   = a2;</span><br><span class=\"line\">    <span class=\"type\">float</span> denom = (NdotH2 * (a2 - <span class=\"number\">1.0</span>) + <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    denom = PI * denom * denom;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num / denom; <span class=\"comment\">//molecular&amp;denominator</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>和理论相比，我们直接把粗糙度(roughness)作为参数传给了上述函数；通过这种方式，我们可以针对每一个不同的项对粗糙度做一些修改。*根据迪士尼公司给出的观察以及后来被\r\nEpic Games\r\n公司采用的光照模型，<strong>在<u>几何遮蔽函数</u>和<u>法线分布函数</u>中采用粗糙度的平方会让光照看起来更加自然。*</strong></p>\r\n</blockquote>\r\n<h5 id=\"g几何分布函数\">G：几何分布函数</h5>\r\n<blockquote>\r\n<p>几何函数从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量。</p>\r\n<p>这种遮蔽存在两种情况，分别是几何遮蔽(Geometry\r\nObstruction)和几何阴影(Geometry\r\nShadowing)，这两种遮蔽各分别由观察方向和光线方向引起。LearnOpenGL\r\n中图示如下；</p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/07/01/geometry_shadowing.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n</blockquote>\r\n<p>与 NDF\r\n类似，几何函数采用一个材料的粗糙度参数作为输入参数，粗糙度较高的表面其微平面间相互遮蔽的概率就越高。我们将要使用的几何函数是\r\nGGX 与 Schlick-Beckmann 近似的结合体，因此又称为 Schlick-GGX：</p>\r\n<p><span class=\"math display\">\\[\r\nG_{SchlickGGX}(n, v, k) = \\frac{n \\cdot v}{(n \\cdot v)(1-k) + k}\r\n\\]</span></p>\r\n<p>这里的 k 是 α\r\n的重映射(Remapping)，取决于我们要用的是针对直接光照还是针对 IBL\r\n光照的几何函数。对于 k，有：</p>\r\n<p><span class=\"math display\">\\[\r\nk_{direct} = \\frac{(\\alpha+1)^2}{8}\\\\\r\nk_{IBL} = \\frac{\\alpha^2}{2}\r\n\\]</span></p>\r\n<p>而同时，为了有效的估算几何部分，需要将观察方向（几何遮蔽）和光线方向向量（几何阴影）都考虑进去。我们可以使用史密斯法(Smith’s\r\nmethod)来把两者都纳入其中：</p>\r\n<p><span class=\"math display\">\\[\r\nG(n, v, l, k) = G_{sub}(n, v, k)G_{sub}(n, l, k)\r\n\\]</span></p>\r\n<p>实现：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> GeometrySchlickGGX(<span class=\"type\">float</span> NdotV, <span class=\"type\">float</span> roughness) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> r = (roughness + <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> k = (r*r) / <span class=\"number\">8.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> num   = NdotV;</span><br><span class=\"line\">    <span class=\"type\">float</span> denom = NdotV * (<span class=\"number\">1.0</span> - k) + k;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num / denom;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> GeometrySmith(<span class=\"type\">vec3</span> N, <span class=\"type\">vec3</span> V, <span class=\"type\">vec3</span> L, <span class=\"type\">float</span> roughness) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotV = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, V), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotL = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, L), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> ggx2  = GeometrySchlickGGX(NdotV, roughness);</span><br><span class=\"line\">    <span class=\"type\">float</span> ggx1  = GeometrySchlickGGX(NdotL, roughness);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ggx1 * ggx2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h5 id=\"f菲涅尔方程\">F：菲涅尔方程</h5>\r\n<blockquote>\r\n<p>菲涅尔（发音为\r\nFreh-nel）方程描述的是<strong>被反射的光线对比光线被折射的部分所占的比率</strong>，这个比率会随着我们观察的角度不同而不同。当光线碰撞到一个表面的时候，菲涅尔方程会根据观察角度告诉我们被反射的光线所占的百分比。利用这个反射比率和能量守恒原则，我们可以直接得出光线被折射的部分以及光线剩余的能量。</p>\r\n</blockquote>\r\n<p>菲涅尔效应产生的结果往往是，物体边缘大量光线被反射而泛白，因为在这些边缘上，法线往往能与视角接近\r\n90°；而在物体的中央会呈现自己本身的颜色，而对于透明物体来说就会露出其下层的物体。</p>\r\n<figure>\r\n<img src=\"https://learnopengl-cn.github.io/img/07/01/fresnel.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>当垂直观察的时候，任何物体或者材质表面都有一个基础反射率(Base\r\nReflectivity)，但是如果以一定的角度往平面上看的时候<a\r\nhref=\"http://filmicgames.com/archives/557\">所有</a>反光都会变得明显起来。你可以自己尝试一下，用垂直的视角观察你自己的木制/金属桌面，此时一定只有最基本的反射性。但是如果你从近乎\r\n90\r\n度（译注：应该是指和法线的夹角）的角度观察的话反光就会变得明显的多。如果从理想的\r\n90\r\n度视角观察，所有的平面理论上来说都能完全的反射光线。这种现象因菲涅尔而闻名，并体现在了菲涅尔方程之中。</p>\r\n</blockquote>\r\n<p>落实到方程上，真实世界的菲涅尔等式一般比较复杂，我们在实时渲染中，往往采用一些近似等式，这里我们采用第一种，即\r\nSchlick 菲涅尔近似等式：</p>\r\n<p><span class=\"math display\">\\[\r\nSchlick菲涅尔近似等式：F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0)(1 - (h\r\n\\cdot v))^5\\\\\\\\\r\nEmpricial菲涅尔近似等式：F_{Empricial}(v, n) = max(0, min(1, bias +\r\nscale \\times (1 - v \\cdot n)^{power}))\\\\\\\\...\r\n\\]</span></p>\r\n<p>Fresnel-Schlick 近似法接收一个参数<code>F0</code>，被称为 0°\r\n入射角的反射率，或者说是直接(垂直)观察表面时有多少光线会被反射。\r\n这个参数<code>F0</code>会因为材料不同而不同，而且特别的，对金属材质需要特别处理：</p>\r\n<blockquote>\r\n<p><code>F0</code>\r\n表示平面的基础反射率，它是利用所谓<strong>折射指数</strong>(Indices of\r\nRefraction)或者说 IOR\r\n计算得出的。然后正如你可以从球体表面看到的那样，我们越是朝球面掠角的方向上看（此时视线和表面法线的夹角接近\r\n90 度）菲涅尔现象就越明显，反光就越强</p>\r\n<p>问题就在于，Fresnel-Schlick\r\n近似仅仅对电介质或者说非金属表面有定义。对于导体(Conductor)表面（金属），使用它们的折射指数计算\r\n<code>F0</code>\r\n并不能得出正确的结果，这样我们就需要使用一种不同的菲涅尔方程来对导体表面进行计算。由于这样很不方便，所以我们预计算出平面对于法向入射的结果<code>F0</code>，然后基于相应观察角的\r\nFresnel-Schlick\r\n近似对这个值进行插值，用这种方法来进行进一步的估算。这样我们就能对金属和非金属材质使用同一个公式了。</p>\r\n</blockquote>\r\n<p>在 PBR\r\n金属流中我们简单地认为大多数的<strong>绝缘体</strong>在<code>F0</code>为\r\n0.04\r\n的时候看起来视觉上是正确的，对于<strong>金属表面</strong>我们根据反射率特别地指定<code>F0</code>，并对\r\n<code>F0</code> 进行插值。这在代码上看起来会像是这样：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> F0 = <span class=\"type\">vec3</span>(<span class=\"number\">0.04</span>);</span><br><span class=\"line\">F0      = <span class=\"built_in\">mix</span>(F0, albedo, metallic);</span><br><span class=\"line\"><span class=\"type\">vec3</span> F  = fresnelSchlick(<span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(H, V), <span class=\"number\">0.0</span>), F0); <span class=\"comment\">// 对于金属表面，我们根据初始的 F0 和 金属性 及 反射率 进行线性插值。</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">vec3</span> fresnelSchlick(<span class=\"type\">float</span> cosTheta, <span class=\"type\">vec3</span> F0) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> F0 + (<span class=\"number\">1.0</span> - F0) * <span class=\"built_in\">pow</span>(<span class=\"built_in\">clamp</span>(<span class=\"number\">1.0</span> - cosTheta, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>), <span class=\"number\">5.0</span>); <span class=\"comment\">// 注意这里用的clamp是为了避免黑点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以看到，对于非金属表面<code>F0</code>始终为 0.04。</p>\r\n<blockquote>\r\n<p>平面对于法向入射的响应或者说基础反射率可以在一些大型数据库中找到，比如<a\r\nhref=\"http://refractiveindex.info/\">这个</a>。下面列举的这一些常见数值就是从\r\nNaty Hoffman 的课程讲义中所得到的：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">材料</th>\r\n<th style=\"text-align: center;\">F0�0 (线性)</th>\r\n<th style=\"text-align: center;\">F0�0 (sRGB)</th>\r\n<th style=\"text-align: center;\">颜色</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">水</td>\r\n<td style=\"text-align: center;\">(0.02, 0.02, 0.02)</td>\r\n<td style=\"text-align: center;\">(0.15, 0.15, 0.15)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">塑料/玻璃（低）</td>\r\n<td style=\"text-align: center;\">(0.03, 0.03, 0.03)</td>\r\n<td style=\"text-align: center;\">(0.21, 0.21, 0.21)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">塑料（高）</td>\r\n<td style=\"text-align: center;\">(0.05, 0.05, 0.05)</td>\r\n<td style=\"text-align: center;\">(0.24, 0.24, 0.24)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">玻璃（高）/红宝石</td>\r\n<td style=\"text-align: center;\">(0.08, 0.08, 0.08)</td>\r\n<td style=\"text-align: center;\">(0.31, 0.31, 0.31)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">钻石</td>\r\n<td style=\"text-align: center;\">(0.17, 0.17, 0.17)</td>\r\n<td style=\"text-align: center;\">(0.45, 0.45, 0.45)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">铁</td>\r\n<td style=\"text-align: center;\">(0.56, 0.57, 0.58)</td>\r\n<td style=\"text-align: center;\">(0.77, 0.78, 0.78)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">铜</td>\r\n<td style=\"text-align: center;\">(0.95, 0.64, 0.54)</td>\r\n<td style=\"text-align: center;\">(0.98, 0.82, 0.76)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">金</td>\r\n<td style=\"text-align: center;\">(1.00, 0.71, 0.29)</td>\r\n<td style=\"text-align: center;\">(1.00, 0.86, 0.57)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">铝</td>\r\n<td style=\"text-align: center;\">(0.91, 0.92, 0.92)</td>\r\n<td style=\"text-align: center;\">(0.96, 0.96, 0.97)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">银</td>\r\n<td style=\"text-align: center;\">(0.95, 0.93, 0.88)</td>\r\n<td style=\"text-align: center;\">(0.98, 0.97, 0.95)</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>这里可以观察到的一个有趣的现象，所有电介质材质表面的基础反射率都不会高于\r\n0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在\r\n0.5 和 1.0\r\n之间变化。此外，<em>对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么\r\n<code>F0</code> 要用 RGB\r\n三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们<strong>只能</strong>在金属表面观察的到。</em></p>\r\n<p>这些金属表面相比于电介质表面所独有的特性引出了所谓的金属工作流的概念。也就是我们需要额外使用一个被称为金属度(Metalness)的参数来参与编写表面材质。金属度用来描述一个材质表面是金属还是非金属的。</p>\r\n<p>理论上来说，一个表面的金属度应该是二元的：要么是金属要么不是金属，不能两者皆是。但是，大多数的渲染管线都允许在\r\n0.0 至 1.0\r\n之间线性的调配金属度。这主要是由于材质纹理精度不足以描述一个拥有诸如细沙/沙状粒子/刮痕的金属表面。通过对这些小的类非金属粒子/刮痕调整金属度值，我们可以获得非常好看的视觉效果。</p>\r\n</blockquote>\r\n<p>另外值得一提的是，当我们采用了菲涅尔方程后，我们会获得一点特殊的便利——我们不再需要再在方程中采用额外的\r\nKs 了——<code>F</code>具有和方程中 Ks\r\n相似的性质。回想一下，<code>F</code> 是干什么的？</p>\r\n<blockquote>\r\n<p>菲涅尔（发音为\r\nFreh-nel）方程描述的是被反射的光线对比光线被折射的部分所占的比率</p>\r\n</blockquote>\r\n<p>而 Ks 和 Kd 是干什么的？</p>\r\n<blockquote>\r\n<p>Kd 是入射光线中被折射部分的能量所占的比率，而 Ks\r\n是被反射部分的比率。</p>\r\n</blockquote>\r\n<p>也就是说，<code>F</code> 已经包含了类似 Ks 的性质，所以我们可以直接将\r\n<code>F</code> 用以代替 Ks 的存在，最终我们实际的运算式子如下：</p>\r\n<h2 id=\"编写-pbr-材质\">编写 PBR 材质</h2>\r\n<p>在了解了 PBR\r\n后面的数学模型之后，最后我们将通过说明美术师一般是如何编写一个我们可以直接输入\r\nPBR 的平面物理属性的来结束这部分的讨论。PBR\r\n渲染管线所需要的每一个表面参数都可以用纹理来定义或者建模。使用纹理可以让我们逐个片段的来控制每个表面上特定的点对于光线是如何响应的：不论那个点是不是金属，粗糙或者平滑，也不论表面对于不同波长的光会有如何的反应。</p>\r\n<p>在下面你可以看到在一个 PBR\r\n渲染管线当中经常会碰到的纹理列表，还有将它们输入 PBR\r\n渲染器所能得到的相应的视觉输出：</p>\r\n<figure>\r\n<img src=\"https://learnopengl-cn.github.io/img/07/01/textures.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p><strong>反照率</strong>：反照率(Albedo)纹理为每一个金属的纹素(Texel)（纹理像素）<em>指定表面颜色或者基础反射率</em>。这和我们之前使用过的漫反射纹理相当类似，不同的是所有光照信息都是由一个纹理中提取的。漫反射纹理的图像当中常常包含一些细小的阴影或者深色的裂纹，而反照率纹理中是不会有这些东西的。它应该只包含表面的颜色（或者折射吸收系数）。</p>\r\n<p><strong>法线</strong>：法线贴图纹理和我们之前在<a\r\nhref=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/\">法线贴图</a>教程中所使用的贴图是完全一样的。法线贴图使我们可以逐片段的指定独特的法线，来为表面制造出起伏不平的假象。</p>\r\n<p><strong>金属度</strong>：金属(Metallic)贴图逐个纹素的指定该纹素是不是金属质地的。根据\r\nPBR 引擎设置的不同，美术师们既可以将金属度编写为灰度值又可以编写为 1 或\r\n0 这样的二元值。</p>\r\n<p><strong>粗糙度</strong>：粗糙度(Roughness)贴图可以以纹素为单位指定某个表面有多粗糙。采样得来的粗糙度数值会影响一个表面的微平面统计学上的取向度。一个比较粗糙的表面会得到更宽阔更模糊的镜面反射（高光），而一个比较光滑的表面则会得到集中而清晰的镜面反射。某些\r\nPBR\r\n引擎预设采用的是对某些美术师来说更加直观的光滑度(Smoothness)贴图而非粗糙度贴图，不过这些数值在采样之时就马上用（1.0\r\n– 光滑度）转换成了粗糙度。</p>\r\n<p><strong>AO</strong>：环境光遮蔽(Ambient Occlusion)贴图或者说 AO\r\n贴图为表面和周围潜在的几何图形指定了一个额外的阴影因子。比如如果我们有一个砖块表面，反照率纹理上的砖块裂缝部分应该没有任何阴影信息。然而\r\nAO\r\n贴图则会把那些光线较难逃逸出来的暗色边缘指定出来。在光照的结尾阶段引入环境遮蔽可以明显的提升你场景的视觉效果。网格/表面的环境遮蔽贴图要么通过手动生成，要么由\r\n3D 建模软件自动生成。</p>\r\n<p>美术师们可以在纹素级别设置或调整这些基于物理的输入值，还可以以现实世界材料的表面物理性质来建立他们的材质数据。这是\r\nPBR\r\n渲染管·线最大的优势之一，因为不论环境或者光照的设置如何改变这些表面的性质是不会改变的，这使得美术师们可以更便捷地获取物理可信的结果。在\r\nPBR 渲染管线中编写的表面可以非常方便的在不同的 PBR\r\n渲染引擎间共享使用，不论处于何种环境中它们看上去都会是正确的，因此看上去也会更自然。</p>\r\n<h2 id=\"结合-ibl\">结合 IBL</h2>\r\n<blockquote>\r\n<p>IBL，即 Image based\r\nlighting，可直译为基于图像的光照，它是一类光照技术的集合。<strong>其光源不是可分解的直接光源，而是将周围环境整体视为一个大光源。</strong>IBL\r\n通常使用（取自现实世界或从 3D 场景生成的）环境立方体贴图 (Cubemap)\r\n，我们可以将立方体贴图的每个像素视为光源，在渲染方程中直接使用它。这种方式可以有效地捕捉环境的全局光照和氛围，使物体更好地融入其环境。</p>\r\n<p>由于基于图像的光照算法会捕捉部分甚至全部的环境光照，通常认为它是一种更精确的环境光照输入格式，甚至也可以说是一种全局光照的粗略近似。基于此特性，IBL\r\n对 PBR\r\n很有意义，因为当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。</p>\r\n</blockquote>\r\n<p>在 IBL\r\n下，有一件事情是很麻烦的：我们无法规避反射率方程中的积分了——直接光源下，积分是可以规避的——因为我们事先已经知道了对积分有贡献的、若干精确的光线方向\r\nw<sub>i</sub>，然而这次，来自周围环境的<strong>每个</strong>方向\r\nw<sub>i</sub>\r\n的入射光都可能具有一些辐射度，使得解决积分变得不那么简单。这为解决积分提出了两个要求：</p>\r\n<ul>\r\n<li>对于给定的任何方向向量\r\nw<sub>i</sub>，我们都能获取这个方向上场景的辐射度。</li>\r\n<li>解决积分需要快速且实时。</li>\r\n</ul>\r\n<p>现在看，第一个要求相对容易些。我们已经有了一些思路：表示环境或场景辐照度的一种方式是（预处理过的）环境立方体贴图，给定这样的立方体贴图，我们可以将立方体贴图的每个纹素视为一个光源。使用一个方向向量\r\nw<sub>i</sub>\r\n对此立方体贴图进行采样，我们就可以获取该方向上的场景辐照度。如此，给定方向向量\r\nw<sub>i</sub> ，获取此方向上场景辐射度的方法就简化为：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> radiance =  <span class=\"built_in\">texture</span>(_cubemapEnvironment, w_i).rgb;</span><br></pre></td></tr></table></figure>\r\n<p>为了以更有效的方式解决积分，我们需要对其大部分结果进行预处理——或称预计算。为此，我们必须深入研究反射方程。原来的反射方程有：</p>\r\n<p><span class=\"math display\">\\[\r\nL_0(p,w_0)=\\int_Ω(k_d*\\frac{c}{\\pi}+k_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i\r\n\\cdot n)}*Li(p,w_i)*n \\cdot w_i*dw_i\r\n\\]</span></p>\r\n<p>我们可以发现，式子中的漫反射项是与积分无关的——这部分是可以拆开的</p>\r\n<p><span class=\"math display\">\\[\r\nL_0(p,w_0)=\\int_Ω(k_d*\\frac{c}{\\pi}+k_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i\r\n\\cdot n)}*Li(p,w_i)*n \\cdot w_i*dw_i\\\\\r\n=\\int_Ωk_d*\\frac{c}{\\pi}*Li(p,w_i)*n \\cdot w*dw_i +\r\n\\int_Ωk_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i \\cdot n)}*L_i(p,w_i)*n \\cdot\r\nw_i*dw_i\r\n\\]</span></p>\r\n<p>这样，我们就可以分别考虑两部分的预计算方法</p>\r\n<p>先看漫反射项：</p>\r\n<h3 id=\"预计算漫反射项\">预计算漫反射项</h3>\r\n<h4 id=\"对方程的一些小改变\">对方程的一些小改变</h4>\r\n<p>让我们先对分离出的原始方程做一些变化：</p>\r\n<p><span class=\"math display\">\\[\r\nL_0(p,w_0)=\\int_Ωk_d*\\frac{c}{\\pi}*Li(p,w_i)*n \\cdot w*dw_i\\\\\r\n=k_d\\frac{c}{\\pi}\\int_ΩLi(p,w_i)*n \\cdot w*dw_i\\\\\r\n\\]</span></p>\r\n<p>不难发现，我们所做的内容也就是将常数项提到了积分外部（颜色 c、折射率\r\nk<sub>d</sub> 和 π\r\n在整个漫反射积分函数中，是常数），这样我们就获得了一个只依赖于\r\nw<sub>i</sub> 的积分（假设 p\r\n位于环境贴图的中心），这样我们就可以通过卷积，预计算一个新的立方体贴图，它在每个采样方向——也就是纹素——中存储漫反射积分的结果。</p>\r\n<blockquote>\r\n\r\n</blockquote>\r\n<h4 id=\"预计算思路\">预计算思路</h4>\r\n<p>目前，我们的主要目标是计算所有间接漫反射光的积分，其中光照的辐照度以环境立方体贴图的形式给出。我们已经知道，在方向\r\nw<sub>i</sub> 上采样 HDR 环境贴图，可以获得场景在此方向上的辐射度\r\nL(p,w<sub>i</sub>)\r\n。虽然如此，要解决积分，我们仍然不能仅从一个方向对环境贴图采样——要从半球\r\nΩ\r\n上所有可能的方向进行采样，这不仅对于片段着色器过于昂贵，并且计算上又不可能从\r\nΩ\r\n的每个可能的方向采样环境光照——理论上可能的方向数量是无限的。后者的解决办法相对容易——我们去对有限数量的方向采样以近似求解，并在半球内以均匀间隔或随机取方向等的方式，可以获得一个相当精确的辐照度近似值，从而离散地计算积分。不过，对于每个片段实时执行此操作仍然太昂贵，因为仍然需要非常大的样本数量才能获得不错的结果，因此我们希望可以<strong>预计算</strong>。</p>\r\n<p>既然明确了需要预计算，那么我们额外需要思考的就是怎么去做预计算。</p>\r\n<p>我们知道的是，我们的计算总是处于一个半球空间中的——即全部从正面来的光——既然半球的朝向决定了我们捕捉辐照度的位置，我们可以预先计算每个可能的半球朝向的辐照度，把结果保存另一个\r\nCubeMap 中，这样我们就几乎达到了我们的目的。</p>\r\n<blockquote>\r\n<p>下面是一个环境立方体贴图及其生成的辐照度图的示例：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/07/03/01/ibl_irradiance.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n</blockquote>\r\n<p>我们可以以这样的手段去描述我们的半球面：</p>\r\n<p>我们用球坐标 θ 和 ϕ 来代替反射方程的积分 ∫\r\n中的立体角，由于积分是围绕立体角 dw 旋转进行的，那我们用以代替 dw\r\n的球坐标也该定义出相同的性质：我们规定对于围绕半球大圆的航向角 ϕ\r\n，我们在 0 到 2π 内采样，而从半球顶点出发的倾斜角 θ ，采样范围是 0 到\r\nπ/2 。于是我们更新一下反射积分方程：</p>\r\n<p><span class=\"math display\">\\[\r\nL_0(p, \\phi_0,\r\n\\theta_0)=k_d\\frac{c}{\\pi}\\int_{\\phi=0}^{2\\pi}\\int_{\\theta=0}^{\\frac{1}{2}\\pi}L_i(p,\r\n\\phi_i, \\theta_i)\\cos(\\theta)\\sin(\\theta)d\\phi d\\theta\r\n\\]</span></p>\r\n<p>求解积分需要我们在半球 Ω\r\n内采集固定数量的离散样本并对其结果求平均值。分别给每个球坐标轴指定离散样本数量\r\nn<sub>1</sub> 和 n<sub>2</sub> 以求其<a\r\nhref=\"https://en.wikipedia.org/wiki/Riemann_sum\">黎曼和</a>，积分式会转换为以下离散版本：</p>\r\n<p><span class=\"math display\">\\[\r\nLo(p,ϕ_0,θ_0)=k_d\\frac{c}{π}\\frac{1}{n_1n_2}\\sum_{\\phi=0}^{n_1}\\sum_{\\theta=0}^{n_2}Li(p,ϕ_i,θ_i)cos(θ)sin(θ)dϕdθ\r\n\\]</span></p>\r\n<h3 id=\"预计算镜面反射\">预计算镜面反射</h3>\r\n<p>相较于漫反射项，我们的镜面反射显然是一个更加复杂的部分，让我们先做分析：</p>\r\n<p><span class=\"math display\">\\[\r\nL_0(p,w_0)=\\int_Ωk_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i \\cdot\r\nn)}*L_i(p,w_i)*n \\cdot w_i*dw_i\r\n\\]</span></p>\r\n<p>我们可以发现，相较于仅有 w<sub>i</sub>\r\n一个变量的漫反射，我们的镜面反射部分同时存在 w<sub>i</sub> 与\r\nw<sub>0</sub>\r\n两个变量——我们无法用两个方向向量采样预计算的立方体图。要想预计算这部分内容，我们得做更多的处理——这里采用的是\r\nEpic Games 的解决方案：分割求和近似法（split sum approximation）。</p>\r\n<p>分割求和近似将方程的镜面部分分割成两个独立的部分，我们可以单独求卷积，然后在\r\nPBR 着色器中求和，以用于间接镜面反射部分\r\nIBL。分割求和近似法类似于我们之前求辐照图预卷积的方法，需要 HDR\r\n环境贴图作为其卷积输入。在该办法中，我们的公式会变为：</p>\r\n<p><span class=\"math display\">\\[\r\nL_0(p,w_0)=\\int_\\Omega L_i(p, w_i)dw_i * \\int_\\Omega f_r()\r\n\\]</span></p>\r\n<p>让我们分别考虑这两部分</p>\r\n<h4 id=\"预滤波环境贴图\">预滤波环境贴图</h4>\r\n<p>预滤波环境贴图的方法与我们对辐射度贴图求卷积的方法非常相似。只是对于卷积的每个粗糙度级别，我们会按顺序把模糊后的结果存储在预滤波贴图的\r\nmipmap 中。</p>\r\n<h3 id=\"ggx-重要性采样\">GGX 重要性采样</h3>\r\n<p>有别于均匀或纯随机地（比如蒙特卡洛）在积分半球 Ω\r\n产生采样向量，<strong>我们的采样会根据粗糙度，偏向微表面的半向量的宏观反射方向。</strong>采样过程将与我们之前看到的过程相似：开始一个大循环，生成一个随机（低差异）序列值，用该序列值在切线空间中生成样本向量，将样本向量变换到世界空间并对场景的辐射度采样。不同之处在于，我们现在使用低差异序列值作为输入来生成采样向量：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> uint SAMPLE_COUNT = <span class=\"number\">4096u</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(uint i = <span class=\"number\">0u</span>; i &lt; SAMPLE_COUNT; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vec2 Xi = <span class=\"built_in\">Hammersley</span>(i, SAMPLE_COUNT);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>此外，要构建采样向量，我们需要一些方法定向和偏移采样向量，以使其朝向特定粗糙度的镜面波瓣方向。我们可以如理论教程中所述使用\r\nNDF，并将 GGX NDF 结合到 Epic Games 所述的球形采样向量的处理中：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vec3 <span class=\"title\">ImportanceSampleGGX</span><span class=\"params\">(vec2 Xi, vec3 N, <span class=\"type\">float</span> roughness)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> a = roughness*roughness;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> phi = <span class=\"number\">2.0</span> * PI * Xi.x;</span><br><span class=\"line\">    <span class=\"type\">float</span> cosTheta = <span class=\"built_in\">sqrt</span>((<span class=\"number\">1.0</span> - Xi.y) / (<span class=\"number\">1.0</span> + (a*a - <span class=\"number\">1.0</span>) * Xi.y));</span><br><span class=\"line\">    <span class=\"type\">float</span> sinTheta = <span class=\"built_in\">sqrt</span>(<span class=\"number\">1.0</span> - cosTheta*cosTheta);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// from spherical coordinates to cartesian coordinates</span></span><br><span class=\"line\">    vec3 H;</span><br><span class=\"line\">    H.x = <span class=\"built_in\">cos</span>(phi) * sinTheta;</span><br><span class=\"line\">    H.y = <span class=\"built_in\">sin</span>(phi) * sinTheta;</span><br><span class=\"line\">    H.z = cosTheta;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// from tangent-space vector to world-space sample vector</span></span><br><span class=\"line\">    vec3 up        = <span class=\"built_in\">abs</span>(N.z) &lt; <span class=\"number\">0.999</span> ? <span class=\"built_in\">vec3</span>(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>) : <span class=\"built_in\">vec3</span>(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    vec3 tangent   = <span class=\"built_in\">normalize</span>(<span class=\"built_in\">cross</span>(up, N));</span><br><span class=\"line\">    vec3 bitangent = <span class=\"built_in\">cross</span>(N, tangent);</span><br><span class=\"line\"></span><br><span class=\"line\">    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">normalize</span>(sampleVec);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>基于特定的粗糙度输入和低差异序列值\r\nXi，我们获得了一个采样向量，该向量大体围绕着预估的微表面的半向量。注意，根据迪士尼对\r\nPBR 的研究，Epic Games 使用了平方粗糙度以获得更好的视觉效果。</p>\r\n<p>使用低差异 Hammersley\r\n序列和上述定义的样本生成方法，我们可以最终完成预滤波器卷积着色器：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 330 core</span></span><br><span class=\"line\">out vec4 FragColor;</span><br><span class=\"line\">in vec3 localPos;</span><br><span class=\"line\"></span><br><span class=\"line\">uniform samplerCube environmentMap;</span><br><span class=\"line\">uniform <span class=\"type\">float</span> roughness;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> PI = <span class=\"number\">3.14159265359</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">RadicalInverse_VdC</span><span class=\"params\">(uint bits)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec2 <span class=\"title\">Hammersley</span><span class=\"params\">(uint i, uint N)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vec3 <span class=\"title\">ImportanceSampleGGX</span><span class=\"params\">(vec2 Xi, vec3 N, <span class=\"type\">float</span> roughness)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vec3 N = <span class=\"built_in\">normalize</span>(localPos);</span><br><span class=\"line\">    vec3 R = N;</span><br><span class=\"line\">    vec3 V = R;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> uint SAMPLE_COUNT = <span class=\"number\">1024u</span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> totalWeight = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    vec3 prefilteredColor = <span class=\"built_in\">vec3</span>(<span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(uint i = <span class=\"number\">0u</span>; i &lt; SAMPLE_COUNT; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vec2 Xi = <span class=\"built_in\">Hammersley</span>(i, SAMPLE_COUNT);</span><br><span class=\"line\">        vec3 H  = <span class=\"built_in\">ImportanceSampleGGX</span>(Xi, N, roughness);</span><br><span class=\"line\">        vec3 L  = <span class=\"built_in\">normalize</span>(<span class=\"number\">2.0</span> * <span class=\"built_in\">dot</span>(V, H) * H - V);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">float</span> NdotL = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, L), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(NdotL &gt; <span class=\"number\">0.0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            prefilteredColor += <span class=\"built_in\">texture</span>(environmentMap, L).rgb * NdotL;</span><br><span class=\"line\">            totalWeight      += NdotL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    prefilteredColor = prefilteredColor / totalWeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    FragColor = <span class=\"built_in\">vec4</span>(prefilteredColor, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>输入的粗糙度随着预过滤的立方体贴图的 mipmap 级别变化（从 0.0 到\r\n1.0），我们根据据粗糙度预过滤环境贴图，把结果存在 prefilteredColor\r\n里。再用 prefilteredColor\r\n除以采样权重总和，其中对最终结果影响较小（NdotL\r\n较小）的采样最终权重也较小。</p>\r\n<h3 id=\"捕获预过滤-mipmap-级别\">捕获预过滤 mipmap 级别</h3>\r\n<p>剩下要做的就是让 OpenGL 在多个 mipmap\r\n级别上以不同的粗糙度值预过滤环境贴图。有了最开始的辐照度教程作为基础，实际上很简单：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prefilterShader.<span class=\"built_in\">use</span>();</span><br><span class=\"line\">prefilterShader.<span class=\"built_in\">setInt</span>(<span class=\"string\">&quot;environmentMap&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">prefilterShader.<span class=\"built_in\">setMat4</span>(<span class=\"string\">&quot;projection&quot;</span>, captureProjection);</span><br><span class=\"line\"><span class=\"built_in\">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class=\"line\"><span class=\"built_in\">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, envCubemap);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glBindFramebuffer</span>(GL_FRAMEBUFFER, captureFBO);</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> maxMipLevels = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">unsigned</span> <span class=\"type\">int</span> mip = <span class=\"number\">0</span>; mip &lt; maxMipLevels; ++mip)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// reisze framebuffer according to mip-level size.</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> mipWidth  = <span class=\"number\">128</span> * std::<span class=\"built_in\">pow</span>(<span class=\"number\">0.5</span>, mip);</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> mipHeight = <span class=\"number\">128</span> * std::<span class=\"built_in\">pow</span>(<span class=\"number\">0.5</span>, mip);</span><br><span class=\"line\">    <span class=\"built_in\">glBindRenderbuffer</span>(GL_RENDERBUFFER, captureRBO);</span><br><span class=\"line\">    <span class=\"built_in\">glRenderbufferStorage</span>(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, mipWidth, mipHeight);</span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, mipWidth, mipHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> roughness = (<span class=\"type\">float</span>)mip / (<span class=\"type\">float</span>)(maxMipLevels - <span class=\"number\">1</span>);</span><br><span class=\"line\">    prefilterShader.<span class=\"built_in\">setFloat</span>(<span class=\"string\">&quot;roughness&quot;</span>, roughness);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">unsigned</span> <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        prefilterShader.<span class=\"built_in\">setMat4</span>(<span class=\"string\">&quot;view&quot;</span>, captureViews[i]);</span><br><span class=\"line\">        <span class=\"built_in\">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class=\"line\">                               GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, prefilterMap, mip);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\">        <span class=\"built_in\">renderCube</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\r\n<p>这个过程类似于辐照度贴图卷积，但是这次我们将帧缓冲区缩放到适当的\r\nmipmap 尺寸， mip 级别每增加一级，尺寸缩小为一半。此外，我们在\r\nglFramebufferTexture2D 的最后一个参数中指定要渲染的目标 mip\r\n级别，然后将要预过滤的粗糙度传给预过滤着色器。</p>\r\n<p>这样我们会得到一张经过适当预过滤的环境贴图，访问该贴图时指定的 mip\r\n等级越高，获得的反射就越模糊。如果我们在天空盒着色器中显示这张预过滤的环境立方体贴图，并在其着色器中强制在其第一个\r\nmip 级别以上采样，如下所示：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec3 envColor = <span class=\"built_in\">textureLod</span>(environmentMap, WorldPos, <span class=\"number\">1.2</span>).rgb;</span><br></pre></td></tr></table></figure>\r\n<p>我们得到的结果看起来确实像原始环境的模糊版本：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/07/03/02/ibl_prefilter_map_sample.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>如果 HDR 环境贴图的预过滤看起来差不多没问题，尝试一下不同的 mipmap\r\n级别，观察预过滤贴图随着 mip 级别增加，反射逐渐从锐利变模糊的过程。</p>\r\n<h2 id=\"预过滤卷积的伪像\">预过滤卷积的伪像</h2>\r\n<p>当前的预过滤贴图可以在大多数情况下正常工作，不过你迟早会遇到几个与预过滤卷积直接相关的渲染问题。我将在这里列出最常见的一些问题，以及如何修复它们。</p>\r\n<h3 id=\"高粗糙度的立方体贴图接缝\">高粗糙度的立方体贴图接缝</h3>\r\n<p>在具有粗糙表面的表面上对预过滤贴图采样，也就等同于在较低的 mip\r\n级别上对预过滤贴图采样。在对立方体贴图进行采样时，默认情况下，OpenGL\r\n不会在立方体面<strong>之间</strong>进行线性插值。由于较低的 mip\r\n级别具有更低的分辨率，并且预过滤贴图代表了与更大的采样波瓣卷积，因此缺乏<strong>立方体的面和面之间的滤波</strong>的问题就更明显：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/07/03/02/ibl_prefilter_seams.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>幸运的是，OpenGL 可以启用\r\nGL_TEXTURE_CUBE_MAP_SEAMLESS，以为我们提供在立方体贴图的面之间进行正确过滤的选项：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glEnable</span>(GL_TEXTURE_CUBE_MAP_SEAMLESS);</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"预过滤卷积的亮点\">预过滤卷积的亮点</h3>\r\n<p>由于镜面反射中光强度的变化大，高频细节多，所以对镜面反射进行卷积需要大量采样，才能正确反映\r\nHDR\r\n环境反射的混乱变化。我们已经进行了大量的采样，但是在某些环境下，在某些较粗糙的\r\nmip 级别上可能仍然不够，导致明亮区域周围出现点状图案：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/07/03/02/ibl_prefilter_dots.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>一种解决方案是进一步增加样本数量，但在某些情况下还是不够。另一种方案如\r\n<a\r\nhref=\"https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/\">Chetan\r\nJags</a>\r\n所述，我们可以在预过滤卷积时，不直接采样环境贴图，而是基于积分的 PDF\r\n和粗糙度采样环境贴图的 mipmap ，以减少伪像：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> D   = <span class=\"built_in\">DistributionGGX</span>(NdotH, roughness);</span><br><span class=\"line\"><span class=\"type\">float</span> pdf = (D * NdotH / (<span class=\"number\">4.0</span> * HdotV)) + <span class=\"number\">0.0001</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> resolution = <span class=\"number\">512.0</span>; <span class=\"comment\">// resolution of source cubemap (per face)</span></span><br><span class=\"line\"><span class=\"type\">float</span> saTexel  = <span class=\"number\">4.0</span> * PI / (<span class=\"number\">6.0</span> * resolution * resolution);</span><br><span class=\"line\"><span class=\"type\">float</span> saSample = <span class=\"number\">1.0</span> / (<span class=\"built_in\">float</span>(SAMPLE_COUNT) * pdf + <span class=\"number\">0.0001</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> mipLevel = roughness == <span class=\"number\">0.0</span> ? <span class=\"number\">0.0</span> : <span class=\"number\">0.5</span> * <span class=\"built_in\">log2</span>(saSample / saTexel);</span><br></pre></td></tr></table></figure>\r\n<p>既然要采样 mipmap ，不要忘记在环境贴图上开启三线性过滤：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, envCubemap);</span><br><span class=\"line\"><span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br></pre></td></tr></table></figure>\r\n<p>设置立方体贴图的基本纹理后，让 OpenGL 生成 mipmap：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// convert HDR equirectangular environment map to cubemap equivalent</span></span><br><span class=\"line\">[...]</span><br><span class=\"line\"><span class=\"comment\">// then generate mipmaps</span></span><br><span class=\"line\"><span class=\"built_in\">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, envCubemap);</span><br><span class=\"line\"><span class=\"built_in\">glGenerateMipmap</span>(GL_TEXTURE_CUBE_MAP);</span><br></pre></td></tr></table></figure>\r\n<p>这个方法效果非常好，可以去除预过滤贴图中较粗糙表面上的大多数甚至全部亮点。</p>\r\n<h5 id=\"蒙特卡洛积分\">蒙特卡洛积分</h5>\r\n<blockquote>\r\n<p>为了充分理解重要性采样，我们首先要了解一种数学结构，称为蒙特卡洛积分。蒙特卡洛积分主要是统计和概率理论的组合。其作用很大，比如：<em>蒙特卡洛可以帮助我们离散地解决人口统计问题，而不必考虑所有人。</em></p>\r\n<p>具体来讲，假设我们得计算一个国家所有公民的平均身高。为了得到结果，我们可以测量每个公民并对他们的身高求平均，这样会得到你需要的确切答案。但是，由于大多数国家人海茫茫，这个方法不现实：需要花费太多精力和时间。</p>\r\n<p>另一种方法是选择一个小得多的完全随机（无偏）的人口子集，测量他们的身高并对结果求平均。可能只测量\r\n100\r\n人，虽然答案并非绝对精确，但会得到一个相对接近真相的答案，这个理论被称作大数定律。我们的想法是，如果从总人口中测量一组较小的真正随机样本的\r\nN，结果将相对接近真实答案，并随着样本数 N 的增加而愈加接近。</p>\r\n<p><strong>蒙特卡罗积分建立在大数定律的基础上，并采用相同的方法来求解积分。不为所有可能的（理论上是无限的）样本值\r\nx 求解积分，而是简单地从总体中随机挑选样本 N\r\n生成采样值并求平均。</strong>随着 N\r\n的增加，我们的结果会越来越接近积分的精确结果：</p>\r\n<p><span class=\"math display\">\\[\r\nO=\\int_{a}^{b}f(x)dx=\\frac{1}{N}\\sum_{i=0}^{N-1}\\frac{f(x)}{pdf(x)}\r\n\\]</span></p>\r\n<p>为了求解这个积分，我们在 <span class=\"math inline\">\\(a\\)</span> 到\r\n<span class=\"math inline\">\\(b\\)</span> 上采样 <span\r\nclass=\"math inline\">\\(N\\)</span>\r\n个随机样本，将它们加在一起并除以样本总数来取平均。<span\r\nclass=\"math inline\">\\(pdf\\)</span> 代表概率密度函数 (probability density\r\nfunction)，它的含义是特定样本在整个样本集上发生的概率。例如，人口身高的\r\n<span class=\"math inline\">\\(pdf\\)</span> 看起来应该像这样：</p>\r\n<figure>\r\n<img src=\"https://learnopengl-cn.github.io/img/07/03/02/ibl_pdf.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>从该图中我们可以看出，如果我们对人口任意随机采样，那么挑选身高为 1.70\r\n的人口样本的可能性更高，而样本身高为 1.50 的概率较低。</p>\r\n<p>当涉及蒙特卡洛积分时，某些样本可能比其他样本具有更高的生成概率。这就是为什么对于任何一般的蒙特卡洛估计，我们都会根据\r\npdf\r\n将采样值作除以或乘以采样概率。到目前为止，我们每次需要估算积分的时候，生成的样本都是均匀分布的，概率完全相等。到目前为止，我们的估计是无偏的，这意味着随着样本数量的不断增加，我们最终将收敛到积分的<strong>精确</strong>解。</p>\r\n<p>但是，某些蒙特卡洛估算是有偏的，这意味着生成的样本并不是完全随机的，而是集中于特定的值或方向。这些有偏的蒙特卡洛估算具有更快的收敛速度，它们会以更快的速度向精确解收敛，但是由于其有偏性，可能永远不会收敛到精确解。通常来说，这是一个可以接受的折衷方案，尤其是在计算机图形学中。因为只要结果在视觉上可以接受，解决方案的精确性就不太重要。</p>\r\n<p>下文我们将会提到一种（有偏的）重要性采样，其生成的样本偏向特定的方向，在这种情况下，我们会将每个样本乘以或除以相应的\r\npdf 再求和。</p>\r\n<p><strong>蒙特卡洛积分在计算机图形学中非常普遍，因为它是一种以高效的离散方式对连续的积分求近似而且非常直观的方法：对任何面积/体积进行采样——例如半球\r\nΩ ——在该面积/体积内生成数量 N\r\n的随机采样，权衡每个样本对最终结果的贡献并求和。</strong></p>\r\n<p>蒙特卡洛积分是一个庞大的数学主题，在此不再赘述，但有一点需要提到：生成随机样本的方法也多种多样。默认情况下，每次采样都是我们熟悉的完全（伪）随机，不过利用半随机序列的某些属性，我们可以生成虽然是随机样本但具有一些有趣性质的样本向量。例如，我们可以对一种名为低差异序列的东西进行蒙特卡洛积分，该序列生成的仍然是随机样本，但样本分布更均匀：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://learnopengl-cn.github.io/img/07/03/02/ibl_low_discrepancy_sequence.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>当使用低差异序列生成蒙特卡洛样本向量时，该过程称为拟蒙特卡洛积分。拟蒙特卡洛方法具有更快的收敛速度，这使得它对于性能繁重的应用很有用。</p>\r\n<p>鉴于我们新获得的有关蒙特卡洛（Monte Carlo）和拟蒙特卡洛（Quasi-Monte\r\nCarlo）积分的知识，我们可以使用一个有趣的属性来获得更快的收敛速度，这就是重要性采样。我们在前文已经提到过它，但是在镜面反射的情况下，反射的光向量被限制在镜面波瓣中，波瓣的大小取决于表面的粗糙度。既然镜面波瓣外的任何（拟）随机生成的样本与镜面积分无关，因此将样本集中在镜面波瓣内生成是有意义的，但代价是蒙特卡洛估算会产生偏差。</p>\r\n<p>本质上来说，这就是重要性采样的核心：只在某些区域生成采样向量，该区域围绕微表面半向量，受粗糙度限制。通过将拟蒙特卡洛采样与低差异序列相结合，并使用重要性采样偏置样本向量的方法，我们可以获得很高的收敛速度。因为我们求解的速度更快，所以要达到足够的近似度，我们所需要的样本更少。因此，这套组合方法甚至可以允许图形应用程序实时求解镜面积分，虽然比预计算结果还是要慢得多。</p>\r\n</blockquote>\r\n<h5 id=\"重要性采样\">重要性采样</h5>\r\n<h5 id=\"低差异序列\">低差异序列</h5>\r\n<p>在本教程中，我们将使用重要性采样来预计算间接反射方程的镜面反射部分，该采样基于拟蒙特卡洛方法给出了随机的低差异序列。我们将使用的序列被称为\r\nHammersley 序列，<a\r\nhref=\"http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\">Holger\r\nDammertz</a> 曾仔细描述过它。Hammersley 序列是基于 Van Der Corput\r\n序列，该序列是把十进制数字的二进制表示镜像翻转到小数点右边而得。（译注：原文为\r\nVan Der Corpus 疑似笔误，下文各处同）</p>\r\n<p>给出一些巧妙的技巧，我们可以在着色器程序中非常有效地生成 Van Der\r\nCorput 序列，我们将用它来获得 Hammersley 序列，设总样本数为\r\nN，样本索引为 i：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> RadicalInverse_VdC(<span class=\"type\">uint</span> bits)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bits = (bits &lt;&lt; <span class=\"number\">16</span>u) | (bits &gt;&gt; <span class=\"number\">16</span>u);</span><br><span class=\"line\">    bits = ((bits &amp; <span class=\"number\">0x55555555</span>u) &lt;&lt; <span class=\"number\">1</span>u) | ((bits &amp; <span class=\"number\">0xAAAAAAAA</span>u) &gt;&gt; <span class=\"number\">1</span>u);</span><br><span class=\"line\">    bits = ((bits &amp; <span class=\"number\">0x33333333</span>u) &lt;&lt; <span class=\"number\">2</span>u) | ((bits &amp; <span class=\"number\">0xCCCCCCCC</span>u) &gt;&gt; <span class=\"number\">2</span>u);</span><br><span class=\"line\">    bits = ((bits &amp; <span class=\"number\">0x0F0F0F0F</span>u) &lt;&lt; <span class=\"number\">4</span>u) | ((bits &amp; <span class=\"number\">0xF0F0F0F0</span>u) &gt;&gt; <span class=\"number\">4</span>u);</span><br><span class=\"line\">    bits = ((bits &amp; <span class=\"number\">0x00FF00FF</span>u) &lt;&lt; <span class=\"number\">8</span>u) | ((bits &amp; <span class=\"number\">0xFF00FF00</span>u) &gt;&gt; <span class=\"number\">8</span>u);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">float</span>(bits) * <span class=\"number\">2.3283064365386963e-10</span>; <span class=\"comment\">// / 0x100000000</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"type\">vec2</span> Hammersley(<span class=\"type\">uint</span> i, <span class=\"type\">uint</span> N)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">vec2</span>(<span class=\"type\">float</span>(i)/<span class=\"type\">float</span>(N), RadicalInverse_VdC(i));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>GLSL 的 Hammersley 函数可以获取大小为 N 的样本集中的低差异样本\r\ni。</p>\r\n<p><strong>无需位运算的 Hammersley 序列</strong></p>\r\n<p>并非所有 OpenGL 相关驱动程序都支持位运算符（例如 WebGL 和 OpenGL ES\r\n2.0），在这种情况下，你可能需要不依赖位运算符的替代版本 Van Der Corput\r\n序列：</p>\r\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> VanDerCorpus(<span class=\"type\">uint</span> n, <span class=\"type\">uint</span> base)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> invBase = <span class=\"number\">1.0</span> / <span class=\"type\">float</span>(base);</span><br><span class=\"line\">    <span class=\"type\">float</span> denom   = <span class=\"number\">1.0</span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> result  = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">uint</span> i = <span class=\"number\">0</span>u; i &lt; <span class=\"number\">32</span>u; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>u)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            denom   = <span class=\"built_in\">mod</span>(<span class=\"type\">float</span>(n), <span class=\"number\">2.0</span>);</span><br><span class=\"line\">            result += denom * invBase;</span><br><span class=\"line\">            invBase = invBase / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">            n       = <span class=\"type\">uint</span>(<span class=\"type\">float</span>(n) / <span class=\"number\">2.0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"type\">vec2</span> HammersleyNoBitOps(<span class=\"type\">uint</span> i, <span class=\"type\">uint</span> N)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">vec2</span>(<span class=\"type\">float</span>(i)/<span class=\"type\">float</span>(N), VanDerCorpus(i, <span class=\"number\">2</span>u));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>请注意，由于旧硬件中的 GLSL 循环限制，该序列循环遍历了所有可能的 32\r\n位，性能略差。但是如果你没有位运算符可用的话可以考虑它，它可以在所有硬件上运行。</p>\r\n<h3 id=\"一个完整的-pbr-构建\">一个完整的 PBR 构建</h3>\r\n<h2 id=\"编写-pbr-shader---渲染方程的实现\">编写 PBR Shader -\r\n渲染方程的实现</h2>\r\n<h3 id=\"实现内容的具体简化\">实现内容的具体简化</h3>\r\n<h3 id=\"实现流程\">实现流程</h3>\r\n<h2 id=\"最后关于当前的-pbr-模型\">最后——关于当前的 PBR 模型</h2>\r\n<h2 id=\"references\">References</h2>\r\n<ul>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/416112744\">重新理解 PBR（1） -\r\n知乎 (zhihu.com)</a></li>\r\n<li><a\r\nhref=\"https://learnopengl-cn.github.io/07%20PBR/01%20Theory/\">理论 -\r\nLearnOpenGL CN (learnopengl-cn.github.io)</a></li>\r\n<li></li>\r\n</ul>\r\n","text":"PBR PBR，或者用更通俗一些的称呼是指基于物理的渲染(Physically Based Rendering)，它指的是一些在不同程度上都基于与现实世界的物理原理更相符的基本理论所构成的渲染技术的集合。 PBR 综述 PBR 是基于物理的渲染，具体表现为使用一种更符合物理学规律...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pbr\"><span class=\"toc-text\">PBR</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pbr-%E7%BB%BC%E8%BF%B0\"><span class=\"toc-text\">PBR 综述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pbr-%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">PBR 理论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">微平面理论</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%83%BD%E9%87%8F%E5%AE%88%E6%81%92\"><span class=\"toc-text\">能量守恒</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E7%8E%87%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">反射率方程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E8%83%BD%E9%87%8F\"><span class=\"toc-text\">关于能量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#brdf\"><span class=\"toc-text\">BRDF</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cook-torrance-%E5%8F%8D%E5%B0%84%E7%8E%87%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">Cook-Torrance 反射率方程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#d%E6%B3%95%E7%BA%BF%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0normal-distribution-functionndf\"><span class=\"toc-text\">D：法线分布函数(Normal\r\nDistribution Function，NDF)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#g%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">G：几何分布函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#f%E8%8F%B2%E6%B6%85%E5%B0%94%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">F：菲涅尔方程</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99-pbr-%E6%9D%90%E8%B4%A8\"><span class=\"toc-text\">编写 PBR 材质</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E5%90%88-ibl\"><span class=\"toc-text\">结合 IBL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%84%E8%AE%A1%E7%AE%97%E6%BC%AB%E5%8F%8D%E5%B0%84%E9%A1%B9\"><span class=\"toc-text\">预计算漫反射项</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%96%B9%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%94%B9%E5%8F%98\"><span class=\"toc-text\">对方程的一些小改变</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A2%84%E8%AE%A1%E7%AE%97%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">预计算思路</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%84%E8%AE%A1%E7%AE%97%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">预计算镜面反射</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A2%84%E6%BB%A4%E6%B3%A2%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE\"><span class=\"toc-text\">预滤波环境贴图</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ggx-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7\"><span class=\"toc-text\">GGX 重要性采样</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8D%95%E8%8E%B7%E9%A2%84%E8%BF%87%E6%BB%A4-mipmap-%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">捕获预过滤 mipmap 级别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%84%E8%BF%87%E6%BB%A4%E5%8D%B7%E7%A7%AF%E7%9A%84%E4%BC%AA%E5%83%8F\"><span class=\"toc-text\">预过滤卷积的伪像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%97%E7%B3%99%E5%BA%A6%E7%9A%84%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE%E6%8E%A5%E7%BC%9D\"><span class=\"toc-text\">高粗糙度的立方体贴图接缝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%84%E8%BF%87%E6%BB%A4%E5%8D%B7%E7%A7%AF%E7%9A%84%E4%BA%AE%E7%82%B9\"><span class=\"toc-text\">预过滤卷积的亮点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86\"><span class=\"toc-text\">蒙特卡洛积分</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7\"><span class=\"toc-text\">重要性采样</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BD%8E%E5%B7%AE%E5%BC%82%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">低差异序列</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84-pbr-%E6%9E%84%E5%BB%BA\"><span class=\"toc-text\">一个完整的 PBR 构建</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99-pbr-shader---%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">编写 PBR Shader -\r\n渲染方程的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B7%E4%BD%93%E7%AE%80%E5%8C%96\"><span class=\"toc-text\">实现内容的具体简化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">实现流程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%90%8E%E5%85%B3%E4%BA%8E%E5%BD%93%E5%89%8D%E7%9A%84-pbr-%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">最后——关于当前的 PBR 模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#references\"><span class=\"toc-text\">References</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Shaderlab 总览及其基本执行逻辑","uid":"3efe5f95488e956915246e267ac83bb6","slug":"Rendering/Shaderlab","date":"2023-05-02T04:23:23.000Z","updated":"2023-10-27T20:14:20.000Z","comments":true,"path":"api/articles/Rendering/Shaderlab.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Shaderlab 总览及其基本执行逻辑 Shaderlab 结构总览 Shaderlab 是 Unity 所使用的，独立的着色器语言。这是一种跨平台的语言体系，大体包含四部分： ShaderLab Text ShaderLab Compiler ShaderLab Asset ...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Mapcap","uid":"e381c275e6062a6db30ed6f89e560299","slug":"Rendering/Mapcap","date":"2023-04-29T04:23:23.000Z","updated":"2023-10-27T20:19:51.000Z","comments":true,"path":"api/articles/Rendering/Mapcap.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"What is Mapcap? MatCap is a method of light expression using pre-rendered images. This technique uses a picture of a sphere that represents ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"Unity","slug":"Unity","count":17,"path":"api/categories/Unity.json"},{"name":"Shader","slug":"Unity/Shader","count":7,"path":"api/categories/Unity/Shader.json"}],"tags":[{"name":"Unity","slug":"Unity","count":17,"path":"api/tags/Unity.json"},{"name":"Shader","slug":"Shader","count":33,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}