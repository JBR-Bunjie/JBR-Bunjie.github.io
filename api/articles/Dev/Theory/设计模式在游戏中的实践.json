{"title":"设计模式在游戏编程中的实践","uid":"d603f61c6dd6ebd8e3ed06a28bd85050","slug":"Dev/Theory/设计模式在游戏中的实践","date":"2023-02-02T04:23:23.000Z","updated":"2023-10-27T19:44:35.000Z","comments":true,"path":"api/articles/Dev/Theory/设计模式在游戏中的实践.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"设计模式在游戏编程中的实践\">设计模式在游戏编程中的实践</h1>\r\n<h2 id=\"设计模式\">设计模式</h2>\r\n<h3 id=\"命令模式\">命令模式</h3>\r\n<blockquote>\r\n<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；\r\n对请求排队或记录请求日志，以及支持可撤销的操作。</p>\r\n</blockquote>\r\n<p>命令模式至少包含这样几个部分：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://www.runoob.com/wp-content/uploads/2014/08/commanduml.jpg\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h4 id=\"介绍\">介绍</h4>\r\n<p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>\r\n<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>\r\n<p><strong>何时使用：</strong>在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>\r\n<p><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者\r\n→ 命令 → 接受者。</p>\r\n<p><strong>关键代码：</strong>定义三个角色：1、received\r\n真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p>\r\n<p><strong>应用实例：</strong>struts 1 中的 action 核心控制器\r\nActionServlet 只有一个，相当于\r\nInvoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的\r\nCommand。</p>\r\n<p><strong>优点：</strong> 1、降低了系统耦合度。\r\n2、新的命令可以很容易添加到系统中去。</p>\r\n<p><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。</p>\r\n<p><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如：\r\n1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p>\r\n<p><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p>\r\n<h4 id=\"使用命令模式之前...\">使用命令模式之前...</h4>\r\n<blockquote>\r\n<p>在每个游戏中都有一块代码读取用户的输入——按钮按下，键盘敲击，鼠标点击，诸如此类。\r\n这块代码会获取用户的输入，然后将其变为游戏中有意义的行为</p>\r\n<figure>\r\n<img src=\"https://gpp.tkchu.me/images/command-buttons-one.png\"\r\nalt=\"一个手柄, A键调用swapWeapon()，B键调用lurch()，X键调用jump()，Y键调用fireGun()。\" />\r\n<figcaption aria-hidden=\"true\">一个手柄,\r\nA键调用swapWeapon()，B键调用lurch()，X键调用jump()，Y键调用fireGun()。</figcaption>\r\n</figure>\r\n</blockquote>\r\n<p>如果对这样一个功能作出实现的话，最简单的实现也许是如下所示的：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void InputHandler::handleInput() &#123;\n  if (isPressed(BUTTON_X)) jump();\n  else if (isPressed(BUTTON_Y)) fireGun();\n  else if (isPressed(BUTTON_A)) swapWeapon();\n  else if (isPressed(BUTTON_B)) lurchIneffectively();\n&#125;</code></pre>\r\n<p>它能实现我们的功能没错，但我们至少能发现这里的耦合度太高了，事实上，这里在实际游玩中，还不能允许玩家修改键位等等。要想实现更多的功能，我们就得将这里的代码解耦——这个时候命令模式就出场了。</p>\r\n<p>命令模式有好几种实现思路，但是它们都有一些共性</p>\r\n<h4 id=\"命令基类-抽象命令类\">命令基类 / 抽象命令类</h4>\r\n<p>这一般是一个抽象类或接口，在其中声明了用于执行请求的\r\nexecute()等方法，通过这些方法可以调用请求接收者的相关操作。</p>\r\n<p>这部分的示例如下：</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Command &#123;\npublic:\n  virtual ~Command() &#123;&#125;\n  virtual void execute() &#x3D; 0;\n&#125;;</code></pre>\r\n<h4 id=\"具体命令类\">具体命令类</h4>\r\n<p>我们根据实际需求，对基类进行实现</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class JumpCommand : public Command &#123;\npublic:\n  virtual void execute() &#123; jump(); &#125;\n&#125;;\n\nclass FireCommand : public Command &#123;\npublic:\n  virtual void execute() &#123; fireGun(); &#125;\n&#125;;z&#96;</code></pre>\r\n<p>这一部分往往是存在很多变化的：也许我们会设立</p>\r\n<h4 id=\"调用部分-请求部分\">调用部分 / 请求部分</h4>\r\n<p>在代码的输入处理部分，为每个按键存储一个指向命令的指针。</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class InputHandler\n&#123;\npublic:\n  void handleInput();\n\n  &#x2F;&#x2F; 绑定命令的方法……\n\nprivate:\n  Command* buttonX_;\n  Command* buttonY_;\n  Command* buttonA_;\n  Command* buttonB_;\n&#125;;</code></pre>\r\n<p>并对于这个接收输入的部分，我们将其修改为：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void InputHandler::handleInput() &#123;\n  if (isPressed(BUTTON_X)) buttonX_-&gt;execute();\n  else if (isPressed(BUTTON_Y)) buttonY_-&gt;execute();\n  else if (isPressed(BUTTON_A)) buttonA_-&gt;execute();\n  else if (isPressed(BUTTON_B)) buttonB_-&gt;execute();\n&#125;</code></pre>\r\n<p>到这里，我们已经实现了这个应用中的解耦了——我们不关心我们具体调用的是什么方法，我们只需要知道，这就是我们需要的方法就行。</p>\r\n<p>但是这里还可以有一个问题，之所以说“可以有”，是因为这里</p>\r\n<h4 id=\"接收部分\">接收部分</h4>\r\n<blockquote>\r\n<p>接收者执行与请求相关的操作，它具体实现对请求的业务处理。</p>\r\n</blockquote>\r\n<p>我们得根据实际情况判断我们是否真的需要这一部分：我们所谓的接收部分，往往就是我们实际的\r\nGameObject，也就是说，这一部分决定了我们到底想要我们的功能对于谁生效——譬如我们在上一部分中的第一个例子，我们可以发现这样一个问题：我们假设了顶层的<code>jump()</code>,\r\n<code>fireGun()</code>之类的函数是用于找到玩家角色的——这些假定同样产生了耦合，而这些耦合限制了这些命令的用处——<code>JumpCommand</code>只能让玩家的角色跳跃。</p>\r\n<p>让我们将这个接收命令的 GameObject\r\n暴露出来，将函数控制的角色对象传进去——这需要修改一下前面的代码：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 抽象类部分\nclass Command &#123;\npublic:\n  virtual ~Command() &#123;&#125;\n  virtual void execute(GameObject&amp; character) &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F; Jump\nclass JumpCommand : public Command &#123;\npublic:\n  virtual void execute(GameActor&amp; actor) &#123;\n    actor.jump();\n  &#125;\n&#125;;\n\n&#x2F;&#x2F; handle\nCommand* InputHandler::handleInput() &#123;\n  if (isPressed(BUTTON_X)) return buttonX_;\n  if (isPressed(BUTTON_Y)) return buttonY_;\n  if (isPressed(BUTTON_A)) return buttonA_;\n  if (isPressed(BUTTON_B)) return buttonB_;\n\n  &#x2F;&#x2F; 没有按下任何按键，就什么也不做\n  return NULL;\n&#125;\n\n&#x2F;&#x2F; 接收部分\nCommand* command &#x3D; inputHandler.handleInput();\nif (command) &#123;\n  command-&gt;execute(actor);\n&#125;</code></pre>\r\n<p>需要注意两点：</p>\r\n<ul>\r\n<li>不管我们有没有暴露作用对象，我们实际产生影响的\r\nCode，是存在于我们的接收部分中的</li>\r\n<li>在新的实例中，我们的功能不是立即执行的——我们会延迟到调用执行时再知道</li>\r\n</ul>\r\n<p>对于传入 GameObject\r\n的情况，我们成功扩大了这个模板的可用性：即使是对于\r\nAI，我们也只需编写适用于它们的<code>Command</code>对象，就可以复用它。</p>\r\n<blockquote>\r\n<p>把控制角色的命令变为第一公民对象，去除直接方法调用中严厉的束缚。\r\n将其视为命令队列，或者是命令流：</p>\r\n<figure>\r\n<img src=\"https://gpp.tkchu.me/images/command-stream.png\"\r\nalt=\"一条连接AI到角色的管道。\" />\r\n<figcaption aria-hidden=\"true\">一条连接AI到角色的管道。</figcaption>\r\n</figure>\r\n<p>一些代码（输入控制器或者 AI）产生一系列命令放入流中。\r\n另一些代码（调度器或者角色自身）调用并消耗命令。\r\n通过在中间加入队列，我们解耦了消费者和生产者。</p>\r\n</blockquote>\r\n<h4 id=\"撤销和重做\">撤销和重做</h4>\r\n<p>我想，命令模式最广泛的用例应该是用于实现撤销和重做功能了。</p>\r\n<p>由于在本模式中，我们天然地将一个过程的进行拆分成了命令发出和命令执行两部分，那我们就可以很方便地记录命令的发出内容，并以此为作为回滚的依据。</p>\r\n<p>我们已经使用了命令来抽象输入控制，所以每个玩家的举动都已经被封装其中。\r\n举个例子，移动一个单位的代码可能如下：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 注意这和前面的命令有些许不同：在前面的例子中，我们需要从修改的角色那里抽象命令; 在这个例子中，我们将命令绑定到要移动的单位上。\n&#x2F;&#x2F; 这条命令的实例不是通用的“移动某物”命令；而是游戏回合中特殊的一次移动\nclass MoveUnitCommand : public Command &#123;\npublic:\n  MoveUnitCommand(Unit* unit, int x, int y)\n  : unit_(unit),\n    x_(x),\n    y_(y)\n  &#123;&#125;\n\n  virtual void execute() &#123;\n    unit_-&gt;moveTo(x_, y_);\n  &#125;\n\nprivate:\n  Unit* unit_;\n  int x_, y_;\n&#125;;</code></pre>\r\n<p>这展现了命令模式应用时的一种情形。\r\n就像之前的例子，指令在某些情形中是可重用的对象，代表了可执行的事件。\r\n我们早期的输入控制器将其实现为一个命令对象，然后在按键按下时调用其<code>execute()</code>方法。</p>\r\n<p>这里的命令更加特殊。它们代表了特定时间点能做的特定事件。\r\n这意味着输入控制代码可以在玩家下决定时<em>创造</em>一个实例。就像这样：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Command* handleInput()\n&#123;\n  Unit* unit &#x3D; getSelectedUnit();\n\n  if (isPressed(BUTTON_UP)) &#123;\n    &#x2F;&#x2F; 向上移动单位\n    int destY &#x3D; unit-&gt;y() - 1;\n    return new MoveUnitCommand(unit, unit-&gt;x(), destY);\n  &#125;\n\n  if (isPressed(BUTTON_DOWN)) &#123;\n    &#x2F;&#x2F; 向下移动单位\n    int destY &#x3D; unit-&gt;y() + 1;\n    return new MoveUnitCommand(unit, unit-&gt;x(), destY);\n  &#125;\n\n  &#x2F;&#x2F; 其他的移动……\n\n  return NULL;\n&#125;</code></pre>\r\n<p>命令的一次性为我们很快地赢得了一个优点。\r\n为了让指令可被取消，我们为每个类定义另一个需要实现的方法：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Command\n&#123;\npublic:\n  virtual ~Command() &#123;&#125;\n  virtual void execute() &#x3D; 0;\n  virtual void undo() &#x3D; 0;\n&#125;;</code></pre>\r\n<p><code>undo()</code>方法回滚了<code>execute()</code>方法造成的游戏状态改变。\r\n这里是添加了撤销功能后的移动命令：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MoveUnitCommand : public Command\n&#123;\npublic:\n  MoveUnitCommand(Unit* unit, int x, int y)\n  : unit_(unit),\n    xBefore_(0),\n    yBefore_(0),\n    x_(x),\n    y_(y)\n  &#123;&#125;\n\n  virtual void execute()\n  &#123;\n    &#x2F;&#x2F; 保存移动之前的位置\n    &#x2F;&#x2F; 这样之后可以复原。\n\n    xBefore_ &#x3D; unit_-&gt;x();\n    yBefore_ &#x3D; unit_-&gt;y();\n\n    unit_-&gt;moveTo(x_, y_);\n  &#125;\n\n  virtual void undo()\n  &#123;\n    unit_-&gt;moveTo(xBefore_, yBefore_);\n  &#125;\n\nprivate:\n  Unit* unit_;\n  int xBefore_, yBefore_;\n  int x_, y_;\n&#125;;</code></pre>\r\n<p>注意我们为类添加了更多的状态。\r\n当单位移动时，它忘记了它之前是什么样的。\r\n如果我们想要撤销这个移动，我们需要记得单位之前的状态，也就是<code>xBefore_</code>和<code>yBefore_</code>的作用。</p>\r\n<p>由于命令趋向于修改对象状态的一小部分，对数据其他部分的快照就是浪费内存。手动内存管理的消耗更小。<em><a\r\nhref=\"http://en.wikipedia.org/wiki/Persistent_data_structure\">持久化数据结构</a></em>是另一个选项。\r\n使用它，每次修改对象都返回一个新对象，保持原来的对象不变。巧妙的实现下，这些新对象与之前的对象共享数据，所以比克隆整个对象开销更小。使用持久化数据结构，每条命令都存储了命令执行之前对象的引用，而撤销只是切换回之前的对象。</p>\r\n<p>为了让玩家撤销移动，我们记录了执行的最后命令。当他们按下<code>control+z</code>时，我们调用命令的<code>undo()</code>方法。\r\n（如果他们已经撤销了，那么就变成了“重做”，我们会再一次执行命令。）</p>\r\n<p>支持多重的撤销也不太难。\r\n我们不单单记录最后一条指令，还要记录指令列表，然后用一个引用指向“当前”的那个。\r\n当玩家执行一条命令，我们将其添加到列表，然后将代表“当前”的指针指向它。</p>\r\n<figure>\r\n<img src=\"https://gpp.tkchu.me/images/command-undo.png\"\r\nalt=\"从旧到新排列的命令栈。 一个当前箭头指向一条命令，一个“撤销”箭头指向之前的命令，一个“重做”指向之后的命令\" />\r\n<figcaption aria-hidden=\"true\">从旧到新排列的命令栈。\r\n一个当前箭头指向一条命令，一个“撤销”箭头指向之前的命令，一个“重做”指向之后的命令</figcaption>\r\n</figure>\r\n<p>当玩家选择“撤销”，我们撤销现在的命令，将代表当前的指针往后退。\r\n当他们选择“重做”，我们将代表当前的指针往前进，执行该指令。\r\n如果在撤销后选择了新命令，那么清除命令列表中当前的指针所指命令之后的全部命令。</p>\r\n<p>第一次在关卡编辑器中实现这点时，我觉得自己简直就是个天才。\r\n我惊讶于它如此的简明有效。\r\n你需要约束自己，保证每个数据修改都通过命令完成，一旦你做到了，余下的都很简单。</p>\r\n<h3 id=\"享元模式\">享元模式</h3>\r\n<p>享元模式最直接的影响就是数据复用：</p>\r\n<blockquote>\r\n<p>迷雾散尽，露出了古朴庄严的森林。古老的铁杉，在头顶编成绿色穹顶。\r\n阳光在树叶间破碎成金色顶棚。从树干间远眺，远处的森林渐渐隐去。</p>\r\n<p>这是我们游戏开发者梦想的超凡场景，这样的场景通常由一个模式支撑着，它的名字低调至极：享元模式。</p>\r\n<p>用几句话就能描述一片巨大的森林，但是在实时游戏中做这件事就完全是另外一件事了。\r\n当屏幕上需要显示一整个森林时，图形程序员看到的是每秒需要送到 GPU\r\n六十次的百万多边形——我们讨论的是成千上万的树，每棵都由上千的多边形组成。\r\n就算有足够的<em>内存</em>描述森林，渲染的过程中，CPU 到 GPU\r\n的部分也太过繁忙了。</p>\r\n<p>让我们仔细分析一下这个场景——每棵树都有：</p>\r\n<ul>\r\n<li>定义树干，树枝和树叶形状的多边形网格。</li>\r\n<li>树皮和树叶的纹理。</li>\r\n<li>在森林中树的位置和朝向。</li>\r\n<li>大小和色彩之类的调节参数，让每棵树都看起来与众不同。</li>\r\n</ul>\r\n<p>如果用代码表示，那么会得到这样的东西：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Tree &#123;\nprivate:\n  Mesh mesh_;\n  Texture bark_;\n  Texture leaves_;\n  Vector position_;\n  double height_;\n  double thickness_;\n  Color barkTint_;\n  Color leafTint_;\n&#125;;</code></pre>\r\n<p>这是一大堆数据，多边形网格和纹理体积非常大。\r\n描述整个森林的对象在一帧的时间就交给 GPU 实在是太过了。\r\n幸运的是，有一种老办法来处理它：<strong>关键点在于，哪怕森林里有千千万万的树，它们大多数长得一模一样。\r\n它们使用了相同的网格和纹理。\r\n这意味着这些树的实例的大部分字段是<em>一样的</em>。</strong></p>\r\n<blockquote>\r\n<p>你要么是疯了，要么是亿万富翁，才能让美术给森林里每棵树建立独立模型。</p>\r\n</blockquote>\r\n<p><img src=\"https://gpp.tkchu.me/images/flyweight-trees.png\"\r\nalt=\"一行树，每棵都有自己的网格、纹理、树叶，调节参数和位置朝向。\" />注意每一棵树的小盒子中的东西都是一样的。</p>\r\n<p><strong>我们可以通过显式地将对象切为两部分来更加明确地模拟。</strong></p>\r\n<p>第一，将树共有的数据拿出来分离到另一个类中：</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class TreeModel &#123;\nprivate:\n  Mesh mesh_;\n  Texture bark_;\n  Texture leaves_;\n&#125;;</code></pre>\r\n<p>游戏只需要一个这种类，\r\n因为没有必要在内存中把相同的网格和纹理重复一千遍。\r\n游戏世界中每个树的实例只需有一个对这个共享<code>TreeModel</code>的<em>引用</em>。\r\n留在<code>Tree</code>中的是那些实例相关的数据：</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Tree &#123;\nprivate:\n  TreeModel* model_;\n\n  Vector position_;\n  double height_;\n  double thickness_;\n  Color barkTint_;\n  Color leafTint_;\n&#125;;</code></pre>\r\n<p>你可以将其想象成这样：</p>\r\n<figure>\r\n<img src=\"https://gpp.tkchu.me/images/flyweight-tree-model.png\"\r\nalt=\"一行树，每个都有自己的参数和位置朝向，指向另一个有网格、纹理、树叶的树模型。\" />\r\n<figcaption\r\naria-hidden=\"true\">一行树，每个都有自己的参数和位置朝向，指向另一个有网格、纹理、树叶的树模型。</figcaption>\r\n</figure>\r\n<p>不过，虽然把所有的东西都存在主存里没什么问题，但是这对渲染也毫无帮助——在森林到屏幕上之前，它得先到\r\nGPU。我们需要用显卡可以识别的方式共享数据。</p>\r\n<p>为了减少需要推送到 GPU\r\n的数据量，我们想把共享的数据——<code>TreeModel</code>——只发送<em>一次</em>。\r\n然后再分别发送每个树独特的数据——位置，颜色，大小。 最后，我们告诉\r\nGPU，“使用同一模型渲染每个实例”。</p>\r\n<p>幸运的是，今日的图形接口和显卡正好支持这一点。\r\n这些细节很繁琐且超出了这部书的范围，但是 Direct3D 和 OpenGL 都可以做<a\r\nhref=\"http://en.wikipedia.org/wiki/Geometry_instancing\"><em>实例渲染</em></a>。</p>\r\n<p>在这些 API 中，你需要提供两部分数据流。\r\n第一部分是一块需要渲染多次的共同数据——在例子中是树的网格和纹理。\r\n第二部分是实例的列表以及绘制第一部分时需要使用的参数。\r\n然后调用一次渲染，绘制整个森林。</p>\r\n<p>这个 API 是由显卡直接实现的，我们可以说，享元模式是唯一的有硬件支持的\r\nGoF 设计模式。</p>\r\n</blockquote>\r\n<h4 id=\"介绍-1\">介绍</h4>\r\n<p>好了，我们已经看了一个具体的例子，下面我介绍模式的通用部分。\r\n享元，就像它的名字暗示的那样，\r\n当你需要共享类时使用，通常是因为你有太多这种类了。</p>\r\n<p>实例渲染时，每棵树通过总线送到 GPU\r\n消耗的更多是<em>时间</em>而非内存，但是基本要点是一样的。</p>\r\n<p>这个模式通过将对象的数据分为两种来解决这个问题。\r\n第一种数据没有特定指明是哪个对象的<em>实例</em>，因此可以在它们间分享。\r\nGof 称之为<em>固有</em>状态，但是我更喜欢将其视为“上下文无关”部分。\r\n在这里的例子中，是树的网格和纹理。</p>\r\n<p>数据的剩余部分是<em>变化</em>状态，那些每个实例独一无二的东西。\r\n在这个例子中，是每棵树的位置，拉伸和颜色。\r\n就像这里的示例代码块一样，这种模式通过在每个对象出现时共享一份固有状态来节约内存。</p>\r\n<p>就目前而言，这看上去像是基础的资源共享，很难被称为一种模式。\r\n部分原因是在这个例子中，我们可以为共享状态划出一个清晰的<em>身份</em>：<code>TreeModel</code>。</p>\r\n<p>我发现，当共享对象没有有效定义的实体时，使用这种模式就不那么明显（使用它也就越发显得精明）。\r\n在那些情况下，这看上去是一个对象被魔术般地同时分配到了多个地方。\r\n让我展示给你另外一个例子。</p>\r\n<h4 id=\"合理示例\">合理示例</h4>\r\n<p>这些树长出来的地方也需要在游戏中表示。\r\n这里可能有草，泥土，丘陵，湖泊，河流，以及其它任何你可以想到的地形。\r\n我们<em>基于区块</em>建立地表：世界的表面被划分为由微小区块组成的巨大网格。\r\n每个区块都由一种地形覆盖。</p>\r\n<p>每种地形类型都有一系列特性会影响游戏玩法：</p>\r\n<ul>\r\n<li>决定了玩家能够多快地穿过它的移动开销。</li>\r\n<li>表明能否用船穿过的水域标识。</li>\r\n<li>用来渲染它的纹理。</li>\r\n</ul>\r\n<p>基于前面的教训，我们不会在每个区块中保存这些状态。\r\n相反，一个通用的方式是为每种地形使用一个枚举。</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">enum Terrain &#123;\n  TERRAIN_GRASS,\n  TERRAIN_HILL,\n  TERRAIN_RIVER\n  &#x2F;&#x2F; 其他地形\n&#125;;</code></pre>\r\n<p>然后，世界管理巨大的网格：</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class World &#123;\nprivate:\n  Terrain tiles_[WIDTH][HEIGHT];\n&#125;;</code></pre>\r\n<blockquote>\r\n<p>这里我使用嵌套数组存储 2D 网格。 在\r\nC/C++中这样是很有效率的，因为它会将所有元素打包在一起。 在 Java\r\n或者其他内存管理语言中，那样做会实际给你一个数组，其中每个元素都是对数组的列的<em>引用</em>，那就不像你想要的那样内存友好了。</p>\r\n<p>反正，隐藏 2D 网格数据结构背后的实现细节，能使代码更好地工作。\r\n我这里这样做只是为了让其保持简单。</p>\r\n</blockquote>\r\n<p>为了获得区块的实际有用的数据，我们做了一些这样的事情：</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">int World::getMovementCost(int x, int y) &#123;\n  switch (tiles_[x][y]) &#123;\n    case TERRAIN_GRASS: return 1;\n    case TERRAIN_HILL:  return 3;\n    case TERRAIN_RIVER: return 2;\n      &#x2F;&#x2F; 其他地形……\n  &#125;\n&#125;\n\nbool World::isWater(int x, int y) &#123;\n  switch (tiles_[x][y]) &#123;\n    case TERRAIN_GRASS: return false;\n    case TERRAIN_HILL:  return false;\n    case TERRAIN_RIVER: return true;\n      &#x2F;&#x2F; 其他地形……\n  &#125;\n&#125;</code></pre>\r\n<p>你知道我的意思了。这可行，但是我觉得很丑。\r\n移动开销和水域标识是区块的<em>数据</em>，但在这里它们散布在代码中。\r\n更糟的是，简单地形的数据被众多方法拆开了。\r\n如果能够将这些包裹起来就好了。毕竟，那是我们设计对象的目的。</p>\r\n<p>如果我们有实际的地形<em>类</em>就好了，像这样：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Terrain &#123;\npublic:\n  Terrain(int movementCost,\n          bool isWater,\n          Texture texture)\n  : movementCost_(movementCost),\n    isWater_(isWater),\n    texture_(texture)\n  &#123;&#125;\n\n  int getMovementCost() const &#123; return movementCost_; &#125;\n  bool isWater() const &#123; return isWater_; &#125;\n  const Texture&amp; getTexture() const &#123; return texture_; &#125;\n\nprivate:\n  int movementCost_;\n  bool isWater_;\n  Texture texture_;\n&#125;;</code></pre>\r\n<p>你会注意这里所有的方法都是<code>const</code>。这不是巧合。\r\n由于同一对象在多处引用，如果你修改了它， 改变会同时在多个地方出现。</p>\r\n<p>这也许不是你想要的。\r\n通过分享对象来节约内存的这种优化，不应该影响到应用的显性行为。\r\n因此，享元对象几乎总是不可变的。</p>\r\n<p>但是我们不想为每个区块都保存一个实例。\r\n如果你看看这个类内部，你会发现里面实际上<em>什么也没有</em>，\r\n唯一特别的是区块在<em>哪里</em>。\r\n用享元的术语讲，区块的<em>所有</em>状态都是“固有的”或者说“上下文无关的”。</p>\r\n<p>鉴于此，我们没有必要保存多个同种地形类型。 地面上的草区块两两无异。\r\n我们不用地形区块对象枚举构成世界网格，而是用<code>Terrain</code>对象<em>指针</em>组成网格：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class World\n&#123;\nprivate:\n  Terrain* tiles_[WIDTH][HEIGHT];\n\n  &#x2F;&#x2F; 其他代码……\n&#125;;</code></pre>\r\n<p>每个相同地形的区块会指向相同的地形实例。</p>\r\n<figure>\r\n<img src=\"https://gpp.tkchu.me/images/flyweight-tiles.png\"\r\nalt=\"一行区块，每个区块指向共享的草、河、山丘对象。\" />\r\n<figcaption\r\naria-hidden=\"true\">一行区块，每个区块指向共享的草、河、山丘对象。</figcaption>\r\n</figure>\r\n<p>由于地形实例在很多地方使用，如果你想要动态分配，它们的生命周期会有点复杂。\r\n因此，我们直接在游戏世界中存储它们。</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class World\n&#123;\npublic:\n  World()\n  : grassTerrain_(1, false, GRASS_TEXTURE),\n    hillTerrain_(3, false, HILL_TEXTURE),\n    riverTerrain_(2, true, RIVER_TEXTURE)\n  &#123;&#125;\n\nprivate:\n  Terrain grassTerrain_;\n  Terrain hillTerrain_;\n  Terrain riverTerrain_;\n\n  &#x2F;&#x2F; 其他代码……\n&#125;;</code></pre>\r\n<p>然后我们可以像这样来描绘地面：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void World::generateTerrain()\n&#123;\n  &#x2F;&#x2F; 将地面填满草皮.\n  for (int x &#x3D; 0; x &lt; WIDTH; x++)\n  &#123;\n    for (int y &#x3D; 0; y &lt; HEIGHT; y++)\n    &#123;\n      &#x2F;&#x2F; 加入一些丘陵\n      if (random(10) &#x3D;&#x3D; 0)\n      &#123;\n        tiles_[x][y] &#x3D; &amp;hillTerrain_;\n      &#125;\n      else\n      &#123;\n        tiles_[x][y] &#x3D; &amp;grassTerrain_;\n      &#125;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 放置河流\n  int x &#x3D; random(WIDTH);\n  for (int y &#x3D; 0; y &lt; HEIGHT; y++) &#123;\n    tiles_[x][y] &#x3D; &amp;riverTerrain_;\n  &#125;\n&#125;</code></pre>\r\n<p>我承认这不是世界上最好的地形生成算法。</p>\r\n<p>现在不需要<code>World</code>中的方法来接触地形属性，我们可以直接暴露出<code>Terrain</code>对象。</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const Terrain&amp; World::getTile(int x, int y) const\n&#123;\n  return *tiles_[x][y];\n&#125;</code></pre>\r\n<p>用这种方式，<code>World</code>不再与各种地形的细节耦合。\r\n如果你想要某一区块的属性，可直接从那个对象获得：</p>\r\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int cost &#x3D; world.getTile(2, 3).getMovementCost();</code></pre>\r\n<p>我们回到了操作实体对象的\r\nAPI，几乎没有额外开销——指针通常不比枚举大。</p>\r\n<h3 id=\"观察者模式\">观察者模式</h3>\r\n<p>观察者模式是 C#中的一个基本模式，已经以 <code>event</code>\r\n语法的形式嵌入了整个语言中。</p>\r\n<h4 id=\"引入\">引入</h4>\r\n<blockquote>\r\n<p>假设我们向游戏中添加了成就系统。\r\n它存储了玩家可以完成的各种各样的成就，比如“杀死 1000\r\n只猴子恶魔”，“从桥上掉下去”，或者“一命通关”。</p>\r\n<p><img src=\"https://gpp.tkchu.me/images/observer-weasel-wielder.png\"\r\nalt=\"成就：一无所成\" /> 我发誓画的这个没有第二个意思，笑。</p>\r\n<p>要实现这样一个包含各种行为来解锁成就的系统是很有技巧的。\r\n如果我们不够小心，成就系统会缠绕在代码库的每个黑暗角落。\r\n当然，“从桥上掉落”和物理引擎相关，\r\n但我们并不想看到在处理撞击代码的线性代数时，\r\n有个对<code>unlockFallOffBridge()</code>的调用是不？</p>\r\n<p>我们喜欢的是，照旧，让关注游戏一部分的所有代码集成到一块。挑战在于，成就在游戏的不同层面被触发。怎么解耦成就系统和其他部分呢？</p>\r\n<p>这就是观察者模式出现的原因。这让代码宣称有趣的事情发生了，<em>而不必关心到底是谁接受了通知。</em></p>\r\n<p>举个例子，有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。\r\n为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。\r\n相反，可以这样做：</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">void Physics::updateEntity(Entity&amp; entity) &#123;\n  bool wasOnSurface &#x3D; entity.isOnSurface();\n  entity.accelerate(GRAVITY);\n  entity.update();\n  if (wasOnSurface &amp;&amp; !entity.isOnSurface()) &#123;\n    notify(entity, EVENT_START_FALL);\n  &#125;\n&#125;\n&#x2F;&#x2F; 物理引擎确实决定了要发送什么通知，所以这并没有完全解耦。但在架构这个领域，通常只能让系统变得*更好*，而不是*完美*。</code></pre>\r\n<p>它做的就是声称，“额，我不知道有谁感兴趣，但是这个东西刚刚掉下去了。做你想做的事吧。”</p>\r\n<p>成就系统注册它自己为观察者，这样无论何时物理代码发送通知，成就系统都能收到。\r\n它可以检查掉落的物体是不是我们的失足英雄，\r\n他之前有没有做过这种不愉快的与桥的经典力学遭遇。\r\n如果满足条件，就伴着礼花和炫光解锁合适的成就，而这些都无需牵扯到物理代码。</p>\r\n<p>事实上，我们可以改变成就的集合或者删除整个成就系统，而不必修改物理引擎。\r\n它仍然会发送它的通知，哪怕实际没有东西接收。</p>\r\n</blockquote>\r\n<h4 id=\"介绍-2\">介绍</h4>\r\n<p>在观察者模式中，我们理所当然地存在两个主要对象：观察者和被观察者</p>\r\n<p>我们可以这样简单归纳这两者的关系：观察者订阅被观察者的状态，当被观察者状态改变时，被观察者主动通知所有订阅的观察者。</p>\r\n<h5 id=\"观察者\">观察者</h5>\r\n<p>我们从那个需要知道别的对象做了什么事的类开始。\r\n这些好打听的对象用如下接口定义：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Observer\n&#123;\npublic:\n  virtual ~Observer() &#123;&#125;\n  virtual void onNotify(const Entity&amp; entity, Event event) &#x3D; 0;\n&#125;;</code></pre>\r\n<p>任何实现了这个的具体类就成为了观察者。\r\n在我们的例子中，是成就系统，所以我们可以像这样实现：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Achievements : public Observer &#123;\npublic:\n  virtual void onNotify(const Entity&amp; entity, Event event) &#123;\n    switch (event) &#123;\n    case EVENT_ENTITY_FELL:\n      if (entity.isHero() &amp;&amp; heroIsOnBridge_) &#123;\n        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);\n      &#125;\n      break;\n\n      &#x2F;&#x2F; 处理其他事件，更新heroIsOnBridge_变量……\n    &#125;\n  &#125;\n\nprivate:\n  void unlock(Achievement achievement) &#123;\n    &#x2F;&#x2F; 如果还没有解锁，那就解锁成就……\n  &#125;\n\n  bool heroIsOnBridge_;\n&#125;;</code></pre>\r\n<h5 id=\"被观察者\">被观察者</h5>\r\n<p>被观察的对象拥有通知的方法函数，用 GoF 的说法，那些对象被称为“主题”。\r\n它有两个任务。首先，它有一个列表，保存默默等它通知的观察者：</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Subject\n&#123;\nprivate:\n  Observer* observers_[MAX_OBSERVERS];\n  int numObservers_;\n&#125;;</code></pre>\r\n<p>重点是被观察者暴露了<em>公开的</em>API 来修改这个列表：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Subject &#123;\npublic:\n  void addObserver(Observer* observer) &#123;\n    &#x2F;&#x2F; 添加到数组中……\n  &#125;\n\n  void removeObserver(Observer* observer) &#123;\n    &#x2F;&#x2F; 从数组中移除……\n  &#125;\n\n  &#x2F;&#x2F; 其他代码……\n&#125;;</code></pre>\r\n<p>这就允许了外界代码控制谁接收通知。\r\n*被观察者与观察者交流，但是不与它们<strong>耦合*</strong>。\r\n在我们的例子中，没有一行物理代码会提及成就。\r\n但它仍然可以与成就系统交流。这就是这个模式的聪慧之处。</p>\r\n<p>被观察者有一<em>列表</em>观察者而不是单个观察者也是很重要的。\r\n这保证了观察者不会相互干扰。\r\n举个例子，假设音频引擎也需要观察坠落事件来播放合适的音乐。\r\n如果客体只支持单个观察者，当音频引擎注册时，就会<em>取消</em>成就系统的注册。这意味着这两个系统需要相互交互——而且是用一种极其糟糕的方式，\r\n第二个注册时会使第一个的注册失效。\r\n支持一列表的观察者保证了每个观察者都是被独立处理的。\r\n就它们各自的视角来看，自己是这世界上唯一看着被观察者的。</p>\r\n<p>被观察者的剩余任务就是发送通知：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Subject &#123;\nprotected:\n  void notify(const Entity&amp; entity, Event event) &#123;\n    for (int i &#x3D; 0; i &lt; numObservers_; i++) &#123;\n      observers_[i]-&gt;onNotify(entity, event);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 其他代码…………\n&#125;;</code></pre>\r\n<p>现在，我们只需要给物理引擎和这些挂钩，这样它可以发送消息，\r\n成就系统可以和引擎连线来接受消息。\r\n我们按照传统的<em>设计模式</em>方法实现，继承<code>Subject</code>：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Physics : public Subject &#123;\npublic:\n  void updateEntity(Entity&amp; entity);\n&#125;;</code></pre>\r\n<p>这让我们将<code>notify()</code>实现为了<code>Subject</code>内的保护方法。\r\n这样派生的物理引擎类可以调用并发送通知，但是外部的代码不行。\r\n同时，<code>addObserver()</code>和<code>removeObserver()</code>是公开的，\r\n所以任何可以接触物理引擎的东西都可以观察它。</p>\r\n<p>在真实代码中，我会避免使用这里的继承。\r\n相反，我会让<code>Physics</code> <em>有</em>\r\n一个<code>Subject</code>的实例。\r\n不再是观察物理引擎本身，被观察的会是独立的“下落事件”对象。\r\n观察者可以用像这样注册它们自己：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">physics.entityFell()\n  .addObserver(this);</code></pre>\r\n<p>对我而言，这是“观察者”系统与“事件”系统的不同之处。\r\n使用前者，你观察<em>做了有趣事情的事物</em>。\r\n使用后者，你观察的对象代表了<em>发生的有趣事情</em>。</p>\r\n<p>现在，当物理引擎做了些值得关注的事情，它调用<code>notify()</code>，就像之前的例子。\r\n它遍历了观察者列表，通知所有观察者。</p>\r\n<figure>\r\n<img src=\"https://gpp.tkchu.me/images/observer-list.png\"\r\nalt=\"被观察者包含一列表观察者的指针。前两个指向成就和音频系统。\" />\r\n<figcaption\r\naria-hidden=\"true\">被观察者包含一列表观察者的指针。前两个指向成就和音频系统。</figcaption>\r\n</figure>\r\n<p>很简单，对吧？只要一个类管理一列表指向接口实例的指针。\r\n难以置信的是，如此直观的东西是无数程序和应用框架交流的主心骨。</p>\r\n<p>观察者模式不是完美无缺的。当我问其他程序员怎么看，他们提出了一些抱怨。\r\n让我们看看可以做些什么来处理这些抱怨。</p>\r\n<h4 id=\"观察者模式的一般实现\">观察者模式的一般实现</h4>\r\n<p>创建 Subject 类：</p>\r\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.ArrayList;\nimport java.util.List;\n\npublic class Subject &#123;\n   private List&lt;Observer&gt; observers  &#x3D; new ArrayList&lt;Observer&gt;();\n   private int state;\n\n   public int getState() &#123;\n      return state;\n   &#125;\n\n   public void setState(int state) &#123;\n      this.state &#x3D; state;\n      notifyAllObservers();\n   &#125;\n\n   public void attach(Observer observer)&#123;\n      observers.add(observer);\n   &#125;\n\n   public void notifyAllObservers()&#123;\n      for (Observer observer : observers) &#123;\n         observer.update();\n      &#125;\n   &#125;\n&#125;</code></pre>\r\n<p>创建 Observer 类：</p>\r\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class Observer &#123;\n   protected Subject subject;\n   public abstract void update();\n&#125;</code></pre>\r\n<p>创建实体观察者类：</p>\r\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BinaryObserver extends Observer&#123;\n   public BinaryObserver(Subject subject)&#123;\n      this.subject &#x3D; subject;\n      this.subject.attach(this);\n   &#125;\n   @Override\n   public void update() &#123;\n      System.out.println( &quot;Binary String: &quot; + Integer.toBinaryString( subject.getState() ) );\n   &#125;\n&#125;\n\npublic class OctalObserver extends Observer&#123;\n   public OctalObserver(Subject subject)&#123;\n      this.subject &#x3D; subject;\n      this.subject.attach(this);\n   &#125;\n   @Override\n   public void update() &#123;\n     System.out.println( &quot;Octal String: &quot; + Integer.toOctalString( subject.getState() ) );\n   &#125;\n&#125;\n\npublic class HexaObserver extends Observer&#123;\n   public HexaObserver(Subject subject)&#123;\n      this.subject &#x3D; subject;\n      this.subject.attach(this);\n   &#125;\n   @Override\n   public void update() &#123;\n      System.out.println( &quot;Hex String: &quot; + Integer.toHexString( subject.getState() ).toUpperCase() );\n   &#125;\n&#125;</code></pre>\r\n<p>使用 <em>Subject</em> 和实体观察者对象：</p>\r\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ObserverPatternDemo &#123;\n   public static void main(String[] args) &#123;\n      Subject subject &#x3D; new Subject();\n\n      new HexaObserver(subject);\n      new OctalObserver(subject);\n      new BinaryObserver(subject);\n\n      System.out.println(&quot;First state change: 15&quot;);\n      subject.setState(15);\n      System.out.println(&quot;Second state change: 10&quot;);\n      subject.setState(10);\n   &#125;\n&#125;</code></pre>\r\n<p>执行程序，输出结果：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">First state change: 15\nHex String: F\nOctal String: 17\nBinary String: 1111\nSecond state change: 10\nHex String: A\nOctal String: 12\nBinary String: 1010</code></pre>\r\n<h3 id=\"原型模式\">原型模式</h3>\r\n<blockquote>\r\n<p>原型模式（Prototype\r\nPattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。这种模式实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。</p>\r\n</blockquote>\r\n<h4 id=\"正式采用原型设计模式\">正式采用原型设计模式</h4>\r\n<p>原型模式的关键思路是<em>一个对象可以产出与它自己相近的对象。</em>\r\n如果你有一个恶灵，你可以制造更多恶灵。\r\n如果你有一个恶魔，你可以制造其他恶魔。\r\n任何怪物都可以被视为<em>原型</em>怪物，产出其他版本的自己。</p>\r\n<p>为了实现这个功能，我们给基类<code>Monster</code>添加一个抽象方法<code>clone()</code>：</p>\r\n<p>创建一个顶级的基类</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Monster\n&#123;\npublic:\n  virtual ~Monster() &#123;&#125;\n  virtual Monster* clone() &#x3D; 0;\n\n  &#x2F;&#x2F; 其他代码……\n&#125;;</code></pre>\r\n<p>每个怪兽子类提供一个特定实现，返回与它自己的类和状态都完全一样的新对象。举个例子：</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Ghost : public Monster &#123;\npublic:\n  Ghost(int health, int speed)\n  : health_(health),\n    speed_(speed)\n  &#123;&#125;\n  &#x2F;&#x2F; 关键在于特定实现中覆写的clone方法\n  virtual Monster* clone() &#123;\n    return new Ghost(health_, speed_);\n  &#125;\n\nprivate:\n  int health_;\n  int speed_;\n&#125;;</code></pre>\r\n<p>一旦我们所有的怪物都支持这个，\r\n我们不再需要为每个怪物类创建生产者类。我们只需定义一个类：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Spawner\n&#123;\npublic:\n  Spawner(Monster* prototype)\n  : prototype_(prototype)\n  &#123;&#125;\n\n  Monster* spawnMonster()\n  &#123;\n    return prototype_-&gt;clone();\n  &#125;\n\nprivate:\n  Monster* prototype_;\n&#125;;</code></pre>\r\n<p>它内部存有一个怪物，一个隐藏的怪物，\r\n它唯一的任务就是被生产者当做模板，去产生更多一样的怪物，\r\n有点像一个从来不离开巢穴的蜂后。</p>\r\n<figure>\r\n<img src=\"https://gpp.tkchu.me/images/prototype-spawner.png\"\r\nalt=\"一个生产者包含一个对怪物应用的原型字段。 他调用原型的clone()方法来产生新的怪物。\" />\r\n<figcaption aria-hidden=\"true\">一个生产者包含一个对怪物应用的原型字段。\r\n他调用原型的clone()方法来产生新的怪物。</figcaption>\r\n</figure>\r\n<p>为了得到恶灵生产者，我们创建一个恶灵的原型实例，然后创建拥有这个实例的生产者：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Monster* ghostPrototype &#x3D; new Ghost(15, 3);\nSpawner* ghostSpawner &#x3D; new Spawner(ghostPrototype);</code></pre>\r\n<p>这个模式的灵巧之处在于它不但拷贝原型的<em>类</em>，也拷贝它的<em>状态</em>。\r\n这就意味着我们可以创建一个生产者，生产快速鬼魂，虚弱鬼魂，慢速鬼魂，而只需创建一个合适的原型鬼魂。</p>\r\n<p>我在这个模式中找到了一些既优雅又令人惊叹的东西。\r\n我无法想象自己是如何创造出它们的，但我更无法想象<em>不知道</em>这些东西的自己该如何是好。</p>\r\n<blockquote>\r\n<p><strong>效果如何?</strong></p>\r\n<p>好吧，我们不需要为每个怪物创建单独的生产者类，那很好。\r\n但我们<em>确实</em>需要在每个怪物类中实现<code>clone()</code>。\r\n这和使用生产者方法比起来也没节约多少代码量。</p>\r\n<p>当你坐下来试着写一个正确的<code>clone()</code>，会遇见令人不快的语义漏洞。\r\n做深层拷贝还是浅层拷贝呢？换言之，如果恶魔拿着叉子，克隆恶魔也要克隆叉子吗？</p>\r\n<p>同时，这看上去没减少已存问题上的代码，\r\n事实上还增添了些<em>人为的问题</em>。\r\n我们需要将每个怪物有独立的类作为前提条件。\r\n这绝对<em>不是</em>当今大多数游戏引擎运作的方法。</p>\r\n<p>我们中大部分痛苦地学到，这样庞杂的类层次管理起来很痛苦，\r\n那就是我们为什么用<a\r\nhref=\"https://gpp.tkchu.me/component.html\">组件模式</a>和<a\r\nhref=\"https://gpp.tkchu.me/type-object.html\">类型对象</a>为不同的实体建模，这样无需一一建构自己的类。</p>\r\n</blockquote>\r\n<h4 id=\"用原型模式来优化数据结构\">用原型模式来优化数据结构</h4>\r\n<p>随着编程的进行，如果你比较程序与数据的字节数，\r\n那么你会发现数据的占比稳定地增长。\r\n早期的游戏在程序中生成几乎所有东西，这样程序可以塞进磁盘和老式游戏卡带。\r\n在今日的游戏中，代码只是驱动游戏的“引擎”，游戏是完全由数据定义的。</p>\r\n<p>这很好，但是将内容推到数据文件中并不能魔术般地解决组织大项目的挑战。\r\n它只能把这挑战变得更难。\r\n我们使用高级编程语言就因为它们有办法管理复杂性：不再是将一堆代码拷来拷去，我们将其移入函数中，通过名字调用。\r\n不再是在一堆类之间复制方法，我们将其放入单独的类中，让其他类可以继承或者组合。</p>\r\n<p>让我们在游戏中考虑考虑：使用原型和委托来重用数据。</p>\r\n<p>游戏中的哥布林也许被定义为像这样的东西：</p>\r\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;name&quot;: &quot;goblin grunt&quot;,\n  &quot;minHealth&quot;: 20,\n  &quot;maxHealth&quot;: 30,\n  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],\n  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]\n&#125;</code></pre>\r\n<p>这看上去很易懂，哪怕是最讨厌文本的设计者也能使用它。\r\n所以，你可以给哥布林大家族添加几个兄弟分支：</p>\r\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;name&quot;: &quot;goblin wizard&quot;,\n  &quot;minHealth&quot;: 20,\n  &quot;maxHealth&quot;: 30,\n  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],\n  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;],\n  &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]\n&#125;\n\n&#123;\n  &quot;name&quot;: &quot;goblin archer&quot;,\n  &quot;minHealth&quot;: 20,\n  &quot;maxHealth&quot;: 30,\n  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],\n  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;],\n  &quot;attacks&quot;: [&quot;short bow&quot;]\n&#125;</code></pre>\r\n<p>现在，如果这是代码，我们会闻到了臭味。\r\n在实体间有很多的重复，训练优良的程序员<em>讨厌</em>重复。\r\n它浪费了空间，消耗了作者更多时间。\r\n你需要仔细阅读代码才知道这些数据<em>是不是</em>相同的。 这难以维护。\r\n如果我们决定让所有哥布林变强，需要记得将三个哥布林都更新一遍。糟糕糟糕糟糕。</p>\r\n<p>如果这是代码，我们会为“哥布林”构建抽象，并在三个哥布林类型中重用。\r\n但是无能的 JSON 没法这么做。所以让我们把它做得更加巧妙些。</p>\r\n<p><strong>我们可以为对象添加<code>\"prototype\"</code>字段，记录委托对象的名字。\r\n如果在此对象内没找到一个字段，那就去委托对象中查找。</strong></p>\r\n<p>这样，我们可以简化我们的哥布林 JSON 内容：</p>\r\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;name&quot;: &quot;goblin grunt&quot;,\n  &quot;minHealth&quot;: 20,\n  &quot;maxHealth&quot;: 30,\n  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],\n  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]\n&#125;\n\n&#123;\n  &quot;name&quot;: &quot;goblin wizard&quot;,\n  &quot;prototype&quot;: &quot;goblin grunt&quot;,\n  &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]\n&#125;\n\n&#123;\n  &quot;name&quot;: &quot;goblin archer&quot;,\n  &quot;prototype&quot;: &quot;goblin grunt&quot;,\n  &quot;attacks&quot;: [&quot;short bow&quot;]\n&#125;</code></pre>\r\n<p>由于弓箭手和术士都将 grunt 作为\r\n<code>原型</code>，我们就不需要在它们中重复血量，防御和弱点。\r\n我们为数据模型增加的逻辑超级简单——基本的单一委托——但已经成功摆脱了一堆冗余。</p>\r\n<p>有趣的事情是，我们没有更进一步，把哥布林委托的<em>抽象</em>原型设置成“基本哥布林”。\r\n相反，我们选择了最简单的哥布林，然后委托给它。</p>\r\n<p>在基于原型的系统中，对象可以克隆产生新对象是很自然的，\r\n我认为在这里也一样自然。这特别适合记录那些只有一处不同的实体的数据。</p>\r\n<p>想想 Boss 和其他独特的事物，它们通常是更加常见事物的重新定义，\r\n原型委托是定义它们的好方法。\r\n断头魔剑，就是一把拥有加成的长剑，可以像下面这样表示：</p>\r\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;name&quot;: &quot;Sword of Head-Detaching&quot;,\n  &quot;prototype&quot;: &quot;longsword&quot;,\n  &quot;damageBonus&quot;: &quot;20&quot;\n&#125;</code></pre>\r\n<p>只需在游戏引擎上多花点时间，你就能让设计者更加方便地添加不同的武器和怪物，而增加的这些丰富度能够取悦玩家。</p>\r\n<h3 id=\"单例模式\">单例模式</h3>\r\n<p><em>设计模式</em> 像这样描述单例模式：</p>\r\n<blockquote>\r\n<p>保证一个类只有一个实例，并且提供了访问该实例的全局访问点。</p>\r\n</blockquote>\r\n<p>我们从“并且”那里将句子分为两部分，分别进行考虑。</p>\r\n<h4 id=\"保证一个类只有一个实例\"><a\r\nhref=\"https://gpp.tkchu.me/singleton.html#保证一个类只有一个实例\">保证一个类只有一个实例</a></h4>\r\n<p>有时候，如果类存在多个实例就不能正确的运行。\r\n通常发生在类与保存全局状态的外部系统互动时。</p>\r\n<p>考虑封装文件系统的 API 类。\r\n因为文件操作需要一段时间完成，所以类使用异步操作。\r\n这就意味着可以同时运行多个操作，必须让它们相互协调。\r\n如果一个操作创建文件，另一个操作删除同一文件，封装器类需要同时考虑，保证它们没有相互妨碍。</p>\r\n<p>为了实现这点，对我们封装器类的调用必须接触之前的每个操作。\r\n如果用户可以自由地创建类的实例，这个实例就无法知道另一实例之前的操作。\r\n而单例模式提供的构建类的方式，在编译时保证类只有单一实例。</p>\r\n<h4 id=\"提供了访问该实例的全局访问点\"><a\r\nhref=\"https://gpp.tkchu.me/singleton.html#提供了访问该实例的全局访问点\">提供了访问该实例的全局访问点</a></h4>\r\n<p>游戏中的不同系统都会使用文件系统封装类：日志，内容加载，游戏状态保存，等等。\r\n如果这些系统不能创建文件系统封装类的实例，它们如何访问该实例呢？</p>\r\n<p>单例为这点也提供了解决方案。\r\n除了创建单一实例以外，它也提供了一种获得它的全局方法。\r\n使用这种范式，无论何处何人都可以访问实例。\r\n综合起来，经典的实现方案如下：</p>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class FileSystem &#123;\npublic:\n  static FileSystem&amp; instance() &#123;\n    &#x2F;&#x2F; 惰性初始化\n    if (instance_ &#x3D;&#x3D; NULL) instance_ &#x3D; new FileSystem();\n    return *instance_;\n  &#125;\n\nprivate:\n  FileSystem() &#123;&#125;\n\n  static FileSystem* instance_;\n&#125;;</code></pre>\r\n<p>静态的<code>instance_</code>成员保存了一个类的实例，\r\n私有的构造器保证了它是<em>唯一</em>的。\r\n公开的静态方法<code>instance()</code>让任何地方的代码都能访问实例。\r\n在首次被请求时，它同样负责惰性实例化该单例。</p>\r\n<p>现代的实现方案看起来是这样的：</p>\r\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class FileSystem &#123;\npublic:\n  static FileSystem&amp; instance() &#123;\n    static FileSystem *instance &#x3D; new FileSystem();\n    return *instance;\n  &#125;\n\nprivate:\n  FileSystem() &#123;&#125;\n&#125;;</code></pre>\r\n<p>哪怕是在多线程情况下，C++11 标准也保证了本地静态变量只会初始化一次，\r\n因此，假设你有一个现代\r\nC++编译器，这段代码是线程安全的，而前面的那个例子不是。</p>\r\n<h4 id=\"c\">C</h4>\r\n<p>Double Check 的懒汉模式</p>\r\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public sealed class Singleton &#123;\n    private static volatile Singleton _instance;\n    private static readonly object _lockObject &#x3D; new Object();\n\n    public static Singleton Instance &#123;\n        get &#123;\n            if (_instance &#x3D;&#x3D; null) &#123;\n                lock (_lockObject) &#123;\n                    if (_instance &#x3D;&#x3D; null) &#123; _instance &#x3D; new Singleton(); &#125;\n                &#125;\n            &#125;\n            return _instance;\n        &#125;\n    &#125;\n&#125;</code></pre>\r\n<p>Lazy&lt;T&gt;的懒汉模式</p>\r\n<pre class=\"line-numbers language-C#\" data-language=\"C#\"><code class=\"language-C#\">public class LazySingleton &#123;\n    private static readonly Lazy&lt;LazySingleton&gt; _instance &#x3D; new Lazy&lt;LazySingleton&gt;(() &#x3D;&gt; new LazySingleton());\n\n    public static LazySingleton Instance &#123;\n        get &#123; return _instance.Value; &#125;\n    &#125;\n\n    private LazySingleton() &#123; &#125;\n&#125;</code></pre>\r\n<p><a\r\nhref=\"https://www.programming-books.io/essential/csharp/lazy-thread-safe-singleton-using-lazyt-d94da571077a42519f1a67c1b4b23584\">Lazy\r\nthread-safe Singleton using LazyT (programming-books.io)</a></p>\r\n<blockquote>\r\n<p>.Net 4.0 type Lazy guarantees thread-safe object initialization, so\r\nthis type could be used to make Singletons.</p>\r\n<p>Using <code>Lazy&lt;T&gt;</code> will make sure that the object is\r\nonly instantiated when it is used somewhere in the calling code.</p>\r\n</blockquote>\r\n<h4 id=\"单例模式的弊端\">单例模式的弊端</h4>\r\n<h3 id=\"状态模式\">状态模式</h3>\r\n<p>我们用状态模式来解决繁复状态切换的代码，这种模式与状态机的构造紧密相连。</p>\r\n<h2 id=\"reference\">Reference</h2>\r\n<ul>\r\n<li><a href=\"https://gpp.tkchu.me/\">游戏编程模式 (tkchu.me)</a></li>\r\n<li><a\r\nhref=\"https://www.runoob.com/design-pattern/design-pattern-tutorial.html\">设计模式\r\n| 菜鸟教程 (runoob.com)</a></li>\r\n</ul>\r\n","text":"设计模式在游戏编程中的实践 设计模式 命令模式 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化； 对请求排队或记录请求日志，以及支持可撤销的操作。 命令模式至少包含这样几个部分： img 介绍 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[{"name":"Theroy","slug":"Theroy","count":5,"path":"api/categories/Theroy.json"}],"tags":[{"name":"Theroy","slug":"Theroy","count":5,"path":"api/tags/Theroy.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">设计模式在游戏编程中的实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">命令模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%89%8D...\"><span class=\"toc-text\">使用命令模式之前...</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%B1%BB-%E6%8A%BD%E8%B1%A1%E5%91%BD%E4%BB%A4%E7%B1%BB\"><span class=\"toc-text\">命令基类 &#x2F; 抽象命令类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E5%91%BD%E4%BB%A4%E7%B1%BB\"><span class=\"toc-text\">具体命令类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E9%83%A8%E5%88%86-%E8%AF%B7%E6%B1%82%E9%83%A8%E5%88%86\"><span class=\"toc-text\">调用部分 &#x2F; 请求部分</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E6%94%B6%E9%83%A8%E5%88%86\"><span class=\"toc-text\">接收部分</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%92%A4%E9%94%80%E5%92%8C%E9%87%8D%E5%81%9A\"><span class=\"toc-text\">撤销和重做</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">享元模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D-1\"><span class=\"toc-text\">介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%90%86%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">合理示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">观察者模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">引入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D-2\"><span class=\"toc-text\">介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85\"><span class=\"toc-text\">观察者</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85\"><span class=\"toc-text\">被观察者</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">观察者模式的一般实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">原型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%BC%8F%E9%87%87%E7%94%A8%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">正式采用原型设计模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%A8%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%9D%A5%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">用原型模式来优化数据结构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">单例模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">保证一个类只有一个实例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%90%E4%BE%9B%E4%BA%86%E8%AE%BF%E9%97%AE%E8%AF%A5%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BF%E9%97%AE%E7%82%B9\"><span class=\"toc-text\">提供了访问该实例的全局访问点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#c\"><span class=\"toc-text\">C</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%8A%E7%AB%AF\"><span class=\"toc-text\">单例模式的弊端</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">状态模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"主流 Anti-Aliasing 算法及原理概览","uid":"bbf9542302ac0838c1965dd8fababb22","slug":"Rendering/主流AA算法及原理","date":"2023-02-25T04:23:23.000Z","updated":"2023-11-07T12:45:24.496Z","comments":true,"path":"api/articles/Rendering/主流AA算法及原理.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"主流 Anti-Aliasing 算法及原理概览 https://zhuanlan.zhihu.com/p/57503957 Spatial Anti-Aliasing SSAA SSAA，即 Super sampling anti-aliasing，有时也称为 full-sce...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"},{"name":"Rendering","slug":"Algorithm/Rendering","count":1,"path":"api/categories/Algorithm/Rendering.json"},{"name":"AA","slug":"Algorithm/Rendering/AA","count":1,"path":"api/categories/Algorithm/Rendering/AA.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"Rendering","slug":"Rendering","count":3,"path":"api/tags/Rendering.json"},{"name":"AA","slug":"AA","count":1,"path":"api/tags/AA.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"龙书 Chapter0. 序章项目的运行","uid":"bde1cebd8cf0309ead488efbe937c7e3","slug":"Language Learning/HLSL/龙书Chapter0","date":"2023-01-02T04:23:23.000Z","updated":"2023-10-27T19:50:16.000Z","comments":true,"path":"api/articles/Language Learning/HLSL/龙书Chapter0.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"龙书 Chapter0. 序章项目的运行 Introduction to 3D Game Programming with DirectX 12 一书学习记录(第一个例子编译错误)_direct3d'&amp;' 需要左值_whoispo 的博客-CSDN 博客 DX12 龙书之...","link":"","photos":[],"count_time":{"symbolsCount":173,"symbolsTime":"1 mins."},"categories":[{"name":"Language Learning","slug":"Language-Learning","count":6,"path":"api/categories/Language-Learning.json"},{"name":"HLSL","slug":"Language-Learning/HLSL","count":1,"path":"api/categories/Language-Learning/HLSL.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"HLSL","slug":"HLSL","count":1,"path":"api/tags/HLSL.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}