{"title":"Setup A Flask Application","uid":"a9c12b026b9f323fd06103f80893c3ae","slug":"Dev/Back End/flask/setup_your_flask","date":"2022-04-23T04:23:23.000Z","updated":"2023-10-27T19:10:26.000Z","comments":true,"path":"api/articles/Dev/Back End/flask/setup_your_flask.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"Setup-A-Flask-Application\"><a href=\"#Setup-A-Flask-Application\" class=\"headerlink\" title=\"Setup A Flask Application\"></a>Setup A Flask Application</h1><h3 id=\"一个简单但完整的示例\"><a href=\"#一个简单但完整的示例\" class=\"headerlink\" title=\"一个简单但完整的示例\"></a>一个简单但完整的示例</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import Flask, jsonify\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    return jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()</code></pre>\n\n<p>此时，当我们访问<code>/api</code>时，应用会返回一个 JSON 映射。</p>\n<ol>\n<li>变量__name__</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>变量__name__是这个应用软件包的名称，而当运行一个单独的 Python 模块时，变量__name__会赋值为__main__</p>\n<p>Flask 会使用这个变量实例化一个新的日志日志记录器(logger)，并在磁盘上定位这个模块所在文件的路径。</p>\n<p>Flask 将使用该文件的目录作为助手程序的根目录(例如与应用程序相关的配置文件)，并根据此目录确定静态文件目录(static)与模板目录(templates)的默认存放位置</p></blockquote>\n<p>在 shell 中运行当前模块时，Flask 会运行其中的内置 Web 服务器，并在默认在 5000 端口监听传入的请求</p>\n<ol start=\"2\">\n<li>访问&#x2F;api</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask# curl -v http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api\n*   Trying 127.0.0.1:5000...\n* Connected to 127.0.0.1 (127.0.0.1) port 5000 (#0)\n&gt; GET &#x2F;api HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5000\n&gt; User-Agent: curl&#x2F;7.81.0\n&gt; Accept: *&#x2F;*\n&gt;\n* Mark bundle as not supporting multiuse\n&lt; HTTP&#x2F;1.1 200 OK\n&lt; Server: Werkzeug&#x2F;2.2.2 Python&#x2F;3.10.4\n&lt; Date: Sat, 10 Sep 2022 11:43:02 GMT\n&lt; Content-Type: application&#x2F;json\n&lt; Content-Length: 19\n&lt; Connection: close\n&lt;\n&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\n* Closing connection 0</code></pre>\n\n<p>可以发现，我们得到了一个合法的 JSON 响应和正确的消息头。</p>\n<ol start=\"3\">\n<li>jsonity 函数</li>\n</ol>\n<p>该函数会将 Python 字典类型转换为合法的 JSON 响应，并在添加适当的 Content-Type 消息头后，将映射信息存储到响应体中</p>\n<h3 id=\"request-对象\"><a href=\"#request-对象\" class=\"headerlink\" title=\"request 对象\"></a>request 对象</h3><p>与大多数 Web 框架不同，flask 不需要显示地将 request 对象传递到代码中——它隐式地提供了一个全局的 request 变量，并用该全局的变量来指向当前的 request 对象。Flask 把传入的 HTTP 请求解析为 WSGI 环境字典，并利用它来创建这个对象</p>\n<p>这样：当服务器的响应不依赖请求的内容时，就没必要处理它。视图只需要确保返回了客户端应该获取的内容，并确保内容能够被 Flask 序列化即可</p>\n<h3 id=\"了解底层到底发生了什么\"><a href=\"#了解底层到底发生了什么\" class=\"headerlink\" title=\"了解底层到底发生了什么\"></a>了解底层到底发生了什么</h3><p>增加 print 方法，了解 curl 访问具体过程</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import Flask, jsonify, request\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    print(request)\n    print(request.environ)\n    response &#x3D; jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n    print(response)\n    print(response.data)\n    return response\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(app.url_map)\n    app.run()</code></pre>\n\n<p>有：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(venv) root@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask&#x2F;chapter2# python app.py\nMap([&lt;Rule &#39;&#x2F;static&#x2F;&lt;filename&gt;&#39; (OPTIONS, GET, HEAD) -&gt; static&gt;,\n &lt;Rule &#39;&#x2F;api&#39; (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])\n * Serving Flask app &#39;app&#39;\n * Debug mode: off\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n * Running on http:&#x2F;&#x2F;127.0.0.1:5000\nPress CTRL+C to quit\n&lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;\n&#123;&#39;wsgi.version&#39;: (1, 0), &#39;wsgi.url_scheme&#39;: &#39;http&#39;, &#39;wsgi.input&#39;: &lt;_io.BufferedReader name&#x3D;4&gt;, &#39;wsgi.errors&#39;: &lt;_io.TextIOWrapper name&#x3D;&#39;&lt;stderr&gt;&#39; mode&#x3D;&#39;w&#39; encoding&#x3D;&#39;utf-8&#39;&gt;, &#39;wsgi.multithread&#39;: True, &#39;wsgi.multiprocess&#39;: False, &#39;wsgi.run_once&#39;: False, &#39;werkzeug.socket&#39;: &lt;socket.socket fd&#x3D;4, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 5000), raddr&#x3D;(&#39;127.0.0.1&#39;, 54614)&gt;, &#39;SERVER_SOFTWARE&#39;: &#39;Werkzeug&#x2F;2.2.2&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_NAME&#39;: &#39;&#39;, &#39;PATH_INFO&#39;: &#39;&#x2F;api&#39;, &#39;QUERY_STRING&#39;: &#39;&#39;, &#39;REQUEST_URI&#39;: &#39;&#x2F;api&#39;, &#39;RAW_URI&#39;: &#39;&#x2F;api&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: 54614, &#39;SERVER_NAME&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;5000&#39;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39;, &#39;HTTP_HOST&#39;: &#39;127.0.0.1:5000&#39;, &#39;HTTP_USER_AGENT&#39;: &#39;curl&#x2F;7.81.0&#39;, &#39;HTTP_ACCEPT&#39;: &#39;*&#x2F;*&#39;, &#39;werkzeug.request&#39;: &lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;&#125;\n&lt;Response 19 bytes [200 OK]&gt;\nb&#39;&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\\n&#39;\n127.0.0.1 - - [10&#x2F;Sep&#x2F;2022 22:55:47] &quot;GET &#x2F;api HTTP&#x2F;1.1&quot; 200 -</code></pre>\n\n<h4 id=\"路由匹配\"><a href=\"#路由匹配\" class=\"headerlink\" title=\"路由匹配\"></a>路由匹配</h4><p>路由匹配发生在 app.url_map 中，这是 Werzeug 中 Map 类的一个实例。<code>Map([&lt;Rule &#39;/static/&lt;filename&gt;&#39; (OPTIONS, GET, HEAD) -&gt; static&gt;, &lt;Rule &#39;/api&#39; (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])</code></p>\n<p>该类使用正则表达式来判定被<code>@app.route</code>装饰的函数时候与传入的请求匹配，路由匹配只会姜茶 route 调用里的路径参数来判断函数时候匹配客户端的请求，默认情况下，声明式路由只支持<code>GET</code>, <code>OPTIONS</code>, <code>HEAD</code>方法的调用，如果使用了不支持的 HTTP 方法，则会出现 405Method Not Allowed 响应，并在 Allow 响应头中返回其所支持的 HTTP 方法列表（正常访问不会出现 Allow 响应头）</p>\n<p>当需要支持指定 HTTP 请求方式时，我们需要给装饰器增加额外的参数：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@app.route(&#39;&#x2F;api&#39;, method&#x3D;[&#39;POST&#39;, &#39;DELETE&#39;, &#39;GET&#39;])</code></pre>\n\n<p>不过，</p>\n<h5 id=\"变量与转换器\"><a href=\"#变量与转换器\" class=\"headerlink\" title=\"变量与转换器\"></a>变量与转换器</h5><p>路由系统支持变量如：<code>/person/&lt;person_id&gt;</code></p>\n<h4 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h4><h4 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h4><h2 id=\"Flask-的内置特性\"><a href=\"#Flask-的内置特性\" class=\"headerlink\" title=\"Flask 的内置特性\"></a>Flask 的内置特性</h2><h2 id=\"微服务骨架\"><a href=\"#微服务骨架\" class=\"headerlink\" title=\"微服务骨架\"></a>微服务骨架</h2><p>拓展：</p>\n<p>这个 <strong>name</strong> 变量可能取什么值？</p>\n<p>当你直接执行一段脚本的时候，这段脚本的 <strong>name</strong>变量等于 <strong>‘main’<strong>，当这段脚本被导入其他程序的时候，</strong>name</strong> 变量等于脚本本身的名字。</p>\n<p>这个 <strong>name</strong> 拿来做什么的？</p>\n<p>作为 Python 的内置变量，<strong>name</strong>变量（前后各有两个下划线）还是挺特殊的。它是每个 Python 模块必备的属性，但它的值取决于你是如何执行这段代码的。</p>\n<p>在许多情况下，你的代码不可能全部都放在同一个文件里，或者你在这个文件里写的函数，在其他地方也可以用到。为了更高效地重用这些代码，你需要在 Python 程序中导入来自其他文件的代码。</p>\n<p>所以，在<strong>name</strong> 变量的帮助下，你可以判断出这时代码是被直接运行，还是被导入到其他程序中去了。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/57309137\">Python 的 <strong>name</strong> 变量，到底是个什么东西？ - 知乎 (zhihu.com)</a></p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><ul>\n<li><a href=\"https://dormousehole.readthedocs.io/en/latest/deploying/index.html\">部署方式</a> 。</li>\n<li><a href=\"https://www.rosehosting.com/blog/how-to-deploy-flask-application-with-nginx-and-gunicorn-on-ubuntu-20-04/\">How to Deploy Flask Application with Nginx and Gunicorn on Ubuntu 20.04 - RoseHosting</a></li>\n</ul>\n","text":"Setup A Flask Application一个简单但完整的示例from flask import Flask, jsonify app &#x3D; Flask(__name__) @app.route(&#39;&#x2F;api&#39;) def my_micros...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"},{"name":"flask","slug":"flask","count":1,"path":"api/tags/flask.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Setup-A-Flask-Application\"><span class=\"toc-text\">Setup A Flask Application</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BD%86%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">一个简单但完整的示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#request-%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">request 对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%86%E8%A7%A3%E5%BA%95%E5%B1%82%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">了解底层到底发生了什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">路由匹配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2%E5%99%A8\"><span class=\"toc-text\">变量与转换器</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">请求</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94\"><span class=\"toc-text\">响应</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Flask-%E7%9A%84%E5%86%85%E7%BD%AE%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Flask 的内置特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AA%A8%E6%9E%B6\"><span class=\"toc-text\">微服务骨架</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">部署</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Download SVG Element As A Pic","uid":"b0ae4fbedb34b36c8057186eece784bd","slug":"Dev/Front End/download svg pic","date":"2022-05-12T19:23:23.000Z","updated":"2023-10-27T19:06:23.000Z","comments":true,"path":"api/articles/Dev/Front End/download svg pic.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Download SVG Element As A PicTHE DEFFERENCE BETWEEN SVG ELEMENT(CODE) AND SVG FILE reference: How can I save svg code as a .svg image? - Sta...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"Javascripts","slug":"Javascripts","count":2,"path":"api/categories/Javascripts.json"}],"tags":[{"name":"Javascripts","slug":"Javascripts","count":3,"path":"api/tags/Javascripts.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Python装饰器","uid":"7c3d41f90666b48d6b76a1cfaa71f837","slug":"Language Learning/Python/装饰器","date":"2022-02-13T04:07:03.000Z","updated":"2023-10-27T20:01:50.000Z","comments":true,"path":"api/articles/Language Learning/Python/装饰器.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Python装饰器1、闭包要想了解装饰器，首先要了解一个概念，闭包。 什么是闭包，一句话说就是，在函数中再嵌套一个函数，并且引用外部函数的变量，这就是一个闭包了。光说没有概念，直接上一个例子。 def outer(x): def inner(y): return x + y re...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":16,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}