{"title":"Setup A Flask Application","uid":"a9c12b026b9f323fd06103f80893c3ae","slug":"Dev/Back End/flask/setup_your_flask","date":"2022-04-23T04:23:23.000Z","updated":"2023-10-27T19:10:26.000Z","comments":true,"path":"api/articles/Dev/Back End/flask/setup_your_flask.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"setup-a-flask-application\">Setup A Flask Application</h1>\r\n<h3 id=\"一个简单但完整的示例\">一个简单但完整的示例</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import Flask, jsonify\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    return jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()</code></pre>\r\n<p>此时，当我们访问<code>/api</code>时，应用会返回一个 JSON 映射。</p>\r\n<ol type=\"1\">\r\n<li>变量__name__</li>\r\n</ol>\r\n<blockquote>\r\n<p>变量__name__是这个应用软件包的名称，而当运行一个单独的 Python\r\n模块时，变量__name__会赋值为__main__</p>\r\n<p>Flask\r\n会使用这个变量实例化一个新的日志日志记录器(logger)，并在磁盘上定位这个模块所在文件的路径。</p>\r\n<p>Flask\r\n将使用该文件的目录作为助手程序的根目录(例如与应用程序相关的配置文件)，并根据此目录确定静态文件目录(static)与模板目录(templates)的默认存放位置</p>\r\n</blockquote>\r\n<p>在 shell 中运行当前模块时，Flask 会运行其中的内置 Web\r\n服务器，并在默认在 5000 端口监听传入的请求</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>访问/api</li>\r\n</ol>\r\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask# curl -v http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api\n*   Trying 127.0.0.1:5000...\n* Connected to 127.0.0.1 (127.0.0.1) port 5000 (#0)\n&gt; GET &#x2F;api HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5000\n&gt; User-Agent: curl&#x2F;7.81.0\n&gt; Accept: *&#x2F;*\n&gt;\n* Mark bundle as not supporting multiuse\n&lt; HTTP&#x2F;1.1 200 OK\n&lt; Server: Werkzeug&#x2F;2.2.2 Python&#x2F;3.10.4\n&lt; Date: Sat, 10 Sep 2022 11:43:02 GMT\n&lt; Content-Type: application&#x2F;json\n&lt; Content-Length: 19\n&lt; Connection: close\n&lt;\n&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\n* Closing connection 0</code></pre>\r\n<p>可以发现，我们得到了一个合法的 JSON 响应和正确的消息头。</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>jsonity 函数</li>\r\n</ol>\r\n<p>该函数会将 Python 字典类型转换为合法的 JSON 响应，并在添加适当的\r\nContent-Type 消息头后，将映射信息存储到响应体中</p>\r\n<h3 id=\"request-对象\">request 对象</h3>\r\n<p>与大多数 Web 框架不同，flask 不需要显示地将 request\r\n对象传递到代码中——它隐式地提供了一个全局的 request\r\n变量，并用该全局的变量来指向当前的 request 对象。Flask 把传入的 HTTP\r\n请求解析为 WSGI 环境字典，并利用它来创建这个对象</p>\r\n<p>这样：当服务器的响应不依赖请求的内容时，就没必要处理它。视图只需要确保返回了客户端应该获取的内容，并确保内容能够被\r\nFlask 序列化即可</p>\r\n<h3 id=\"了解底层到底发生了什么\">了解底层到底发生了什么</h3>\r\n<p>增加 print 方法，了解 curl 访问具体过程</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import Flask, jsonify, request\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    print(request)\n    print(request.environ)\n    response &#x3D; jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n    print(response)\n    print(response.data)\n    return response\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(app.url_map)\n    app.run()</code></pre>\r\n<p>有：</p>\r\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(venv) root@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask&#x2F;chapter2# python app.py\nMap([&lt;Rule &#39;&#x2F;static&#x2F;&lt;filename&gt;&#39; (OPTIONS, GET, HEAD) -&gt; static&gt;,\n &lt;Rule &#39;&#x2F;api&#39; (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])\n * Serving Flask app &#39;app&#39;\n * Debug mode: off\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n * Running on http:&#x2F;&#x2F;127.0.0.1:5000\nPress CTRL+C to quit\n&lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;\n&#123;&#39;wsgi.version&#39;: (1, 0), &#39;wsgi.url_scheme&#39;: &#39;http&#39;, &#39;wsgi.input&#39;: &lt;_io.BufferedReader name&#x3D;4&gt;, &#39;wsgi.errors&#39;: &lt;_io.TextIOWrapper name&#x3D;&#39;&lt;stderr&gt;&#39; mode&#x3D;&#39;w&#39; encoding&#x3D;&#39;utf-8&#39;&gt;, &#39;wsgi.multithread&#39;: True, &#39;wsgi.multiprocess&#39;: False, &#39;wsgi.run_once&#39;: False, &#39;werkzeug.socket&#39;: &lt;socket.socket fd&#x3D;4, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 5000), raddr&#x3D;(&#39;127.0.0.1&#39;, 54614)&gt;, &#39;SERVER_SOFTWARE&#39;: &#39;Werkzeug&#x2F;2.2.2&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_NAME&#39;: &#39;&#39;, &#39;PATH_INFO&#39;: &#39;&#x2F;api&#39;, &#39;QUERY_STRING&#39;: &#39;&#39;, &#39;REQUEST_URI&#39;: &#39;&#x2F;api&#39;, &#39;RAW_URI&#39;: &#39;&#x2F;api&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: 54614, &#39;SERVER_NAME&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;5000&#39;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39;, &#39;HTTP_HOST&#39;: &#39;127.0.0.1:5000&#39;, &#39;HTTP_USER_AGENT&#39;: &#39;curl&#x2F;7.81.0&#39;, &#39;HTTP_ACCEPT&#39;: &#39;*&#x2F;*&#39;, &#39;werkzeug.request&#39;: &lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;&#125;\n&lt;Response 19 bytes [200 OK]&gt;\nb&#39;&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\\n&#39;\n127.0.0.1 - - [10&#x2F;Sep&#x2F;2022 22:55:47] &quot;GET &#x2F;api HTTP&#x2F;1.1&quot; 200 -</code></pre>\r\n<h4 id=\"路由匹配\">路由匹配</h4>\r\n<p>路由匹配发生在 app.url_map 中，这是 Werzeug 中 Map\r\n类的一个实例。<code>Map([&lt;Rule '/static/&lt;filename&gt;' (OPTIONS, GET, HEAD) -&gt; static&gt;, &lt;Rule '/api' (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])</code></p>\r\n<p>该类使用正则表达式来判定被<code>@app.route</code>装饰的函数时候与传入的请求匹配，路由匹配只会姜茶\r\nroute\r\n调用里的路径参数来判断函数时候匹配客户端的请求，默认情况下，声明式路由只支持<code>GET</code>,\r\n<code>OPTIONS</code>, <code>HEAD</code>方法的调用，如果使用了不支持的\r\nHTTP 方法，则会出现 405Method Not Allowed 响应，并在 Allow\r\n响应头中返回其所支持的 HTTP 方法列表（正常访问不会出现 Allow\r\n响应头）</p>\r\n<p>当需要支持指定 HTTP 请求方式时，我们需要给装饰器增加额外的参数：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@app.route(&#39;&#x2F;api&#39;, method&#x3D;[&#39;POST&#39;, &#39;DELETE&#39;, &#39;GET&#39;])</code></pre>\r\n<p>不过，</p>\r\n<h5 id=\"变量与转换器\">变量与转换器</h5>\r\n<p>路由系统支持变量如：<code>/person/&lt;person_id&gt;</code></p>\r\n<h4 id=\"请求\">请求</h4>\r\n<h4 id=\"响应\">响应</h4>\r\n<h2 id=\"flask-的内置特性\">Flask 的内置特性</h2>\r\n<h2 id=\"微服务骨架\">微服务骨架</h2>\r\n<p>拓展：</p>\r\n<p>这个 <strong>name</strong> 变量可能取什么值？</p>\r\n<p>当你直接执行一段脚本的时候，这段脚本的 <strong>name</strong>变量等于\r\n<strong>'main'</strong>，当这段脚本被导入其他程序的时候，<strong>name</strong>\r\n变量等于脚本本身的名字。</p>\r\n<p>这个 <strong>name</strong> 拿来做什么的？</p>\r\n<p>作为 Python\r\n的内置变量，<strong>name</strong>变量（前后各有两个下划线）还是挺特殊的。它是每个\r\nPython 模块必备的属性，但它的值取决于你是如何执行这段代码的。</p>\r\n<p>在许多情况下，你的代码不可能全部都放在同一个文件里，或者你在这个文件里写的函数，在其他地方也可以用到。为了更高效地重用这些代码，你需要在\r\nPython 程序中导入来自其他文件的代码。</p>\r\n<p>所以，在<strong>name</strong>\r\n变量的帮助下，你可以判断出这时代码是被直接运行，还是被导入到其他程序中去了。</p>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/57309137\">Python 的\r\n<strong>name</strong> 变量，到底是个什么东西？ - 知乎\r\n(zhihu.com)</a></p>\r\n<h2 id=\"部署\">部署</h2>\r\n<ul>\r\n<li><a\r\nhref=\"https://dormousehole.readthedocs.io/en/latest/deploying/index.html\">部署方式</a>\r\n。</li>\r\n<li><a\r\nhref=\"https://www.rosehosting.com/blog/how-to-deploy-flask-application-with-nginx-and-gunicorn-on-ubuntu-20-04/\">How\r\nto Deploy Flask Application with Nginx and Gunicorn on Ubuntu 20.04 -\r\nRoseHosting</a></li>\r\n</ul>\r\n","text":"Setup A Flask Application 一个简单但完整的示例 from flask import Flask, jsonify app &#x3D; Flask(__name__) @app.route(&#39;&#x2F;api&#39;) def my_micr...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"},{"name":"flask","slug":"flask","count":1,"path":"api/tags/flask.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#setup-a-flask-application\"><span class=\"toc-text\">Setup A Flask Application</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BD%86%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">一个简单但完整的示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#request-%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">request 对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%86%E8%A7%A3%E5%BA%95%E5%B1%82%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">了解底层到底发生了什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">路由匹配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2%E5%99%A8\"><span class=\"toc-text\">变量与转换器</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">请求</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94\"><span class=\"toc-text\">响应</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#flask-%E7%9A%84%E5%86%85%E7%BD%AE%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Flask 的内置特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AA%A8%E6%9E%B6\"><span class=\"toc-text\">微服务骨架</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">部署</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Download SVG Element As A Pic","uid":"b0ae4fbedb34b36c8057186eece784bd","slug":"Dev/Front End/download svg pic","date":"2022-05-12T19:23:23.000Z","updated":"2023-10-27T19:06:23.000Z","comments":true,"path":"api/articles/Dev/Front End/download svg pic.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Download SVG Element As A Pic THE DEFFERENCE BETWEEN SVG ELEMENT(CODE) AND SVG FILE reference: How can I save svg code as a .svg image? - St...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"Javascripts","slug":"Javascripts","count":2,"path":"api/categories/Javascripts.json"}],"tags":[{"name":"Javascripts","slug":"Javascripts","count":3,"path":"api/tags/Javascripts.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Python装饰器","uid":"7c3d41f90666b48d6b76a1cfaa71f837","slug":"Language Learning/Python/装饰器","date":"2022-02-13T04:07:03.000Z","updated":"2023-10-27T20:01:50.000Z","comments":true,"path":"api/articles/Language Learning/Python/装饰器.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Python装饰器 1、闭包 要想了解装饰器，首先要了解一个概念，闭包。 什么是闭包，一句话说就是，在函数中再嵌套一个函数，并且引用外部函数的变量，这就是一个闭包了。光说没有概念，直接上一个例子。 def outer(x): def inner(y): return x + y ...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Python","slug":"Python","count":9,"path":"api/categories/Python.json"},{"name":"Language Learning","slug":"Python/Language-Learning","count":8,"path":"api/categories/Python/Language-Learning.json"}],"tags":[{"name":"Language Learning","slug":"Language-Learning","count":19,"path":"api/tags/Language-Learning.json"},{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}