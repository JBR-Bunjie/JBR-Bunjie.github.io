{"title":"Hash Function","uid":"991c84bc86acdc32c9243fba302e2655","slug":"Algorithm/HashFunction/HashFunction","date":"2022-12-23T04:23:23.000Z","updated":"2023-11-07T12:40:02.354Z","comments":true,"path":"api/articles/Algorithm/HashFunction/HashFunction.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"简明hash-function教程\">简明Hash function教程</h1>\r\n<div class=\"warning\">\r\n<p>请注意！这篇文档是关于散列函数Hash function的，如果需要了解Hash\r\ntable相关内容请查阅“简明Hash table教程”等相关文章</p>\r\n</div>\r\n<h2 id=\"引子\">引子</h2>\r\n<p>在各种下载站的资源页面下方，经常会有如下以SHA开头的特殊字段</p>\r\n<blockquote>\r\n<p><strong>SHA1：</strong>9B71AD5604B3816BCC7E9AFA3052AE7D823163E8</p>\r\n</blockquote>\r\n<p>或者是或MD5开头的特殊字段</p>\r\n<blockquote>\r\n<p>MD5：124756ef340daf80196b4124686d651c</p>\r\n</blockquote>\r\n<p>这些特殊字段既非下载链接，也特定网址。那么这些特殊的字段都有什么用？</p>\r\n<p>想要解决这个问题，我们需要先了解一下什么是Hash算法</p>\r\n<h2 id=\"hash算法\">Hash算法</h2>\r\n<h3 id=\"什么是hash\">什么是Hash？</h3>\r\n<p>先简单介绍一下Hash算法</p>\r\n<blockquote>\r\n<p><a href=\"https://zh.wikipedia.org/wiki/散列函数\">散列函数</a>（Hash\r\nfunction）又称散列算法、哈希函数，是一种从任何一种数据中创建数字“指纹”的方法。</p>\r\n</blockquote>\r\n<div class=\"tip\">\r\n<p>请注意！Hash算法并非特指某一种算法，而是所有满足Hash算法的一整类算法的统称</p>\r\n</div>\r\n<p>Hash算法的实际效果为：对任意一组输入数据进行计算处理，并最终得到一个固定长度的输出摘要。</p>\r\n<p>经典的比如经MD5算法运算后的结果只有16位或者32位16进制字符，而SHA-1的结果为40位16进制字符</p>\r\n<h3 id=\"试着去生成一串hash-code吧\">试着去生成一串Hash Code吧</h3>\r\n<p>现在打开你的任何一款ide，通过MD5方法来对<code>你好啊</code>这串字符进行处理，如下是Python对之进行处理的例子</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import hashlib\nstr1 &#x3D; &quot;你好呀&quot; # 准备Hash算法需要处理的数据块\nm &#x3D; hashlib.md5() # 确定特定的Hash算法\nm.update(str1.encode(&quot;utf8&quot;)) # 执行该算法\nprint(m.hexdigest(), type(m.hexdigest())) # 查验输出结果\n\n# python提供了一个build-in function：hash，但是它有点特殊，具体了解可以参照下文：\n# https:&#x2F;&#x2F;blog.csdn.net&#x2F;cunchi4221&#x2F;article&#x2F;details&#x2F;107474126</code></pre>\r\n<p>检查一下结果：<code>4f65fdb33e0f2bd0de6bd1b41fdea968 &lt;class 'str'&gt;</code>——一个32个字符，32Byte，128bit大小的字符串，和MD5算法规定的长度完全一致。同时，当我们重复执行这个程序时，我们发现程序最终得到的结果和第一次的结果不变！</p>\r\n<p>是的！更进一步地，当我们的数据和Hash算法确定以后，不管是在本地，还是在别的任何设备上再次执行这串代码，它的结果是不会发生变化的。也就是说，<strong>一个既定的输入在既定的Hash算法中只会对应一个特定的输出</strong></p>\r\n<p>根据这个特点，我们可以用某种特定的Hash算法来检验资源的完整性：当用户完成资源的下载后，如果本地资源使用对应的Hash算法得到的Hash\r\ncode与下载网站上给出的Hash\r\ncode不相符的话，就意味着你的本地资源有问题，需要进行修复或者重新下载</p>\r\n<h3 id=\"hash算法还能干什么\">Hash算法还能干什么？</h3>\r\n<p>事实上，Hash\r\nCode被大量使用于网站的密码加密中：当用户注册的时候，用户的密码通过某种Hash算法加密后得到一串Hash\r\nCode，服务器就将Hash\r\nCode代替明文密码存储到服务器的数据库中，用户登陆时输入的密码经过加密会再次得到相同的结果，这当然与数据库中存储的内容一致，这样子就完成了用户的验证。</p>\r\n<p>由于Hash算法是一种<a href=\"#progress\">有损的压缩运算</a>，即在实时的运算中损失了大部分原始数据，这并不是加密而是摘要，同时也导致得到原数据最直接的方式只有再次输入，想要破解一般只能够依靠穷举。故一般认为Hash算法是不可逆运算，所以即便是服务器数据库泄露也不必担心账号被别人盗取</p>\r\n<h3\r\nid=\"尝试使用hash算法并研究它的输出规律\">尝试使用Hash算法，并研究它的输出规律</h3>\r\n<p>为了研究Hash算法的输出结果的规律，我们需要几个实例</p>\r\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloWorld &#123;\n    public static void main(String []args) &#123;\n\t\tSystem.out.println(&quot;hello, java&quot;.hashCode());\n\t\tSystem.out.println(&quot;hello, java&quot;.hashCode()); &#x2F;&#x2F;相同数据输入，查看结果\n        \n        System.out.println(&quot;---------------------------&quot;);\n\t\t\n\t\tSystem.out.println(&quot;hello, jav&quot;.hashCode());\n\t\tSystem.out.println(&quot;hello, java&quot;.hashCode());\n\t\tSystem.out.println(&quot;hello, javav&quot;.hashCode());\n\t\tSystem.out.println(&quot;AaAaA&quot;.hashCode());  \n\t\tSystem.out.println(&quot;AaAaAa&quot;.hashCode());\n\t\tSystem.out.println(&quot;AaAaAaA&quot;.hashCode()); &#x2F;&#x2F; 不同数据输入，查看结果\n\t\t\n        System.out.println(&quot;---------------------------&quot;);\n\t\t\n\t\tSystem.out.println(&quot;AaAaAa&quot;.hashCode());\n\t\tSystem.out.println(&quot;BBAaBB&quot;.hashCode()); &#x2F;&#x2F; 仍然是不同数据输入，再次查看结果\n    &#125;\n&#125;\n\n&#x2F;* outputs：\n2057144552\n2057144552 &#x2F;&#x2F; 相同的输入经过散列表算法运算后得到了相同的输出\n---------------------------\n-1596208487\n2057144552\n-653028210\n62984129\n1952508096\n398208897 &#x2F;&#x2F; 不同的输入“理所当然”地得到了完全不同的输出\n---------------------------\n1952508096\n1952508096 &#x2F;&#x2F; 不同的输入居然得到了相同的输出！\n*&#x2F;</code></pre>\r\n<p>从以上实例中我们可以发现虽然一般的不同字符经过运算后输出的结果是不同的，但是也存在不同字符串在经过运算后得到了相同的输出</p>\r\n<p>特别地，我们将这种两个不同的输入值经过运算后得到了相同的输入值的情况称作是<strong>“Hash\r\ncollision”</strong></p>\r\n<p>需要指出的是，发生collision并不可怕，当一个更大的数据集被映射到一个更小的数据集或容器时，一定会出现多对一的情况，这是一件不可避免的事，而算法的优劣只取决于出现collision的频率如何。如果collision出现频次过高，那么就意味着这个Hash算法生成的Hash\r\nCode可以在较短时间内被别人使用穷举等办法来破解其内容——也就是说，它不安全，所以用户需要设置更长更复杂组合的密码，而服务器则需要使用更不容易被破解的Hash算法。</p>\r\n<p>一般来讲<strong>输出大小</strong>越长的算法，安全性也就越高。只有安全度足够高的Hash算法，即没有任何人能够成功实现碰撞的哈希，才有资格被考虑用在加密场合</p>\r\n<figure>\r\n<img src=\"../../../images\\Algorithm\\CommonHash.png\"\r\nalt=\"image-20210916211845148\" />\r\n<figcaption aria-hidden=\"true\">image-20210916211845148</figcaption>\r\n</figure>\r\n<p>在<strong>极限情况</strong>下，传统的MD5算法可以保证最多<code>340282366920938463463374607431768211456</code>个数据与结果的一一对应，而SHA-1算法甚至可以保证最多<code>1461501637330902918203684832716283019655932542976</code>个数据，但是由于计算机算力的进步，算法自身的缺陷，现呈的彩虹表等的诸多原因存在，它们已经可以在短时间内被破解，为了保证数据的安全，我们需要使用更安全的Hash算法如SHA-2系列的Hash算法来做数据加密</p>\r\n<h3 id=\"小结\">小结</h3>\r\n<ol type=\"1\">\r\n<li><p>什么是Hash算法？</p>\r\n<ul>\r\n<li>Hash算法，一般译为哈希算法，摘要算法或者散列算法，它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。</li>\r\n</ul></li>\r\n<li><p>哈希算法的特点？</p>\r\n<ul>\r\n<li>相同的输入一定得到相同的输出；</li>\r\n<li>不同的输入大概率得到不同的输出。</li>\r\n</ul></li>\r\n<li><p>哈希加密的作用：</p>\r\n<ul>\r\n<li>完整性校验：MD5，SHA-1</li>\r\n<li>数据加密：SHA-2系列等</li>\r\n</ul></li>\r\n</ol>\r\n<h2 id=\"hash算法是怎么实现的以md5为例\"><span\r\nid=\"progress\">Hash算法是怎么实现的？——以MD5为例</span></h2>\r\n<p>Hash算法原理大同小异，大体上的流程包括对原数据块进行切片，再对切片进行细分，并利用每一细分小组的内容按预设算法进行破坏式压缩处理来得到最终的结果，下面以MD5算法为例介绍Hash算法流程</p>\r\n<h3 id=\"原理概述\">原理概述：</h3>\r\n<p>MD5算法先对数据块填充，将不合规的数据标准化。然后进行分组，标准是每512bit为大小分一组。在每一个分组中又进一步划分出16个32位的子分组。设立四个<a href=\"#variable\">标准幻数</a>，定义四个非线性函数，一个大小为64的常数数组，一个大小为64的位移常量数组。</p>\r\n<p>在计算过程中，根据512位分组的数据进行外循环，在这之中利用每个细分小组进行一轮16次循环一共4轮合64次的内循环。</p>\r\n<p>在单次内部循环中，根据正在进行的轮次运用四个非线性函数中的一个对子分组进行的数据进行处理，将处理的结果与标准幻数相加，并进行下一次循环。当主循环完成时，原标准幻数就与数据紧密联系起来，把所有标准幻数组合到一起，这就是一个基于MD5算法的Hash\r\nCode</p>\r\n<blockquote>\r\n<p><span id=\"variable\">什么是幻数？</span></p>\r\n<p>不同领域对于幻数这一名称有不同的定义，而MD5中的幻数其实就是在算法中被预设的4个32位的整数，对于一个128位的MD5\r\nHash\r\nCode来说，由4个32位的整数结果彼此组和来得到最终结果貌似是一个不错的选择，而这4个结果就是由这4个标准幻数A,B,C,D根据数据块的内容按照预定算法经过不断演变得到的</p>\r\n</blockquote>\r\n<p>实际使用的标准幻数：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">A &#x3D; 0x67452301\nB &#x3D; 0xEFCDAB89\nC &#x3D; 0x98BADCFE\nD &#x3D; 0x10325476 </code></pre>\r\n<p>注意，其实这四个标准幻数和ABCD四个字母全无关系，实际生效的只是他们后面的变量值，而这四个值只是被算法规定如此而已<del><code>也许这也算是一种另类的私货？</code></del></p>\r\n<h3 id=\"详细流程介绍\">详细流程介绍：</h3>\r\n<h4 id=\"填充\">填充</h4>\r\n<p>首先将原数据进行补长（长度的度量是bits）到一个对512取模的结果为448的数<br>在补长的过程中，我们先在原数据末尾append\r\n\"1\" bit to message，然后再append \"0\" bits until message length in bits ≡\r\n448 (mod 512)</p>\r\n<p>完成了补长之后，利用最后的64位（512-448=64）来记录<strong>填充前</strong>的长度(append\r\noriginal length in bits mod 2<sup>64</sup> to message)</p>\r\n<p>当上述两个操作都完成以后，数据的总长度就是512的倍数了</p>\r\n<p>一定要补长(64+1~512)，内容为100…0（如若消息长448，则填充512+64）</p>\r\n<h4 id=\"计算\">计算</h4>\r\n<p>首先把结果分割为N个512位的块：Y0，Y1，…（每一个512位块再细分为16个32比特子组）</p>\r\n<p>每个块都进行一次循环，在当前循环中，我们将整个块再次细分为16个32位的子块</p>\r\n<p>在正式开始循环之前，我们还需要这些东西：</p>\r\n<ul>\r\n<li>设立四个标准幻数</li>\r\n</ul>\r\n<figure>\r\n<img src=\"Initialize.png\" alt=\"image-20210917110650229\" />\r\n<figcaption aria-hidden=\"true\">image-20210917110650229</figcaption>\r\n</figure>\r\n<p>我们无需考究这四个数字的16进制内容有什么含义，但是规律明显得让人不禁发笑</p>\r\n<p>我们分别以ABCD为名设立四个32位的整数变量，A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476，这就是实际使用到的标准幻数</p>\r\n<ul>\r\n<li><p>定义四个非线性函数：</p>\r\n<figure>\r\n<img src=\"../../../images\\Algorithm\\MD5&#39;s%20function.png\"\r\nalt=\"image-20210917103252897\" />\r\n<figcaption aria-hidden=\"true\">image-20210917103252897</figcaption>\r\n</figure></li>\r\n<li><p>定义常量数组(正弦函数表)：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">for i in range(0, 64)\n    k[i] &#x3D; math.floor(math.fabs(math.sin(i + 1)) * (2 ** 32))\n# 或者直接赋值：\nk &#x3D; [\n     0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n      0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,\n      0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n      0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,\n      0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n      0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n      0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n      0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391\n]</code></pre></li>\r\n</ul>\r\n<blockquote>\r\n<p>和为什么标准幻数被定义成那样子一样，解释为什么常量数组是这些东西的理由也只有“它是被定义成这样子的”。不过常量数组有一个优势：我们可以了解这些数字具体是怎么来的：</p>\r\n<p>你应该已经看见了定义常量数组的第一种（即利用正弦函数实时生成的）办法，这就是这些数据产生的来源。</p>\r\n</blockquote>\r\n<ul>\r\n<li><p>定义位移常量:</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># md5转换用到的常量，数据都是算法本身规定的\nr &#x3D; [\n    7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n\t5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n\t4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n\t6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21\n]</code></pre></li>\r\n</ul>\r\n<blockquote>\r\n<p>事实上：所有常量都是经由算法规定的，毕竟只有经过被“规定”的步骤才能保证结果的一致性</p>\r\n</blockquote>\r\n<p>循环计算</p>\r\n<p>循环分为内层和外层，外层是对512块进行循环，内层则对32位子块进行循环</p>\r\n<p>每次外层循环中，我们共会进行四轮内层循环，每次内层循环我们都会按顺序对单个32位子块进行处理</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">for i in outside: # 外层循环\n    for t in range(0, 64): # 内层总循环\n        if 0 ≤ i ≤ 15:\n            f &#x3D; (b &amp; c) | (~b &amp; d) # 临时变量f，实际上是存储了当前轮次的非线性函数的结果\n            g &#x3D; i # 存储当前轮次下的第几次\n        else if 16 ≤ i ≤ 31:\n            f &#x3D; (d &amp; b) | ((~d) &amp; c)\n            g &#x3D; (5×i + 1) % 16\n        else if 32 ≤ i ≤ 47:\n            f &#x3D; b ^ c ^ d\n            g &#x3D; (3×i + 5) % 16\n        else if 48 ≤ i ≤ 63:\n            f &#x3D; c ^ (b | (~ d))\n            g &#x3D; (7×i) % 16\n        temp &#x3D; d\n        d &#x3D; c\n        c &#x3D; b\n        b &#x3D; ((a + f + k[i] + w[g]) &lt;&lt; r[i]) + b\n        # w[g]是当前顺序下的32位数据子块,k[i]是我们已经生成好的常量数组,r[i]则是当前轮次所使用到的左移量\n        a &#x3D; temp\n    A &#x3D; A + a\n    B &#x3D; B + b \n    C &#x3D; C + c\n    D &#x3D; D + d</code></pre>\r\n<p>每次：一个输入128位，另一个输入512位，结果输出128位，用于下一轮输入</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>结果</li>\r\n</ol>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">digest &#x3D; str(A) + str(B) + str(C) + str(D)</code></pre>\r\n<p>//最后一步的输出即为散列结果，共128位。</p>\r\n<p>又如SHA-1等算法原理与MD5大同小异，主要的变化之处在于：增加初始的标准幻数个数，增加循环轮数与参与范围，改变变换的非线性函数等</p>\r\n<h2 id=\"怎么改进hash算法\">怎么改进Hash算法？</h2>\r\n<p>虽然我们认为哈希算法是一种“有损的压缩运算”，但是其攻击手段并不少，而当今Hash解密网站更是不胜枚举</p>\r\n<p><a href=\"https://cmd5.com/\">md5在线解密破解,md5解密加密\r\n(cmd5.com)</a></p>\r\n<h3 id=\"彩虹表\">彩虹表</h3>\r\n<p><a href=\"https://en.wikipedia.org/wiki/Rainbow_table\">Rainbow table -\r\nWikipedia</a></p>\r\n<p><a\r\nhref=\"http://www.ha97.com/4009.html\">（总结）密码破解之王：Ophcrack彩虹表(Rainbow\r\nTables)原理详解（附：120G彩虹表下载） (ha97.com)</a></p>\r\n<p>什么是彩虹表？ - 知乎用户的回答 - 知乎\r\nhttps://www.zhihu.com/question/19790488/answer/19290308</p>\r\n<h3 id=\"加盐salting\">“加盐”(salting)</h3>\r\n<blockquote>\r\n<p>给密码加一个随即的前缀或者后缀，然后再进行hash。这个随即的后缀或者前缀成为“盐”。通过加盐，相同的密码经过hash后就可以得到不一样的字符串了。检查用户输入的密码是否正确的时候，我们也还需要这个盐，所以盐一般都是跟hash一起保存在数据库里，或者作为hash字符串的一部分。</p>\r\n<p>盐不需要保密，只要盐是随机的话，查表，彩虹表都会失效。因为攻击者无法事先知道盐是什么，也就没有办法预先计算出查询表和彩虹表。如果每个用户都是使用了不同的盐，那么反向查表攻击也没法成功。</p>\r\n</blockquote>\r\n<p>因为能取得的“最好的结果”，也就是取得加盐后的密码，那究竟哪部分是我们添加的“盐”呢，黑客不知道</p>\r\n<p>下面是另一角度的思考：</p>\r\n<blockquote>\r\n<p>为什么加盐哈希可以抵御彩虹表</p>\r\n<p>彩虹表在生成的过程中，针对的是特定的函数H，H如果发生了改变，则已有的彩虹表数据就完全无法使用。</p>\r\n<p>生成彩虹表需要先预先选定一些口令，再一步步生成。然而如果加盐的话，会导致之前生成的那些口令都没有用了。（正确的口令需要有加了盐的格式），因此可以抵御彩虹表攻击。</p>\r\n</blockquote>\r\n<p>详见：</p>\r\n<p><a\r\nhref=\"https://wooyun.js.org/drops/加盐hash保存密码的正确方式.html\">加盐hash保存密码的正确方式\r\n- D＆G (wooyun.js.org)</a></p>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/moxuyou-/articles/14209188.html\">彩虹表攻击\r\n- 莫须有- - 博客园 (cnblogs.com)</a></p>\r\n","text":"简明Hash function教程 请注意！这篇文档是关于散列函数Hash function的，如果需要了解Hash table相关内容请查阅“简明Hash table教程”等相关文章 引子 在各种下载站的资源页面下方，经常会有如下以SHA开头的特殊字段 SHA1：9B71AD5...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"Hash","slug":"Hash","count":1,"path":"api/tags/Hash.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%80%E6%98%8Ehash-function%E6%95%99%E7%A8%8B\"><span class=\"toc-text\">简明Hash function教程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%AD%90\"><span class=\"toc-text\">引子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#hash%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Hash算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFhash\"><span class=\"toc-text\">什么是Hash？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%95%E7%9D%80%E5%8E%BB%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%B2hash-code%E5%90%A7\"><span class=\"toc-text\">试着去生成一串Hash Code吧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#hash%E7%AE%97%E6%B3%95%E8%BF%98%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">Hash算法还能干什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8hash%E7%AE%97%E6%B3%95%E5%B9%B6%E7%A0%94%E7%A9%B6%E5%AE%83%E7%9A%84%E8%BE%93%E5%87%BA%E8%A7%84%E5%BE%8B\"><span class=\"toc-text\">尝试使用Hash算法，并研究它的输出规律</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#hash%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BB%A5md5%E4%B8%BA%E4%BE%8B\"><span class=\"toc-text\">Hash算法是怎么实现的？——以MD5为例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">原理概述：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">详细流程介绍：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A1%AB%E5%85%85\"><span class=\"toc-text\">填充</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">计算</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E6%94%B9%E8%BF%9Bhash%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">怎么改进Hash算法？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%A9%E8%99%B9%E8%A1%A8\"><span class=\"toc-text\">彩虹表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E7%9B%90salting\"><span class=\"toc-text\">“加盐”(salting)</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"售货员问题","uid":"ab5351d849d735008d49a961e1e5262a","slug":"Algorithm/DP/Traveling Salesman Problem","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T16:10:04.000Z","comments":true,"path":"api/articles/Algorithm/DP/Traveling Salesman Problem.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"一、题目 一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。 售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。 （等价于求图的最短哈密尔顿回路问题）令G=(V, E)是一个带权重的有向...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"DP","slug":"DP","count":1,"path":"api/tags/DP.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Noise Generate","uid":"e93f281683f5f1e8c6e0ab2a6dab5abb","slug":"Algorithm/NOISE/Noise","date":"2022-12-23T04:23:23.000Z","updated":"2023-11-07T12:40:15.545Z","comments":true,"path":"api/articles/Algorithm/NOISE/Noise.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"噪声 - Noise Randomness is needed to make things unpredictable, varied, and appear natural. ——catlike coding 在任何游戏中，噪声都是不可缺少的存在。因此，了解这些噪声的特点、用...","link":"","photos":[],"count_time":{"symbolsCount":916,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"Noise","slug":"Noise","count":1,"path":"api/tags/Noise.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}