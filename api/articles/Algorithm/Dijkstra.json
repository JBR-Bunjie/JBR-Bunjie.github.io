{"title":"Dijkstra Algorithm","uid":"d42b57b5bace0bb67392a01a7601ad24","slug":"Algorithm/Dijkstra","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:14:51.000Z","comments":true,"path":"api/articles/Algorithm/Dijkstra.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"Dijkstra-算法详解\"><a href=\"#Dijkstra-算法详解\" class=\"headerlink\" title=\"Dijkstra 算法详解\"></a>Dijkstra 算法详解</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Dijkstra 算法是求一个图中一个点到其他所有点的最短路径的算法</p>\n<p>Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 O(n2)</p>\n<p>$$<br>\\begin{align}<br>&amp;(n-1)+(n-2)+···+1\\<br>= &amp;\\frac{n*(n - 1)}{2}\\<br>= &amp;\\frac{n^2}{2} - \\frac{n}{2}\\<br>≈ &amp;n^2<br>\\end{align}<br>$$</p>\n<h2 id=\"主要行为\"><a href=\"#主要行为\" class=\"headerlink\" title=\"主要行为\"></a>主要行为</h2><p>每次从「未求出最短路径的点」中 取出 距离距离起点 最小路径的点，以这个点为桥梁 刷新「未求出最短路径的点」的距离</p>\n<h2 id=\"图解案例分析\"><a href=\"#图解案例分析\" class=\"headerlink\" title=\"图解案例分析\"></a>图解案例分析</h2><h3 id=\"题要\"><a href=\"#题要\" class=\"headerlink\" title=\"题要\"></a>题要</h3><p>以 A 点为顶点，求到其他点的最短路径。</p>\n<p><img src=\"v2-72ddc44daec6a2916724464ec78ba342_1440w.jpg\" alt=\"img\"></p>\n<p>邻接矩阵图</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[][] graph &#x3D; new int[][]&#123;\n&#123;0 , 2, ∞, 6&#125;\n&#123;2 , 0, 3, 2&#125;\n&#123;∞ , 3, 0, 2&#125;\n&#123;6 , 2, 2, 0&#125;&#125;;</code></pre>\n\n<h3 id=\"算法过程\"><a href=\"#算法过程\" class=\"headerlink\" title=\"算法过程\"></a>算法过程</h3><p>result：已求出 最小路径的顶点<br>notFound：未求出 最小路径的顶点，里面的值是 到起点的距离<br>每次从 「未求出最短路径的点」中 取出 距离距离起点 最近的点，以这个点为桥梁 刷新「未求出最短路径的点」的距离</p>\n<p>初始，result={A(0)} 中只有起点 A，notFound={B(2),C(∞),D(6)} 中是除了 A 点的其他点，里面的值是到起点的距离（例如 B(2) 代表 B点到起点的距离为 2）</p>\n<p><img src=\"v2-e8e6bf35bb176af1b1a7d9d57ed949e9_r.jpg\" alt=\"img\"></p>\n<p>然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 B(2) ，然后通过 B(2) 为桥梁 刷新「未求出最短路径的点」的距离</p>\n<p>取出 最短路径的点：<br>从「未求出最短路径的点」notFound 中取出 最短路径的点 B(2)，放入结果 result 中，结果如下：</p>\n<p>「未求出最短路径点」 notFound={C(∞),D(6)}，「已求出最短路径的点 」result={A(0),B(2)}</p>\n<p>刷新距离：<br>通过 B(2) 为桥梁，刷新距离。</p>\n<p>例如 AD = 6 &lt; AB + BD = 4 以 B(2) 为桥梁的距离更短，就刷新「未求出最短路径点」D(6) 的距离为 D(4)</p>\n<p>notFound={C(∞),D(4)}</p>\n<p>同理刷新 C(∞) 的距离为 C(5) ，最后结果如下：</p>\n<p>「未求出最短路径点」 notFound={C(5),D(4)} ，「已求出最短路径的点」<code>result=&#123;A(0),B(2)&#125; </code></p>\n<p><img src=\"v2-69b92f2678598a9570a559f92f65a046_r.jpg\" alt=\"img\"></p>\n<p>然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 D(4) ，然后通过 D(4) 为桥梁 刷新「未求出最短路径的点」的距离</p>\n<p>同理，最后结果如下：</p>\n<p>「未求出最短路径点」 notFound={C(5)} ，「已求出最短路径的点」result={A(0),B(2),D(4)}</p>\n<p><img src=\"v2-a83ad70c54cb580475bf8eaeaf4a7a5c_r.jpg\" alt=\"img\"></p>\n<p>然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 C(5) ，算法结束</p>\n<p>result={A(0),B(2),D(4),C(5)} 就是最终所求的 最短距离</p>\n<p><img src=\"v2-564bc4d16069ea3c35ce4a2dfd7a8ded_r.jpg\" alt=\"img\"></p>\n<ol start=\"3\">\n<li>代码</li>\n</ol>\n<p>这里使用 -1 表无穷大，下面是 Java 代码和测试案例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Dijkstra &#123;\n    public static int[] dijkstra(int[][] graph,int startVertex)&#123;\n        &#x2F;&#x2F;初始化 以求出最短路径的点 result[]\n        int length &#x3D; graph.length;\n        int[] result &#x3D; new int[length];\n        for (int i &#x3D; 0; i &lt; length; i++) &#123;\n            result[i] &#x3D; -1;\n        &#125;\n        result[startVertex] &#x3D; 0 ;\n        \n        &#x2F;&#x2F; 初始化 未求出最短路径的点 notFound[]\n        int[] notFound &#x3D; new int[length];\n        for (int i &#x3D; 0; i &lt; length; i++) &#123;\n            notFound[i] &#x3D; graph[startVertex][i];\n        &#125;\n        notFound[startVertex] &#x3D; -1;\n        \n        &#x2F;&#x2F; 开始 Dijkstra 算法\n        for (int i &#x3D; 1; i &lt; length; i++) &#123;\n            &#x2F;&#x2F;1. 从「未求出最短路径的点」notFound 中取出 最短路径的点\n            &#x2F;&#x2F;1.1 找到最短距离的点\n            int min &#x3D; Integer.MAX_VALUE;\n            int minIndex &#x3D; 0;\n            for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                if (notFound[j] &gt; 0 &amp;&amp; notFound[j] &lt; min)&#123;\n                    min &#x3D; notFound[j];\n                    minIndex &#x3D; j;\n                &#125;\n            &#125;\n            &#x2F;&#x2F;1.2 将最短距离的点 取出 放入结果中\n            result[minIndex] &#x3D; min;\n            notFound[minIndex] &#x3D; -1;\n            \n            &#x2F;&#x2F;2. 刷新 「未求出最短距离的点」 notFound[] 中的距离\n            &#x2F;&#x2F;2.1 遍历刚刚找到最短距离的点 (B) 的出度 (BA、BB、BC、BD)\n            for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                &#x2F;&#x2F; 出度可通行(例如 BD:graph[1][3]  &gt; 0)\n                &#x2F;&#x2F; 出度点不能已经在结果集 result中(例如 D: result[3] &#x3D;&#x3D; -1)\n                if (graph[minIndex][j] &gt; 0\n                &amp;&amp; result[j] &#x3D;&#x3D; -1)&#123;\n                    int newDistance &#x3D; result[minIndex] + graph[minIndex][j];\n                    &#x2F;&#x2F;通过 B 为桥梁，刷新距离\n                    &#x2F;&#x2F;（比如&#96;AD &#x3D; 6 &lt; AB + BD &#x3D; 4&#96; 就刷新距离）（ -1 代表无限大）\n                    if (newDistance &lt; notFound[j] || notFound[j]&#x3D;&#x3D;-1)&#123;\n                        notFound[j] &#x3D; newDistance;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n    &#x2F;** 测试案例 *&#x2F;\n    public static void main(String[] args) &#123;\n        char[] vertices &#x3D; new char[]&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;&#125;;\n        int[][] graph &#x3D; new int[][]&#123;\n            &#123;0, 2, -1, 6&#125;, \n            &#123;2, 0, 3, 2&#125;, \n            &#123;-1, 3, 0, 2&#125;, \n            &#123;6, 2, 2, 0&#125;\n        &#125;;\n        int[] dijkstra &#x3D; dijkstra(graph, 0);\n        for (int i : dijkstra) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p>测试结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0\n2\n5\n4</code></pre>\n<p><a href=\"https://zhuanlan.zhihu.com/p/338414118\">Dijkstra算法详解 通俗易懂 - 知乎 (zhihu.com)</a></p>\n<p>另题：</p>\n<p><img src=\"v2-6ca1b3a193342af0c9b7750c824d6707_r.jpg\" alt=\"img\"></p>\n","text":"Dijkstra 算法详解概述Dijkstra 算法是求一个图中一个点到其他所有点的最短路径的算法 Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 O(n2) $$\\begin{align}&amp...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Shortest Path Algorithm","slug":"Shortest-Path-Algorithm","count":1,"path":"api/tags/Shortest-Path-Algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Dijkstra-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">Dijkstra 算法详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">主要行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">图解案例分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A6%81\"><span class=\"toc-text\">题要</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">算法过程</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"全排列","uid":"4bbde60d3dafb255adad1c9293392efa","slug":"Algorithm/Permutations","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:15:31.000Z","comments":true,"path":"api/articles/Algorithm/Permutations.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Permutations - 全排列顾名思义，就是找出当前元素所有可行的序列 一个朴素的思想是递归，这种方式简单但并不高效快捷 以两个示例来进行算法说明： Example1: 实验五 数据输出 实验准备理解数据输入、输出的技巧。 实验目的理解算法设计的数学基本思想，理解算法程序化...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"穷举","slug":"穷举","count":1,"path":"api/tags/穷举.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"中国邮递员问题","uid":"08152463b75b8ab3478d28a28a35a8b9","slug":"Algorithm/The Chinese Postman Problem","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:20:45.000Z","comments":true,"path":"api/articles/Algorithm/The Chinese Postman Problem.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"The Route of the PostmanReference The Chinese-Postman-Method (tum.de) 邮递员问题 - 维基百科，自由的百科全书 (wikipedia.org) 中国邮递员问题 | Junnor.G (cfonheart.git...","link":"","photos":[],"count_time":{"symbolsCount":815,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Shortest Route","slug":"Shortest-Route","count":1,"path":"api/tags/Shortest-Route.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}