{"title":"Dijkstra Algorithm","uid":"d42b57b5bace0bb67392a01a7601ad24","slug":"Algorithm/Dijkstra","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:14:51.763Z","comments":true,"path":"api/articles/Algorithm/Dijkstra.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"dijkstra-算法详解\">Dijkstra 算法详解</h1>\r\n<h2 id=\"概述\">概述</h2>\r\n<p>Dijkstra 算法是求一个图中一个点到其他所有点的最短路径的算法</p>\r\n<p>Dijkstra\r\n算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度\r\nO(n2)</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n&amp;(n-1)+(n-2)+···+1\\\\\r\n= &amp;\\frac{n*(n - 1)}{2}\\\\\r\n= &amp;\\frac{n^2}{2} - \\frac{n}{2}\\\\\r\n≈ &amp;n^2\r\n\\end{align}\r\n\\]</span></p>\r\n<h2 id=\"主要行为\">主要行为</h2>\r\n<p>每次从「未求出最短路径的点」中 取出 距离距离起点\r\n最小路径的点，以这个点为桥梁 刷新「未求出最短路径的点」的距离</p>\r\n<h2 id=\"图解案例分析\">图解案例分析</h2>\r\n<h3 id=\"题要\">题要</h3>\r\n<p>以 A 点为顶点，求到其他点的最短路径。</p>\r\n<figure>\r\n<img src=\"v2-72ddc44daec6a2916724464ec78ba342_1440w.jpg\" alt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>邻接矩阵图</p>\r\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[][] graph &#x3D; new int[][]&#123;\n&#123;0 , 2, ∞, 6&#125;\n&#123;2 , 0, 3, 2&#125;\n&#123;∞ , 3, 0, 2&#125;\n&#123;6 , 2, 2, 0&#125;&#125;;</code></pre>\r\n<h3 id=\"算法过程\">算法过程</h3>\r\n<p>result：已求出 最小路径的顶点 notFound：未求出\r\n最小路径的顶点，里面的值是 到起点的距离 每次从 「未求出最短路径的点」中\r\n取出 距离距离起点 最近的点，以这个点为桥梁\r\n刷新「未求出最短路径的点」的距离</p>\r\n<p>初始，result={A(0)} 中只有起点 A，notFound={B(2),C(∞),D(6)} 中是除了\r\nA 点的其他点，里面的值是到起点的距离（例如 B(2) 代表 B点到起点的距离为\r\n2）</p>\r\n<figure>\r\n<img src=\"v2-e8e6bf35bb176af1b1a7d9d57ed949e9_r.jpg\" alt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 B(2)\r\n，然后通过 B(2) 为桥梁 刷新「未求出最短路径的点」的距离</p>\r\n<p>取出 最短路径的点： 从「未求出最短路径的点」notFound 中取出\r\n最短路径的点 B(2)，放入结果 result 中，结果如下：</p>\r\n<p>「未求出最短路径点」 notFound={C(∞),D(6)}，「已求出最短路径的点\r\n」result={A(0),B(2)}</p>\r\n<p>刷新距离： 通过 B(2) 为桥梁，刷新距离。</p>\r\n<p>例如 AD = 6 &lt; AB + BD = 4 以 B(2)\r\n为桥梁的距离更短，就刷新「未求出最短路径点」D(6) 的距离为 D(4)</p>\r\n<p>notFound={C(∞),D(4)}</p>\r\n<p>同理刷新 C(∞) 的距离为 C(5) ，最后结果如下：</p>\r\n<p>「未求出最短路径点」 notFound={C(5),D(4)}\r\n，「已求出最短路径的点」<code>result=&#123;A(0),B(2)&#125;</code></p>\r\n<figure>\r\n<img src=\"v2-69b92f2678598a9570a559f92f65a046_r.jpg\" alt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 D(4)\r\n，然后通过 D(4) 为桥梁 刷新「未求出最短路径的点」的距离</p>\r\n<p>同理，最后结果如下：</p>\r\n<p>「未求出最短路径点」 notFound={C(5)}\r\n，「已求出最短路径的点」result={A(0),B(2),D(4)}</p>\r\n<figure>\r\n<img src=\"v2-a83ad70c54cb580475bf8eaeaf4a7a5c_r.jpg\" alt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 C(5)\r\n，算法结束</p>\r\n<p>result={A(0),B(2),D(4),C(5)} 就是最终所求的 最短距离</p>\r\n<figure>\r\n<img src=\"v2-564bc4d16069ea3c35ce4a2dfd7a8ded_r.jpg\" alt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li>代码</li>\r\n</ol>\r\n<p>这里使用 -1 表无穷大，下面是 Java 代码和测试案例</p>\r\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Dijkstra &#123;\n    public static int[] dijkstra(int[][] graph,int startVertex)&#123;\n        &#x2F;&#x2F;初始化 以求出最短路径的点 result[]\n        int length &#x3D; graph.length;\n        int[] result &#x3D; new int[length];\n        for (int i &#x3D; 0; i &lt; length; i++) &#123;\n            result[i] &#x3D; -1;\n        &#125;\n        result[startVertex] &#x3D; 0 ;\n        \n        &#x2F;&#x2F; 初始化 未求出最短路径的点 notFound[]\n        int[] notFound &#x3D; new int[length];\n        for (int i &#x3D; 0; i &lt; length; i++) &#123;\n            notFound[i] &#x3D; graph[startVertex][i];\n        &#125;\n        notFound[startVertex] &#x3D; -1;\n        \n        &#x2F;&#x2F; 开始 Dijkstra 算法\n        for (int i &#x3D; 1; i &lt; length; i++) &#123;\n            &#x2F;&#x2F;1. 从「未求出最短路径的点」notFound 中取出 最短路径的点\n            &#x2F;&#x2F;1.1 找到最短距离的点\n            int min &#x3D; Integer.MAX_VALUE;\n            int minIndex &#x3D; 0;\n            for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                if (notFound[j] &gt; 0 &amp;&amp; notFound[j] &lt; min)&#123;\n                    min &#x3D; notFound[j];\n                    minIndex &#x3D; j;\n                &#125;\n            &#125;\n            &#x2F;&#x2F;1.2 将最短距离的点 取出 放入结果中\n            result[minIndex] &#x3D; min;\n            notFound[minIndex] &#x3D; -1;\n            \n            &#x2F;&#x2F;2. 刷新 「未求出最短距离的点」 notFound[] 中的距离\n            &#x2F;&#x2F;2.1 遍历刚刚找到最短距离的点 (B) 的出度 (BA、BB、BC、BD)\n            for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                &#x2F;&#x2F; 出度可通行(例如 BD:graph[1][3]  &gt; 0)\n                &#x2F;&#x2F; 出度点不能已经在结果集 result中(例如 D: result[3] &#x3D;&#x3D; -1)\n                if (graph[minIndex][j] &gt; 0\n                &amp;&amp; result[j] &#x3D;&#x3D; -1)&#123;\n                    int newDistance &#x3D; result[minIndex] + graph[minIndex][j];\n                    &#x2F;&#x2F;通过 B 为桥梁，刷新距离\n                    &#x2F;&#x2F;（比如&#96;AD &#x3D; 6 &lt; AB + BD &#x3D; 4&#96; 就刷新距离）（ -1 代表无限大）\n                    if (newDistance &lt; notFound[j] || notFound[j]&#x3D;&#x3D;-1)&#123;\n                        notFound[j] &#x3D; newDistance;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n    &#x2F;** 测试案例 *&#x2F;\n    public static void main(String[] args) &#123;\n        char[] vertices &#x3D; new char[]&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;&#125;;\n        int[][] graph &#x3D; new int[][]&#123;\n            &#123;0, 2, -1, 6&#125;, \n            &#123;2, 0, 3, 2&#125;, \n            &#123;-1, 3, 0, 2&#125;, \n            &#123;6, 2, 2, 0&#125;\n        &#125;;\n        int[] dijkstra &#x3D; dijkstra(graph, 0);\n        for (int i : dijkstra) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;</code></pre>\r\n<p>测试结果 <pre class=\"line-numbers language-none\"><code class=\"language-none\">0\n2\n5\n4</code></pre> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/338414118\">Dijkstra算法详解 通俗易懂\r\n- 知乎 (zhihu.com)</a></p>\r\n<p>另题：</p>\r\n<figure>\r\n<img src=\"v2-6ca1b3a193342af0c9b7750c824d6707_r.jpg\" alt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n","text":"Dijkstra 算法详解 概述 Dijkstra 算法是求一个图中一个点到其他所有点的最短路径的算法 Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 O(n2) \\[ \\begin{align} ...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Shortest Path Algorithm","slug":"Shortest-Path-Algorithm","count":1,"path":"api/tags/Shortest-Path-Algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#dijkstra-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">Dijkstra 算法详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">主要行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">图解案例分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A6%81\"><span class=\"toc-text\">题要</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">算法过程</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"CRC Algorithm","uid":"2e7a3ae4090ee29ca9a2e76805bad9b3","slug":"Algorithm/CRC、LRC、BCC校验与模二运算","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:13:55.103Z","comments":true,"path":"api/articles/Algorithm/CRC、LRC、BCC校验与模二运算.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":" 那简而言之就是 取首位 异或(首位为0 除数为0) 左移 上述三个步骤循环呗 当左移后余数长度小于被除数时则取余 也可以这么理解吧 当余数开头出现n个0的时候就可以全部消掉直到首位是1 商补上n-1个0和一个1就可以了 继续异或运算嘛 我是看到有好几题余数开头俩0的 分析看看 ...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"CRC","slug":"CRC","count":1,"path":"api/tags/CRC.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"全排列","uid":"4bbde60d3dafb255adad1c9293392efa","slug":"Algorithm/Permutations","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:15:31.702Z","comments":true,"path":"api/articles/Algorithm/Permutations.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Permutations - 全排列 顾名思义，就是找出当前元素所有可行的序列 一个朴素的思想是递归，这种方式简单但并不高效快捷 以两个示例来进行算法说明： Example1: 实验五 数据输出 实验准备 理解数据输入、输出的技巧。 实验目的 理解算法设计的数学基本思想，理解算法...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"穷举","slug":"穷举","count":1,"path":"api/tags/穷举.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}