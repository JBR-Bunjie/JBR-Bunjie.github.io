{"title":"Sugiyama Algorithm","uid":"9fd0e4d3dba46b1add7af94a3f9b782a","slug":"Algorithm/Sugiyama","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:20:19.000Z","comments":true,"path":"api/articles/Algorithm/Sugiyama.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"划时代的自动布局算法：sugiyama算法\"><a href=\"#划时代的自动布局算法：sugiyama算法\" class=\"headerlink\" title=\"划时代的自动布局算法：sugiyama算法\"></a>划时代的自动布局算法：sugiyama算法</h1><h2 id=\"sugiyama-algorithm-steps\"><a href=\"#sugiyama-algorithm-steps\" class=\"headerlink\" title=\"sugiyama algorithm steps\"></a>sugiyama algorithm steps</h2><p>of the framework is to divide the task of drawing a graph into several subproblems, most of which closely resemble other well known problems within computer science. That way one can use algorithms for the similar problems to solve the Sugiyama subproblems and thereby simplify the graph layout process. The different steps of the method are illustrated in figure 2. They are the following: </p>\n<ul>\n<li>Cycle removal </li>\n</ul>\n<p>First the possibly cyclic graph must be made acyclic by removing cycles, done by reversing some edges. </p>\n<ul>\n<li>Layer assignment </li>\n</ul>\n<p>Second, the vertices are assigned to layers and dummy vertices and dummy edges are introduced for every edge that spans over more than two layers so as to create a proper layering [2], i.e. one where every edge has its endpoints in adjacent layers. </p>\n<ul>\n<li>Vertex ordering </li>\n</ul>\n<p>Third, the vertices are ordered within their layers to minimise edge crossings.</p>\n<ul>\n<li>Coordinate assignment </li>\n</ul>\n<p>Fourth and last, the vertices are assigned coordinates to create a balanced graph.</p>\n<h2 id=\"sugiyama-barycenter算法内容\"><a href=\"#sugiyama-barycenter算法内容\" class=\"headerlink\" title=\"sugiyama barycenter算法内容\"></a>sugiyama barycenter算法内容</h2><p>两层间的情况：</p>\n<p>n层间的情况：</p>\n<h2 id=\"纯python实现：\"><a href=\"#纯python实现：\" class=\"headerlink\" title=\"纯python实现：\"></a>纯python实现：</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"></code></pre>\n\n\n\n\n\n\n\n<p>原论文地址：</p>\n<p><a href=\"https://ieeexplore.ieee.org/document/4308636\">Methods for Visual Understanding of Hierarchical System Structures | IEEE Journals &amp; Magazine | IEEE Xplore</a></p>\n<p>所实现算法的仓库：</p>\n<p>视频教程：</p>\n<p><a href=\"https://www.youtube.com/playlist?list=PLubYOWSl9mIvxe_HwoSyT-oXgkOmB1u3V\">(40) Hierarchical Drawings: Sugiyama Framework | Visualization of Graphs - Lecture 8 - YouTube</a></p>\n<p>More Resource:</p>\n<p><a href=\"https://publications.lib.chalmers.se/records/fulltext/161388.pdf\">161388.pdf (chalmers.se)</a></p>\n","text":"划时代的自动布局算法：sugiyama算法sugiyama algorithm stepsof the framework is to divide the task of drawing a graph into several subproblems, most of whi...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Auto Layout","slug":"Auto-Layout","count":1,"path":"api/tags/Auto-Layout.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%92%E6%97%B6%E4%BB%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E7%AE%97%E6%B3%95%EF%BC%9Asugiyama%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">划时代的自动布局算法：sugiyama算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#sugiyama-algorithm-steps\"><span class=\"toc-text\">sugiyama algorithm steps</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#sugiyama-barycenter%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">sugiyama barycenter算法内容</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%AFpython%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">纯python实现：</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"中国邮递员问题","uid":"08152463b75b8ab3478d28a28a35a8b9","slug":"Algorithm/The Chinese Postman Problem","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:20:45.000Z","comments":true,"path":"api/articles/Algorithm/The Chinese Postman Problem.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"The Route of the PostmanReference The Chinese-Postman-Method (tum.de) 邮递员问题 - 维基百科，自由的百科全书 (wikipedia.org) 中国邮递员问题 | Junnor.G (cfonheart.git...","link":"","photos":[],"count_time":{"symbolsCount":815,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Shortest Route","slug":"Shortest-Route","count":1,"path":"api/tags/Shortest-Route.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"利用递归、无循环地打印数组","uid":"7dbcf1e35df66bdccacdaed2ecd943d3","slug":"Algorithm/ReverseOutputWithoutCycle","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:19:21.000Z","comments":true,"path":"api/articles/Algorithm/ReverseOutputWithoutCycle.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"ReverseOutputWithoutCycle描述：不用循环，不逐一赋值地把一个数组逆序输出 循环 -&gt; 递归；即用递归去承担原本循环的工作 即： void Print(int[] arr, int len) &#123; if (len &gt; 0) &#123; ...","link":"","photos":[],"count_time":{"symbolsCount":250,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Recursion","slug":"Recursion","count":1,"path":"api/tags/Recursion.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}