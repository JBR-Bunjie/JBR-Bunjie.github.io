{"title":"拓扑排序","uid":"01d132f13ac67dff21350f57c338a855","slug":"Algorithm/SORT/Topological Sort","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:09:34.270Z","comments":true,"path":"api/articles/Algorithm/SORT/Topological Sort.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h2 id=\"拓扑排序\">拓扑排序</h2>\r\n<h3 id=\"reference\">Reference：</h3>\r\n<p><a\r\nhref=\"http://songlee24.github.io/2015/05/07/topological-sorting/\">拓扑排序（Topological\r\nSorting） | 神奕的博客 (songlee24.github.io)</a></p>\r\n<h3 id=\"detail\">Detail：</h3>\r\n<blockquote>\r\n<p>在图论中，<strong>拓扑排序（Topological\r\nSorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic\r\nGraph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>\r\n<ol type=\"1\">\r\n<li>每个顶点出现且只出现一次。</li>\r\n<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B\r\n的前面。</li>\r\n</ol>\r\n<p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p>\r\n</blockquote>\r\n<p>在sugiyama算法的“分层”步骤中，我们相当于直接用到了这种思路</p>\r\n<p>唯一的不同是：</p>\r\n<p>拓扑排序根据顺序剔除边后入度为零的全部节点生成了一个序列</p>\r\n<p>而sugiyama将当前所有为零的节点并入独立的一整层</p>\r\n<h3 id=\"用途\">用途？</h3>\r\n<blockquote>\r\n<p>拓扑排序通常用来“排序”具有依赖关系的任务。</p>\r\n<p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边\r\n表示在做任务 B 之前必须先完成任务\r\nA。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p>\r\n</blockquote>\r\n","text":"拓扑排序 Reference： 拓扑排序（Topological Sorting） | 神奕的博客 (songlee24.github.io) Detail： 在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic...","link":"","photos":[],"count_time":{"symbolsCount":541,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Sort","slug":"Sort","count":3,"path":"api/tags/Sort.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">拓扑排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#detail\"><span class=\"toc-text\">Detail：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E9%80%94\"><span class=\"toc-text\">用途？</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"售货员问题！","uid":"26cdbb886310bf39cb3aaad08f67e70b","slug":"Algorithm/DP/Traveling Salesman Problem","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:05:23.408Z","comments":true,"path":"api/articles/Algorithm/DP/Traveling Salesman Problem.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"一、题目 一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。 售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。 （等价于求图的最短哈密尔顿回路问题）令G=(V, E)是一个带权重的有向...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"DP","slug":"DP","count":1,"path":"api/tags/DP.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Hash Function","uid":"991c84bc86acdc32c9243fba302e2655","slug":"Algorithm/HashFunction/HashFunction","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:06:01.382Z","comments":true,"path":"api/articles/Algorithm/HashFunction/HashFunction.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"简明Hash function教程 请注意！这篇文档是关于散列函数Hash function的，如果需要了解Hash table相关内容请查阅“简明Hash table教程”等相关文章 引子 在各种下载站的资源页面下方，经常会有如下以SHA开头的特殊字段 SHA1：9B71AD5...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Hash","slug":"Hash","count":1,"path":"api/tags/Hash.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}