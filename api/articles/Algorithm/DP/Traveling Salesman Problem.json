{"title":"售货员问题！","uid":"26cdbb886310bf39cb3aaad08f67e70b","slug":"Algorithm/DP/Traveling Salesman Problem","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:05:23.000Z","comments":true,"path":"api/articles/Algorithm/DP/Traveling Salesman Problem.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h2 id=\"一、题目\"><a href=\"#一、题目\" class=\"headerlink\" title=\"一、题目\"></a>一、题目</h2><ul>\n<li>一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。<br>售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。</li>\n<li>（等价于求图的最短哈密尔顿回路问题）令G=(V, E)是一个带权重的有向图，顶点集V=(v0, v1, …, vn-1)。从图中任一顶点vi出发，经图中所有其他顶点一次且只有一次，最后回到同一顶点vi的最短路径。</li>\n</ul>\n<h2 id=\"二、测试用例\"><a href=\"#二、测试用例\" class=\"headerlink\" title=\"二、测试用例\"></a>二、测试用例</h2><p><img src=\"https://img-blog.csdnimg.cn/20190923191204612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<p>其中1,2,3,4,5代表五个城市。此模型可抽象为图，可用邻接矩阵c表示，如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190917202003190.png\" alt=\"img\"></p>\n<h2 id=\"三、动态规划方程\"><a href=\"#三、动态规划方程\" class=\"headerlink\" title=\"三、动态规划方程\"></a>三、动态规划方程</h2><p> 假设从顶点s出发，令d(i, V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。</p>\n<p>​    推导：(分情况来讨论)</p>\n<p>​    ①当V为空集，那么d()<img src=\"https://private.codecogs.com/gif.latex?d(i,%20V)\" alt=\"d(i, V)\">，表示直接从i回到s了，此时<img src=\"https://private.codecogs.com/gif.latex?d(i,V)%20=%20c_%7Bis%7D\" alt=\"d(i,V) = c_{is}\"> 且 <img src=\"https://private.codecogs.com/gif.latex?(i%5Cneq%20s)\" alt=\"(i\\neq s)\"></p>\n<p>​    ②如果V不为空，那么就是对子问题的最优求解。你必须在V这个城市集合中，尝试每一个，并求出最优解。</p>\n<p>​     <img src=\"https://private.codecogs.com/gif.latex?d(i,%20V)=min(C_%7Bik%7D%20&plus;%20d(k,%20V-(k))\" alt=\"d(i, V)=min(C_{ik} + d(k, V-(k))\"></p>\n<p>​      注：<img src=\"https://private.codecogs.com/gif.latex?c_%7Bik%7D\" alt=\"c_{ik}\">表示选择的城市和城市i的距离，<img src=\"https://private.codecogs.com/gif.latex?d(k,%20V-(k))\" alt=\"d(k, V-(k))\">是一个子问题。</p>\n<p>​    综上所述，TSP问题的动态规划方程就出来了：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190923192452307.png\" alt=\"img\"></p>\n<h2 id=\"四、用例分析\"><a href=\"#四、用例分析\" class=\"headerlink\" title=\"四、用例分析\"></a>四、用例分析</h2><p>现在对问题定义中的例子来说明TSP的求解过程。(假设出发城市是 0城市)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190923192924546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190923192935826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<p>这里只画出了d(1,{2,3,4}),由于篇幅有限这里就不画了。</p>\n<p>①我们要求的最终结果是d(0,{1,2,3,4}),它表示，从城市0开始，经过{1,2,3,4}之中的城市并且只有一次，求出最短路径.。<br>②d(0,{1,2,3,4})是不能一下子求出来的，那么他的值是怎么得出的呢？看上图的第二层，第二层表明了d(0,{1,2,3,4})所需依赖的值。那么得出：<br>   <img src=\"https://img-blog.csdnimg.cn/20190923194300642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\" alt=\"img\"><br>   ③d(1,{2,3,4})，d(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样也不是一步就能求出来的，它们的解一样需要有依赖，就比如说d(1,{2,3,4})<br><img src=\"https://img-blog.csdnimg.cn/20190923194321514.png\" alt=\"img\"><br>   d(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样需要这么求。</p>\n<p>  ④按照上面的思路，只有最后一层的，当V为空集时，就可以满足<img src=\"https://private.codecogs.com/gif.latex?d(i,V)%20=%20c_%7Bis%7D\" alt=\"d(i,V) = c_{is}\"> 且 <img src=\"https://private.codecogs.com/gif.latex?(i%5Cneq%20s)\" alt=\"(i\\neq s)\">该条件，直接求出dp数组部分的值。</p>\n<h2 id=\"五、数据结构\"><a href=\"#五、数据结构\" class=\"headerlink\" title=\"五、数据结构\"></a>五、数据结构</h2><p>由上述动态规划公式d(i,V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。根据上述给的测试用例有5个城市编号0,1,2,3,4。那么访问n个城市，恰好访问每个城市一次，并最终回到出发城市的嘴短距离可表示为d(0,{1,2,3,4}),那么问题来了我们用什么数据结构表示d(i,V)，这里我们就可二维数据dp[N][M]来表示，N表示城市的个数，M表示集合的数量，即<img src=\"https://private.codecogs.com/gif.latex?M%20=%202%5E%7BN-1%7D\" alt=\"M = 2^{N-1}\">,之所以这么表示因为集合V有<img src=\"https://private.codecogs.com/gif.latex?2%5E%7BN-1%7D\" alt=\"2^{N-1}\">个子集。根据测试用例可得出如下dp数组表格：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190923200357348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<p>那么你们可能就有疑问了，为什么这么表示？这里说明一下比如集合{1,2,3,4}为什么用15表示，<strong>我们可以把集合中元素看成二进制1的位置</strong>（二进制从右开始看），1表示从右开始第一位为1,2表示从又开始第二位为1，所以集合{1,2,3,4}可表示二进制（1111）转化为十进制为15。再举个例子比如集合{1,3}表示为二进制为0101，十进制为5。所以我们求出dp[0][15]（通用表示dp[0][<img src=\"https://private.codecogs.com/gif.latex?2%5E%7BN-1%7D-1\" alt=\"2^{N-1}-1\">]）就是本题的最终解。</p>\n<p>注意：</p>\n<ul>\n<li>对于第y个城市，他的二进制表达为，1&lt;&lt;(y-1)。</li>\n<li>对于数字x，要看它的第i位是不是1，那么可以通过判断布尔表达式 (((x &gt;&gt; (i - 1) ) &amp; 1) == 1或者（x  &amp; (1&lt;&lt;(i-1))）!= 0的真值来实现。</li>\n<li>由动态规划公式可知，需要从集合中剔除元素。假如集合用索引x表示，要剔除元素标号为i,我们异或运算实现减法，其运算表示为： x = x ^ (1&lt;&lt;(i - 1))。</li>\n</ul>\n<h2 id=\"六、最短路径顶点的计算\"><a href=\"#六、最短路径顶点的计算\" class=\"headerlink\" title=\"六、最短路径顶点的计算\"></a>六、最短路径顶点的计算</h2><p>我们先计算dp[N][M]数组之后，我可以用dp数组来反向推出其路径。其算法思想如下：</p>\n<p>比如在第一步时，我们就知道那个值最小，如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190923194300642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<p>因为dp[][]数组我们已经计算出来了，由计算可知C01+d(1,{2,3,4})最小，所以一开始从起始点0出发，经过1。接下来同样计算d(1,{2,3,4})</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190923194321514.png\" alt=\"img\"></p>\n<p>由计算可知C14+d(4,{2,3})所以0—&gt;1—-&gt;4，接下来同理求d(4,{2,3})，这里就省略，读者可以自行计算。最终计算出来的路径为：0—&gt;1—&gt;4—&gt;2—&gt;3—&gt;0</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n \nusing namespace std;\n \n#define N 5\n#define INF 10e7\n#define min(a,b) ((a&gt;b)?b:a)\n \nstatic const int M &#x3D; 1 &lt;&lt; (N-1);\n&#x2F;&#x2F;存储城市之间的距离\nint g[N][N] &#x3D; &#123;&#123;0,3,INF,8,9&#125;,\n               &#123;3,0,3,10,5&#125;,\n               &#123;INF,3,0,4,3&#125;,\n               &#123;8,10,4,0,20&#125;,\n               &#123;9,5,3,20,0&#125;&#125;;\n\n&#x2F;&#x2F;保存顶点i到状态s最后回到起始点的最小距离\nint dp[N][M];\n\n&#x2F;&#x2F;保存路径\nvector&lt;int&gt; path;\n \n&#x2F;&#x2F;核心函数，求出动态规划dp数组\nvoid TSP()&#123;\n    &#x2F;&#x2F;初始化dp[i][0]\n    for(int i &#x3D; 0; i &lt; N; i++)\n        dp[i][0] &#x3D; g[i][0];\n    \n    &#x2F;&#x2F;求解dp[i][j]\n    for(int j &#x3D; 1; j &lt; M; j++ ) &#123;\n        for(int i &#x3D; 0; i &lt; N; i++ ) &#123;\n            dp[i][j] &#x3D; INF;\n            &#x2F;&#x2F;如果集和j(或状态j)中包含结点i,则不符合条件退出\n            if( ((j &gt;&gt; (i-1)) &amp; 1) &#x3D;&#x3D; 1)\n                continue;\n            \n            for(int k &#x3D; 1; k &lt; N; k++) &#123;\n                if( ((j &gt;&gt; (k-1)) &amp; 1) &#x3D;&#x3D; 0)\n                    continue;\n                \n                if( dp[i][j] &gt; g[i][k] + dp[k][j^(1&lt;&lt;(k-1))] )\n                    dp[i][j] &#x3D; g[i][k] + dp[k][j^(1&lt;&lt;(k-1))] ;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;判断结点是否都以访问,不包括0号结点\nbool isVisited(bool visited[])&#123;\n    for(int i &#x3D; 1 ; i&lt;N ;i++)\n        if(visited[i] &#x3D;&#x3D; false)\n            return false;\n    return true;\n&#125;\n\n&#x2F;&#x2F;获取最优路径，保存在path中,根据动态规划公式反向找出最短路径结点\nvoid getPath()&#123;\n    &#x2F;&#x2F;标记访问数组\n    bool visited[N] &#x3D; &#123;false&#125;;\n    &#x2F;&#x2F;前驱节点编号\n    int pioneer &#x3D; 0 ,min &#x3D; INF, S &#x3D; M - 1,temp ;\n    &#x2F;&#x2F;把起点结点编号加入容器\n    path.push_back(0);\n \n    while(!isVisited(visited))&#123;\n        for(int i&#x3D;1; i&lt;N;i++)\n            if(visited[i] &#x3D;&#x3D; false &amp;&amp; (S&amp;(1&lt;&lt;(i-1))) !&#x3D; 0)\n                if(min &gt; g[i][pioneer] + dp[i][(S^(1&lt;&lt;(i-1)))])\n                    min &#x3D; g[i][pioneer] + dp[i][(S^(1&lt;&lt;(i-1)))] ;\n                    temp &#x3D; i;\n            \n        pioneer &#x3D; temp;\n        path.push_back(pioneer);\n        visited[pioneer] &#x3D; true;\n        S &#x3D; S ^ (1&lt;&lt;(pioneer - 1));\n        min &#x3D; INF;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;输出路径\nvoid printPath()&#123;\n    cout&lt;&lt;&quot;最小路径为：&quot;;\n    vector&lt;int&gt;::iterator  it &#x3D; path.begin();\n    for(it ; it !&#x3D; path.end();it++)\n        cout&lt;&lt;*it&lt;&lt;&quot;---&gt;&quot;;\n    &#x2F;&#x2F;单独输出起点编号\n    cout&lt;&lt;0;\n&#125;\n \nint main()\n&#123;\n    TSP();\n    cout&lt;&lt;&quot;最小值为：&quot;&lt;&lt;dp[0][M-1]&lt;&lt;endl;\n    getPath();\n    printPath();\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"八、测试结果及性能分析\"><a href=\"#八、测试结果及性能分析\" class=\"headerlink\" title=\"八、测试结果及性能分析\"></a>八、测试结果及性能分析</h2><p><img src=\"https://img-blog.csdnimg.cn/20190923205046784.png\" alt=\"img\"></p>\n<p>时间复杂度：<img src=\"https://private.codecogs.com/gif.latex?O(2%5E%7Bn%7Dn%5E%7B2%7D)\" alt=\"O(2^{n}n^{2})\"></p>\n<p>空间复杂度：<img src=\"https://private.codecogs.com/gif.latex?O(2%5E%7Bn%7D)\" alt=\"O(2^{n})\"></p>\n<p><a href=\"https://blog.csdn.net/qq_39559641/article/details/101209534\">旅行商问题（动态规划方法，超级详细的）_仁者乐山智者乐水的博客-CSDN博客_旅行商问题</a></p>\n","text":"一、题目 一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。 （等价于求图的最短哈密尔顿回路问题）令G=(V, E)是一个带权重的有向图...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"DP","slug":"DP","count":1,"path":"api/tags/DP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">一、题目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B\"><span class=\"toc-text\">二、测试用例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">三、动态规划方程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E7%94%A8%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">四、用例分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">五、数据结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">六、最短路径顶点的计算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\"><span class=\"toc-text\">八、测试结果及性能分析</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"拓扑排序","uid":"01d132f13ac67dff21350f57c338a855","slug":"Algorithm/SORT/Topological Sort","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:09:34.000Z","comments":true,"path":"api/articles/Algorithm/SORT/Topological Sort.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"拓扑排序Reference：拓扑排序（Topological Sorting） | 神奕的博客 (songlee24.github.io) Detail： 在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic G...","link":"","photos":[],"count_time":{"symbolsCount":524,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Sort","slug":"Sort","count":3,"path":"api/tags/Sort.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Hash Function","uid":"991c84bc86acdc32c9243fba302e2655","slug":"Algorithm/HashFunction/HashFunction","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:06:01.000Z","comments":true,"path":"api/articles/Algorithm/HashFunction/HashFunction.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"简明Hash function教程 WARNING 请注意！这篇文档是关于散列函数Hash function的，如果需要了解Hash table相关内容请查阅“简明Hash table教程”等相关文章 引子在各种下载站的资源页面下方，经常会有如下以SHA开头的特殊字段 SHA1：...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Hash","slug":"Hash","count":1,"path":"api/tags/Hash.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}