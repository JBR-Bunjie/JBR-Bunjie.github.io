{"title":"售货员问题","uid":"ab5351d849d735008d49a961e1e5262a","slug":"Algorithm/DP/Traveling Salesman Problem","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T16:10:04.000Z","comments":true,"path":"api/articles/Algorithm/DP/Traveling Salesman Problem.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h2 id=\"一题目\">一、题目</h2>\r\n<ul>\r\n<li>一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。\r\n售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。</li>\r\n<li>（等价于求图的最短哈密尔顿回路问题）令G=(V,\r\nE)是一个带权重的有向图，顶点集V=(v0, v1, ...,\r\nvn-1)。从图中任一顶点vi出发，经图中所有其他顶点一次且只有一次，最后回到同一顶点vi的最短路径。</li>\r\n</ul>\r\n<h2 id=\"二测试用例\">二、测试用例</h2>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923191204612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>其中1,2,3,4,5代表五个城市。此模型可抽象为图，可用邻接矩阵c表示，如下图所示：</p>\r\n<figure>\r\n<img src=\"https://img-blog.csdnimg.cn/20190917202003190.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h2 id=\"三动态规划方程\">三、动态规划方程</h2>\r\n<p>假设从顶点s出发，令d(i,\r\nV)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。</p>\r\n<p>​ 推导：(分情况来讨论)</p>\r\n<p>​ ①当V为空集，那么d()<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28i%2C%20V%29\" />，表示直接从i回到s了，此时<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28i%2CV%29%20%3D%20c_%7Bis%7D\" />\r\n且 <embed\r\nsrc=\"https://private.codecogs.com/gif.latex?%28i%5Cneq%20s%29\" /></p>\r\n<p>​\r\n②如果V不为空，那么就是对子问题的最优求解。你必须在V这个城市集合中，尝试每一个，并求出最优解。</p>\r\n<p>​ <embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28i%2C%20V%29%3Dmin%28C_%7Bik%7D%20+%20d%28k%2C%20V-%28k%29%29\" /></p>\r\n<p>​ 注：<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?c_%7Bik%7D\" />表示选择的城市和城市i的距离，<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28k%2C%20V-%28k%29%29\" />是一个子问题。</p>\r\n<p>​ 综上所述，TSP问题的动态规划方程就出来了：</p>\r\n<figure>\r\n<img src=\"https://img-blog.csdnimg.cn/20190923192452307.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h2 id=\"四用例分析\">四、用例分析</h2>\r\n<p>现在对问题定义中的例子来说明TSP的求解过程。(假设出发城市是 0城市)</p>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923192924546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923192935826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>这里只画出了d(1,{2,3,4}),由于篇幅有限这里就不画了。</p>\r\n<p>①我们要求的最终结果是d(0,{1,2,3,4}),它表示，从城市0开始，经过{1,2,3,4}之中的城市并且只有一次，求出最短路径.。\r\n②d(0,{1,2,3,4})是不能一下子求出来的，那么他的值是怎么得出的呢？看上图的第二层，第二层表明了d(0,{1,2,3,4})所需依赖的值。那么得出：\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923194300642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n③d(1,{2,3,4})，d(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样也不是一步就能求出来的，它们的解一样需要有依赖，就比如说d(1,{2,3,4})\r\n<img src=\"https://img-blog.csdnimg.cn/20190923194321514.png\"\r\nalt=\"img\" />\r\nd(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样需要这么求。</p>\r\n<p>④按照上面的思路，只有最后一层的，当V为空集时，就可以满足<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?d%28i%2CV%29%20%3D%20c_%7Bis%7D\" />\r\n且 <embed\r\nsrc=\"https://private.codecogs.com/gif.latex?%28i%5Cneq%20s%29\" />该条件，直接求出dp数组部分的值。</p>\r\n<h2 id=\"五数据结构\">五、数据结构</h2>\r\n<p>由上述动态规划公式d(i,V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。根据上述给的测试用例有5个城市编号0,1,2,3,4。那么访问n个城市，恰好访问每个城市一次，并最终回到出发城市的嘴短距离可表示为d(0,{1,2,3,4}),那么问题来了我们用什么数据结构表示d(i,V)，这里我们就可二维数据dp[N][M]来表示，N表示城市的个数，M表示集合的数量，即<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?M%20%3D%202%5E%7BN-1%7D\" />,之所以这么表示因为集合V有<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?2%5E%7BN-1%7D\" />个子集。根据测试用例可得出如下dp数组表格：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923200357348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>那么你们可能就有疑问了，为什么这么表示？这里说明一下比如集合{1,2,3,4}为什么用15表示，<strong>我们可以把集合中元素看成二进制1的位置</strong>（二进制从右开始看），1表示从右开始第一位为1,2表示从又开始第二位为1，所以集合{1,2,3,4}可表示二进制（1111）转化为十进制为15。再举个例子比如集合{1,3}表示为二进制为0101，十进制为5。所以我们求出dp[0][15]（通用表示dp[0][<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?2%5E%7BN-1%7D-1\" />]）就是本题的最终解。</p>\r\n<p>注意：</p>\r\n<ul>\r\n<li>对于第y个城市，他的二进制表达为，1&lt;&lt;(y-1)。</li>\r\n<li>对于数字x，要看它的第i位是不是1，那么可以通过判断布尔表达式 (((x\r\n&gt;&gt; (i - 1) ) &amp; 1) == 1或者（x &amp; (1&lt;&lt;(i-1))）!=\r\n0的真值来实现。</li>\r\n<li>由动态规划公式可知，需要从集合中剔除元素。假如集合用索引x表示，要剔除元素标号为i,我们异或运算实现减法，其运算表示为：\r\nx = x ^ (1&lt;&lt;(i - 1))。</li>\r\n</ul>\r\n<h2 id=\"六最短路径顶点的计算\">六、最短路径顶点的计算</h2>\r\n<p>我们先计算dp[N][M]数组之后，我可以用dp数组来反向推出其路径。其算法思想如下：</p>\r\n<p>比如在第一步时，我们就知道那个值最小，如下图所示：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/20190923194300642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>因为dp[][]数组我们已经计算出来了，由计算可知C01+d(1,{2,3,4})最小，所以一开始从起始点0出发，经过1。接下来同样计算d(1,{2,3,4})</p>\r\n<figure>\r\n<img src=\"https://img-blog.csdnimg.cn/20190923194321514.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>由计算可知C14+d(4,{2,3})所以0---&gt;1----&gt;4，接下来同理求d(4,{2,3})，这里就省略，读者可以自行计算。最终计算出来的路径为：0---&gt;1---&gt;4---&gt;2---&gt;3---&gt;0</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n \nusing namespace std;\n \n#define N 5\n#define INF 10e7\n#define min(a,b) ((a&gt;b)?b:a)\n \nstatic const int M &#x3D; 1 &lt;&lt; (N-1);\n&#x2F;&#x2F;存储城市之间的距离\nint g[N][N] &#x3D; &#123;&#123;0,3,INF,8,9&#125;,\n               &#123;3,0,3,10,5&#125;,\n               &#123;INF,3,0,4,3&#125;,\n               &#123;8,10,4,0,20&#125;,\n               &#123;9,5,3,20,0&#125;&#125;;\n\n&#x2F;&#x2F;保存顶点i到状态s最后回到起始点的最小距离\nint dp[N][M];\n\n&#x2F;&#x2F;保存路径\nvector&lt;int&gt; path;\n \n&#x2F;&#x2F;核心函数，求出动态规划dp数组\nvoid TSP()&#123;\n    &#x2F;&#x2F;初始化dp[i][0]\n    for(int i &#x3D; 0; i &lt; N; i++)\n        dp[i][0] &#x3D; g[i][0];\n    \n    &#x2F;&#x2F;求解dp[i][j]\n    for(int j &#x3D; 1; j &lt; M; j++ ) &#123;\n        for(int i &#x3D; 0; i &lt; N; i++ ) &#123;\n            dp[i][j] &#x3D; INF;\n            &#x2F;&#x2F;如果集和j(或状态j)中包含结点i,则不符合条件退出\n            if( ((j &gt;&gt; (i-1)) &amp; 1) &#x3D;&#x3D; 1)\n                continue;\n            \n            for(int k &#x3D; 1; k &lt; N; k++) &#123;\n                if( ((j &gt;&gt; (k-1)) &amp; 1) &#x3D;&#x3D; 0)\n                    continue;\n                \n                if( dp[i][j] &gt; g[i][k] + dp[k][j^(1&lt;&lt;(k-1))] )\n                    dp[i][j] &#x3D; g[i][k] + dp[k][j^(1&lt;&lt;(k-1))] ;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;判断结点是否都以访问,不包括0号结点\nbool isVisited(bool visited[])&#123;\n    for(int i &#x3D; 1 ; i&lt;N ;i++)\n        if(visited[i] &#x3D;&#x3D; false)\n            return false;\n    return true;\n&#125;\n\n&#x2F;&#x2F;获取最优路径，保存在path中,根据动态规划公式反向找出最短路径结点\nvoid getPath()&#123;\n    &#x2F;&#x2F;标记访问数组\n    bool visited[N] &#x3D; &#123;false&#125;;\n    &#x2F;&#x2F;前驱节点编号\n    int pioneer &#x3D; 0 ,min &#x3D; INF, S &#x3D; M - 1,temp ;\n    &#x2F;&#x2F;把起点结点编号加入容器\n    path.push_back(0);\n \n    while(!isVisited(visited))&#123;\n        for(int i&#x3D;1; i&lt;N;i++)\n            if(visited[i] &#x3D;&#x3D; false &amp;&amp; (S&amp;(1&lt;&lt;(i-1))) !&#x3D; 0)\n                if(min &gt; g[i][pioneer] + dp[i][(S^(1&lt;&lt;(i-1)))])\n                    min &#x3D; g[i][pioneer] + dp[i][(S^(1&lt;&lt;(i-1)))] ;\n                    temp &#x3D; i;\n            \n        pioneer &#x3D; temp;\n        path.push_back(pioneer);\n        visited[pioneer] &#x3D; true;\n        S &#x3D; S ^ (1&lt;&lt;(pioneer - 1));\n        min &#x3D; INF;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;输出路径\nvoid printPath()&#123;\n    cout&lt;&lt;&quot;最小路径为：&quot;;\n    vector&lt;int&gt;::iterator  it &#x3D; path.begin();\n    for(it ; it !&#x3D; path.end();it++)\n        cout&lt;&lt;*it&lt;&lt;&quot;---&gt;&quot;;\n    &#x2F;&#x2F;单独输出起点编号\n    cout&lt;&lt;0;\n&#125;\n \nint main()\n&#123;\n    TSP();\n    cout&lt;&lt;&quot;最小值为：&quot;&lt;&lt;dp[0][M-1]&lt;&lt;endl;\n    getPath();\n    printPath();\n    return 0;\n&#125;</code></pre>\r\n<h2 id=\"八测试结果及性能分析\">八、测试结果及性能分析</h2>\r\n<figure>\r\n<img src=\"https://img-blog.csdnimg.cn/20190923205046784.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>时间复杂度：<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?O%282%5E%7Bn%7Dn%5E%7B2%7D%29\" /></p>\r\n<p>空间复杂度：<embed\r\nsrc=\"https://private.codecogs.com/gif.latex?O%282%5E%7Bn%7D%29\" /></p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/qq_39559641/article/details/101209534\">旅行商问题（动态规划方法，超级详细的）_仁者乐山智者乐水的博客-CSDN博客_旅行商问题</a></p>\r\n","text":"一、题目 一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。 售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。 （等价于求图的最短哈密尔顿回路问题）令G=(V, E)是一个带权重的有向...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"DP","slug":"DP","count":1,"path":"api/tags/DP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">一、题目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B\"><span class=\"toc-text\">二、测试用例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">三、动态规划方程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E7%94%A8%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">四、用例分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">五、数据结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">六、最短路径顶点的计算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\"><span class=\"toc-text\">八、测试结果及性能分析</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Birthday Paradox","uid":"b0298187d3b43e42af9c0e2b93f65724","slug":"Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T14:27:36.000Z","comments":true,"path":"api/articles/Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"生日悖论-birthday paradox 一个很简单的概率关系，由于其反直觉而称为“悖论”： 一个房间要多少人，则两个人的生日相同的概率 对应情况 所需人数 大于50%？ 23人 大于70%？ 30人 大于97%？ 50人 大于99%？ 57人 可以发现，概率大于99%所需的人...","link":"","photos":[],"count_time":{"symbolsCount":966,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Hash Function","uid":"991c84bc86acdc32c9243fba302e2655","slug":"Algorithm/HashFunction/HashFunction","date":"2022-12-23T04:23:23.000Z","updated":"2023-11-01T04:27:17.784Z","comments":true,"path":"api/articles/Algorithm/HashFunction/HashFunction.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"简明Hash function教程 请注意！这篇文档是关于散列函数Hash function的，如果需要了解Hash table相关内容请查阅“简明Hash table教程”等相关文章 引子 在各种下载站的资源页面下方，经常会有如下以SHA开头的特殊字段 SHA1：9B71AD5...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"Hash","slug":"Hash","count":1,"path":"api/tags/Hash.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}