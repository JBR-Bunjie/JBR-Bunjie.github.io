{"title":"大数运算","uid":"c7cd6315021c2b49c9efb80c79e420a8","slug":"Algorithm/大数四则运算","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:25:14.000Z","comments":true,"path":"api/articles/Algorithm/大数四则运算.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<p>前言：</p>\n<p>在计算机中数字表示的范围是有限制的，比如我们熟知的 int、float、double 等数据类型所能表示的范围都是有限的，如果我们要对位数达到几十位、几百位、上千位的大整数进行计算，这些数据类型显然不能满足我们的要求，因此我们需要通过算法来实现这些功能。</p>\n<p>1、大数加法</p>\n<p>两个大数我们可以用数组来保存，然后在数组中逐位进行相加，再判断该位相加后是否需要进位，为了方便计算，我们将数字的低位放在数组的前面，高位放在后面。</p>\n<p>下面是两个正的大整数相加算法的C语言参考代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\n#define MAX 1000    &#x2F;&#x2F; 大数的最大位数\n\n\n&#x2F;*\n  大数加法\n  参数：\n  num1为第一个大数，用字符数组保存\n  num2为第二个大数\n  sum数组保存相加的结果  即：num1+num2&#x3D;sum\n  返回值：返回数组sum的有效长度，即计算结果的位数\n *&#x2F;\nint Addition(char num1[], char num2[], int sum[])\n&#123;\n    int i, j, len;\n    int n2[MAX] &#x3D; &#123;0&#125;;\n    int len1 &#x3D; strlen (num1); &#x2F;&#x2F; 计算数组num1的长度，即大数的位数\n    int len2 &#x3D; strlen (num2); &#x2F;&#x2F; 计算数组num2的长度，即大数的位数\n\n    len &#x3D; len1&gt;len2 ? len1 : len2; &#x2F;&#x2F; 获取较大的位数\n    &#x2F;&#x2F;将num1字符数组的数字字符转换为整型数字，且逆向保存在整型数组sum中，即低位在前，高位在后\n    for (i &#x3D; len1-1, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)\n        sum[j] &#x3D; num1[i] - &#39;0&#39;;\n    &#x2F;&#x2F; 转换第二个数\n    for (i &#x3D; len2-1, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)\n        n2[j] &#x3D; num2[i] - &#39;0&#39;;\n    &#x2F;&#x2F; 将两个大数相加\n    for (i &#x3D; 0; i &lt;&#x3D; len; i++)\n    &#123;\n        sum[i] +&#x3D; n2[i];  &#x2F;&#x2F; 两个数从低位开始相加\n        if (sum[i] &gt; 9)   &#x2F;&#x2F; 判断是否有进位\n        &#123;   &#x2F;&#x2F; 进位\n            sum[i] -&#x3D; 10;\n            sum[i+1]++;\n        &#125;\n    &#125;\n    if(sum[len] !&#x3D; 0)  &#x2F;&#x2F; 判断最高位是否有进位\n        len++;\n    return len;   &#x2F;&#x2F; 返回和的位数\n&#125;\n\nint main()\n&#123;\n    int i, len;\n    int sum[MAX] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 存放计算的结果，低位在前，高位在后，即sum[0]是低位\n    char num1[] &#x3D; &quot;1234567891234567891234&quot;; &#x2F;&#x2F; 第一个大数\n    char num2[] &#x3D; &quot;2345678912345678913345&quot;; &#x2F;&#x2F; 第二个大数\n    len &#x3D; Addition(num1, num2, sum);    &#x2F;&#x2F; 两数相加\n    printf(&quot;%s\\n  +\\n%s\\n  &#x3D;\\n&quot;, num1, num2);\n    &#x2F;&#x2F; 反向输出求和结果\n    for (i &#x3D; len-1; i &gt;&#x3D; 0; i--)\n        printf(&quot;%d&quot;, sum[i]);\n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;\n</code></pre>\n\n<p>2、大数减法</p>\n<p>相减算法也是从低位开始减的。先要判断被减数和减数哪一个位数长，若被减数位数长是正常的减法；若减数位数长，则用被减数减去减数，最后还要加上负号；当两数位数长度相等时，最好比较哪一个数字大，否则负号处理会很繁琐；处理每一项时要，如果前一位相减有借位，就先减去上一位的借位，无则不减，再去判断是否能够减开被减数，如果减不开，就要借位后再去减，同时置借位为1，否则置借位为0。</p>\n<p>下面是C语言参考代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\n#define MAX 1000    &#x2F;&#x2F; 大数的最大位数\n\n&#x2F;*\n  大数减法\n  参数：\n  num1为被减数，用字符数组保存\n  num2为减数\n  sum数组保存相减的结果   即：num1-num2&#x3D;sum\n  返回值：返回数组sum的有效长度，即计算结果的位数\n *&#x2F;\nint Subtraction(char num1[], char num2[], int sum[])\n&#123;\n    int i, j, len, blag;\n    char *temp;\n    int n2[MAX] &#x3D; &#123;0&#125;;\n    int len1 &#x3D; strlen(num1); &#x2F;&#x2F; 计算数组num1的长度，即大数的位数\n    int len2 &#x3D; strlen(num2); &#x2F;&#x2F; 计算数组num2的长度，即大数的位数\n\n    &#x2F;&#x2F; 在进行减法之前要进行一些预处理\n    blag &#x3D; 0; &#x2F;&#x2F; 为0表示结果是正整数，为1表示结果是负整数\n    if(len1 &lt; len2) &#x2F;&#x2F; 如果被减数位数小于减数\n    &#123;\n        blag &#x3D; 1; &#x2F;&#x2F; 标记结果为负数\n        &#x2F;&#x2F; 交换两个数，便于计算\n        temp &#x3D; num1;\n        num1 &#x3D; num2;\n        num2 &#x3D; temp;\n        len &#x3D; len1;\n        len1 &#x3D; len2;\n        len2 &#x3D; len;\n    &#125;\n    else if(len1 &#x3D;&#x3D;len2) &#x2F;&#x2F; 如果被减数的位数等于减数的位数\n    &#123;\n        &#x2F;&#x2F; 判断哪个数大\n        for(i &#x3D; 0; i &lt; len1; i++)\n        &#123;\n            if(num1[i] &#x3D;&#x3D; num2[i])\n                continue;\n            if(num1[i] &gt; num2[i])\n            &#123;\n                blag &#x3D; 0; &#x2F;&#x2F; 标记结果为正数\n                break;\n            &#125;\n            else\n            &#123;\n                blag &#x3D; 1; &#x2F;&#x2F; 标记结果为负数\n                &#x2F;&#x2F; 交换两个数，便于计算\n                temp &#x3D; num1;\n                num1 &#x3D; num2;\n                num2 &#x3D; temp;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    len &#x3D; len1&gt;len2 ? len1 : len2; &#x2F;&#x2F; 获取较大的位数\n    &#x2F;&#x2F;将num1字符数组的数字转换为整型数且逆向保存在整型数组sum中，即低位在前，高位在后\n    for (i &#x3D; len1-1, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)\n        sum[j] &#x3D; num1[i] - &#39;0&#39;;\n    &#x2F;&#x2F; 转换第二个数\n    for (i &#x3D; len2-1, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)\n        n2[j] &#x3D; num2[i] - &#39;0&#39;;\n    &#x2F;&#x2F; 将两个大数相减\n    for (i &#x3D; 0; i &lt;&#x3D; len; i++)\n    &#123;\n        sum[i] &#x3D; sum[i] - n2[i]; &#x2F;&#x2F; 两个数从低位开始相减\n        if (sum[i] &lt; 0)   &#x2F;&#x2F; 判断是否有借位\n        &#123;    &#x2F;&#x2F; 借位\n            sum[i] +&#x3D; 10;\n            sum[i+1]--;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 计算结果长度\n    for (i &#x3D; len1-1; i&gt;&#x3D;0 &amp;&amp; sum[i] &#x3D;&#x3D; 0; i--)\n        ;\n    len &#x3D; i+1;\n    if(blag&#x3D;&#x3D;1)\n    &#123;\n        sum[len] &#x3D; -1;  &#x2F;&#x2F; 在高位添加一个-1表示负数\n        len++;\n    &#125;\n    return len;   &#x2F;&#x2F; 返回结果的位数\n&#125;\n\nint main()\n&#123;\n    int i, len;\n    int sum[MAX] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 存放计算的结果，低位在前，高位在后，即sum[0]是低位\n    char num1[] &#x3D; &quot;987654321987654321&quot;; &#x2F;&#x2F; 第一个大数\n    char num2[] &#x3D; &quot;123456789123456789&quot;; &#x2F;&#x2F; 第二个大数\n    len &#x3D; Subtraction(num1, num2, sum);    &#x2F;&#x2F; 两数相减\n    &#x2F;&#x2F; 输出结果\n    printf(&quot;%s\\n  -\\n%s\\n  &#x3D;\\n&quot;, num1, num2);\n    if(sum[i&#x3D;len-1] &lt; 0) &#x2F;&#x2F; 根据高位是否是-1判断是否是负数\n    &#123;\n        printf(&quot;-&quot;); &#x2F;&#x2F; 输出负号\n        i--;\n    &#125;\n    for (; i &gt;&#x3D; 0; i--)\n        printf(&quot;%d&quot;, sum[i]);\n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;</code></pre>\n\n<p>3、大数乘法</p>\n<p>首先说一下乘法计算的算法，从低位向高位乘，在竖式计算中，我们是将乘数第一位与被乘数的每一位相乘，记录结果，之后，用第二位相乘，记录结果并且左移一位，以此类推，直到计算完最后一位，再将各项结果相加，得出最后结果。</p>\n<p>计算的过程基本上和小学生列竖式做乘法相同。为了编程方便，并不急于处理进位，而是将进位问题留待最后统一处理。</p>\n<p>总结一个规律: 即一个数的第i 位和另一个数的第j 位相乘所得的数，一定是要累加到结果的第i+j 位上。这里i, j 都是从右往左，从0 开始数。<code>ans[i+j] = a[i]*b[j];</code></p>\n<p>另外注意进位时要处理，当前的值加上进位的值再看本位数字是否又有进位；前导清零。</p>\n<p>下面是C语言的两个正大数相乘的参考代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\n#define MAX 1000    &#x2F;&#x2F; 大数的最大位数\n\n\n&#x2F;*\n  大数乘法\n  参数：\n  num1为第一个因数，用字符数组保存\n  num2为第二个因数\n  sum数组保存相乘的结果  即：num1*num2&#x3D;sum\n  返回值：返回数组sum的有效长度，即计算结果的位数\n *&#x2F;\nint Multiplication(char num1[],char num2[], int sum[])\n&#123;\n    int i, j, len, len1, len2;\n    int a[MAX+10] &#x3D; &#123;0&#125;;\n    int b[MAX+10] &#x3D; &#123;0&#125;;\n    int c[MAX*2+10] &#x3D; &#123;0&#125;;\n\n    len1 &#x3D; strlen(num1);\n    for(j &#x3D; 0, i &#x3D; len1-1; i &gt;&#x3D; 0; i--) &#x2F;&#x2F;把数字字符转换为整型数\n        a[j++] &#x3D; num1[i]-&#39;0&#39;;\n    len2 &#x3D; strlen(num2);\n    for(j &#x3D; 0, i &#x3D; len2-1; i &gt;&#x3D; 0; i--)\n        b[j++] &#x3D; num2[i]-&#39;0&#39;;\n\n    for(i &#x3D; 0; i &lt; len2; i++)&#x2F;&#x2F;用第二个数乘以第一个数,每次一位\n    &#123;\n        for(j &#x3D; 0; j &lt; len1; j++)\n        &#123;\n            c[i+j] +&#x3D; b[i] * a[j]; &#x2F;&#x2F;先乘起来,后面统一进位\n        &#125;\n    &#125;\n\n    for(i&#x3D;0; i&lt;MAX*2; i++) &#x2F;&#x2F;循环统一处理进位问题\n    &#123;\n        if(c[i]&gt;&#x3D;10)\n        &#123;\n            c[i+1]+&#x3D;c[i]&#x2F;10;\n            c[i]%&#x3D;10;\n        &#125;\n    &#125;\n\n    for(i &#x3D; MAX*2; c[i]&#x3D;&#x3D;0 &amp;&amp; i&gt;&#x3D;0; i--); &#x2F;&#x2F;跳过高位的0\n    len &#x3D; i+1; &#x2F;&#x2F; 记录结果的长度\n    for(; i&gt;&#x3D;0; i--)\n        sum[i]&#x3D;c[i];\n    return len;\n&#125;\n\nint main()\n&#123;\n    int i, len;\n    int sum[MAX*2+10] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 存放计算的结果，低位在前，高位在后，即sum[0]是低位\n    char num1[] &#x3D; &quot;123456789123456789&quot;; &#x2F;&#x2F; 第一个大数\n    char num2[] &#x3D; &quot;123456789123456789&quot;; &#x2F;&#x2F; 第二个大数\n    len &#x3D; Multiplication(num1, num2, sum);\n    &#x2F;&#x2F; 输出结果\n    printf(&quot;%s\\n  *\\n%s\\n  &#x3D;\\n&quot;, num1, num2);\n    for(i &#x3D; len-1; i&gt;&#x3D;0; i--)\n        printf(&quot;%d&quot;, sum[i]);\n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;</code></pre>\n\n<p>4、大数除法</p>\n<p>大数除法是四则运算里面最难的一种。不同于一般的模拟，除法操作不是模仿手工除法，而是利用减法操作来实现的。其基本思想是反复做除法，看从被除数里面最多能减去多少个除数，商就是多少。逐个减显然太慢，要判断一次最多能减少多少个整数(除数)的10的n次方。</p>\n<p>以7546除以23为例：</p>\n<p>先用7546减去23的100倍，即减去2300，可以减3次，余下646，此时商就是300 (300=100*3)；<br>然后646减去23的10倍，即减去230，可以减2次，余下186，此时商就是320 (320=300+10*2)；</p>\n<p>然后186减去23，可以减8次，余下2，此时商就是328 (328=320+1*8)；</p>\n<p>因为2除以23的结果小于1，而我们又不用计算小数点位，所以不必再继续算下去了。</p>\n<p>下面是C语言的两个正大数相除的参考代码，计算结果中没有小数：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#define MAX 1000    &#x2F;&#x2F; 大数的最大位数\n\n&#x2F;&#x2F; 注：\n&#x2F;&#x2F; 本代码在以下博客代码中进行修改：\n&#x2F;&#x2F; http:&#x2F;&#x2F;www.cnblogs.com&#x2F;javawebsoa&#x2F;archive&#x2F;2013&#x2F;08&#x2F;01&#x2F;3231078.html\n&#x2F;&#x2F;\n\n\n&#x2F;*\n  函数SubStract功能：\n  用长度为len1的大整数p1减去长度为len2的大整数p2\n  结果存在p1中，返回值代表结果的长度\n  不够减：返回-1 ， 正好够：返回0\n*&#x2F;\nint SubStract(int *p1, int len1, int *p2, int len2)\n&#123;\n    int i;\n    if(len1 &lt; len2)\n        return -1;\n    if(len1 &#x3D;&#x3D; len2 )\n    &#123;                        &#x2F;&#x2F; 判断p1 &gt; p2\n        for(i &#x3D; len1-1; i &gt;&#x3D; 0; i--)\n        &#123;\n            if(p1[i] &gt; p2[i])   &#x2F;&#x2F; 若大，则满足条件，可做减法\n                break;\n            else if(p1[i] &lt; p2[i]) &#x2F;&#x2F; 否则返回-1\n                return -1;\n        &#125;\n    &#125;\n    for(i &#x3D; 0; i &lt;&#x3D; len1-1; i++)  &#x2F;&#x2F; 从低位开始做减法\n    &#123;\n        p1[i] -&#x3D; p2[i];         &#x2F;&#x2F; 相减\n        if(p1[i] &lt; 0)           &#x2F;&#x2F; 若是否需要借位\n        &#123;   &#x2F;&#x2F; 借位\n            p1[i] +&#x3D; 10;\n            p1[i+1]--;\n        &#125;\n    &#125;\n    for(i &#x3D; len1-1; i &gt;&#x3D; 0; i--)  &#x2F;&#x2F; 查找结果的最高位\n    &#123;\n        if( p1[i] )             &#x2F;&#x2F;最高位第一个不为0\n            return (i+1);       &#x2F;&#x2F;得到位数并返回\n    &#125;\n    return 0;                   &#x2F;&#x2F;两数相等的时候返回0\n&#125;\n\n\n&#x2F;*\n  大数除法---结果不包括小数点\n  num1 被除数\n  num2 除数\n  sum  商，存放计算的结果，即：num1&#x2F;num2&#x3D;sum\n  返回数组sum的有效长度，即商的位数\n*&#x2F;\nint Division(char num1[], char num2[], char sum[])\n&#123;\n    int k, i, j;\n    int len1, len2, len&#x3D;0;     &#x2F;&#x2F;大数位数\n    int dValue;                &#x2F;&#x2F;两大数相差位数\n    int nTemp;                 &#x2F;&#x2F;Subtract函数返回值\n    int num_a[MAX] &#x3D; &#123;0&#125;;      &#x2F;&#x2F;被除数\n    int num_b[MAX] &#x3D; &#123;0&#125;;      &#x2F;&#x2F;除数\n    int num_c[MAX] &#x3D; &#123;0&#125;;      &#x2F;&#x2F;商\n\n    len1 &#x3D; strlen(num1);       &#x2F;&#x2F;获得大数的位数\n    len2 &#x3D; strlen(num2);\n\n    &#x2F;&#x2F;将数字字符转换成整型数，且翻转保存在整型数组中\n    for( j &#x3D; 0, i &#x3D; len1-1; i &gt;&#x3D; 0; j++, i-- )\n        num_a[j] &#x3D; num1[i] - &#39;0&#39;;\n    for( j &#x3D; 0, i &#x3D; len2-1; i &gt;&#x3D; 0; j++, i-- )\n        num_b[j] &#x3D; num2[i] - &#39;0&#39;;\n\n    if( len1 &lt; len2 )          &#x2F;&#x2F;如果被除数小于除数，直接返回-1，表示结果为0\n    &#123;\n        return -1;\n    &#125;\n    dValue &#x3D; len1 - len2;      &#x2F;&#x2F;相差位数\n    for (i &#x3D; len1-1; i &gt;&#x3D; 0; i--)    &#x2F;&#x2F;将除数扩大，使得除数和被除数位数相等\n    &#123;\n        if (i &gt;&#x3D; dValue)\n            num_b[i] &#x3D; num_b[i-dValue];\n        else                         &#x2F;&#x2F;低位置0\n            num_b[i] &#x3D; 0;\n    &#125;\n    len2 &#x3D; len1;\n    for(j &#x3D; 0; j &lt;&#x3D; dValue; j++ )    &#x2F;&#x2F;重复调用，同时记录减成功的次数，即为商\n    &#123;\n        while((nTemp &#x3D; SubStract(num_a, len1, num_b+j, len2-j)) &gt;&#x3D; 0)\n        &#123;\n            len1 &#x3D; nTemp;            &#x2F;&#x2F;结果长度\n            num_c[dValue-j]++;       &#x2F;&#x2F;每成功减一次，将商的相应位加1\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 计算商的位数，并将商放在sum字符数组中\n    for(i &#x3D; MAX-1; num_c[i] &#x3D;&#x3D; 0 &amp;&amp; i &gt;&#x3D; 0; i-- );  &#x2F;&#x2F;跳过高位0，获取商的位数\n    if(i &gt;&#x3D; 0)\n        len &#x3D; i + 1; &#x2F;&#x2F; 保存位数\n    for(j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)     &#x2F;&#x2F; 将结果复制到sum数组中\n        sum[j] &#x3D; num_c[i] + &#39;0&#39;;\n    sum[j] &#x3D; &#39;\\0&#39;;   &#x2F;&#x2F; sum字符数组结尾置0\n    return len;      &#x2F;&#x2F; 返回商的位数\n&#125;\n\n\nint main()\n&#123;\n    int i;\n    int len;                &#x2F;&#x2F; 商的位数\n    char num1[MAX] &#x3D; &quot;1234567899876543210&quot;;   &#x2F;&#x2F; 第一个大数\n    char num2[MAX] &#x3D; &quot;20160415123025&quot;;              &#x2F;&#x2F; 第二个大数\n    char sum[MAX] &#x3D; &#123;0&#125;;    &#x2F;&#x2F; 计算结果\n\n    &#x2F;&#x2F;scanf(&quot;%s&quot;, num1);      &#x2F;&#x2F;以字符串形式读入大数\n    &#x2F;&#x2F;scanf(&quot;%s&quot;, num2);\n\n    len &#x3D; Division(num1, num2, sum);\n\n    &#x2F;&#x2F;输出结果\n    printf(&quot;%s\\n  ÷\\n%s\\n  &#x3D;\\n&quot;, num1, num2);\n    if( len&gt;&#x3D;0 )\n    &#123;\n        for(i &#x3D; 0; i &lt; len; i++ )\n            printf(&quot;%c&quot;, sum[i]);\n    &#125;\n    else\n    &#123;\n        printf(&quot;0&quot;);\n    &#125;\n    printf(&quot;\\n&quot;);\n\n    return 0;\n&#125;</code></pre>\n","text":"前言： 在计算机中数字表示的范围是有限制的，比如我们熟知的 int、float、double 等数据类型所能表示的范围都是有限的，如果我们要对位数达到几十位、几百位、上千位的大整数进行计算，这些数据类型显然不能满足我们的要求，因此我们需要通过算法来实现这些功能。 1、大数加法 两...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"calculate","slug":"calculate","count":1,"path":"api/tags/calculate.json"}],"toc":"","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Floor method","uid":"920b0f28d25f5984040e129525c64cc1","slug":"Algorithm/小数取整","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:25:54.000Z","comments":true,"path":"api/articles/Algorithm/小数取整.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"以python为例： int()进行强制类型转化 round()函数 format()函数 两个精巧的数学计算 a &#x3D; 60.89564 a&#x2F;&#x2F;1 a-(a+1)%1 (a+B-1)&#x2F;&#x2F;B # 向上取整 ","link":"","photos":[],"count_time":{"symbolsCount":131,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Number Processing","slug":"Number-Processing","count":1,"path":"api/tags/Number-Processing.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"平面分割问题","uid":"61e7c8da8f21c01a5499770adb3ae992","slug":"Algorithm/平面切割","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:27:40.000Z","comments":true,"path":"api/articles/Algorithm/平面切割.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"直线切割平面问题Reference： 平面分割_xzx9的博客-CSDN博客_平面分割空间 平面分割类问题总结 - Yeader - 博客园 (cnblogs.com) Detail：【题型一】直线分割平面 在一个平面上有一个圆和n条直线，这些直线中每一条在圆内同其他直线相交，假...","link":"","photos":[],"count_time":{"symbolsCount":517,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Geometry","slug":"Geometry","count":1,"path":"api/tags/Geometry.json"},{"name":"plane","slug":"plane","count":1,"path":"api/tags/plane.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}