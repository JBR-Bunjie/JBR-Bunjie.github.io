{"title":"R&K Algorithm","uid":"3300e6e8edea21eb33ad89b2150bf9cc","slug":"Algorithm/String Processing/KR&RK","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:10:37.847Z","comments":true,"path":"api/articles/Algorithm/String Processing/KR&RK.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"Rabin–Karp-algorithm-拉宾-卡普算法\"><a href=\"#Rabin–Karp-algorithm-拉宾-卡普算法\" class=\"headerlink\" title=\"Rabin–Karp algorithm - 拉宾-卡普算法\"></a>Rabin–Karp algorithm - 拉宾-卡普算法</h1><p><del>拉宾-卡普算法（英語：Rabin–Karp algorithm）或卡普-拉宾算法（Karp–Rabin algorithm）</del></p>\n<h2 id=\"General\"><a href=\"#General\" class=\"headerlink\" title=\"General\"></a>General</h2><p><a href=\"https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm\">Rabin-Karp 算法</a>是由 <a href=\"https://en.wikipedia.org/wiki/Richard_M._Karp\">Richard M. Karp</a>和 <a href=\"https://en.wikipedia.org/wiki/Michael_O._Rabin\">Michael O. Rabin</a>创建的字符串搜索算法</p>\n<p>KR Algorithm使用散列来查找文本中的一组模式字符串中的任何一个。</p>\n<h2 id=\"Detail\"><a href=\"#Detail\" class=\"headerlink\" title=\"Detail\"></a>Detail</h2><p>假设我们有一个文本： <strong>yeminsajid</strong> ，我们想知道文本中是否存在模式 <strong>nsa</strong> 。要计算散列和滚动散列，我们需要使用素数。这可以是任何素数。让我们在这个例子中使用 <strong>prime</strong> = <strong>11</strong> 。我们将使用以下公式确定哈希值：</p>\n<pre class=\"line-numbers language-placeholder\" data-language=\"placeholder\"><code class=\"language-placeholder\">(1st letter) X (prime) + (2nd letter) X (prime)¹ + (3rd letter) X (prime)² X + ......</code></pre>\n\n<p>我们将表示：</p>\n<pre class=\"line-numbers language-placeholder\" data-language=\"placeholder\"><code class=\"language-placeholder\">a -&gt; 1    g -&gt; 7    m -&gt; 13   s -&gt; 19   y -&gt; 25\nb -&gt; 2    h -&gt; 8    n -&gt; 14   t -&gt; 20   z -&gt; 26\nc -&gt; 3    i -&gt; 9    o -&gt; 15   u -&gt; 21\nd -&gt; 4    j -&gt; 10   p -&gt; 16   v -&gt; 22\ne -&gt; 5    k -&gt; 11   q -&gt; 17   w -&gt; 23\nf -&gt; 6    l -&gt; 12   r -&gt; 18   x -&gt; 24</code></pre>\n\n<p><strong>nsa</strong> 的哈希值为 ：<br>$$<br>HASH(nsa) = 14 * 11^0 + 19 * 11^1 + 1 * 11^2 = 344<br>$$</p>\n<p>现在我们找到文本的滚动哈希值。如果滚动哈希与模式的哈希值匹配，我们将检查字符串是否匹配。因为我们的模式有 <strong>3 个</strong>字母，我们将采取 1 日 <strong>3</strong> 封 <strong>YEM</strong> 从我们的文本，并计算哈希值。我们得到：<br>$$<br>HASH(yem) = 25 * 11^0 + 5 * 11^1 + 13 * 11^2 = 1653<br>$$<br>此值与我们的模式的哈希值不匹配。所以字符串在这里不存在。现在我们需要考虑下一步。计算下一个字符串 <strong>emi</strong> 的哈希值。我们当然可以直接重新从。但这将是相当微不足道的，并且会花费更多。相反，我们使用另一种技术。</p>\n<ul>\n<li>我们从当前哈希值中减去 <strong>Previous String</strong> 中的 <strong>第一个字母的</strong> 即 <strong>y</strong> 的值。即：<code>1653 - 25 = 1628</code>。</li>\n<li>再次除以设定的<strong>素数 prime——11</strong>，可得：1628 / 11 = 148`。</li>\n<li>最后加上<strong>新的字母 *（素数）^ m - 1</strong>，可得：<code>148 + 9 X 11² = 1237</code>。</li>\n</ul>\n<p>新的哈希值不等于我们的模式哈希值。继续前进直到 <strong>a</strong> (nsa)，有：</p>\n<pre class=\"line-numbers language-placeholder\" data-language=\"placeholder\"><code class=\"language-placeholder\">Previous String: ins\nFirst Letter of Previous String: i(9)\nNew Letter: a(1)\nNew String: &quot;nsa&quot;\n------------------------------\n2462 - 9 &#x3D; 2453\n2453 &#x2F; 11 &#x3D; 223\n223 + 1 X 11² &#x3D; 344</code></pre>\n\n<p>这是一个匹配！ 现由于两个字符串都匹配，因此匹配字符串存在于目标字符串中，现在我们只需要返回目标字符串匹配字段的起始位置即可。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><h3 id=\"KR-JS\"><a href=\"#KR-JS\" class=\"headerlink\" title=\"KR - JS\"></a>KR - JS</h3><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;**\n * @param &#123;string&#125; haystack\n * @param &#123;string&#125; needle\n * @return &#123;number&#125;\n *&#x2F;\n&#x2F;*\n\n*&#x2F;\n&#x2F;**\n * @param &#123;string&#125; haystack\n * @param &#123;string&#125; needle\n * @return &#123;number&#125;\n *&#x2F;\nvar strStr &#x3D; function(haystack, needle)&#123;\n    if(needle.length &#x3D;&#x3D; 0) return 0;\n    let n &#x3D; haystack.length;\n    let m &#x3D; needle.length;\n    let s &#x3D; &#39; &#39;+haystack;\n    let t &#x3D; &#39; &#39;+needle;\n    \n    &#x2F;&#x2F;String添加一个重新确定字符值得方法\n    String.prototype.newCode &#x3D; function()&#123;\n        return this.charCodeAt()-97+1;\n    &#125;\n    &#x2F;&#x2F;确定模数 尽量避免冲突\n    let p &#x3D; 999991, d &#x3D; 131;\n    &#x2F;&#x2F;计算thash\n    let tHash &#x3D; 0;\n    for(let i&#x3D;1; i&lt;&#x3D;m; i++)&#123;\n        tHash &#x3D; (tHash*d + t[i].newCode()) % p;\n    &#125;\n    &#x2F;&#x2F;计算sHash子串的值\n    let sHash &#x3D; new Array(n+1);\n    sHash[0] &#x3D; 0;\n    for(let i&#x3D;1; i&lt;&#x3D;n; i++)&#123;\n        sHash[i] &#x3D; (sHash[i-1]*d + s[i].newCode()) % p;\n    &#125;\n   \n\n    &#x2F;&#x2F;hello ll\n    for(let i&#x3D;m; i&lt;&#x3D;n; i++)&#123;\n        if(calcHash(i-m, i, m) &#x3D;&#x3D; tHash)&#123;\n            return i-m;\n        &#125;\n    &#125;\n    return -1;\n    function calcHash(l, r, len)&#123;\n        &#x2F;&#x2F;_hello  求ll的hash\n        &#x2F;&#x2F;先求_hell的hash, 再求_he的hash进行补位\n        &#x2F;&#x2F;_hell - _he00 就是ll\n        &#x2F;&#x2F;注意相减的时候为避免负数，可以先加上模数。再取模\n        return (sHash[r] - (sHash[l]*myPow(d, len, p))%p + p) % p;\n    &#125;\n&#125;\nfunction myPow(x,n, m)&#123;\n    function helper(x,n)&#123;\n        if(n&#x3D;&#x3D;0) return 1.0;\n        let y &#x3D; helper(x, n&#x2F;2 | 0);\n        return n%2 &#x3D;&#x3D;0 ? (y*y)%m: (y*y*x)%m;\n    &#125;\n    return n&gt;&#x3D;0? helper(x, n) : 1.0&#x2F;helper(x, n);\n&#125;</code></pre>\n\n\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"http://www.tastones.com/stackoverflow/algorithm/substring-search/introduction_to_rabin-karp_algorithm/\">Rabin-Karp 算法简介 | 他山教程，只选择最优质的自学材料 (tastones.com)</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/implement-strstr/solution/28-shi-xian-strstr-rabin-karp-by-jingyua-w3h1/\">28. 实现 strStr() 题解 - 力扣（LeetCode） (leetcode-cn.com)</a></li>\n</ul>\n","text":"Rabin–Karp algorithm - 拉宾-卡普算法拉宾-卡普算法（英語：Rabin–Karp algorithm）或卡普-拉宾算法（Karp–Rabin algorithm） GeneralRabin-Karp 算法是由 Richard M. Karp和 Michael...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"String Processing","slug":"String-Processing","count":7,"path":"api/tags/String-Processing.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Rabin%E2%80%93Karp-algorithm-%E6%8B%89%E5%AE%BE-%E5%8D%A1%E6%99%AE%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Rabin–Karp algorithm - 拉宾-卡普算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#General\"><span class=\"toc-text\">General</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Detail\"><span class=\"toc-text\">Detail</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Code\"><span class=\"toc-text\">Code</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#KR-JS\"><span class=\"toc-text\">KR - JS</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Heap Sort - 堆排序","uid":"120c49bf67650504f15740668777cd42","slug":"Algorithm/SORT/Heap Sort","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:09:02.391Z","comments":true,"path":"api/articles/Algorithm/SORT/Heap Sort.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Heap Sort - 堆排序Reference： Recommend：堆排序之JAVA实现月光下一只赏月的猪的博客-CSDN博客java 堆排序 （高效率排序算法三）堆排序_送人玫瑰手留余香的博客-CSDN博客_堆排序效率 1.7 堆排序 | 菜鸟教程 (runoob.com)...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Sort","slug":"Sort","count":3,"path":"api/tags/Sort.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"Boyer Moore Algorithm","uid":"0d08c32366a524bf34b2dc2c2fb0333a","slug":"Algorithm/String Processing/Boyer Moore Algorithm","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:10:08.976Z","comments":true,"path":"api/articles/Algorithm/String Processing/Boyer Moore Algorithm.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Boyer Moore AlgorithmGeneral高效，可靠，应用广泛：各种文本编辑器的”查找”功能（Ctrl+F），大多采用Boyer-Moore算法 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。 De...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"String Processing","slug":"String-Processing","count":7,"path":"api/tags/String-Processing.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}