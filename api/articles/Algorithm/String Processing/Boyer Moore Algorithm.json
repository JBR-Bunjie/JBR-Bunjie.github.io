{"title":"Boyer Moore Algorithm","uid":"0d08c32366a524bf34b2dc2c2fb0333a","slug":"Algorithm/String Processing/Boyer Moore Algorithm","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:10:08.000Z","comments":true,"path":"api/articles/Algorithm/String Processing/Boyer Moore Algorithm.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"Boyer-Moore-Algorithm\"><a href=\"#Boyer-Moore-Algorithm\" class=\"headerlink\" title=\"Boyer Moore Algorithm\"></a>Boyer Moore Algorithm</h1><h2 id=\"General\"><a href=\"#General\" class=\"headerlink\" title=\"General\"></a>General</h2><p>高效，可靠，应用广泛：各种文本编辑器的”查找”功能（Ctrl+F），大多采用<a href=\"https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm\">Boyer-Moore算法</a></p>\n<p>1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。</p>\n<h2 id=\"Detail\"><a href=\"#Detail\" class=\"headerlink\" title=\"Detail\"></a>Detail</h2><h3 id=\"“坏字符规则”\"><a href=\"#“坏字符规则”\" class=\"headerlink\" title=\"“坏字符规则”\"></a>“坏字符规则”</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置</p></blockquote>\n<p>如果”坏字符”不包含在搜索词之中，则上一次出现位置为 -1。</p>\n<h3 id=\"“好后缀规则”\"><a href=\"#“好后缀规则”\" class=\"headerlink\" title=\"“好后缀规则”\"></a>“好后缀规则”</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>后移位数 = 好后缀的(最后)位置 - 后缀(在搜索词中)的上一次出现位置</p></blockquote>\n<p><strong>注意点</strong>：</p>\n<ol>\n<li>“好后缀”的位置以最后一个字符为准。假定”ABCDEF”的”EF”是好后缀，则它的位置以”F”为准，即5（从0开始计算）</li>\n<li>如果”好后缀”在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，”EF”在”ABCDEF”之中只出现一次，则它的上一次出现位置为-1（即未出现）</li>\n<li>如果”好后缀”有多个，则除了最长的那个”好后缀”，其他”好后缀”的上一次出现位置必须在头部。比如，假定”BABCDAB”的”好后缀”是”DAB”、”AB”、”B”，请问这时”好后缀”的上一次出现位置是什么？回答是，此时采用的好后缀是”B”，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个”好后缀”只出现一次，则可以把搜索词改写成如下形式进行位置计算”(DA)BABCDAB”，即虚拟加入最前面的”DA”</li>\n</ol>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static int pattern(String pattern, String target) &#123;\n    int tLen &#x3D; target.length();&#x2F;&#x2F;主串的长度\n    int pLen &#x3D; pattern.length();&#x2F;&#x2F;模式串的长度\n\n\t&#x2F;&#x2F;如果模式串比主串长，没有可比性，直接返回-1\n    if (pLen &gt; tLen) &#123;\n        return -1;\n    &#125;\n\n    int[] bad_table &#x3D; build_bad_table(pattern);&#x2F;&#x2F; 获得坏字符数值的数组，实现看下面\n    int[] good_table &#x3D; build_good_table(pattern);&#x2F;&#x2F; 获得好后缀数值的数组，实现看下面\n\n    for (int i &#x3D; pLen - 1, j; i &lt; tLen;) &#123;\n        System.out.println(&quot;跳跃位置：&quot; + i);\n        &#x2F;&#x2F;这里和上面实现坏字符的时候不一样的地方，我们之前提前求出坏字符以及好后缀\n        &#x2F;&#x2F;对应的数值数组，所以，我们只要在一边循环中进行比较。还要说明的一点是，这里\n        &#x2F;&#x2F;没有使用skip记录跳过的位置，直接针对主串中移动的指针i进行移动\n        for (j &#x3D; pLen - 1; target.charAt(i) &#x3D;&#x3D; pattern.charAt(j); i--, j--) &#123;\n            if (j &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;指向模式串的首字符，说明匹配成功，直接返回就可以了\n                System.out.println(&quot;匹配成功，位置：&quot; + i);\n                &#x2F;&#x2F;如果你还要匹配不止一个模式串，那么这里直接跳出这个循环，并且让i++\n                &#x2F;&#x2F;因为不能直接跳过整个已经匹配的字符串，这样的话可能会丢失匹配。\n&#x2F;&#x2F;\t\t\t\t\ti++;   &#x2F;&#x2F; 多次匹配\n&#x2F;&#x2F;\t\t\t\t\tbreak;\n                return i;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;如果出现坏字符，那么这个时候比较坏字符以及好后缀的数组，哪个大用哪个\n        i +&#x3D; Math.max(good_table[pLen - j - 1], bad_table[target.charAt(i)]);\n    &#125;\n    return -1;\n&#125;\n\n&#x2F;&#x2F;字符信息表\npublic static int[] build_bad_table(String pattern) &#123;\n    final int table_size &#x3D; 256;&#x2F;&#x2F;上面已经解释过了，字符的种类\n    int[] bad_table &#x3D; new int[table_size];&#x2F;&#x2F;创建一个数组，用来记录坏字符出现时，应该跳过的字符数\n    int pLen &#x3D; pattern.length();&#x2F;&#x2F;模式串的长度\n\n    for (int i &#x3D; 0; i &lt; bad_table.length; i++) &#123;\n        bad_table[i] &#x3D; pLen;  \n        &#x2F;&#x2F;默认初始化全部为匹配字符串长度,因为当主串中的坏字符在模式串中没有出\n        &#x2F;&#x2F;现时，直接跳过整个模式串的长度就可以了\n    &#125;\n    for (int i &#x3D; 0; i &lt; pLen - 1; i++) &#123;\n        int k &#x3D; pattern.charAt(i);&#x2F;&#x2F;记录下当前的字符ASCII码值\n        &#x2F;&#x2F;这里其实很值得思考一下，bad_table就不多说了，是根据字符的ASCII值存储\n        &#x2F;&#x2F;坏字符出现最右的位置，这在上面实现坏字符的时候也说过了。不过你仔细思考\n        &#x2F;&#x2F;一下，为什么这里存的坏字符数值，是最右的那个坏字符相对于模式串最后一个\n        &#x2F;&#x2F;字符的位置？为什么？首先你要理解i的含义，这个i不是在这里的i，而是在上面\n        &#x2F;&#x2F;那个pattern函数的循环的那个i，为了方便我们称呼为I，这个I很神奇，虽然I是\n        &#x2F;&#x2F;在主串上的指针，但是由于在循环中没有使用skip来记录，直接使用I随着j匹配\n        &#x2F;&#x2F;进行移动，也就意味着，在某种意义上，I也可以直接定位到模式串的相对位置，\n        &#x2F;&#x2F;理解了这一点，就好理解在本循环中，i的行为了。\n\n\t\t&#x2F;&#x2F;其实仔细去想一想，我们分情况来思考，如果模式串的最\n        &#x2F;&#x2F;后一个字符，也就是匹配开始的第一个字符，出现了坏字符，那么这个时候，直\n        &#x2F;&#x2F;接移动这个数值，那么正好能让最右的那个字符正对坏字符。那么如果不是第一个\n        &#x2F;&#x2F;字符出现坏字符呢？这种情况你仔细想一想，这种情况也就意味着出现了好后缀的\n        &#x2F;&#x2F;情况，假设我们将最右的字符正对坏字符\n        bad_table[k] &#x3D; pLen - 1 - i;\n    &#125;\n    return bad_table;\n&#125;\n\n&#x2F;&#x2F;匹配偏移表\npublic static int[] build_good_table(String pattern) &#123;\n    int pLen &#x3D; pattern.length();&#x2F;&#x2F;模式串长度\n    int[] good_table &#x3D; new int[pLen];&#x2F;&#x2F;创建一个数组，存好后缀数值\n    &#x2F;&#x2F;用于记录最新前缀的相对位置，初始化为模式串长度，因为意思就是当前后缀字符串为空\n    &#x2F;&#x2F;要明白lastPrefixPosition 的含义\n    int lastPrefixPosition &#x3D; pLen;\n\n    for (int i &#x3D; pLen - 1; i &gt;&#x3D; 0; --i) &#123;\n        if (isPrefix(pattern, i + 1)) &#123;\n        &#x2F;&#x2F;如果当前的位置存在前缀匹配，那么记录当前位置\n            lastPrefixPosition &#x3D; i + 1;\n        &#125;\n        good_table[pLen - 1 - i] &#x3D; lastPrefixPosition - i + pLen - 1;\n    &#125;\n\n    for (int i &#x3D; 0; i &lt; pLen - 1; ++i) &#123;\n    &#x2F;&#x2F;计算出指定位置匹配的后缀的字符串长度\n        int slen &#x3D; suffixLength(pattern, i);\n        good_table[slen] &#x3D; pLen - 1 - i + slen;\n    &#125;\n    return good_table;\n&#125;\n\n&#x2F;&#x2F;前缀匹配\nprivate static boolean isPrefix(String pattern, int p) &#123;\n    int patternLength &#x3D; pattern.length();&#x2F;&#x2F;模式串长度\n    &#x2F;&#x2F;这里j从模式串第一个字符开始，i从指定的字符位置开始，通过循环判断当前指定的位置p\n    &#x2F;&#x2F;之后的字符串是否匹配模式串前缀\n    for (int i &#x3D; p, j &#x3D; 0; i &lt; patternLength; ++i, ++j) &#123;\n        if (pattern.charAt(i) !&#x3D; pattern.charAt(j)) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\n\n&#x2F;&#x2F;后缀匹配\nprivate static int suffixLength(String pattern, int p) &#123;\n    int pLen &#x3D; pattern.length();\n    int len &#x3D; 0;\n    for (int i &#x3D; p, j &#x3D; pLen - 1; i &gt;&#x3D; 0 &amp;&amp; pattern.charAt(i) &#x3D;&#x3D; pattern.charAt(j); i--, j--) &#123;\n        len +&#x3D; 1;\n    &#125;\n    return len;\n&#125;</code></pre>\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html\">字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 (ruanyifeng.com)</a></li>\n<li><a href=\"https://blog.csdn.net/DBC_121/article/details/105569440\">不用找了，学习BM算法，这篇就够了（思路+详注代码）_BoCong-Deng的博客-CSDN博客_bm算法</a></li>\n</ul>\n","text":"Boyer Moore AlgorithmGeneral高效，可靠，应用广泛：各种文本编辑器的”查找”功能（Ctrl+F），大多采用Boyer-Moore算法 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。 De...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"String Processing","slug":"String-Processing","count":7,"path":"api/tags/String-Processing.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Boyer-Moore-Algorithm\"><span class=\"toc-text\">Boyer Moore Algorithm</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#General\"><span class=\"toc-text\">General</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Detail\"><span class=\"toc-text\">Detail</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%80%9C%E5%9D%8F%E5%AD%97%E7%AC%A6%E8%A7%84%E5%88%99%E2%80%9D\"><span class=\"toc-text\">“坏字符规则”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%80%9C%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E2%80%9D\"><span class=\"toc-text\">“好后缀规则”</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Code\"><span class=\"toc-text\">Code</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"拓扑排序","uid":"01d132f13ac67dff21350f57c338a855","slug":"Algorithm/SORT/Topological Sort","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:09:34.000Z","comments":true,"path":"api/articles/Algorithm/SORT/Topological Sort.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"拓扑排序Reference：拓扑排序（Topological Sorting） | 神奕的博客 (songlee24.github.io) Detail： 在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic G...","link":"","photos":[],"count_time":{"symbolsCount":524,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Sort","slug":"Sort","count":3,"path":"api/tags/Sort.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"R&K Algorithm","uid":"3300e6e8edea21eb33ad89b2150bf9cc","slug":"Algorithm/String Processing/KR&RK","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:10:37.000Z","comments":true,"path":"api/articles/Algorithm/String Processing/KR&RK.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Rabin–Karp algorithm - 拉宾-卡普算法拉宾-卡普算法（英語：Rabin–Karp algorithm）或卡普-拉宾算法（Karp–Rabin algorithm） GeneralRabin-Karp 算法是由 Richard M. Karp和 Michael...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"String Processing","slug":"String-Processing","count":7,"path":"api/tags/String-Processing.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}