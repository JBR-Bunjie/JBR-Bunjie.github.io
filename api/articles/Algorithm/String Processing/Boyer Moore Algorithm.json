{"title":"Boyer Moore Algorithm","uid":"0d08c32366a524bf34b2dc2c2fb0333a","slug":"Algorithm/String Processing/Boyer Moore Algorithm","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T14:29:30.000Z","comments":true,"path":"api/articles/Algorithm/String Processing/Boyer Moore Algorithm.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"boyer-moore-algorithm\">Boyer Moore Algorithm</h1>\r\n<h2 id=\"general\">General</h2>\r\n<p>高效，可靠，应用广泛：各种文本编辑器的\"查找\"功能（Ctrl+F），大多采用<a\r\nhref=\"https://en.wikipedia.org/wiki/Boyer–Moore_string_search_algorithm\">Boyer-Moore算法</a></p>\r\n<p>1977年，德克萨斯大学的Robert S. Boyer教授和J Strother\r\nMoore教授发明了这种算法。</p>\r\n<h2 id=\"detail\">Detail</h2>\r\n<h3 id=\"坏字符规则\">\"坏字符规则\"</h3>\r\n<blockquote>\r\n<p>后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置</p>\r\n</blockquote>\r\n<p>如果\"坏字符\"不包含在搜索词之中，则上一次出现位置为 -1。</p>\r\n<h3 id=\"好后缀规则\">\"好后缀规则\"</h3>\r\n<blockquote>\r\n<p>后移位数 = 好后缀的(最后)位置 - 后缀(在搜索词中)的上一次出现位置</p>\r\n</blockquote>\r\n<p><strong>注意点</strong>：</p>\r\n<ol type=\"1\">\r\n<li>\"好后缀\"的位置以最后一个字符为准。假定\"ABCDEF\"的\"EF\"是好后缀，则它的位置以\"F\"为准，即5（从0开始计算）</li>\r\n<li>如果\"好后缀\"在搜索词中只出现一次，则它的上一次出现位置为\r\n-1。比如，\"EF\"在\"ABCDEF\"之中只出现一次，则它的上一次出现位置为-1（即未出现）</li>\r\n<li>如果\"好后缀\"有多个，则除了最长的那个\"好后缀\"，其他\"好后缀\"的上一次出现位置必须在头部。比如，假定\"BABCDAB\"的\"好后缀\"是\"DAB\"、\"AB\"、\"B\"，请问这时\"好后缀\"的上一次出现位置是什么？回答是，此时采用的好后缀是\"B\"，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个\"好后缀\"只出现一次，则可以把搜索词改写成如下形式进行位置计算\"(DA)BABCDAB\"，即虚拟加入最前面的\"DA\"</li>\r\n</ol>\r\n<h2 id=\"code\">Code</h2>\r\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static int pattern(String pattern, String target) &#123;\n    int tLen &#x3D; target.length();&#x2F;&#x2F;主串的长度\n    int pLen &#x3D; pattern.length();&#x2F;&#x2F;模式串的长度\n\n\t&#x2F;&#x2F;如果模式串比主串长，没有可比性，直接返回-1\n    if (pLen &gt; tLen) &#123;\n        return -1;\n    &#125;\n\n    int[] bad_table &#x3D; build_bad_table(pattern);&#x2F;&#x2F; 获得坏字符数值的数组，实现看下面\n    int[] good_table &#x3D; build_good_table(pattern);&#x2F;&#x2F; 获得好后缀数值的数组，实现看下面\n\n    for (int i &#x3D; pLen - 1, j; i &lt; tLen;) &#123;\n        System.out.println(&quot;跳跃位置：&quot; + i);\n        &#x2F;&#x2F;这里和上面实现坏字符的时候不一样的地方，我们之前提前求出坏字符以及好后缀\n        &#x2F;&#x2F;对应的数值数组，所以，我们只要在一边循环中进行比较。还要说明的一点是，这里\n        &#x2F;&#x2F;没有使用skip记录跳过的位置，直接针对主串中移动的指针i进行移动\n        for (j &#x3D; pLen - 1; target.charAt(i) &#x3D;&#x3D; pattern.charAt(j); i--, j--) &#123;\n            if (j &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;指向模式串的首字符，说明匹配成功，直接返回就可以了\n                System.out.println(&quot;匹配成功，位置：&quot; + i);\n                &#x2F;&#x2F;如果你还要匹配不止一个模式串，那么这里直接跳出这个循环，并且让i++\n                &#x2F;&#x2F;因为不能直接跳过整个已经匹配的字符串，这样的话可能会丢失匹配。\n&#x2F;&#x2F;\t\t\t\t\ti++;   &#x2F;&#x2F; 多次匹配\n&#x2F;&#x2F;\t\t\t\t\tbreak;\n                return i;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;如果出现坏字符，那么这个时候比较坏字符以及好后缀的数组，哪个大用哪个\n        i +&#x3D; Math.max(good_table[pLen - j - 1], bad_table[target.charAt(i)]);\n    &#125;\n    return -1;\n&#125;\n\n&#x2F;&#x2F;字符信息表\npublic static int[] build_bad_table(String pattern) &#123;\n    final int table_size &#x3D; 256;&#x2F;&#x2F;上面已经解释过了，字符的种类\n    int[] bad_table &#x3D; new int[table_size];&#x2F;&#x2F;创建一个数组，用来记录坏字符出现时，应该跳过的字符数\n    int pLen &#x3D; pattern.length();&#x2F;&#x2F;模式串的长度\n\n    for (int i &#x3D; 0; i &lt; bad_table.length; i++) &#123;\n        bad_table[i] &#x3D; pLen;  \n        &#x2F;&#x2F;默认初始化全部为匹配字符串长度,因为当主串中的坏字符在模式串中没有出\n        &#x2F;&#x2F;现时，直接跳过整个模式串的长度就可以了\n    &#125;\n    for (int i &#x3D; 0; i &lt; pLen - 1; i++) &#123;\n        int k &#x3D; pattern.charAt(i);&#x2F;&#x2F;记录下当前的字符ASCII码值\n        &#x2F;&#x2F;这里其实很值得思考一下，bad_table就不多说了，是根据字符的ASCII值存储\n        &#x2F;&#x2F;坏字符出现最右的位置，这在上面实现坏字符的时候也说过了。不过你仔细思考\n        &#x2F;&#x2F;一下，为什么这里存的坏字符数值，是最右的那个坏字符相对于模式串最后一个\n        &#x2F;&#x2F;字符的位置？为什么？首先你要理解i的含义，这个i不是在这里的i，而是在上面\n        &#x2F;&#x2F;那个pattern函数的循环的那个i，为了方便我们称呼为I，这个I很神奇，虽然I是\n        &#x2F;&#x2F;在主串上的指针，但是由于在循环中没有使用skip来记录，直接使用I随着j匹配\n        &#x2F;&#x2F;进行移动，也就意味着，在某种意义上，I也可以直接定位到模式串的相对位置，\n        &#x2F;&#x2F;理解了这一点，就好理解在本循环中，i的行为了。\n\n\t\t&#x2F;&#x2F;其实仔细去想一想，我们分情况来思考，如果模式串的最\n        &#x2F;&#x2F;后一个字符，也就是匹配开始的第一个字符，出现了坏字符，那么这个时候，直\n        &#x2F;&#x2F;接移动这个数值，那么正好能让最右的那个字符正对坏字符。那么如果不是第一个\n        &#x2F;&#x2F;字符出现坏字符呢？这种情况你仔细想一想，这种情况也就意味着出现了好后缀的\n        &#x2F;&#x2F;情况，假设我们将最右的字符正对坏字符\n        bad_table[k] &#x3D; pLen - 1 - i;\n    &#125;\n    return bad_table;\n&#125;\n\n&#x2F;&#x2F;匹配偏移表\npublic static int[] build_good_table(String pattern) &#123;\n    int pLen &#x3D; pattern.length();&#x2F;&#x2F;模式串长度\n    int[] good_table &#x3D; new int[pLen];&#x2F;&#x2F;创建一个数组，存好后缀数值\n    &#x2F;&#x2F;用于记录最新前缀的相对位置，初始化为模式串长度，因为意思就是当前后缀字符串为空\n    &#x2F;&#x2F;要明白lastPrefixPosition 的含义\n    int lastPrefixPosition &#x3D; pLen;\n\n    for (int i &#x3D; pLen - 1; i &gt;&#x3D; 0; --i) &#123;\n        if (isPrefix(pattern, i + 1)) &#123;\n        &#x2F;&#x2F;如果当前的位置存在前缀匹配，那么记录当前位置\n            lastPrefixPosition &#x3D; i + 1;\n        &#125;\n        good_table[pLen - 1 - i] &#x3D; lastPrefixPosition - i + pLen - 1;\n    &#125;\n\n    for (int i &#x3D; 0; i &lt; pLen - 1; ++i) &#123;\n    &#x2F;&#x2F;计算出指定位置匹配的后缀的字符串长度\n        int slen &#x3D; suffixLength(pattern, i);\n        good_table[slen] &#x3D; pLen - 1 - i + slen;\n    &#125;\n    return good_table;\n&#125;\n\n&#x2F;&#x2F;前缀匹配\nprivate static boolean isPrefix(String pattern, int p) &#123;\n    int patternLength &#x3D; pattern.length();&#x2F;&#x2F;模式串长度\n    &#x2F;&#x2F;这里j从模式串第一个字符开始，i从指定的字符位置开始，通过循环判断当前指定的位置p\n    &#x2F;&#x2F;之后的字符串是否匹配模式串前缀\n    for (int i &#x3D; p, j &#x3D; 0; i &lt; patternLength; ++i, ++j) &#123;\n        if (pattern.charAt(i) !&#x3D; pattern.charAt(j)) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\n\n&#x2F;&#x2F;后缀匹配\nprivate static int suffixLength(String pattern, int p) &#123;\n    int pLen &#x3D; pattern.length();\n    int len &#x3D; 0;\n    for (int i &#x3D; p, j &#x3D; pLen - 1; i &gt;&#x3D; 0 &amp;&amp; pattern.charAt(i) &#x3D;&#x3D; pattern.charAt(j); i--, j--) &#123;\n        len +&#x3D; 1;\n    &#125;\n    return len;\n&#125;</code></pre>\r\n<h2 id=\"reference\">Reference</h2>\r\n<ul>\r\n<li><a\r\nhref=\"https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html\">字符串匹配的Boyer-Moore算法\r\n- 阮一峰的网络日志 (ruanyifeng.com)</a></li>\r\n<li><a\r\nhref=\"https://blog.csdn.net/DBC_121/article/details/105569440\">不用找了，学习BM算法，这篇就够了（思路+详注代码）_BoCong-Deng的博客-CSDN博客_bm算法</a></li>\r\n</ul>\r\n","text":"Boyer Moore Algorithm General 高效，可靠，应用广泛：各种文本编辑器的\"查找\"功能（Ctrl+F），大多采用Boyer-Moore算法 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。 ...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"String Processing","slug":"String-Processing","count":5,"path":"api/tags/String-Processing.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#boyer-moore-algorithm\"><span class=\"toc-text\">Boyer Moore Algorithm</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#general\"><span class=\"toc-text\">General</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#detail\"><span class=\"toc-text\">Detail</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9D%8F%E5%AD%97%E7%AC%A6%E8%A7%84%E5%88%99\"><span class=\"toc-text\">&quot;坏字符规则&quot;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99\"><span class=\"toc-text\">&quot;好后缀规则&quot;</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#code\"><span class=\"toc-text\">Code</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Noise Generate","uid":"e93f281683f5f1e8c6e0ab2a6dab5abb","slug":"Algorithm/NOISE/Noise","date":"2022-12-23T04:23:23.000Z","updated":"2023-11-01T04:26:53.242Z","comments":true,"path":"api/articles/Algorithm/NOISE/Noise.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"噪声 - Noise Randomness is needed to make things unpredictable, varied, and appear natural. ——catlike coding 在任何游戏中，噪声都是不可缺少的存在。因此，了解这些噪声的特点、用...","link":"","photos":[],"count_time":{"symbolsCount":916,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"Noise","slug":"Noise","count":1,"path":"api/tags/Noise.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"KMP","uid":"53896b079468d4c41963b2300dea196e","slug":"Algorithm/String Processing/KMP","date":"2022-12-23T04:23:23.000Z","updated":"2023-11-01T04:22:30.582Z","comments":true,"path":"api/articles/Algorithm/String Processing/KMP.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"KMP算法 KMP算法作用简介： 在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"String Processing","slug":"String-Processing","count":5,"path":"api/tags/String-Processing.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}