{"title":"KMP","uid":"53896b079468d4c41963b2300dea196e","slug":"Algorithm/String Processing/KMP","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T14:29:53.000Z","comments":true,"path":"api/articles/Algorithm/String Processing/KMP.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"kmp算法\">KMP算法</h1>\r\n<h2 id=\"kmp算法作用简介\">KMP算法作用简介：</h2>\r\n<p>在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。</p>\r\n<h2 id=\"kmp算法原理\">KMP算法原理：</h2>\r\n<h3 id=\"前缀与后缀\">1.前缀与后缀</h3>\r\n<blockquote>\r\n<p>几个必须明确的概念：前缀、后缀、相同前缀后缀的最大长度（为表述方便，下文均用公共最大长指代）</p>\r\n<ul>\r\n<li><code>abcdef</code>的前缀：<code>a</code>、<code>ab</code>、<code>abc</code>、<code>abcd</code>、<code>abcde</code>（注意：abcdef不是前缀）</li>\r\n<li><code>abcdef</code>的后缀：<code>f</code>、<code>ef</code>、<code>def</code>、<code>cdef</code>、<code>bcdef</code>（注意：abcdef不是后缀）</li>\r\n<li><code>abcdef</code>的公共最大长：0（因为其前缀与后缀没有相同的）</li>\r\n<li><code>ababa</code>的前缀：<code>a</code>、<code>ab</code>、<code>aba</code>、<code>abab</code></li>\r\n<li><code>ababa</code>的后缀：<code>a</code>、<code>ba</code>、<code>aba</code>、<code>baba</code></li>\r\n<li><code>ababa</code>的公共最大长：3（因为他们的公共前缀后缀中最长的为aba，长度3）</li>\r\n</ul>\r\n</blockquote>\r\n<h3 id=\"确定pmt-partial-match-table\">2.确定PMT (Partial Match\r\nTable)</h3>\r\n<blockquote>\r\n<p>\"部分匹配值\"就是\"前缀\"和\"后缀\"的最长的共有元素的长度。以\"ABCDABD\"为例，</p>\r\n<ul>\r\n<li>\"A\"的前缀和后缀都为空集，共有元素的长度为0；其value为</li>\r\n<li>\"AB\"的前缀为[A]，后缀为[B]，共有元素的长度为0；　　</li>\r\n<li>\"ABC\"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；　　</li>\r\n<li>\"ABCD\"的前缀为[A, AB, ABC]，后缀为[BCD, CD,\r\nD]，共有元素的长度为0；　　</li>\r\n<li>\"ABCDA\"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA,\r\nA]，共有元素为\"A\"，长度为1；　　</li>\r\n<li>\"ABCDAB\"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB,\r\nAB, B]，共有元素为\"AB\"，长度为2；　　</li>\r\n<li>\"ABCDABD\"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD,\r\nCDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>\r\n</ul>\r\n</blockquote>\r\n<p>得表：</p>\r\n<figure>\r\n<img src=\"bg2013050109.png\" alt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<h2 id=\"kmp算法的python实现\">KMP算法的Python实现：</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">strStr</span>(<span class=\"params\">self, haystack: <span class=\"built_in\">str</span>, needle: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">KMP</span>(<span class=\"params\">s, p</span>):</span><br><span class=\"line\">            <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            s 为主串</span></span><br><span class=\"line\"><span class=\"string\">            p 为模式串</span></span><br><span class=\"line\"><span class=\"string\">            如果 t 里有 p，返回打头下标</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span></span><br><span class=\"line\">            nex = getNext(p)</span><br><span class=\"line\">            i = <span class=\"number\">0</span></span><br><span class=\"line\">            j = <span class=\"number\">0</span>   <span class=\"comment\"># 分别是 s 和 p 的指针</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(s) <span class=\"keyword\">and</span> j &lt; <span class=\"built_in\">len</span>(p):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j == -<span class=\"number\">1</span> <span class=\"keyword\">or</span> s[i] == p[j]: <span class=\"comment\"># j == -1 是由于 j = next[j]产生</span></span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                    j += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    j = nex[j]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == <span class=\"built_in\">len</span>(p): <span class=\"comment\"># j 走到了末尾，说明匹配到了</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i - j</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">getNext</span>(<span class=\"params\">p</span>):</span><br><span class=\"line\">            <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">            p 为模式串</span></span><br><span class=\"line\"><span class=\"string\">            返回 next 数组，即部分匹配表</span></span><br><span class=\"line\"><span class=\"string\">            &quot;&quot;&quot;</span></span><br><span class=\"line\">            nex = [<span class=\"number\">0</span>] * (<span class=\"built_in\">len</span>(p) + <span class=\"number\">1</span>)</span><br><span class=\"line\">            nex[<span class=\"number\">0</span>] = -<span class=\"number\">1</span></span><br><span class=\"line\">            i = <span class=\"number\">0</span></span><br><span class=\"line\">            j = -<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(p):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j == -<span class=\"number\">1</span> <span class=\"keyword\">or</span> p[i] == p[j]:</span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                    j += <span class=\"number\">1</span></span><br><span class=\"line\">                    nex[i] = j     <span class=\"comment\"># 这是最大的不同：记录next[i]</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    j = nex[j]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> nex</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> KMP(haystack, needle)</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"reference\">Reference</h2>\r\n<ul>\r\n<li><a\r\nhref=\"https://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html\">字符串匹配的KMP算法\r\n- 阮一峰的网络日志 (ruanyifeng.com)</a></li>\r\n<li>如何更好地理解和掌握 KMP 算法? - 白鱼咸蛋笨大的回答 - 知乎\r\nhttps://www.zhihu.com/question/21923021/answer/642165149</li>\r\n<li>如何更好地理解和掌握 KMP 算法? - 海纳的回答 - 知乎\r\nhttps://www.zhihu.com/question/21923021/answer/281346746\r\n<sub>(第一个示例比较特殊)</sub></li>\r\n</ul>\r\n","text":"KMP算法 KMP算法作用简介： 在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"String Processing","slug":"String-Processing","count":5,"path":"api/tags/String-Processing.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#kmp%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">KMP算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#kmp%E7%AE%97%E6%B3%95%E4%BD%9C%E7%94%A8%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">KMP算法作用简介：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#kmp%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">KMP算法原理：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BC%80%E4%B8%8E%E5%90%8E%E7%BC%80\"><span class=\"toc-text\">1.前缀与后缀</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A1%AE%E5%AE%9Apmt-partial-match-table\"><span class=\"toc-text\">2.确定PMT (Partial Match\r\nTable)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#kmp%E7%AE%97%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">KMP算法的Python实现：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Boyer Moore Algorithm","uid":"0d08c32366a524bf34b2dc2c2fb0333a","slug":"Algorithm/String Processing/Boyer Moore Algorithm","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T14:29:30.000Z","comments":true,"path":"api/articles/Algorithm/String Processing/Boyer Moore Algorithm.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Boyer Moore Algorithm General 高效，可靠，应用广泛：各种文本编辑器的\"查找\"功能（Ctrl+F），大多采用Boyer-Moore算法 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"String Processing","slug":"String-Processing","count":5,"path":"api/tags/String-Processing.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"R&K Algorithm","uid":"3300e6e8edea21eb33ad89b2150bf9cc","slug":"Algorithm/String Processing/KR&RK","date":"2022-12-23T04:23:23.000Z","updated":"2023-10-27T14:29:56.000Z","comments":true,"path":"api/articles/Algorithm/String Processing/KR&RK.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Rabin–Karp algorithm - 拉宾-卡普算法 拉宾-卡普算法（英語：Rabin–Karp algorithm）或卡普-拉宾算法（Karp–Rabin algorithm） General Rabin-Karp 算法是由 Richard M. Karp和 Micha...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":31,"path":"api/tags/Algorithm.json"},{"name":"String Processing","slug":"String-Processing","count":5,"path":"api/tags/String-Processing.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}