{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Algorithm/String Processing/KMP","date":"2023-03-07T16:14:44.930Z","updated":"2022-04-09T10:09:54.000Z","comments":true,"path":"api/articles/Algorithm/String Processing/KMP.json","keywords":null,"cover":[],"content":"<h1 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h1><h2 id=\"KMP算法作用简介：\"><a href=\"#KMP算法作用简介：\" class=\"headerlink\" title=\"KMP算法作用简介：\"></a>KMP算法作用简介：</h2><p>在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。</p>\n<h2 id=\"KMP算法原理：\"><a href=\"#KMP算法原理：\" class=\"headerlink\" title=\"KMP算法原理：\"></a>KMP算法原理：</h2><h3 id=\"1-前缀与后缀\"><a href=\"#1-前缀与后缀\" class=\"headerlink\" title=\"1.前缀与后缀\"></a>1.前缀与后缀</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>几个必须明确的概念：前缀、后缀、相同前缀后缀的最大长度（为表述方便，下文均用公共最大长指代）</p>\n<ul>\n<li><code>abcdef</code>的前缀：<code>a</code>、<code>ab</code>、<code>abc</code>、<code>abcd</code>、<code>abcde</code>（注意：abcdef不是前缀）</li>\n<li><code>abcdef</code>的后缀：<code>f</code>、<code>ef</code>、<code>def</code>、<code>cdef</code>、<code>bcdef</code>（注意：abcdef不是后缀）</li>\n<li><code>abcdef</code>的公共最大长：0（因为其前缀与后缀没有相同的）</li>\n<li><code>ababa</code>的前缀：<code>a</code>、<code>ab</code>、<code>aba</code>、<code>abab</code></li>\n<li><code>ababa</code>的后缀：<code>a</code>、<code>ba</code>、<code>aba</code>、<code>baba</code></li>\n<li><code>ababa</code>的公共最大长：3（因为他们的公共前缀后缀中最长的为aba，长度3）</li>\n</ul></blockquote>\n<h3 id=\"2-确定PMT-Partial-Match-Table\"><a href=\"#2-确定PMT-Partial-Match-Table\" class=\"headerlink\" title=\"2.确定PMT (Partial Match Table)\"></a>2.确定PMT (Partial Match Table)</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p>\n<ul>\n<li>“A”的前缀和后缀都为空集，共有元素的长度为0；其value为</li>\n<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；　　</li>\n<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；　　</li>\n<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；　　</li>\n<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；　　</li>\n<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；　　</li>\n<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>\n</ul></blockquote>\n<p>得表：</p>\n<p><img src=\"bg2013050109.png\" alt=\"img\"></p>\n<h2 id=\"KMP算法的Python实现：\"><a href=\"#KMP算法的Python实现：\" class=\"headerlink\" title=\"KMP算法的Python实现：\"></a>KMP算法的Python实现：</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n        def KMP(s, p):\n            &quot;&quot;&quot;\n            s 为主串\n            p 为模式串\n            如果 t 里有 p，返回打头下标\n            &quot;&quot;&quot;\n            nex &#x3D; getNext(p)\n            i &#x3D; 0\n            j &#x3D; 0   # 分别是 s 和 p 的指针\n            while i &lt; len(s) and j &lt; len(p):\n                if j &#x3D;&#x3D; -1 or s[i] &#x3D;&#x3D; p[j]: # j &#x3D;&#x3D; -1 是由于 j &#x3D; next[j]产生\n                    i +&#x3D; 1\n                    j +&#x3D; 1\n                else:\n                    j &#x3D; nex[j]\n\n            if j &#x3D;&#x3D; len(p): # j 走到了末尾，说明匹配到了\n                return i - j\n            else:\n                return -1\n\n        def getNext(p):\n            &quot;&quot;&quot;\n            p 为模式串\n            返回 next 数组，即部分匹配表\n            &quot;&quot;&quot;\n            nex &#x3D; [0] * (len(p) + 1)\n            nex[0] &#x3D; -1\n            i &#x3D; 0\n            j &#x3D; -1\n            while i &lt; len(p):\n                if j &#x3D;&#x3D; -1 or p[i] &#x3D;&#x3D; p[j]:\n                    i +&#x3D; 1\n                    j +&#x3D; 1\n                    nex[i] &#x3D; j     # 这是最大的不同：记录next[i]\n                else:\n                    j &#x3D; nex[j]\n\n            return nex\n        \n        return KMP(haystack, needle)</code></pre>\n\n\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\">字符串匹配的KMP算法 - 阮一峰的网络日志 (ruanyifeng.com)</a></li>\n<li>如何更好地理解和掌握 KMP 算法? - 白鱼咸蛋笨大的回答 - 知乎 <a href=\"https://www.zhihu.com/question/21923021/answer/642165149\">https://www.zhihu.com/question/21923021/answer/642165149</a></li>\n<li>如何更好地理解和掌握 KMP 算法? - 海纳的回答 - 知乎 <a href=\"https://www.zhihu.com/question/21923021/answer/281346746\">https://www.zhihu.com/question/21923021/answer/281346746</a> <del>(第一个示例比较特殊)</del></li>\n</ul>\n","text":"KMP算法KMP算法作用简介：在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。 KM...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#KMP%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">KMP算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP%E7%AE%97%E6%B3%95%E4%BD%9C%E7%94%A8%E7%AE%80%E4%BB%8B%EF%BC%9A\"><span class=\"toc-text\">KMP算法作用简介：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">KMP算法原理：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E7%BC%80%E4%B8%8E%E5%90%8E%E7%BC%80\"><span class=\"toc-text\">1.前缀与后缀</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%A1%AE%E5%AE%9APMT-Partial-Match-Table\"><span class=\"toc-text\">2.确定PMT (Partial Match Table)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP%E7%AE%97%E6%B3%95%E7%9A%84Python%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">KMP算法的Python实现：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Algorithm/String Processing/正则提速","date":"2023-03-07T16:14:44.940Z","updated":"2022-04-06T08:48:52.000Z","comments":true,"path":"api/articles/Algorithm/String Processing/正则提速.json","keywords":null,"cover":null,"text":" 让匹配更快失败，尤其是匹配很长的字符串时，匹配失败的位置要比成功的位置多得多。 以简单、必须的字元开始，排除明显不匹配的位置，如锚点(^或$)，特殊字符(x或\\u263A)字符类([a-z]或\\d之类的速记符)，和单词边界(\\b)；尽量避免使用分组、选择、重复量词开头，如/on...","link":"","photos":[],"count_time":{"symbolsCount":896,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Algorithm/String Processing/Boyer Moore Algorithm","date":"2023-03-07T16:14:44.928Z","updated":"2022-04-09T12:24:13.000Z","comments":true,"path":"api/articles/Algorithm/String Processing/Boyer Moore Algorithm.json","keywords":null,"cover":null,"text":"Boyer Moore AlgorithmGeneral高效，可靠，应用广泛：各种文本编辑器的”查找”功能（Ctrl+F），大多采用Boyer-Moore算法 1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。 De...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}