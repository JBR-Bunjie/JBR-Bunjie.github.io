{"title":"三角形","uid":"e7ccb6064d60a08f73c48322b41c41c6","slug":"Algorithm/三角形面积计算","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:23:12.000Z","comments":true,"path":"api/articles/Algorithm/三角形面积计算.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h2 id=\"求面积\"><a href=\"#求面积\" class=\"headerlink\" title=\"求面积\"></a>求面积</h2><h3 id=\"1-底高求面积\"><a href=\"#1-底高求面积\" class=\"headerlink\" title=\"1.底高求面积\"></a>1.底高求面积</h3><p>已知三角形底a，高h，则<br>$$<br>S = \\frac{a·h}{2}<br>$$</p>\n<h3 id=\"2-海伦公式\"><a href=\"#2-海伦公式\" class=\"headerlink\" title=\"2.海伦公式\"></a>2.海伦公式</h3><p>已知三角形三边a,b,c，则<br>$$<br>\\begin{aligned}<br>p &amp;= \\frac{a+b+c}{2}\\<br>S &amp;= \\sqrt{[p(p - a)(p - b)(p - c)]}\\<br>&amp;=\\sqrt{[(1/16)(a+b+c)(a+b-c)(a+c-b)(b+c-a)]}\\<br>&amp;=1/4\\sqrt{[(a+b+c)(a+b-c)(a+c-b)(b+c-a)]}<br>\\end{aligned}<br>$$</p>\n<h3 id=\"3-边角公式\"><a href=\"#3-边角公式\" class=\"headerlink\" title=\"3.边角公式\"></a>3.边角公式</h3><p>已知三角形两边a,b,这两边夹角$\\alpha$，则有：<br>$$<br>\\begin{aligned}<br>S = \\frac{a·b·\\sin\\alpha}{2}<br>\\end{aligned}<br>$$<br>即两夹边之积乘夹角正弦值的一半。</p>\n<h3 id=\"4-内切圆面积公式\"><a href=\"#4-内切圆面积公式\" class=\"headerlink\" title=\"4.内切圆面积公式\"></a>4.内切圆面积公式</h3><p>设三角形三边分别为a、b、c，内切圆半径为r</p>\n<p>则三角形面积<br>$$<br>S = \\frac{(a+b+c)·r}{2}<br>$$</p>\n<h3 id=\"5-外接圆面积公式\"><a href=\"#5-外接圆面积公式\" class=\"headerlink\" title=\"5.外接圆面积公式\"></a>5.外接圆面积公式</h3><p>设三角形三边分别为a、b、c，外接圆半径为R</p>\n<p>则三角形面积<br>$$<br>\\begin{aligned}<br>S &amp;= \\frac{a · b · c}{4R}\\<br>&amp;= 2R^2 · \\sin{A} · \\sin{B} · \\sin{C}<br>\\end{aligned}<br>$$</p>\n<h3 id=\"6-行列式形式\"><a href=\"#6-行列式形式\" class=\"headerlink\" title=\"6.行列式形式\"></a>6.行列式形式</h3><p>$$<br>S = \\frac{1}{2}<br>\\left|<br>\\begin{array}{cccc}<br>a&amp;b&amp;1\\<br>c&amp;d&amp;1\\<br>e&amp;f&amp;1<br>\\end{array}<br>\\right|<br>$$</p>\n<p>为三阶行列式，此三角形$ABC$在平面直角坐标系内$A(a,b), B(c,d), C(e,f)$，这里$ABC$选取最好按逆时针顺序从右上角开始取，因为这样取得出的结果一般都为正值，如果不按这个规则取，可能会得到负值，但不要紧，只要取绝对值就可以了，不会影响三角形面积的大小。</p>\n<h3 id=\"7-中线面积公式\"><a href=\"#7-中线面积公式\" class=\"headerlink\" title=\"7.中线面积公式\"></a>7.中线面积公式</h3><p>Ma,Mb,Mc为三角形的中线长.<br>$$<br>S=\\sqrt{[(Ma+Mb+Mc)<em>(Mb+Mc-Ma)</em>(Mc+Ma-Mb)*(Ma+Mb-Mc)]/3}<br>$$</p>\n<h2 id=\"单色三角形\"><a href=\"#单色三角形\" class=\"headerlink\" title=\"单色三角形\"></a>单色三角形</h2><h3 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>在空间中给出了n个点。这些点任三点不共线，并且每两个点之间都有一条线相连，每一条线不是红的就是黑的。在这些点和线组成的三角形中，如果一个三角形的三条边的颜色都相同，那么我们就称这个三角形为单色三角形。现给出所有涂红色的线，试求出单色三角形的数目。</p>\n<h3 id=\"mathematics-side\"><a href=\"#mathematics-side\" class=\"headerlink\" title=\"mathematics side\"></a>mathematics side</h3><h4 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question:\"></a>Question:</h4><p>给定空间里n(n&lt;=1000)个点，假设任意三个点都不共线。</p>\n<p>将任意两点之间的连线涂上红色或者黑色。</p>\n<p>问3条边同色的三角形个数。</p>\n<hr>\n<h4 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer:\"></a>Answer:</h4><p>由于三角形总数C(n,3)，所以求出异色三角形个数就求出了同色三角形个数。</p>\n<p>值得注意的是，当我们比较一个三角形是否是单色三角形时，我们实际比较的是三角形中的任意两条边，而不是比较一个“三角形”</p>\n<p>利用这样的比较关系，我们比较的对象是单个顶点而不是每个三角形，易知：一个异色三角形存在两个顶点，该三角形中与它们相邻的两边是不同色的；而对从一个顶点出发的两条异色边都属于一个异色三角形。这是个一对二的关系。</p>\n<p>已知第i个点会连接总共n-1条边。设第i个点连接了a条红边、n-1-a条黑边，由于边之间的组合关系，这些边一定属于a(n-1-a)个不同的异色三角形。由于异色三角形都会被考虑两次，所以最终的答案为C(n, 3) - sigmaΣ(i from 1 to n)a(n-1-a)/2</p>\n<p>请注意，每个i下的a都是不同的，为了彰显这之中的关联，可以改设为ai，故得答案：</p>\n<p><strong>C(n, 3) - Σ(i from 1 to n) ai * (n - 1 - ai) / 2</strong></p>\n<hr>\n<h3 id=\"programming-side\"><a href=\"#programming-side\" class=\"headerlink\" title=\"programming side\"></a>programming side</h3><h4 id=\"Question-1\"><a href=\"#Question-1\" class=\"headerlink\" title=\"Question:\"></a>Question:</h4><p>任务：</p>\n<p>请写一个程序：</p>\n<p>从文本文件中读入点数和对红色连线的描述；</p>\n<p>找出该图中红色三角形的数目；</p>\n<p>把结果输出到文件TRO.OUT中。</p>\n<p>输入格式：</p>\n<p>在文本文件TRO.IN的第一行包括一个整数n，3 &lt;= n &lt;= 1000，为空间中的点数。</p>\n<p>该文件的第二行为一个整数m，0 &lt;= m &lt;= 250000，为红色连线的数目。</p>\n<p>以下的m行中每行为两个用空格分开的整数p和k，1 &lt;= p &lt; k &lt;= n，表示第p点和第k号点之间的连线为红色。</p>\n<p>输出格式：</p>\n<p>你应该在文本文件TRO.OUT输出唯一的一个整数——同色三角形的数目。</p>\n<p>样例：</p>\n<p>输入</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>6<br>9<br>1 2<br>2 3<br>2 5<br>1 4<br>1 6<br>3 4<br>4 5<br>5 6<br>3 6</p></blockquote>\n<p>输出</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>2</p></blockquote>\n<h4 id=\"Answer-1\"><a href=\"#Answer-1\" class=\"headerlink\" title=\"Answer:\"></a>Answer:</h4><p>按照在mathematics side中的思路，我们可以发现，单个点的比较中，是不存在“方向”的，或者说，所比较的每条线都是双向的。而同时也不在意当前点对点的具体内容，我们只在意当前点下，具体 有 多少“红线”与“黑线”</p>\n<p>故我们用一个字典来记录各个顶点下的线数即可</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n \nusing namespace std;\n \nconst int maxn &#x3D; 200010;\ntypedef long long LL;\n \nint a[maxn];\nint cnt[maxn];\nint n,num;\nint ele[100];\n \nvoid fen(int x)&#x2F;&#x2F;素因子分解\n&#123;\n    num&#x3D;0;\n    for(int i&#x3D;2;i*i&lt;&#x3D;x;i++)&#123;\n        if(x%i&#x3D;&#x3D;0)&#123;\n            ele[num++]&#x3D;i;\n            while(x%i&#x3D;&#x3D;0)\n                x&#x2F;&#x3D;i;\n        &#125;\n    &#125;\n    if(x&gt;1) ele[num++]&#x3D;x;\n&#125;\n \nvoid init()&#x2F;&#x2F;预处理与a[i]不互质的数的个数\n&#123;\n    memset(cnt,0,sizeof(cnt));\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        scanf(&quot;%d&quot;,&amp;a[i]);\n        fen(a[i]);\n        for(int j&#x3D;1;j&lt;(1&lt;&lt;num);j++)&#123;\n            int tmp&#x3D;1;\n            for(int k&#x3D;0;k&lt;num;k++)\n                if((1&lt;&lt;k)&amp;j) tmp*&#x3D;ele[k];\n            cnt[tmp]++;\n        &#125;\n    &#125;\n&#125;\n \nLL solve()\n&#123;\n    LL ans&#x3D;n;\n    ans&#x3D;ans*(n-1)*(n-2)&#x2F;6;&#x2F;&#x2F;防止爆int\n    LL sum&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;&#x2F;&#x2F;容斥原理求与a[i]不互质的数的个数\n        fen(a[i]);\n        LL tmp&#x3D;0;\n        for(int j&#x3D;1;j&lt;(1&lt;&lt;num);j++)&#123;\n            LL ret &#x3D; 1;\n            int t&#x3D;0;\n            for(int k&#x3D;0;k&lt;num;k++)&#123;\n                if((1&lt;&lt;k)&amp;j)&#123;\n                    ret*&#x3D;ele[k];\n                    t++;\n                &#125;\n            &#125;\n            if(t&amp;1) tmp+&#x3D;cnt[ret];\n            else tmp-&#x3D;cnt[ret];\n        &#125;\n        if(tmp&#x3D;&#x3D;0) continue;\n        else sum+&#x3D;(n-tmp)*(tmp-1);\n        &#x2F;&#x2F;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;&quot; &quot;&lt;&lt;(n-tmp)*(tmp-1)&#x2F;2&lt;&lt;endl;\n    &#125;\n    return ans-sum&#x2F;2;\n&#125;\nint main()\n&#123;\n    int t;\n    scanf(&quot;%d&quot;,&amp;t);\n    while(t--)&#123;\n        init();\n        LL ans&#x3D;solve();\n        printf(&quot;%I64d\\n&quot;,ans);\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n","text":"求面积1.底高求面积已知三角形底a，高h，则$$S = \\frac{a·h}{2}$$ 2.海伦公式已知三角形三边a,b,c，则$$\\begin{aligned}p &amp;= \\frac{a+b+c}{2}\\S &amp;= \\sqrt{[p(p - a)(p - b)(p ...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"triangle area","slug":"triangle-area","count":1,"path":"api/tags/triangle-area.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B1%82%E9%9D%A2%E7%A7%AF\"><span class=\"toc-text\">求面积</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%BA%95%E9%AB%98%E6%B1%82%E9%9D%A2%E7%A7%AF\"><span class=\"toc-text\">1.底高求面积</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">2.海伦公式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%BE%B9%E8%A7%92%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">3.边角公式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%86%85%E5%88%87%E5%9C%86%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">4.内切圆面积公式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%A4%96%E6%8E%A5%E5%9C%86%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">5.外接圆面积公式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E8%A1%8C%E5%88%97%E5%BC%8F%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">6.行列式形式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E4%B8%AD%E7%BA%BF%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">7.中线面积公式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%89%B2%E4%B8%89%E8%A7%92%E5%BD%A2\"><span class=\"toc-text\">单色三角形</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Description\"><span class=\"toc-text\">Description</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mathematics-side\"><span class=\"toc-text\">mathematics side</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Question\"><span class=\"toc-text\">Question:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Answer\"><span class=\"toc-text\">Answer:</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#programming-side\"><span class=\"toc-text\">programming side</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Question-1\"><span class=\"toc-text\">Question:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Answer-1\"><span class=\"toc-text\">Answer:</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"大数运算","uid":"c7cd6315021c2b49c9efb80c79e420a8","slug":"Algorithm/大数四则运算","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:25:14.000Z","comments":true,"path":"api/articles/Algorithm/大数四则运算.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"前言： 在计算机中数字表示的范围是有限制的，比如我们熟知的 int、float、double 等数据类型所能表示的范围都是有限的，如果我们要对位数达到几十位、几百位、上千位的大整数进行计算，这些数据类型显然不能满足我们的要求，因此我们需要通过算法来实现这些功能。 1、大数加法 两...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"calculate","slug":"calculate","count":1,"path":"api/tags/calculate.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"字符画","uid":"88fe004551a3de4348d535f91c34c293","slug":"Algorithm/字符画","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:25:26.000Z","comments":true,"path":"api/articles/Algorithm/字符画.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"字符画另类应用当你需要在shell里查看图片时 现有框架ascii-image-converter TheZoraiz/ascii-image-converter: A cross-platform command-line tool to convert images into...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"String Processing","slug":"String-Processing","count":7,"path":"api/tags/String-Processing.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}