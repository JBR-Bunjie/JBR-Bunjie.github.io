{"title":"三角形","uid":"e7ccb6064d60a08f73c48322b41c41c6","slug":"Algorithm/三角形面积计算","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:23:12.530Z","comments":true,"path":"api/articles/Algorithm/三角形面积计算.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h2 id=\"求面积\">求面积</h2>\r\n<h3 id=\"底高求面积\">1.底高求面积</h3>\r\n<p>已知三角形底a，高h，则 <span class=\"math display\">\\[\r\nS = \\frac{a·h}{2}\r\n\\]</span></p>\r\n<h3 id=\"海伦公式\">2.海伦公式</h3>\r\n<p>已知三角形三边a,b,c，则 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\np &amp;= \\frac{a+b+c}{2}\\\\\r\nS &amp;= \\sqrt{[p(p - a)(p - b)(p - c)]}\\\\\r\n&amp;=\\sqrt{[(1/16)(a+b+c)(a+b-c)(a+c-b)(b+c-a)]}\\\\\r\n&amp;=1/4\\sqrt{[(a+b+c)(a+b-c)(a+c-b)(b+c-a)]}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h3 id=\"边角公式\">3.边角公式</h3>\r\n<p>已知三角形两边a,b,这两边夹角<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>，则有： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\nS = \\frac{a·b·\\sin\\alpha}{2}\r\n\\end{aligned}\r\n\\]</span> 即两夹边之积乘夹角正弦值的一半。</p>\r\n<h3 id=\"内切圆面积公式\">4.内切圆面积公式</h3>\r\n<p>设三角形三边分别为a、b、c，内切圆半径为r</p>\r\n<p>则三角形面积 <span class=\"math display\">\\[\r\nS = \\frac{(a+b+c)·r}{2}\r\n\\]</span></p>\r\n<h3 id=\"外接圆面积公式\">5.外接圆面积公式</h3>\r\n<p>设三角形三边分别为a、b、c，外接圆半径为R</p>\r\n<p>则三角形面积 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nS &amp;= \\frac{a · b · c}{4R}\\\\\r\n&amp;= 2R^2 · \\sin{A} · \\sin{B} · \\sin{C}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h3 id=\"行列式形式\">6.行列式形式</h3>\r\n<p><span class=\"math display\">\\[\r\nS = \\frac{1}{2}\r\n\\left|\r\n\\begin{array}{cccc}\r\na&amp;b&amp;1\\\\\r\nc&amp;d&amp;1\\\\\r\ne&amp;f&amp;1\r\n\\end{array}\r\n\\right|\r\n\\]</span></p>\r\n<p>为三阶行列式，此三角形<span\r\nclass=\"math inline\">\\(ABC\\)</span>在平面直角坐标系内<span\r\nclass=\"math inline\">\\(A(a,b), B(c,d), C(e,f)\\)</span>，这里<span\r\nclass=\"math inline\">\\(ABC\\)</span>选取最好按逆时针顺序从右上角开始取，因为这样取得出的结果一般都为正值，如果不按这个规则取，可能会得到负值，但不要紧，只要取绝对值就可以了，不会影响三角形面积的大小。</p>\r\n<h3 id=\"中线面积公式\">7.中线面积公式</h3>\r\n<p>Ma,Mb,Mc为三角形的中线长. <span class=\"math display\">\\[\r\nS=\\sqrt{[(Ma+Mb+Mc)*(Mb+Mc-Ma)*(Mc+Ma-Mb)*(Ma+Mb-Mc)]/3}\r\n\\]</span></p>\r\n<h2 id=\"单色三角形\">单色三角形</h2>\r\n<h3 id=\"description\">Description</h3>\r\n<p>在空间中给出了n个点。这些点任三点不共线，并且每两个点之间都有一条线相连，每一条线不是红的就是黑的。在这些点和线组成的三角形中，如果一个三角形的三条边的颜色都相同，那么我们就称这个三角形为单色三角形。现给出所有涂红色的线，试求出单色三角形的数目。</p>\r\n<h3 id=\"mathematics-side\">mathematics side</h3>\r\n<h4 id=\"question\">Question:</h4>\r\n<p>给定空间里n(n&lt;=1000)个点，假设任意三个点都不共线。</p>\r\n<p>将任意两点之间的连线涂上红色或者黑色。</p>\r\n<p>问3条边同色的三角形个数。</p>\r\n<hr />\r\n<h4 id=\"answer\">Answer:</h4>\r\n<p>由于三角形总数C(n,3)，所以求出异色三角形个数就求出了同色三角形个数。</p>\r\n<p>值得注意的是，当我们比较一个三角形是否是单色三角形时，我们实际比较的是三角形中的任意两条边，而不是比较一个“三角形”</p>\r\n<p>利用这样的比较关系，我们比较的对象是单个顶点而不是每个三角形，易知：一个异色三角形存在两个顶点，该三角形中与它们相邻的两边是不同色的；而对从一个顶点出发的两条异色边都属于一个异色三角形。这是个一对二的关系。</p>\r\n<p>已知第i个点会连接总共n-1条边。设第i个点连接了a条红边、n-1-a条黑边，由于边之间的组合关系，这些边一定属于a(n-1-a)个不同的异色三角形。由于异色三角形都会被考虑两次，所以最终的答案为C(n,\r\n3) - sigmaΣ(i from 1 to n)a(n-1-a)/2</p>\r\n<p>请注意，每个i下的a都是不同的，为了彰显这之中的关联，可以改设为ai，故得答案：</p>\r\n<p><strong>C(n, 3) - Σ(i from 1 to n) ai * (n - 1 - ai) / 2</strong></p>\r\n<hr />\r\n<h3 id=\"programming-side\">programming side</h3>\r\n<h4 id=\"question-1\">Question:</h4>\r\n<p>任务：</p>\r\n<p>请写一个程序：</p>\r\n<p>从文本文件中读入点数和对红色连线的描述；</p>\r\n<p>找出该图中红色三角形的数目；</p>\r\n<p>把结果输出到文件TRO.OUT中。</p>\r\n<p>输入格式：</p>\r\n<p>在文本文件TRO.IN的第一行包括一个整数n，3 &lt;= n &lt;=\r\n1000，为空间中的点数。</p>\r\n<p>该文件的第二行为一个整数m，0 &lt;= m &lt;=\r\n250000，为红色连线的数目。</p>\r\n<p>以下的m行中每行为两个用空格分开的整数p和k，1 &lt;= p &lt; k &lt;=\r\nn，表示第p点和第k号点之间的连线为红色。</p>\r\n<p>输出格式：</p>\r\n<p>你应该在文本文件TRO.OUT输出唯一的一个整数——同色三角形的数目。</p>\r\n<p>样例：</p>\r\n<p>输入</p>\r\n<blockquote>\r\n<p>6 9 1 2 2 3 2 5 1 4 1 6 3 4 4 5 5 6 3 6</p>\r\n</blockquote>\r\n<p>输出</p>\r\n<blockquote>\r\n<p>2</p>\r\n</blockquote>\r\n<h4 id=\"answer-1\">Answer:</h4>\r\n<p>按照在mathematics\r\nside中的思路，我们可以发现，单个点的比较中，是不存在“方向”的，或者说，所比较的每条线都是双向的。而同时也不在意当前点对点的具体内容，我们只在意当前点下，具体\r\n有 多少“红线”与“黑线”</p>\r\n<p>故我们用一个字典来记录各个顶点下的线数即可</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n \nusing namespace std;\n \nconst int maxn &#x3D; 200010;\ntypedef long long LL;\n \nint a[maxn];\nint cnt[maxn];\nint n,num;\nint ele[100];\n \nvoid fen(int x)&#x2F;&#x2F;素因子分解\n&#123;\n    num&#x3D;0;\n    for(int i&#x3D;2;i*i&lt;&#x3D;x;i++)&#123;\n        if(x%i&#x3D;&#x3D;0)&#123;\n            ele[num++]&#x3D;i;\n            while(x%i&#x3D;&#x3D;0)\n                x&#x2F;&#x3D;i;\n        &#125;\n    &#125;\n    if(x&gt;1) ele[num++]&#x3D;x;\n&#125;\n \nvoid init()&#x2F;&#x2F;预处理与a[i]不互质的数的个数\n&#123;\n    memset(cnt,0,sizeof(cnt));\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        scanf(&quot;%d&quot;,&amp;a[i]);\n        fen(a[i]);\n        for(int j&#x3D;1;j&lt;(1&lt;&lt;num);j++)&#123;\n            int tmp&#x3D;1;\n            for(int k&#x3D;0;k&lt;num;k++)\n                if((1&lt;&lt;k)&amp;j) tmp*&#x3D;ele[k];\n            cnt[tmp]++;\n        &#125;\n    &#125;\n&#125;\n \nLL solve()\n&#123;\n    LL ans&#x3D;n;\n    ans&#x3D;ans*(n-1)*(n-2)&#x2F;6;&#x2F;&#x2F;防止爆int\n    LL sum&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;&#x2F;&#x2F;容斥原理求与a[i]不互质的数的个数\n        fen(a[i]);\n        LL tmp&#x3D;0;\n        for(int j&#x3D;1;j&lt;(1&lt;&lt;num);j++)&#123;\n            LL ret &#x3D; 1;\n            int t&#x3D;0;\n            for(int k&#x3D;0;k&lt;num;k++)&#123;\n                if((1&lt;&lt;k)&amp;j)&#123;\n                    ret*&#x3D;ele[k];\n                    t++;\n                &#125;\n            &#125;\n            if(t&amp;1) tmp+&#x3D;cnt[ret];\n            else tmp-&#x3D;cnt[ret];\n        &#125;\n        if(tmp&#x3D;&#x3D;0) continue;\n        else sum+&#x3D;(n-tmp)*(tmp-1);\n        &#x2F;&#x2F;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;&quot; &quot;&lt;&lt;(n-tmp)*(tmp-1)&#x2F;2&lt;&lt;endl;\n    &#125;\n    return ans-sum&#x2F;2;\n&#125;\nint main()\n&#123;\n    int t;\n    scanf(&quot;%d&quot;,&amp;t);\n    while(t--)&#123;\n        init();\n        LL ans&#x3D;solve();\n        printf(&quot;%I64d\\n&quot;,ans);\n    &#125;\n    return 0;\n&#125;</code></pre>\r\n","text":"求面积 1.底高求面积 已知三角形底a，高h，则 \\[ S = \\frac{a·h}{2} \\] 2.海伦公式 已知三角形三边a,b,c，则 \\[ \\begin{aligned} p &amp;= \\frac{a+b+c}{2}\\\\ S &amp;= \\sqrt{[p(p - a...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"triangle area","slug":"triangle-area","count":1,"path":"api/tags/triangle-area.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B1%82%E9%9D%A2%E7%A7%AF\"><span class=\"toc-text\">求面积</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%95%E9%AB%98%E6%B1%82%E9%9D%A2%E7%A7%AF\"><span class=\"toc-text\">1.底高求面积</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">2.海伦公式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%B9%E8%A7%92%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">3.边角公式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%88%87%E5%9C%86%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">4.内切圆面积公式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%96%E6%8E%A5%E5%9C%86%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">5.外接圆面积公式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E5%88%97%E5%BC%8F%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">6.行列式形式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E7%BA%BF%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F\"><span class=\"toc-text\">7.中线面积公式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%89%B2%E4%B8%89%E8%A7%92%E5%BD%A2\"><span class=\"toc-text\">单色三角形</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#description\"><span class=\"toc-text\">Description</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mathematics-side\"><span class=\"toc-text\">mathematics side</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#question\"><span class=\"toc-text\">Question:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#answer\"><span class=\"toc-text\">Answer:</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#programming-side\"><span class=\"toc-text\">programming side</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#question-1\"><span class=\"toc-text\">Question:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#answer-1\"><span class=\"toc-text\">Answer:</span></a></li></ol></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"Sugiyama Algorithm","uid":"9fd0e4d3dba46b1add7af94a3f9b782a","slug":"Algorithm/Sugiyama","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:20:19.908Z","comments":true,"path":"api/articles/Algorithm/Sugiyama.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"划时代的自动布局算法：sugiyama算法 sugiyama algorithm steps of the framework is to divide the task of drawing a graph into several subproblems, most of w...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Auto Layout","slug":"Auto-Layout","count":1,"path":"api/tags/Auto-Layout.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"大数运算","uid":"c7cd6315021c2b49c9efb80c79e420a8","slug":"Algorithm/大数四则运算","date":"2022-12-23T04:23:23.000Z","updated":"2023-03-08T01:25:14.794Z","comments":true,"path":"api/articles/Algorithm/大数四则运算.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"前言： 在计算机中数字表示的范围是有限制的，比如我们熟知的 int、float、double 等数据类型所能表示的范围都是有限的，如果我们要对位数达到几十位、几百位、上千位的大整数进行计算，这些数据类型显然不能满足我们的要求，因此我们需要通过算法来实现这些功能。 1、大数加法 两...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":26,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"calculate","slug":"calculate","count":1,"path":"api/tags/calculate.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}