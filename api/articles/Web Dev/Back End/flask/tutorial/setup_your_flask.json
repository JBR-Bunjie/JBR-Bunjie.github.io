{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Back End/flask/tutorial/setup_your_flask","date":"2023-03-07T16:14:46.345Z","updated":"2022-09-10T15:41:13.000Z","comments":true,"path":"api/articles/Web Dev/Back End/flask/tutorial/setup_your_flask.json","keywords":null,"cover":null,"content":"<h2 id=\"flask如何处理请求\">Flask如何处理请求</h2>\r\n<h3 id=\"一个简单但完整的示例\">一个简单但完整的示例</h3>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import Flask, jsonify\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    return jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()</code></pre>\r\n<p>此时，当我们访问<code>/api</code>时，应用会返回一个JSON映射。</p>\r\n<ol type=\"1\">\r\n<li>变量__name__</li>\r\n</ol>\r\n<blockquote>\r\n<p>变量__name__是这个应用软件包的名称，而当运行一个单独的Python模块时，变量__name__会赋值为__main__</p>\r\n<p>Flask会使用这个变量实例化一个新的日志日志记录器(logger)，并在磁盘上定位这个模块所在文件的路径。</p>\r\n<p>Flask将使用该文件的目录作为助手程序的根目录(例如与应用程序相关的配置文件)，并根据此目录确定静态文件目录(static)与模板目录(templates)的默认存放位置</p>\r\n</blockquote>\r\n<p>在shell中运行当前模块时，Flask会运行其中的内置Web服务器，并在默认在5000端口监听传入的请求</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>访问/api</li>\r\n</ol>\r\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask# curl -v http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api\n*   Trying 127.0.0.1:5000...\n* Connected to 127.0.0.1 (127.0.0.1) port 5000 (#0)\n&gt; GET &#x2F;api HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5000\n&gt; User-Agent: curl&#x2F;7.81.0\n&gt; Accept: *&#x2F;*\n&gt; \n* Mark bundle as not supporting multiuse\n&lt; HTTP&#x2F;1.1 200 OK\n&lt; Server: Werkzeug&#x2F;2.2.2 Python&#x2F;3.10.4\n&lt; Date: Sat, 10 Sep 2022 11:43:02 GMT\n&lt; Content-Type: application&#x2F;json\n&lt; Content-Length: 19\n&lt; Connection: close\n&lt; \n&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\n* Closing connection 0</code></pre>\r\n<p>可以发现，我们得到了一个合法的JSON响应和正确的消息头。</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>jsonity函数</li>\r\n</ol>\r\n<p>该函数会将Python字典类型转换为合法的JSON响应，并在添加适当的Content-Type消息头后，将映射信息存储到响应体中</p>\r\n<h3 id=\"request对象\">request对象</h3>\r\n<p>与大多数Web框架不同，flask不需要显示地将request对象传递到代码中——它隐式地提供了一个全局的request变量，并用该全局的变量来指向当前的request对象。Flask把传入的HTTP请求解析为WSGI环境字典，并利用它来创建这个对象</p>\r\n<p>这样：当服务器的响应不依赖请求的内容时，就没必要处理它。视图只需要确保返回了客户端应该获取的内容，并确保内容能够被Flask序列化即可</p>\r\n<h3 id=\"了解底层到底发生了什么\">了解底层到底发生了什么</h3>\r\n<p>增加print方法，了解curl访问具体过程</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import Flask, jsonify, request\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    print(request)\n    print(request.environ)\n    response &#x3D; jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n    print(response)\n    print(response.data)\n    return response\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(app.url_map)\n    app.run()</code></pre>\r\n<p>有：</p>\r\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(venv) root@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask&#x2F;chapter2# python app.py \nMap([&lt;Rule &#39;&#x2F;static&#x2F;&lt;filename&gt;&#39; (OPTIONS, GET, HEAD) -&gt; static&gt;,\n &lt;Rule &#39;&#x2F;api&#39; (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])\n * Serving Flask app &#39;app&#39;\n * Debug mode: off\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n * Running on http:&#x2F;&#x2F;127.0.0.1:5000\nPress CTRL+C to quit\n&lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;\n&#123;&#39;wsgi.version&#39;: (1, 0), &#39;wsgi.url_scheme&#39;: &#39;http&#39;, &#39;wsgi.input&#39;: &lt;_io.BufferedReader name&#x3D;4&gt;, &#39;wsgi.errors&#39;: &lt;_io.TextIOWrapper name&#x3D;&#39;&lt;stderr&gt;&#39; mode&#x3D;&#39;w&#39; encoding&#x3D;&#39;utf-8&#39;&gt;, &#39;wsgi.multithread&#39;: True, &#39;wsgi.multiprocess&#39;: False, &#39;wsgi.run_once&#39;: False, &#39;werkzeug.socket&#39;: &lt;socket.socket fd&#x3D;4, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 5000), raddr&#x3D;(&#39;127.0.0.1&#39;, 54614)&gt;, &#39;SERVER_SOFTWARE&#39;: &#39;Werkzeug&#x2F;2.2.2&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_NAME&#39;: &#39;&#39;, &#39;PATH_INFO&#39;: &#39;&#x2F;api&#39;, &#39;QUERY_STRING&#39;: &#39;&#39;, &#39;REQUEST_URI&#39;: &#39;&#x2F;api&#39;, &#39;RAW_URI&#39;: &#39;&#x2F;api&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: 54614, &#39;SERVER_NAME&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;5000&#39;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39;, &#39;HTTP_HOST&#39;: &#39;127.0.0.1:5000&#39;, &#39;HTTP_USER_AGENT&#39;: &#39;curl&#x2F;7.81.0&#39;, &#39;HTTP_ACCEPT&#39;: &#39;*&#x2F;*&#39;, &#39;werkzeug.request&#39;: &lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;&#125;\n&lt;Response 19 bytes [200 OK]&gt;\nb&#39;&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\\n&#39;\n127.0.0.1 - - [10&#x2F;Sep&#x2F;2022 22:55:47] &quot;GET &#x2F;api HTTP&#x2F;1.1&quot; 200 -</code></pre>\r\n<h4 id=\"路由匹配\">路由匹配</h4>\r\n<p>路由匹配发生在app.url_map中，这是Werzeug中Map类的一个实例。<code>Map([&lt;Rule '/static/&lt;filename&gt;' (OPTIONS, GET, HEAD) -&gt; static&gt;, &lt;Rule '/api' (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])</code></p>\r\n<p>该类使用正则表达式来判定被<code>@app.route</code>装饰的函数时候与传入的请求匹配，路由匹配只会姜茶route调用里的路径参数来判断函数时候匹配客户端的请求，默认情况下，声明式路由只支持<code>GET</code>,\r\n<code>OPTIONS</code>,\r\n<code>HEAD</code>方法的调用，如果使用了不支持的HTTP方法，则会出现405Method\r\nNot\r\nAllowed响应，并在Allow响应头中返回其所支持的HTTP方法列表（正常访问不会出现Allow响应头）</p>\r\n<p>当需要支持指定HTTP请求方式时，我们需要给装饰器增加额外的参数：</p>\r\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@app.route(&#39;&#x2F;api&#39;, method&#x3D;[&#39;POST&#39;, &#39;DELETE&#39;, &#39;GET&#39;])</code></pre>\r\n<p>不过，</p>\r\n<h5 id=\"变量与转换器\">变量与转换器</h5>\r\n<p>路由系统支持变量如：<code>/person/&lt;person_id&gt;</code></p>\r\n<h4 id=\"请求\">请求</h4>\r\n<h4 id=\"响应\">响应</h4>\r\n<h2 id=\"flask的内置特性\">Flask的内置特性</h2>\r\n<h2 id=\"微服务骨架\">微服务骨架</h2>\r\n<p>拓展：</p>\r\n<p><strong>这个 <strong>name</strong> 变量可能取什么值？</strong></p>\r\n<p>当你直接执行一段脚本的时候，这段脚本的\r\n<strong><strong>name</strong></strong>变量等于\r\n<strong>'<strong>main</strong>'</strong>，当这段脚本被导入其他程序的时候，<strong><strong>name</strong></strong>\r\n变量等于脚本本身的名字。</p>\r\n<p><strong>这个 <strong>name</strong> 拿来做什么的？</strong></p>\r\n<p>作为 Python\r\n的内置变量，<strong><strong>name</strong></strong>变量（前后各有两个下划线）还是挺特殊的。它是每个\r\nPython 模块必备的属性，但它的值取决于你是如何执行这段代码的。</p>\r\n<p>在许多情况下，你的代码不可能全部都放在同一个文件里，或者你在这个文件里写的函数，在其他地方也可以用到。为了更高效地重用这些代码，你需要在\r\nPython 程序中导入来自其他文件的代码。</p>\r\n<p>所以，在<strong><strong>name</strong></strong>\r\n变量的帮助下，你可以判断出这时代码是被直接运行，还是被导入到其他程序中去了。</p>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/57309137\">Python 的\r\n<strong>name</strong> 变量，到底是个什么东西？ - 知乎\r\n(zhihu.com)</a></p>\r\n","text":"Flask如何处理请求 一个简单但完整的示例 from flask import Flask, jsonify app &#x3D; Flask(__name__) @app.route(&#39;&#x2F;api&#39;) def my_microservice(): re...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#flask%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">Flask如何处理请求</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BD%86%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">一个简单但完整的示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#request%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">request对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%86%E8%A7%A3%E5%BA%95%E5%B1%82%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">了解底层到底发生了什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">路由匹配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2%E5%99%A8\"><span class=\"toc-text\">变量与转换器</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">请求</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94\"><span class=\"toc-text\">响应</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#flask%E7%9A%84%E5%86%85%E7%BD%AE%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Flask的内置特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AA%A8%E6%9E%B6\"><span class=\"toc-text\">微服务骨架</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Back End/MAVEN/COMMAND","date":"2023-03-07T16:14:46.355Z","updated":"2022-03-06T14:55:45.000Z","comments":true,"path":"api/articles/Web Dev/Back End/MAVEN/COMMAND.json","keywords":null,"cover":null,"text":" Maven Command Description mvn --version Prints out the version of Maven you are running. mvn clean Clears the target directory into which M...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Back End/flask/坑","date":"2023-03-07T16:14:46.337Z","updated":"2022-09-11T10:26:06.000Z","comments":true,"path":"api/articles/Web Dev/Back End/flask/坑.json","keywords":null,"cover":null,"text":"注意你的sql文件 当你犯错时，不妨再去看看语法： DROP TABLE IF EXISTS user; DROP TABLE IF EXISTS post; CREATE TABLE user ( id INTEGER PRIMARY KEY AUTOINCREMENT, us...","link":"","photos":[],"count_time":{"symbolsCount":504,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}