{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Back End/flask/tutorial/setup_your_flask","date":"2023-03-08T00:30:41.957Z","updated":"2022-09-10T15:41:13.000Z","comments":true,"path":"api/articles/Web Dev/Back End/flask/tutorial/setup_your_flask.json","keywords":null,"cover":null,"content":"<h2 id=\"Flask如何处理请求\"><a href=\"#Flask如何处理请求\" class=\"headerlink\" title=\"Flask如何处理请求\"></a>Flask如何处理请求</h2><h3 id=\"一个简单但完整的示例\"><a href=\"#一个简单但完整的示例\" class=\"headerlink\" title=\"一个简单但完整的示例\"></a>一个简单但完整的示例</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import Flask, jsonify\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    return jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()</code></pre>\n\n<p>此时，当我们访问<code>/api</code>时，应用会返回一个JSON映射。</p>\n<ol>\n<li>变量__name__</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>变量__name__是这个应用软件包的名称，而当运行一个单独的Python模块时，变量__name__会赋值为__main__</p>\n<p>Flask会使用这个变量实例化一个新的日志日志记录器(logger)，并在磁盘上定位这个模块所在文件的路径。</p>\n<p>Flask将使用该文件的目录作为助手程序的根目录(例如与应用程序相关的配置文件)，并根据此目录确定静态文件目录(static)与模板目录(templates)的默认存放位置</p></blockquote>\n<p>在shell中运行当前模块时，Flask会运行其中的内置Web服务器，并在默认在5000端口监听传入的请求</p>\n<ol start=\"2\">\n<li>访问/api</li>\n</ol>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">root@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask# curl -v http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api\n*   Trying 127.0.0.1:5000...\n* Connected to 127.0.0.1 (127.0.0.1) port 5000 (#0)\n&gt; GET &#x2F;api HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5000\n&gt; User-Agent: curl&#x2F;7.81.0\n&gt; Accept: *&#x2F;*\n&gt; \n* Mark bundle as not supporting multiuse\n&lt; HTTP&#x2F;1.1 200 OK\n&lt; Server: Werkzeug&#x2F;2.2.2 Python&#x2F;3.10.4\n&lt; Date: Sat, 10 Sep 2022 11:43:02 GMT\n&lt; Content-Type: application&#x2F;json\n&lt; Content-Length: 19\n&lt; Connection: close\n&lt; \n&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\n* Closing connection 0</code></pre>\n\n<p>可以发现，我们得到了一个合法的JSON响应和正确的消息头。</p>\n<ol start=\"3\">\n<li>jsonity函数</li>\n</ol>\n<p>该函数会将Python字典类型转换为合法的JSON响应，并在添加适当的Content-Type消息头后，将映射信息存储到响应体中</p>\n<h3 id=\"request对象\"><a href=\"#request对象\" class=\"headerlink\" title=\"request对象\"></a>request对象</h3><p>与大多数Web框架不同，flask不需要显示地将request对象传递到代码中——它隐式地提供了一个全局的request变量，并用该全局的变量来指向当前的request对象。Flask把传入的HTTP请求解析为WSGI环境字典，并利用它来创建这个对象</p>\n<p>这样：当服务器的响应不依赖请求的内容时，就没必要处理它。视图只需要确保返回了客户端应该获取的内容，并确保内容能够被Flask序列化即可</p>\n<h3 id=\"了解底层到底发生了什么\"><a href=\"#了解底层到底发生了什么\" class=\"headerlink\" title=\"了解底层到底发生了什么\"></a>了解底层到底发生了什么</h3><p>增加print方法，了解curl访问具体过程</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import Flask, jsonify, request\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    print(request)\n    print(request.environ)\n    response &#x3D; jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n    print(response)\n    print(response.data)\n    return response\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(app.url_map)\n    app.run()</code></pre>\n\n<p>有：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">(venv) root@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask&#x2F;chapter2# python app.py \nMap([&lt;Rule &#39;&#x2F;static&#x2F;&lt;filename&gt;&#39; (OPTIONS, GET, HEAD) -&gt; static&gt;,\n &lt;Rule &#39;&#x2F;api&#39; (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])\n * Serving Flask app &#39;app&#39;\n * Debug mode: off\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n * Running on http:&#x2F;&#x2F;127.0.0.1:5000\nPress CTRL+C to quit\n&lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;\n&#123;&#39;wsgi.version&#39;: (1, 0), &#39;wsgi.url_scheme&#39;: &#39;http&#39;, &#39;wsgi.input&#39;: &lt;_io.BufferedReader name&#x3D;4&gt;, &#39;wsgi.errors&#39;: &lt;_io.TextIOWrapper name&#x3D;&#39;&lt;stderr&gt;&#39; mode&#x3D;&#39;w&#39; encoding&#x3D;&#39;utf-8&#39;&gt;, &#39;wsgi.multithread&#39;: True, &#39;wsgi.multiprocess&#39;: False, &#39;wsgi.run_once&#39;: False, &#39;werkzeug.socket&#39;: &lt;socket.socket fd&#x3D;4, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 5000), raddr&#x3D;(&#39;127.0.0.1&#39;, 54614)&gt;, &#39;SERVER_SOFTWARE&#39;: &#39;Werkzeug&#x2F;2.2.2&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_NAME&#39;: &#39;&#39;, &#39;PATH_INFO&#39;: &#39;&#x2F;api&#39;, &#39;QUERY_STRING&#39;: &#39;&#39;, &#39;REQUEST_URI&#39;: &#39;&#x2F;api&#39;, &#39;RAW_URI&#39;: &#39;&#x2F;api&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: 54614, &#39;SERVER_NAME&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;5000&#39;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39;, &#39;HTTP_HOST&#39;: &#39;127.0.0.1:5000&#39;, &#39;HTTP_USER_AGENT&#39;: &#39;curl&#x2F;7.81.0&#39;, &#39;HTTP_ACCEPT&#39;: &#39;*&#x2F;*&#39;, &#39;werkzeug.request&#39;: &lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;&#125;\n&lt;Response 19 bytes [200 OK]&gt;\nb&#39;&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\\n&#39;\n127.0.0.1 - - [10&#x2F;Sep&#x2F;2022 22:55:47] &quot;GET &#x2F;api HTTP&#x2F;1.1&quot; 200 -</code></pre>\n\n<h4 id=\"路由匹配\"><a href=\"#路由匹配\" class=\"headerlink\" title=\"路由匹配\"></a>路由匹配</h4><p>路由匹配发生在app.url_map中，这是Werzeug中Map类的一个实例。<code>Map([&lt;Rule &#39;/static/&lt;filename&gt;&#39; (OPTIONS, GET, HEAD) -&gt; static&gt;, &lt;Rule &#39;/api&#39; (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])</code></p>\n<p>该类使用正则表达式来判定被<code>@app.route</code>装饰的函数时候与传入的请求匹配，路由匹配只会姜茶route调用里的路径参数来判断函数时候匹配客户端的请求，默认情况下，声明式路由只支持<code>GET</code>, <code>OPTIONS</code>, <code>HEAD</code>方法的调用，如果使用了不支持的HTTP方法，则会出现405Method Not Allowed响应，并在Allow响应头中返回其所支持的HTTP方法列表（正常访问不会出现Allow响应头）</p>\n<p>当需要支持指定HTTP请求方式时，我们需要给装饰器增加额外的参数：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@app.route(&#39;&#x2F;api&#39;, method&#x3D;[&#39;POST&#39;, &#39;DELETE&#39;, &#39;GET&#39;])</code></pre>\n\n\n\n<p>不过，</p>\n<h5 id=\"变量与转换器\"><a href=\"#变量与转换器\" class=\"headerlink\" title=\"变量与转换器\"></a>变量与转换器</h5><p>路由系统支持变量如：<code>/person/&lt;person_id&gt;</code></p>\n<h4 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h4><h4 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h4><h2 id=\"Flask的内置特性\"><a href=\"#Flask的内置特性\" class=\"headerlink\" title=\"Flask的内置特性\"></a>Flask的内置特性</h2><h2 id=\"微服务骨架\"><a href=\"#微服务骨架\" class=\"headerlink\" title=\"微服务骨架\"></a>微服务骨架</h2><p>拓展：</p>\n<p><strong>这个 <strong>name</strong> 变量可能取什么值？</strong></p>\n<p>当你直接执行一段脚本的时候，这段脚本的 **<strong>name</strong>**变量等于 <strong>‘<strong>main</strong>‘<strong>，当这段脚本被导入其他程序的时候，</strong><strong>name</strong></strong> 变量等于脚本本身的名字。</p>\n<p><strong>这个 <strong>name</strong> 拿来做什么的？</strong></p>\n<p>作为 Python 的内置变量，**<strong>name</strong>**变量（前后各有两个下划线）还是挺特殊的。它是每个 Python 模块必备的属性，但它的值取决于你是如何执行这段代码的。</p>\n<p>在许多情况下，你的代码不可能全部都放在同一个文件里，或者你在这个文件里写的函数，在其他地方也可以用到。为了更高效地重用这些代码，你需要在 Python 程序中导入来自其他文件的代码。</p>\n<p>所以，在**<strong>name</strong>** 变量的帮助下，你可以判断出这时代码是被直接运行，还是被导入到其他程序中去了。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/57309137\">Python 的 <strong>name</strong> 变量，到底是个什么东西？ - 知乎 (zhihu.com)</a></p>\n","text":"Flask如何处理请求一个简单但完整的示例from flask import Flask, jsonify app &#x3D; Flask(__name__) @app.route(&#39;&#x2F;api&#39;) def my_microservice(): retu...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Flask%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">Flask如何处理请求</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BD%86%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">一个简单但完整的示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#request%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">request对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%86%E8%A7%A3%E5%BA%95%E5%B1%82%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">了解底层到底发生了什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">路由匹配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2%E5%99%A8\"><span class=\"toc-text\">变量与转换器</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">请求</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94\"><span class=\"toc-text\">响应</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Flask%E7%9A%84%E5%86%85%E7%BD%AE%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Flask的内置特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AA%A8%E6%9E%B6\"><span class=\"toc-text\">微服务骨架</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"learningOpenGl Chapter 2.5","uid":"38c975c13d700e0f4a358527ea875949","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/02Lighting/04.Light casters","date":"2023-03-08T02:21:08.000Z","updated":"2023-03-08T02:28:27.000Z","comments":true,"path":"api/articles/Technical Artist/Opengl/learnopengl-cn.readthedocs.io/02Lighting/04.Light casters.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"Light Casters - 投光物 All the lighting we’ve used so far came from a single source that is a single point in space. It gives good results, but...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"TA","slug":"TA","count":14,"path":"api/categories/TA.json"}],"tags":[{"name":"Shader","slug":"Shader","count":19,"path":"api/tags/Shader.json"},{"name":"Opengl","slug":"Opengl","count":14,"path":"api/tags/Opengl.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Back End/django/Python Django Web典型模块开发实战/总述及django安装","date":"2023-03-08T00:30:41.954Z","updated":"2022-08-25T14:56:01.000Z","comments":true,"path":"api/articles/Web Dev/Back End/django/Python Django Web典型模块开发实战/总述及django安装.json","keywords":null,"cover":null,"text":"需要安装的内容： Django本体 ","link":"","photos":[],"count_time":{"symbolsCount":18,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}