{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Back End/flask/start","date":"2023-03-08T00:28:42.152Z","updated":"2021-11-08T12:49:18.000Z","comments":true,"path":"api/articles/Web Dev/Back End/flask/start.json","keywords":null,"cover":[],"content":"<h1 id=\"快速上手\"><a href=\"#快速上手\" class=\"headerlink\" title=\"快速上手\"></a>快速上手</h1><p>对应的官网页面：<a href=\"https://dormousehole.readthedocs.io/en/latest/quickstart.html#html\">快速上手 — Flask 中文文档 (2.0.2) (dormousehole.readthedocs.io)</a></p>\n<h2 id=\"一个最小的应用\"><a href=\"#一个最小的应用\" class=\"headerlink\" title=\"一个最小的应用\"></a>一个最小的应用</h2><p>一个最小的 Flask 应用如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import Flask\n\napp &#x3D; Flask(__name__)\n\n@app.route(&quot;&#x2F;&quot;)\ndef hello_world():\n    return &quot;&lt;p&gt;Hello, World!&lt;&#x2F;p&gt;&quot;</code></pre>\n\n<p>那么，这些代码是什么意思呢？</p>\n<ol>\n<li>首先我们<strong>导入了 <code>Flask</code> 类</strong>。该类的实例将会成为我们的 <strong>WSGI 应用</strong>。</li>\n<li>接着我们<strong>创建一个该类的实例</strong>。第一个参数是应用模块或者包的名称。 <code>__name__</code> 是一个适用于大多数情况的快捷方式。有了这个参数， Flask 才能知道在哪里可以找到模板和静态文件等东西。</li>\n<li>然后我们使用 <strong><code>route()</code> 装饰器</strong>来告诉 Flask <strong>触发函数 的 URL</strong> 。</li>\n<li>函数返回需要在用户浏览器中显示的信息。默认的内容类型是 HTML ，因此字 符串中的 HTML 会被浏览器渲染。</li>\n</ol>\n<p>把它保存为 <code>hello.py</code> 或其他类似名称。</p>\n<div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>请不要使用 <code>flask.py</code> 作为应用名称，这会与 Flask 本身发生冲突。</p>\n\n</div>\n<p>可以使用 <strong>flask</strong> 命令或者 python 的 <code>-m</code> 开关来运行这个应 用。在运行应用之前，需要在终端里导出 <code>FLASK_APP</code> 环境变量：</p>\n<p>Powershell</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">&gt; $env:FLASK_APP &#x3D; &quot;hello&quot;\n&gt; flask run\n * Running on http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;</code></pre>\n\n<p>应用发现行为</p>\n<p>作为一个捷径，如果文件名为 <code>app.py</code> 或者 <code>wsgi.py</code> ，那么您不 需要设置 <code>FLASK_APP</code> 环境变量。详见 <a href=\"https://dormousehole.readthedocs.io/en/latest/cli.html\">命令行接口</a> 。</p>\n<p>这样就启动了一个非常简单的内建的服务器。这个服务器用于测试应该是足够了， 但是用于生产可能是不够的。关于部署的有关内容参见 <a href=\"https://dormousehole.readthedocs.io/en/latest/deploying/index.html\">部署方式</a> 。</p>\n<p>现在在浏览器中打开 <a href=\"http://127.0.0.1:5000/\">http://127.0.0.1:5000/</a> ，应该可以看到 Hello World! 字样。</p>\n<p>外部可见的服务器</p>\n<p>运行服务器后，会发现只有您自己的电脑可以使用服务，而网络中的其他电脑却 不行。缺省设置就是这样的，因为在调试模式下该应用的用户可以执行您电脑中 的任意 Python 代码。</p>\n<p>如果您关闭了调试器或信任您网络中的用户，那么可以让服务器被公开访问。 只要在命令行上简单的加上 <code>--host=0.0.0.0</code> 即可:</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">$ flask run --host&#x3D;0.0.0.0</code></pre>\n\n<p>这行代码告诉您的操作系统监听所有公开的 IP 。</p>\n<h2 id=\"如果服务器不能启动怎么办\"><a href=\"#如果服务器不能启动怎么办\" class=\"headerlink\" title=\"如果服务器不能启动怎么办\"></a>如果服务器不能启动怎么办</h2><p>假如运行 <strong>python -m flask</strong> 命令失败或者 <strong>flask</strong> 命令 不存在，那么可能会有多种原因导致失败。<strong>首先应该检查错误信息</strong>。</p>\n<h3 id=\"老版本的-Flask\"><a href=\"#老版本的-Flask\" class=\"headerlink\" title=\"老版本的 Flask\"></a>老版本的 Flask</h3><p>版本低于 0.11 的 Flask，启动应用的方式是不同的。</p>\n<p>简单的说就是 <strong>flask</strong> 和 <strong>python -m flask</strong> 命令都无法使用。在这种情 况下有两个选择：一是升级 Flask 到更新的版本，二是参阅 <a href=\"https://dormousehole.readthedocs.io/en/latest/server.html\">开发服务器</a> ， 学习其他启动服务器的方法。</p>\n<h3 id=\"非法导入名称\"><a href=\"#非法导入名称\" class=\"headerlink\" title=\"非法导入名称\"></a>非法导入名称</h3><p><code>FLASK_APP</code> 环境变量中储存的是模块的名称，运行 <strong>flask run</strong> 命令就 会导入这个模块。如果模块的名称不对，那么就会出现导入错误。出现错误的时机是在 应用开始的时候。如果调试模式打开的情况下，会在运行到应用开始的时候出现导入 错误。出错信息会告诉您尝试导入哪个模块时出错，为什么会出错。</p>\n<p>最常见的错误是因为拼写错误而没有真正创建一个 <code>app</code> 对象。</p>\n<h2 id=\"调试模式\"><a href=\"#调试模式\" class=\"headerlink\" title=\"调试模式\"></a>调试模式</h2><p><code>flask run</code> 命令不只可以启动开发服务器。如果您打开调试模式，那么服务 器会在修改应用代码之后自动重启，并且当请求过程中发生错误时还会在浏览器 中提供一个交互调试器。</p>\n<p><img src=\"debugger.png\" alt=\"The interactive debugger in action.\"></p>\n<p>:::Warning</p>\n<p>调试器允许执行来自浏览器的任意 Python 代码。虽然它由一个 pin 保护， 但仍然存在巨大安全风险。不要在生产环境中运行开发服务器或调试器。</p>\n<p>:::</p>\n<p>如果需要打开所有开发功能，那么需要在运行 <code>flask run</code> 之前设置 <code>FLASK_ENV</code> 环境变量为 <code>development</code> 。</p>\n<p>Powershell</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">&gt; $env:FLASK_ENV &#x3D; &quot;development&quot;\n&gt; flask run</code></pre>\n\n<p>另见：</p>\n<ul>\n<li><a href=\"https://dormousehole.readthedocs.io/en/latest/server.html\">开发服务器</a> 和 <a href=\"https://dormousehole.readthedocs.io/en/latest/cli.html\">命令行接口</a> 包含有关开发模式运行的内容。</li>\n<li><a href=\"https://dormousehole.readthedocs.io/en/latest/debugging.html\">调试应用程序错误</a> 包含有关内置调试器和其他调试器的内容。</li>\n<li><a href=\"https://dormousehole.readthedocs.io/en/latest/logging.html\">日志</a> 和 <a href=\"https://dormousehole.readthedocs.io/en/latest/errorhandling.html\">应用错误处理</a> 包含有关日志记录和显示友好 的出错信息页面的内容</li>\n</ul>\n<h2 id=\"HTML-转义\"><a href=\"#HTML-转义\" class=\"headerlink\" title=\"HTML 转义\"></a>HTML 转义</h2><p>当返回 HTML （ Flask 中的默认响应类型）时，为了防止注入攻击，所有用户提供的值在输出渲染前必须被转义。使用 Jinja （这个稍后会介绍）渲染的 HTML 模板会自动执行此操作。</p>\n<p>在下面展示的 <code>escape()</code> 可以手动转义。因为保持简洁的原因，在多数示例中它被省略了，但您应该始终留心处理不可信的数据。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from markupsafe import escape\n\n@app.route(&quot;&#x2F;&lt;name&gt;&quot;) # 在这里定义了一个&lt;name&gt;来接收用用户内容\ndef hello(name):\n    return f&quot;Hello, &#123;escape(name)&#125;!&quot;</code></pre>\n\n<p>如果一个用户想要提交其名称为 <code>&lt;script&gt;alert(&quot;bad&quot;)&lt;/script&gt;</code> ，那么 宁可转义为文本，也好过在浏览器中执行脚本。</p>\n<p>路由中的 <code>&lt;name&gt;</code> 从 URL 中捕获值并将其传递给视图函数。这些变量规则见 下文。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>现代 web 应用都使用有意义的 URL ，这样有助于用户记忆，网页会更得到用户的青睐， 提高回头率。</p>\n<p>使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Flask.route\"><code>route()</code></a> 装饰器来把函数绑定到 URL:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return &#39;Index Page&#39;\n\n@app.route(&#39;&#x2F;hello&#39;)\ndef hello():\n    return &#39;Hello, World&#39;</code></pre>\n\n<p>但是能做的不仅仅是这些！您可以动态变化 URL 的某些部分， 还可以为一个函数指定多个规则。</p>\n<h3 id=\"变量规则\"><a href=\"#变量规则\" class=\"headerlink\" title=\"变量规则\"></a>变量规则</h3><p>通过把 URL 的一部分标记为 <code>&lt;variable_name&gt;</code> 就可以在 URL 中添加变量。标记的部分会作为关键字参数传递给函数。通过使用 <code>&lt;converter:variable_name&gt;</code> ，可以 选择性的 加上一个转换器，为变量指定规则。请看下面的例子:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from markupsafe import escape\n\n@app.route(&#39;&#x2F;user&#x2F;&lt;username&gt;&#39;)\ndef show_user_profile(username):\n    # show the user profile for that user\n    return f&#39;User &#123;escape(username)&#125;&#39;\n\n@app.route(&#39;&#x2F;post&#x2F;&lt;int:post_id&gt;&#39;)\ndef show_post(post_id):\n    # show the post with the given id, the id is an integer\n    return f&#39;Post &#123;post_id&#125;&#39;\n\n@app.route(&#39;&#x2F;path&#x2F;&lt;path:subpath&gt;&#39;)\ndef show_subpath(subpath):\n    # show the subpath after &#x2F;path&#x2F;\n    return f&#39;Subpath &#123;escape(subpath)&#125;&#39;</code></pre>\n\n<p>转换器类型：</p>\n<table>\n<thead>\n<tr>\n<th><code>string</code></th>\n<th>（缺省值） 接受任何 不包含斜杠 的文本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>int</code></td>\n<td>接受 正 整数</td>\n</tr>\n<tr>\n<td><code>float</code></td>\n<td>接受 正 浮点数</td>\n</tr>\n<tr>\n<td><code>path</code></td>\n<td>类似 <code>string</code> ，但可以包含斜杠</td>\n</tr>\n<tr>\n<td><code>uuid</code></td>\n<td>接受 UUID 字符串</td>\n</tr>\n</tbody></table>\n<h3 id=\"唯一的-URL-重定向行为\"><a href=\"#唯一的-URL-重定向行为\" class=\"headerlink\" title=\"唯一的 URL / 重定向行为\"></a>唯一的 URL / 重定向行为</h3><p>以下两条规则的不同之处在于是否使用尾部的斜杠。:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@app.route(&#39;&#x2F;projects&#x2F;&#39;)\ndef projects():\n    return &#39;The project page&#39;\n\n@app.route(&#39;&#x2F;about&#39;)\ndef about():\n    return &#39;The about page&#39;</code></pre>\n\n<p><code>projects</code> 的 URL 是中规中矩的，尾部有一个斜杠，看起来就如同一个文件 夹。</p>\n<p>访问一个没有斜杠结尾的 URL （ <code>/projects</code> ）时 Flask 会自动进行重定向，帮您在尾部加上一个斜杠（ <code>/projects/</code> ）</p>\n<p><code>about</code> 的 URL 没有尾部斜杠，因此其行为表现与一个文件类似。如果访问这 个 URL 时添加了尾部斜杠（<code>/about/</code> ）就会得到一个 404 “未找到” 错 误。这样可以保持 URL 唯一，并有助于搜索引擎重复索引同一页面。</p>\n<h3 id=\"URL-构建\"><a href=\"#URL-构建\" class=\"headerlink\" title=\"URL 构建\"></a>URL 构建</h3><p><a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.url_for\"><code>url_for()</code></a> 函数用于构建指定函数的 URL。它把函数名称作为第一个 参数。它可以接受任意个关键字参数，每个关键字参数对应 URL 中的变量。未知变量 将添加到 URL 中作为查询参数。</p>\n<p>为什么不在把 URL 写死在模板中，而要使用反转函数 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.url_for\"><code>url_for()</code></a> 动态构建？</p>\n<ol>\n<li>反转通常比硬编码 URL 的描述性更好。</li>\n<li>您可以只在一个地方改变 URL ，而不用到处乱找。</li>\n<li>URL 创建会为您处理特殊字符的转义，比较直观。</li>\n<li>生产的路径总是绝对路径，可以避免相对路径产生副作用。</li>\n<li>如果您的应用是放在 URL 根路径之外的地方（如在 <code>/myapplication</code> 中，不在 <code>/</code> 中）， <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.url_for\"><code>url_for()</code></a> 会为您妥善处理。</li>\n</ol>\n<p>例如，这里我们使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Flask.test_request_context\"><code>test_request_context()</code></a> 方法来尝试使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.url_for\"><code>url_for()</code></a> 。 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Flask.test_request_context\"><code>test_request_context()</code></a> 告诉 Flask 正在处理一个请求，而实际上也许我们正处在交互 Python shell 之中， 并没有真正的请求。参见 <a href=\"https://dormousehole.readthedocs.io/en/latest/quickstart.html#context-locals\">本地环境</a> 。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import url_for\n\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return &#39;index&#39;\n\n@app.route(&#39;&#x2F;login&#39;)\ndef login():\n    return &#39;login&#39;\n\n@app.route(&#39;&#x2F;user&#x2F;&lt;username&gt;&#39;)\ndef profile(username):\n    return f&#39;&#123;username&#125;\\&#39;s profile&#39;\n\nwith app.test_request_context():\n    print(url_for(&#39;index&#39;))\n    print(url_for(&#39;login&#39;))\n    print(url_for(&#39;login&#39;, next&#x3D;&#39;&#x2F;&#39;))\n    print(url_for(&#39;profile&#39;, username&#x3D;&#39;John Doe&#39;))\n&#x2F;\n&#x2F;login\n&#x2F;login?next&#x3D;&#x2F;\n&#x2F;user&#x2F;John%20Doe</code></pre>\n\n<h3 id=\"HTTP-方法\"><a href=\"#HTTP-方法\" class=\"headerlink\" title=\"HTTP 方法\"></a>HTTP 方法</h3><p>Web 应用使用不同的 HTTP 方法处理 URL 。当您使用 Flask 时，应当熟悉 HTTP 方法。 缺省情况下，一个路由只回应 <code>GET</code> 请求。 可以使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Flask.route\"><code>route()</code></a> 装饰器的 <code>methods</code> 参数来处理不同的 HTTP 方法:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import request\n\n@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])\ndef login():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        return do_the_login()\n    else:\n        return show_the_login_form()</code></pre>\n\n<p>如果当前使用了 GET 方法， Flask 会自动添加 <code>HEAD</code> 方法支持，并且同时还会 按照 <a href=\"https://www.ietf.org/rfc/rfc2068.txt\">HTTP RFC</a> 来处理 <code>HEAD</code> 请求。同样， <code>OPTIONS</code> 也会自动实现。</p>\n<h2 id=\"静态文件\"><a href=\"#静态文件\" class=\"headerlink\" title=\"静态文件\"></a>静态文件</h2><p>动态的 web 应用也需要静态文件，一般是 CSS 和 JavaScript 文件。理想情况下您的服务器已经配置好了为您的提供静态文件的服务。但是在开发过程中， Flask 也能做好这项工作。只要在您的包或模块旁边创建一个名为 <code>static</code> 的文件夹就行了。 静态文件位于应用的 <code>/static</code> 中。</p>\n<p>使用特定的 <code>&#39;static&#39;</code> 端点就可以生成相应的 URL</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">url_for(&#39;static&#39;, filename&#x3D;&#39;style.css&#39;)</code></pre>\n\n<p>这个静态文件在文件系统中的位置应该是 <code>static/style.css</code> </p>\n<h2 id=\"渲染模板\"><a href=\"#渲染模板\" class=\"headerlink\" title=\"渲染模板\"></a>渲染模板</h2><p>在 Python 内部生成 HTML 不好玩，且相当笨拙。因为您必须自己负责 HTML 转义， 以确保应用的安全。因此， Flask 自动为您配置 <a href=\"https://palletsprojects.com/p/jinja/\">Jinja2</a> 模板引擎。</p>\n<p>使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.render_template\"><code>render_template()</code></a> 方法可以渲染模板，您只要提供模板名称和需要 作为参数传递给模板的变量就行了。下面是一个简单的模板渲染例子:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from flask import render_template\n\n@app.route(&#39;&#x2F;hello&#x2F;&#39;)\n@app.route(&#39;&#x2F;hello&#x2F;&lt;name&gt;&#39;)\ndef hello(name&#x3D;None):\n    return render_template(&#39;hello.html&#39;, name&#x3D;name)</code></pre>\n\n<p>Flask 会在 <code>templates</code> 文件夹内寻找模板。因此，如果您的应用是一个模块， 那么模板文件夹应该在模块旁边；如果是一个包，那么就应该在包里面：</p>\n<p><strong>情形 1</strong> : 一个模块:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">&#x2F;application.py\n&#x2F;templates\n    &#x2F;hello.html</code></pre>\n\n<p><strong>情形 2</strong> : 一个包:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">&#x2F;application\n    &#x2F;__init__.py\n    &#x2F;templates\n        &#x2F;hello.html</code></pre>\n\n<p>您可以充分使用 Jinja2 模板引擎的威力。更多内容，详见官方 <a href=\"https://jinja.palletsprojects.com/templates/\">Jinja2 模板文档</a> 。</p>\n<p>模板示例：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;!doctype html&gt;\n&lt;title&gt;Hello from Flask&lt;&#x2F;title&gt;\n&#123;% if name %&#125;\n  &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;&#x2F;h1&gt;\n&#123;% else %&#125;\n  &lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;\n&#123;% endif %&#125;</code></pre>\n\n<p>在模板内部可以像使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.url_for\"><code>url_for()</code></a> 和 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.get_flashed_messages\"><code>get_flashed_messages()</code></a> 函数一样访问 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Flask.config\"><code>config</code></a> 、 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.request\"><code>request</code></a> 、 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.session\"><code>session</code></a> 和 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.g\"><code>g</code></a> <a href=\"https://dormousehole.readthedocs.io/en/latest/quickstart.html#id13\">1</a> 对象。</p>\n<p>模板在继承使用的情况下尤其有用。其工作原理参见 <a href=\"https://dormousehole.readthedocs.io/en/latest/patterns/templateinheritance.html\">模板继承</a> 。简单的说，模板继承可以使每个页面 的特定元素（如页头、导航和页尾）保持一致。</p>\n<p>自动转义默认开启。因此，如果 <code>name</code> 包含 HTML ，那么会被自动转义。如 果您可以信任某个变量，且知道它是安全的 HTML （例如变量来自一个把 wiki 标记转换为 HTML 的模块），那么可以使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Markup\"><code>Markup</code></a> 类把 它标记为安全的，或者在模板中使用 <code>|safe</code> 过滤器。更多例子参见 Jinja 2 文档。</p>\n<p>下面 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Markup\"><code>Markup</code></a> 类的基本使用方法:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; Markup(&#39;&lt;strong&gt;Hello %s!&lt;&#x2F;strong&gt;&#39;) % &#39;&lt;blink&gt;hacker&lt;&#x2F;blink&gt;&#39;\nMarkup(&#39;&lt;strong&gt;Hello &lt;blink&gt;hacker&lt;&#x2F;blink&gt;!&lt;&#x2F;strong&gt;&#39;)\n&gt;&gt;&gt; Markup.escape(&#39;&lt;blink&gt;hacker&lt;&#x2F;blink&gt;&#39;)\nMarkup(&#39;&lt;blink&gt;hacker&lt;&#x2F;blink&gt;&#39;)\n&gt;&gt;&gt; Markup(&#39;&lt;em&gt;Marked up&lt;&#x2F;em&gt; &amp;raquo; HTML&#39;).striptags()\n&#39;Marked up \\xbb HTML&#39;</code></pre>\n\n<details class=\"changelog\"><summary style=\"cursor: pointer; font-style: italic; margin-bottom: 10px;\">Changelog</summary></details>\n\n<ul>\n<li><p><a href=\"https://dormousehole.readthedocs.io/en/latest/quickstart.html#id12\">1</a></p>\n<p>不确定 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.g\"><code>g</code></a> 对象是什么？它是某个可以根据需要储存信 息的东西，详见 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.g\"><code>g</code></a> 对象的文档和 <a href=\"https://dormousehole.readthedocs.io/en/latest/patterns/sqlite3.html\">使用 SQLite 3</a> 。</p>\n</li>\n</ul>\n<h2 id=\"操作请求数据\"><a href=\"#操作请求数据\" class=\"headerlink\" title=\"操作请求数据\"></a>操作请求数据</h2><p>对于 web 应用来说对客户端向服务器发送的数据作出响应很重要。在 Flask 中 由全局对象 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.request\"><code>request</code></a> 来提供请求信息。如果您有一些 Python 基础，那么可能 会奇怪：既然这个对象是全局的，怎么还能保持线程安全？答案 是本地环境：</p>\n<h3 id=\"本地环境\"><a href=\"#本地环境\" class=\"headerlink\" title=\"本地环境\"></a>本地环境</h3><p>内部信息</p>\n<p>如果您想了解工作原理和如何使用本地环境进行测试，那么请阅读本节， 否则可以跳过本节。</p>\n<p>某些对象在 Flask 中是全局对象，但不是通常意义下的全局对象。这些对象实际上是 特定环境下本地对象的代理。真拗口！但还是很容易理解的。</p>\n<p>设想现在处于处理线程的环境中。一个请求进来了，服务器决定生成一个新线程（或者 叫其他什么名称的东西，这个下层的东西能够处理包括线程在内的并发系统）。当 Flask 开始其内部请求处理时会把当前线程作为活动环境，并把当前应用和 WSGI 环境绑定到 这个环境（线程）。它以一种聪明的方式使得一个应用可以在不中断的情况下调用另一个 应用。</p>\n<p>这对您有什么用？基本上您可以完全不必理会。这个只有在做单元测试时才有用。在测试 时会遇到由于没有请求对象而导致依赖于请求的代码会突然崩溃的情况。对策是自己创建 一个请求对象并绑定到环境。最简单的单元测试解决方案是使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Flask.test_request_context\"><code>test_request_context()</code></a> 环境管理器。通过使用 <code>with</code> 语句 可以绑定一个测试请求，以便于交互。例如:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from flask import request\n\nwith app.test_request_context(&#39;&#x2F;hello&#39;, method&#x3D;&#39;POST&#39;):\n    # now you can do something with the request until the\n    # end of the with block, such as basic assertions:\n    assert request.path &#x3D;&#x3D; &#39;&#x2F;hello&#39;\n    assert request.method &#x3D;&#x3D; &#39;POST&#39;</code></pre>\n\n<p>另一种方式是把整个 WSGI 环境传递给 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Flask.request_context\"><code>request_context()</code></a> 方法:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">with app.request_context(environ):\n    assert request.method &#x3D;&#x3D; &#39;POST&#39;</code></pre>\n\n<h3 id=\"请求对象\"><a href=\"#请求对象\" class=\"headerlink\" title=\"请求对象\"></a>请求对象</h3><p>请求对象在 API 一节中有详细说明这里不细谈（参见 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Request\"><code>Request</code></a> ）。 这里简略地谈一下最常见的操作。首先，您必须从 <code>flask</code> 模块导入请求对象:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from flask import request</code></pre>\n\n<p>通过使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Request.method\"><code>method</code></a> 属性可以操作当前请求方法，通过使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Request.form\"><code>form</code></a> 属性处理表单数据（在 <code>POST</code> 或者 <code>PUT</code> 请求 中传输的数据）。以下是使用上述两个属性的例子:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;POST&#39;, &#39;GET&#39;])\ndef login():\n    error &#x3D; None\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        if valid_login(request.form[&#39;username&#39;],\n                       request.form[&#39;password&#39;]):\n            return log_the_user_in(request.form[&#39;username&#39;])\n        else:\n            error &#x3D; &#39;Invalid username&#x2F;password&#39;\n    # the code below is executed if the request method\n    # was GET or the credentials were invalid\n    return render_template(&#39;login.html&#39;, error&#x3D;error)</code></pre>\n\n<p>当 <code>form</code> 属性中不存在这个键时会发生什么？会引发一个 <a href=\"https://docs.python.org/3/library/exceptions.html#KeyError\"><code>KeyError</code></a> 。 如果您不像捕捉一个标准错误一样捕捉 <a href=\"https://docs.python.org/3/library/exceptions.html#KeyError\"><code>KeyError</code></a> ，那么会显示一个 HTTP 400 Bad Request 错误页面。因此，多数情况下您不必处理这个问题。</p>\n<p>要操作 URL （如 <code>?key=value</code> ）中提交的参数可以使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Request.args\"><code>args</code></a> 属性:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">searchword &#x3D; request.args.get(&#39;key&#39;, &#39;&#39;)</code></pre>\n\n<p>用户可能会改变 URL 导致出现一个 400 请求出错页面，这样降低了用户友好度。因此， 我们推荐使用 get 或通过捕捉 <a href=\"https://docs.python.org/3/library/exceptions.html#KeyError\"><code>KeyError</code></a> 来访问 URL 参数。</p>\n<p>完整的请求对象方法和属性参见 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Request\"><code>Request</code></a> 文档。</p>\n<h3 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h3><p>用 Flask 处理文件上传很容易，只要确保不要忘记在您的 HTML 表单中设置 <code>enctype=&quot;multipart/form-data&quot;</code> 属性就可以了。否则浏览器将不会传送您的文件。</p>\n<p>已上传的文件被储存在内存或文件系统的临时位置。您可以通过请求对象 <code>files</code> 属性来访问上传的文件。每个上传的文件都储存在这个 字典型属性中。这个属性基本和标准 Python <code>file</code> 对象一样，另外多出一个 用于把上传文件保存到服务器的文件系统中的 <a href=\"https://werkzeug.palletsprojects.com/en/2.0.x/datastructures/#werkzeug.datastructures.FileStorage.save\"><code>save()</code></a> 方法。下例展示其如何运作:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from flask import request\n\n@app.route(&#39;&#x2F;upload&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])\ndef upload_file():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        f &#x3D; request.files[&#39;the_file&#39;]\n        f.save(&#39;&#x2F;var&#x2F;www&#x2F;uploads&#x2F;uploaded_file.txt&#39;)\n    ...</code></pre>\n\n<p>如果想要知道文件上传之前其在客户端系统中的名称，可以使用 <a href=\"https://werkzeug.palletsprojects.com/en/2.0.x/datastructures/#werkzeug.datastructures.FileStorage.filename\"><code>filename</code></a> 属性。但是请牢记这个值是 可以伪造的，永远不要信任这个值。如果想要把客户端的文件名作为服务器上的文件名， 可以通过 Werkzeug 提供的 <a href=\"https://werkzeug.palletsprojects.com/en/2.0.x/utils/#werkzeug.utils.secure_filename\"><code>secure_filename()</code></a> 函数:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from werkzeug.utils import secure_filename\n\n@app.route(&#39;&#x2F;upload&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])\ndef upload_file():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        file &#x3D; request.files[&#39;the_file&#39;]\n        file.save(f&quot;&#x2F;var&#x2F;www&#x2F;uploads&#x2F;&#123;secure_filename(file.filename)&#125;&quot;)\n    ...</code></pre>\n\n<p>更好的例子参见 <a href=\"https://dormousehole.readthedocs.io/en/latest/patterns/fileuploads.html\">上传文件</a> 。</p>\n<h3 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h3><p>要访问 cookies ，可以使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Request.cookies\"><code>cookies</code></a> 属性。可以使用响应 对象 的 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Response.set_cookie\"><code>set_cookie</code></a> 方法来设置 cookies 。请求对象的 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Request.cookies\"><code>cookies</code></a> 属性是一个包含了客户端传输的所有 cookies 的字典。在 Flask 中，如果使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/quickstart.html#sessions\">会话</a> ，那么就不要直接使用 cookies ，因为 <a href=\"https://dormousehole.readthedocs.io/en/latest/quickstart.html#sessions\">会话</a> 比较安全一些。</p>\n<p>读取 cookies:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from flask import request\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    username &#x3D; request.cookies.get(&#39;username&#39;)\n    # use cookies.get(key) instead of cookies[key] to not get a\n    # KeyError if the cookie is missing.</code></pre>\n\n<p>储存 cookies:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from flask import make_response\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    resp &#x3D; make_response(render_template(...))\n    resp.set_cookie(&#39;username&#39;, &#39;the username&#39;)\n    return resp</code></pre>\n\n<p>注意， cookies 设置在响应对象上。通常只是从视图函数返回字符串， Flask 会把它们转换为响应对象。如果您想显式地转换，那么可以使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.make_response\"><code>make_response()</code></a> 函数，然后再修改它。</p>\n<p>使用 doc:patterns/deferredcallbacks 方案可以在没有响应对象的情况下设 置一个 cookie 。</p>\n<p>另见 <a href=\"https://dormousehole.readthedocs.io/en/latest/quickstart.html#about-responses\">关于响应</a> 。</p>\n<h2 id=\"重定向和错误\"><a href=\"#重定向和错误\" class=\"headerlink\" title=\"重定向和错误\"></a>重定向和错误</h2><p>使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.redirect\"><code>redirect()</code></a> 函数可以重定向。使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.abort\"><code>abort()</code></a> 可以 更早退出请求，并返回错误代码:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from flask import abort, redirect, url_for\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return redirect(url_for(&#39;login&#39;))\n\n@app.route(&#39;&#x2F;login&#39;)\ndef login():\n    abort(401)\n    this_is_never_executed()</code></pre>\n\n<p>上例实际上是没有意义的，它让一个用户从索引页重定向到一个无法访问的页面（401 表示禁止访问）。但是上例可以说明重定向和出错跳出是如何工作的。</p>\n<p>缺省情况下每种出错代码都会对应显示一个黑白的出错页面。使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Flask.errorhandler\"><code>errorhandler()</code></a> 装饰器可以定制出错页面:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@app.errorhandler(404)\ndef page_not_found(error):\n    return render_template(&#39;page_not_found.html&#39;), 404</code></pre>\n\n<p>注意 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.render_template\"><code>render_template()</code></a> 后面的 <code>404</code> ，这表示页面对就的出错 代码是 404 ，即页面不存在。缺省情况下 200 表示：一切正常。</p>\n<p>详见 <a href=\"https://dormousehole.readthedocs.io/en/latest/errorhandling.html\">应用错误处理</a> 。</p>\n<h2 id=\"关于响应\"><a href=\"#关于响应\" class=\"headerlink\" title=\"关于响应\"></a>关于响应</h2><p>视图函数的返回值会自动转换为一个响应对象。如果返回值是一个字符串，那么会被 转换为一个包含作为响应体的字符串、一个 <code>200 OK</code> 出错代码 和一个 <em>text/html</em> 类型的响应对象。如果返回值是一个字典，那么会调用 <code>jsonify()</code> 来产生一个响应。以下是转换的规则：</p>\n<ol>\n<li>如果视图返回的是一个响应对象，那么就直接返回它。</li>\n<li>如果返回的是一个字符串，那么根据这个字符串和缺省参数生成一个用于返回的 响应对象。</li>\n<li>如果返回的是一个字典，那么调用 <code>jsonify</code> 创建一个响应对象。</li>\n<li>如果返回的是一个元组，那么元组中的项目可以提供额外的信息。元组中必须至少 包含一个项目，且项目应当由 <code>(response, status)</code> 、 <code>(response, headers)</code> 或者 <code>(response, status, headers)</code> 组成。 <code>status</code> 的值会重载状态代码， <code>headers</code> 是一个由额外头部值组成的列表 或字典。</li>\n<li>如果以上都不是，那么 Flask 会假定返回值是一个有效的 WSGI 应用并把它转换为 一个响应对象。</li>\n</ol>\n<p>如果想要在视图内部掌控响应对象的结果，那么可以使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.make_response\"><code>make_response()</code></a> 函数。</p>\n<p>设想有如下视图:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@app.errorhandler(404)\ndef not_found(error):\n    return render_template(&#39;error.html&#39;), 404</code></pre>\n\n<p>可以使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.make_response\"><code>make_response()</code></a> 包裹返回表达式，获得响应对象，并对该对象 进行修改，然后再返回:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@app.errorhandler(404)\ndef not_found(error):\n    resp &#x3D; make_response(render_template(&#39;error.html&#39;), 404)\n    resp.headers[&#39;X-Something&#39;] &#x3D; &#39;A value&#39;\n    return resp</code></pre>\n\n<h3 id=\"JSON-格式的-API\"><a href=\"#JSON-格式的-API\" class=\"headerlink\" title=\"JSON 格式的 API\"></a>JSON 格式的 API</h3><p>JSON 格式的响应是常见的，用 Flask 写这样的 API 是很容易上手的。如果从视图 返回一个 <code>dict</code> ，那么它会被转换为一个 JSON 响应。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@app.route(&quot;&#x2F;me&quot;)\ndef me_api():\n    user &#x3D; get_current_user()\n    return &#123;\n        &quot;username&quot;: user.username,\n        &quot;theme&quot;: user.theme,\n        &quot;image&quot;: url_for(&quot;user_image&quot;, filename&#x3D;user.image),\n    &#125;</code></pre>\n\n<p>如果 <code>dict</code> 还不能满足需求，还需要创建其他类型的 JSON 格式响应，可以使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.json.jsonify\"><code>jsonify()</code></a> 函数。该函数会序列化任何支持的 JSON 数据类型。 也可以研究研究 Flask 社区扩展，以支持更复杂的应用。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">@app.route(&quot;&#x2F;users&quot;)\ndef users_api():\n    users &#x3D; get_all_users()\n    return jsonify([user.to_json() for user in users])</code></pre>\n\n\n\n<h2 id=\"会话\"><a href=\"#会话\" class=\"headerlink\" title=\"会话\"></a>会话</h2><p>除了请求对象之外还有一种称为 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.session\"><code>session</code></a> 的对象，允许您在不同请求 之间储存信息。这个对象相当于用密钥签名加密的 cookie ，即用户可以查看您的 cookie ，但是如果没有密钥就无法修改它。</p>\n<p>使用会话之前您必须设置一个密钥。举例说明:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from flask import session\n\n# Set the secret key to some random bytes. Keep this really secret!\napp.secret_key &#x3D; b&#39;_5#y2L&quot;F4Q8z\\n\\xec]&#x2F;&#39;\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    if &#39;username&#39; in session:\n        return f&#39;Logged in as &#123;session[&quot;username&quot;]&#125;&#39;\n    return &#39;You are not logged in&#39;\n\n@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])\ndef login():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        session[&#39;username&#39;] &#x3D; request.form[&#39;username&#39;]\n        return redirect(url_for(&#39;index&#39;))\n    return &#39;&#39;&#39;\n        &lt;form method&#x3D;&quot;post&quot;&gt;\n            &lt;p&gt;&lt;input type&#x3D;text name&#x3D;username&gt;\n            &lt;p&gt;&lt;input type&#x3D;submit value&#x3D;Login&gt;\n        &lt;&#x2F;form&gt;\n    &#39;&#39;&#39;\n\n@app.route(&#39;&#x2F;logout&#39;)\ndef logout():\n    # remove the username from the session if it&#39;s there\n    session.pop(&#39;username&#39;, None)\n    return redirect(url_for(&#39;index&#39;))</code></pre>\n\n<p>如何生成一个好的密钥</p>\n<p>生成随机数的关键在于一个好的随机种子，因此一个好的密钥应当有足够的随机性。 操作系统可以有多种方式基于密码随机生成器来生成随机数据。使用下面的命令 可以快捷的为 <code>Flask.secret_key</code> （ 或者 <a href=\"https://dormousehole.readthedocs.io/en/latest/config.html#SECRET_KEY\"><code>SECRET_KEY</code></a> ）生成值:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ python -c &#39;import os; print(os.urandom(16))&#39;\nb&#39;_5#y2L&quot;F4Q8z\\n\\xec]&#x2F;&#39;</code></pre>\n\n<p>基于 cookie 的会话的说明： Flask 会取出会话对象中的值，把值序列化后储存到 cookie 中。在打开 cookie 的情况下，如果需要查找某个值，但是这个值在请求中 没有持续储存的话，那么不会得到一个清晰的出错信息。请检查页面响应中的 cookie 的大小是否与网络浏览器所支持的大小一致。</p>\n<p>除了缺省的客户端会话之外，还有许多 Flask 扩展支持服务端会话。</p>\n<h2 id=\"消息闪现\"><a href=\"#消息闪现\" class=\"headerlink\" title=\"消息闪现\"></a>消息闪现</h2><p>一个好的应用和用户接口都有良好的反馈，否则到后来用户就会讨厌这个应用。 Flask 通过闪现系统来提供了一个易用的反馈方式。闪现系统的基本工作原理是 在请求结束时记录一个消息，提供且只提供给下一个请求使用。通常通过一个布 局模板来展现闪现的消息。</p>\n<p><a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.flash\"><code>flash()</code></a> 用于闪现一个消息。在模板中，使用 <a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.get_flashed_messages\"><code>get_flashed_messages()</code></a> 来操作消息。完整的例子参见 <a href=\"https://dormousehole.readthedocs.io/en/latest/patterns/flashing.html\">消息闪现</a> 。</p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><details class=\"changelog\"><summary style=\"cursor: pointer; font-style: italic; margin-bottom: 10px;\">Changelog</summary></details>\n\n<p>有时候可能会遇到数据出错需要纠正的情况。例如因为用户篡改了数据或客户端 代码出错而导致一个客户端代码向服务器发送了明显错误的 HTTP 请求。多数时 候在类似情况下返回 <code>400 Bad Request</code> 就没事了，但也有不会返回的时候， 而代码还得继续运行下去。</p>\n<p>这时候就需要使用日志来记录这些不正常的东西了。自从 Flask 0.3 后就已经为 您配置好 了一个日志工具。</p>\n<p>以下是一些日志调用示例:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.logger.debug(&#39;A value for debugging&#39;)\napp.logger.warning(&#39;A warning occurred (%d apples)&#39;, 42)\napp.logger.error(&#39;An error occurred&#39;)</code></pre>\n\n<p><a href=\"https://dormousehole.readthedocs.io/en/latest/api.html#flask.Flask.logger\"><code>logger</code></a> 是一个标准的 <a href=\"https://docs.python.org/3/library/logging.html#logging.Logger\"><code>Logger</code></a> Logger 类，更多信息详见官方的 <a href=\"https://docs.python.org/3/library/logging.html#module-logging\"><code>logging</code></a> 文档。</p>\n<p>参见 <a href=\"https://dormousehole.readthedocs.io/en/latest/errorhandling.html\">应用错误处理</a> 。</p>\n<h2 id=\"集成-WSGI-中间件\"><a href=\"#集成-WSGI-中间件\" class=\"headerlink\" title=\"集成 WSGI 中间件\"></a>集成 WSGI 中间件</h2><p>如果想要在应用中添加一个 WSGI 中间件，那么可以用应用的 <code>wsgi_app</code> 属性 来包装。例如，假设需要在 Nginx 后面使用 <a href=\"https://werkzeug.palletsprojects.com/en/2.0.x/middleware/proxy_fix/#werkzeug.middleware.proxy_fix.ProxyFix\"><code>ProxyFix</code></a> 中间件，那么可以这样做:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from werkzeug.middleware.proxy_fix import ProxyFix\napp.wsgi_app &#x3D; ProxyFix(app.wsgi_app)</code></pre>\n\n<p>用 <code>app.wsgi_app</code> 来包装，而不用 <code>app</code> 包装，意味着 <code>app</code> 仍旧指向您 的 Flask 应用，而不是指向中间件。这样可以继续直接使用和配置 <code>app</code> 。</p>\n<h2 id=\"使用-Flask-扩展\"><a href=\"#使用-Flask-扩展\" class=\"headerlink\" title=\"使用 Flask 扩展\"></a>使用 Flask 扩展</h2><p>扩展是帮助完成公共任务的包。例如 Flask-SQLAlchemy 为在 Flask 中轻松使用 SQLAlchemy 提供支持。</p>\n<p>更多关于 Flask 扩展的内容请参阅 <a href=\"https://dormousehole.readthedocs.io/en/latest/extensions.html\">扩展</a> 。</p>\n<h2 id=\"部署到网络服务器\"><a href=\"#部署到网络服务器\" class=\"headerlink\" title=\"部署到网络服务器\"></a>部署到网络服务器</h2><p>已经准备好部署您的新 Flask 应用了？请移步 <a href=\"https://dormousehole.readthedocs.io/en/latest/deploying/index.html\">部署方式</a> 。</p>\n","text":"快速上手对应的官网页面：快速上手 — Flask 中文文档 (2.0.2) (dormousehole.readthedocs.io) 一个最小的应用一个最小的 Flask 应用如下： from flask import Flask app &#x3D; Flask(__name...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B\"><span class=\"toc-text\">快速上手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">一个最小的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8D%E8%83%BD%E5%90%AF%E5%8A%A8%E6%80%8E%E4%B9%88%E5%8A%9E\"><span class=\"toc-text\">如果服务器不能启动怎么办</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%80%81%E7%89%88%E6%9C%AC%E7%9A%84-Flask\"><span class=\"toc-text\">老版本的 Flask</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E6%B3%95%E5%AF%BC%E5%85%A5%E5%90%8D%E7%A7%B0\"><span class=\"toc-text\">非法导入名称</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">调试模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTML-%E8%BD%AC%E4%B9%89\"><span class=\"toc-text\">HTML 转义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">路由</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99\"><span class=\"toc-text\">变量规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%94%AF%E4%B8%80%E7%9A%84-URL-%E9%87%8D%E5%AE%9A%E5%90%91%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">唯一的 URL &#x2F; 重定向行为</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#URL-%E6%9E%84%E5%BB%BA\"><span class=\"toc-text\">URL 构建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">HTTP 方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">静态文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">渲染模板</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">操作请求数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">本地环境</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">请求对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">文件上传</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookies\"><span class=\"toc-text\">Cookies</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">重定向和错误</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E5%93%8D%E5%BA%94\"><span class=\"toc-text\">关于响应</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JSON-%E6%A0%BC%E5%BC%8F%E7%9A%84-API\"><span class=\"toc-text\">JSON 格式的 API</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%9A%E8%AF%9D\"><span class=\"toc-text\">会话</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E9%97%AA%E7%8E%B0\"><span class=\"toc-text\">消息闪现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">日志</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%86%E6%88%90-WSGI-%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">集成 WSGI 中间件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Flask-%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">使用 Flask 扩展</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%83%A8%E7%BD%B2%E5%88%B0%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">部署到网络服务器</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Back End/flask/DEPLOY","date":"2023-03-08T00:28:42.155Z","updated":"2022-04-03T15:56:18.000Z","comments":true,"path":"api/articles/Web Dev/Back End/flask/DEPLOY.json","keywords":null,"cover":null,"text":"How to Deploy Flask Application with Nginx and Gunicorn on Ubuntu 20.04 - RoseHosting ","link":"","photos":[],"count_time":{"symbolsCount":86,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Back End/flask/why we need microservices","date":"2023-03-08T00:28:42.150Z","updated":"2022-09-10T15:24:51.000Z","comments":true,"path":"api/articles/Web Dev/Back End/flask/why we need microservices.json","keywords":null,"cover":null,"text":"单体应用有很多显而易见的好处 项目起步简单， 易于部署 但是 项目通常都会增长，比最初计划的要大，最终演变成失控性增长 ","link":"","photos":[],"count_time":{"symbolsCount":64,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}