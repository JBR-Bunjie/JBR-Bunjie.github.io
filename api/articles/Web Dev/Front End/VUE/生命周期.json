{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Front End/VUE/生命周期","date":"2023-03-08T00:28:44.416Z","updated":"2021-10-30T12:55:15.000Z","comments":true,"path":"api/articles/Web Dev/Front End/VUE/生命周期.json","keywords":null,"cover":[],"content":"<p><img src=\"https://upload-images.jianshu.io/upload_images/11370083-f279314aef6741db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp\" alt=\"img\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11370083-ab96d006045028d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp\" alt=\"img\"></p>\n<h3 id=\"beforeCreate-创建前\"><a href=\"#beforeCreate-创建前\" class=\"headerlink\" title=\"beforeCreate( 创建前 )\"></a>beforeCreate( 创建前 )</h3><p>在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。</p>\n<h3 id=\"created-创建后-）\"><a href=\"#created-创建后-）\" class=\"headerlink\" title=\"created ( 创建后 ）\"></a>created ( 创建后 ）</h3><p>实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成</p>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><p>挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。</p>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><p>挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。</p>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><p>在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程</p>\n<h3 id=\"updated（更新后）\"><a href=\"#updated（更新后）\" class=\"headerlink\" title=\"updated（更新后）\"></a>updated（更新后）</h3><p>在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用</p>\n<h3 id=\"beforeDestroy（销毁前）\"><a href=\"#beforeDestroy（销毁前）\" class=\"headerlink\" title=\"beforeDestroy（销毁前）\"></a>beforeDestroy（销毁前）</h3><p>在实例销毁之前调用，实例仍然完全可用，</p>\n<p>这一步还可以用this来获取实例，<br>一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件</p>\n<h3 id=\"destroyed（销毁后）\"><a href=\"#destroyed（销毁后）\" class=\"headerlink\" title=\"destroyed（销毁后）\"></a>destroyed（销毁后）</h3><p>在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用</p>\n","text":" beforeCreate( 创建前 )在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。 created ( 创建后 ）实例已经创建完成之后被调...","link":"","photos":[],"count_time":{"symbolsCount":995,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#beforeCreate-%E5%88%9B%E5%BB%BA%E5%89%8D\"><span class=\"toc-text\">beforeCreate( 创建前 )</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#created-%E5%88%9B%E5%BB%BA%E5%90%8E-%EF%BC%89\"><span class=\"toc-text\">created ( 创建后 ）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#beforeMount\"><span class=\"toc-text\">beforeMount</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mounted\"><span class=\"toc-text\">mounted</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#beforeUpdate\"><span class=\"toc-text\">beforeUpdate</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#updated%EF%BC%88%E6%9B%B4%E6%96%B0%E5%90%8E%EF%BC%89\"><span class=\"toc-text\">updated（更新后）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#beforeDestroy%EF%BC%88%E9%94%80%E6%AF%81%E5%89%8D%EF%BC%89\"><span class=\"toc-text\">beforeDestroy（销毁前）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#destroyed%EF%BC%88%E9%94%80%E6%AF%81%E5%90%8E%EF%BC%89\"><span class=\"toc-text\">destroyed（销毁后）</span></a></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Front End/VUE/父子组件交互","date":"2023-03-08T00:28:44.418Z","updated":"2021-11-04T14:34:53.000Z","comments":true,"path":"api/articles/Web Dev/Front End/VUE/父子组件交互.json","keywords":null,"cover":[],"text":"vue父子组件之间的传值 本章主要说下父子组件的传值。 Github：https://github.com/Ewall1106/mall 父组件向子组件传值 第一个就是要明白怎么在父页面中向子组件中传值？你可以给子组件传入一个静态的值： 图片来自vue官网 但我们一般都是需要传动...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Web Dev/Front End/NPM/基本命令与配置","date":"2023-03-08T00:28:44.413Z","updated":"2023-03-07T15:26:51.000Z","comments":true,"path":"api/articles/Web Dev/Front End/NPM/基本命令与配置.json","keywords":null,"cover":null,"text":"NPM基本命令修改npm源设置npm下载来源为淘宝源 查看当前源npm config get registry 设置为淘宝源 npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org 临时使用源（适用于一次...","link":"","photos":[],"count_time":{"symbolsCount":982,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}