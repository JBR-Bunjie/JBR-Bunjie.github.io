{"title":"learningOpenGl Chapter 1.3","uid":"840d5a833aff18f2fbd4e2e8f83d93a6","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/02.Hello Window","date":"2023-03-08T02:21:08.000Z","updated":"2023-03-08T02:26:56.544Z","comments":true,"path":"api/articles/Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/02.Hello Window.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","content":"<h1 id=\"1-3-你好，窗口\"><a href=\"#1-3-你好，窗口\" class=\"headerlink\" title=\"1.3 你好，窗口\"></a>1.3 你好，窗口</h1><h2 id=\"1-3-1-引入库，并作基本初始化\"><a href=\"#1-3-1-引入库，并作基本初始化\" class=\"headerlink\" title=\"1.3.1 引入库，并作基本初始化\"></a>1.3.1 引入库，并作基本初始化</h2><p>Let’s see if we can get GLFW up and running. First, create a <code>.cpp</code> file and add the following includes to the top of your newly created file.</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;glad&#x2F;glad.h&gt;\n#include &lt;GLFW&#x2F;glfw3.h&gt;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>请确认在包含GLFW的头文件之前包含了GLEW的头文件。在包含glew.h头文件时会引入许多OpenGL必要的头文件（例如<code>GL/gl.h</code>），所以你需要在包含其它依赖于OpenGL的头文件之前先包含GLEW</p></blockquote>\n<p>Next, we create the main function where we will instantiate the GLFW window:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int main()\n&#123;\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    &#x2F;&#x2F;glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n  \n    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);\n    \n    return 0;\n&#125;</code></pre>\n\n<p>In the main function </p>\n<ul>\n<li><p>we first initialize GLFW with glfwInit, </p>\n</li>\n<li><p>after which we can configure GLFW using glfwWindowHint. </p>\n<ul>\n<li>The first argument of glfwWindowHint tells us what option we want to configure, where we can select the option from a large enum of possible options prefixed with <code>GLFW_</code>. </li>\n<li>The second argument is an integer that sets the value of our option. A list of all the possible options and its corresponding values can be found at <a href=\"http://www.glfw.org/docs/latest/window.html#window_hints\">GLFW’s window handling</a> documentation. </li>\n</ul>\n<p>If you try to run the application now and it gives a lot of <em>undefined reference</em> errors it means you didn’t successfully link the GLFW library.</p>\n</li>\n</ul>\n<p>Since the focus of this book is on OpenGL version 3.3 we’d like to tell GLFW that 3.3 is the OpenGL version we want to use. This way GLFW can make the proper arrangements when creating the OpenGL context. This ensures that when a user does not have the proper OpenGL version GLFW fails to run. We set the major and minor version both to <code>3</code>. We also tell GLFW we want to explicitly use the <strong>core-profile</strong>, 并且不允许用户调整窗口的大小。Telling GLFW we want to use the core-profile means we’ll get access to a smaller subset of OpenGL features without backwards-compatible features we no longer need.</p>\n<h2 id=\"1-3-2-创建窗口对象并设为进程的主要上下文\"><a href=\"#1-3-2-创建窗口对象并设为进程的主要上下文\" class=\"headerlink\" title=\"1.3.2 创建窗口对象并设为进程的主要上下文\"></a>1.3.2 创建窗口对象并设为进程的主要上下文</h2><p>接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, nullptr, nullptr);\nif (window &#x3D;&#x3D; nullptr)\n&#123;\n    std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;\n    glfwTerminate();\n    return -1;\n&#125;\nglfwMakeContextCurrent(window);</code></pre>\n\n<p>The <code>glfwCreateWindow</code> function requires </p>\n<ul>\n<li>the window width and height as its first two arguments respectively. </li>\n<li>The third argument allows us to create a name for the window; for now we call it <code>&quot;LearnOpenGL&quot;</code> but you’re allowed to name it however you like. </li>\n<li>We can ignore the last 2 parameters. </li>\n<li>The function returns a GLFWwindow object that we’ll later need for other GLFW operations. After that we tell GLFW to make the context of our window the main context on the current thread (<code>glfwMakeContextCurrent()</code>).</li>\n</ul>\n<h2 id=\"1-3-3-初始化GLEW\"><a href=\"#1-3-3-初始化GLEW\" class=\"headerlink\" title=\"1.3.3 初始化GLEW\"></a>1.3.3 初始化GLEW</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在之前的教程中已经提到过，GLEW是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLEW。</p></blockquote>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">glewExperimental &#x3D; GL_TRUE;\nif (glewInit() !&#x3D; GLEW_OK)\n&#123;\n    std::cout &lt;&lt; &quot;Failed to initialize GLEW&quot; &lt;&lt; std::endl;\n    return -1;\n&#125;</code></pre>\n\n<p>这样我们在后面就可以跳过对OpenGL的函数的查找过程快速调用了</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>请注意，我们在初始化GLEW之前设置glewExperimental变量的值为<code>GL_TRUE</code>，这样做能让GLEW在管理OpenGL的函数指针时更多地使用现代化的技术，如果把它设置为<code>GL_FALSE</code>的话可能会在使用OpenGL的核心模式时出现一些问题。</p></blockquote>\n<h2 id=\"1-3-4-设置视口-Viewport-？\"><a href=\"#1-3-4-设置视口-Viewport-？\" class=\"headerlink\" title=\"1.3.4 设置视口(Viewport)？\"></a>1.3.4 设置视口(Viewport)？</h2><p>你需要知道，在你已经创建好的窗口里，不是所有内容都是可以用来作画的，对于该window的实际可用来渲染的区域的大小，我们必须手动指定。</p>\n<p>注：视口的起点与窗口起点总是一致的。</p>\n<p>在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL<strong>渲染窗口的尺寸大小</strong>，这样OpenGL才只能知道怎样相对于窗口大小显示数据和坐标。我们可以通过调用glViewport函数来设置窗口的<strong>维度</strong>(Dimension)：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int width, height;\nglfwGetFramebufferSize(window, &amp;width, &amp;height);\n\nglViewport(0, 0, width, height);</code></pre>\n\n<p>glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素），这里我们是直接从GLFW中获取的。我们从GLFW中获取视口的维度而不设置为800*600是为了让它在高DPI的屏幕上（比如说Apple的视网膜显示屏）也能<a href=\"http://www.glfw.org/docs/latest/window.html#window_size\">正常工作</a>。</p>\n<p>我们实际上也可以将视口的维度设置为比GLFW的维度小，这样子之后所有的OpenGL渲染将会在一个更小的窗口中显示，这样子的话我们也可以将一些其它元素显示在OpenGL视口之外。</p>\n<h2 id=\"1-3-5-准备好你的引擎\"><a href=\"#1-3-5-准备好你的引擎\" class=\"headerlink\" title=\"1.3.5 准备好你的引擎\"></a>1.3.5 准备好你的引擎</h2><p>我们总是希望程序在明确地被关闭之前，能不断绘制图像并能够接受用户输入。因此我们需要一个while循环——让它在GLFW退出前一直保持运行，我们可以把它称之为游戏循环(Game Loop)。下面几行的代码就实现了一个简单的游戏循环：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">while(!glfwWindowShouldClose(window))\n&#123;\n    glfwPollEvents();\n    glfwSwapBuffers(window);\n&#125;</code></pre>\n\n<ul>\n<li>glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回<code>true</code>然后游戏循环便结束了，之后为我们就可以关闭应用程序了。</li>\n<li>glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等），然后调用对应的回调函数（可以通过回调方法手动设置）。我们一般在游戏循环的开始调用事件处理函数。</li>\n<li>glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</li>\n</ul>\n<h2 id=\"1-3-6-最后一件事\"><a href=\"#1-3-6-最后一件事\" class=\"headerlink\" title=\"1.3.6 最后一件事\"></a>1.3.6 最后一件事</h2><p>当游戏循环结束后我们需要正确释放/删除之前的分配的所有资源。我们可以在main函数的最后调用glfwTerminate函数来释放GLFW分配的内存。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">glfwTerminate();\nreturn 0;</code></pre>\n\n<p>这样便能清理所有的资源并正确地退出应用程序。这时运行这份代码，你可以看到一个黑窗口。</p>\n<h2 id=\"1-3-7-输入\"><a href=\"#1-3-7-输入\" class=\"headerlink\" title=\"1.3.7 输入\"></a>1.3.7 输入</h2><p>通过GLFW的回调函数(Callback Function)，我们可以实现一些用户控制。</p>\n<p>回调函数事实上是一个函数指针，当我们设置好后，GLWF会在合适的时候调用它。其中， <strong>按键回调</strong>(KeyCallback)是众多回调函数中的一种。当我们设置了按键回调之后，GLFW会在用户有键盘交互时调用它。该回调函数的原型如下所示：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);</code></pre>\n\n<p>按键回调函数接受</p>\n<ul>\n<li><p>一个<code>GLFWwindow</code>指针作为它的第一个参数；</p>\n</li>\n<li><p>第二个整形参数用来表示按下的按键；</p>\n</li>\n<li><p><code>action</code>参数表示这个按键是被按下还是释放；</p>\n</li>\n<li><p>最后一个整形参数表示是否有Ctrl、Shift、Alt、Super等按钮的操作。</p>\n</li>\n</ul>\n<p>GLFW会在合适的时候调用它，并为各个参数传入适当的值。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)\n&#123;\n    &#x2F;&#x2F; 当用户按下ESC键,我们设置window窗口的WindowShouldClose属性为true\n    &#x2F;&#x2F; 关闭应用程序\n    if(key &#x3D;&#x3D; GLFW_KEY_ESCAPE &amp;&amp; action &#x3D;&#x3D; GLFW_PRESS)\n        glfwSetWindowShouldClose(window, GL_TRUE);\n&#125;</code></pre>\n\n<p>在我们（新创建的）key_callback函数中，我们检测了键盘是否按下了Escape键。如果键的确按下了(不释放)，我们使用<code>glfwSetwindowShouldClose</code>函数设定<code>WindowShouldClose</code>属性为<code>true</code>从而关闭GLFW。main函数的<code>while</code>循环下一次的检测将为失败，程序就关闭了。</p>\n<p>最后一件事就是通过GLFW注册我们的函数至合适的回调，代码是这样的:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">glfwSetKeyCallback(window, key_callback);  </code></pre>\n\n<p>除了按键回调函数之外，我们还能我们自己的函数注册其它的回调。例如，我们可以注册一个回调函数来处理窗口尺寸变化、处理一些错误信息等。我们可以在创建窗口之后，开始游戏循环之前注册各种回调函数。</p>\n<h2 id=\"1-3-8-渲染\"><a href=\"#1-3-8-渲染\" class=\"headerlink\" title=\"1.3.8 渲染\"></a>1.3.8 渲染</h2><p>我们要把所有的渲染(Rendering)操作放到游戏循环中，因为我们想让这些渲染指令在每次游戏循环迭代的时候都能被执行。代码将会是这样的：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 程序循环\nwhile(!glfwWindowShouldClose(window))\n&#123;\n    &#x2F;&#x2F; 检查事件\n    glfwPollEvents();\n\n    &#x2F;&#x2F; 渲染指令\n    ...\n\n    &#x2F;&#x2F; 交换缓冲\n    glfwSwapBuffers(window);\n&#125;</code></pre>\n\n<p>为了测试一切都正常工作，我们使用一个自定义的颜色清空屏幕。在每个新的渲染迭代开始的时候我们总是希望清屏，否则我们仍能看见上一次迭代的渲染结果（这可能是你想要的效果，但通常这不是）。我们可以通过调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\nglClear(GL_COLOR_BUFFER_BIT);</code></pre>\n\n<p>注意，除了glClear之外，我们还调用了<strong>glClearColor来设置清空屏幕所用的颜色</strong>。当调用glClear函数，<strong>清除颜色缓冲之后，整个颜色缓冲都会被填充为glClearColor里所设置的颜色</strong>。在这里，我们将屏幕设置为了类似黑板的深蓝绿色。</p>\n<h2 id=\"附录：完整代码：\"><a href=\"#附录：完整代码：\" class=\"headerlink\" title=\"附录：完整代码：\"></a>附录：完整代码：</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;iostream&gt;\n\n&#x2F;&#x2F; GLEW\n#define GLEW_STATIC\n#include &lt;GL&#x2F;glew.h&gt;\n\n&#x2F;&#x2F; GLFW\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\n\n&#x2F;&#x2F; Function prototypes\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);\n\n&#x2F;&#x2F; Window dimensions\nconst GLuint WIDTH &#x3D; 800, HEIGHT &#x3D; 600;\n\n&#x2F;&#x2F; The MAIN function, from here we start the application and run the game loop\nint main()\n&#123;\n    std::cout &lt;&lt; &quot;Starting GLFW context, OpenGL 3.3&quot; &lt;&lt; std::endl;\n    &#x2F;&#x2F; Init GLFW\n    glfwInit();\n    &#x2F;&#x2F; Set all the required options for GLFW\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);\n\n    &#x2F;&#x2F; Create a GLFWwindow object that we can use for GLFW&#39;s functions\n    GLFWwindow* window &#x3D; glfwCreateWindow(WIDTH, HEIGHT, &quot;LearnOpenGL&quot;, nullptr, nullptr);    \n    if (window &#x3D;&#x3D; nullptr)\n    &#123;\n        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;\n        glfwTerminate();\n        return -1;\n    &#125;\n    glfwMakeContextCurrent(window);\n    &#x2F;&#x2F; Set the required callback functions\n    glfwSetKeyCallback(window, key_callback);\n\n    &#x2F;&#x2F; Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions\n    glewExperimental &#x3D; GL_TRUE;\n    &#x2F;&#x2F; Initialize GLEW to setup the OpenGL Function pointers\n    if (glewInit() !&#x3D; GLEW_OK)\n    &#123;\n        std::cout &lt;&lt; &quot;Failed to initialize GLEW&quot; &lt;&lt; std::endl;\n        return -1;\n    &#125;    \n\n    &#x2F;&#x2F; Define the viewport dimensions\n    int width, height;\n    glfwGetFramebufferSize(window, &amp;width, &amp;height);  \n    glViewport(0, 0, width, height);\n\n    &#x2F;&#x2F; Game loop\n    while (!glfwWindowShouldClose(window))\n    &#123;\n        &#x2F;&#x2F; Check if any events have been activiated (key pressed, mouse moved etc.) and call corresponding response functions\n        glfwPollEvents();\n\n        &#x2F;&#x2F; Render\n        &#x2F;&#x2F; Clear the colorbuffer\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        &#x2F;&#x2F; Swap the screen buffers\n        glfwSwapBuffers(window);\n    &#125;\n\n    &#x2F;&#x2F; Terminate GLFW, clearing any resources allocated by GLFW.\n    glfwTerminate();\n    return 0;\n&#125;\n\n&#x2F;&#x2F; Is called whenever a key is pressed&#x2F;released via GLFW\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)\n&#123;\n    std::cout &lt;&lt; key &lt;&lt; std::endl;\n    if (key &#x3D;&#x3D; GLFW_KEY_ESCAPE &amp;&amp; action &#x3D;&#x3D; GLFW_PRESS)\n        glfwSetWindowShouldClose(window, GL_TRUE);\n&#125;</code></pre>\n\n","text":"1.3 你好，窗口1.3.1 引入库，并作基本初始化Let’s see if we can get GLFW up and running. First, create a .cpp file and add the following includes to the top o...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"TA","slug":"TA","count":14,"path":"api/categories/TA.json"}],"tags":[{"name":"Opengl","slug":"Opengl","count":14,"path":"api/tags/Opengl.json"},{"name":"Shader","slug":"Shader","count":14,"path":"api/tags/Shader.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-3-%E4%BD%A0%E5%A5%BD%EF%BC%8C%E7%AA%97%E5%8F%A3\"><span class=\"toc-text\">1.3 你好，窗口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-1-%E5%BC%95%E5%85%A5%E5%BA%93%EF%BC%8C%E5%B9%B6%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">1.3.1 引入库，并作基本初始化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-2-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%AE%BE%E4%B8%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">1.3.2 创建窗口对象并设为进程的主要上下文</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-3-%E5%88%9D%E5%A7%8B%E5%8C%96GLEW\"><span class=\"toc-text\">1.3.3 初始化GLEW</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-4-%E8%AE%BE%E7%BD%AE%E8%A7%86%E5%8F%A3-Viewport-%EF%BC%9F\"><span class=\"toc-text\">1.3.4 设置视口(Viewport)？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-5-%E5%87%86%E5%A4%87%E5%A5%BD%E4%BD%A0%E7%9A%84%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">1.3.5 准备好你的引擎</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-6-%E6%9C%80%E5%90%8E%E4%B8%80%E4%BB%B6%E4%BA%8B\"><span class=\"toc-text\">1.3.6 最后一件事</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-7-%E8%BE%93%E5%85%A5\"><span class=\"toc-text\">1.3.7 输入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-8-%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">1.3.8 渲染</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%BD%95%EF%BC%9A%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span class=\"toc-text\">附录：完整代码：</span></a></li></ol></li></ol>","author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}},"mapped":true,"prev_post":{"title":"learningOpenGl Chapter 1.1","uid":"84a91876a3b2e3a40cf47c0b0209858c","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/00.OpenGL","date":"2023-03-08T02:21:08.000Z","updated":"2023-03-08T02:26:34.929Z","comments":true,"path":"api/articles/Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/00.OpenGL.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"当你使用多个捕获组时，请务必小心NULL！这是某个捕获组未能捕获任何内容的结果！ 验证：是否有bug 在线正则表达式测试 中文 (oschina.net) 在线正则验证 英文 regex101: build, test, and debug regex 在线验证正则表达式结构：R...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"TA","slug":"TA","count":14,"path":"api/categories/TA.json"}],"tags":[{"name":"Opengl","slug":"Opengl","count":14,"path":"api/tags/Opengl.json"},{"name":"Shader","slug":"Shader","count":14,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}},"next_post":{"title":"learningOpenGl Chapter 1.2","uid":"fc711215d7019d15e7fa23ec8cb6e4d7","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/01.CreateAWindow","date":"2023-03-08T02:21:08.000Z","updated":"2023-03-08T02:26:48.320Z","comments":true,"path":"api/articles/Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/01.CreateAWindow.json","keywords":null,"cover":"https://raw.githubusercontent.com/JBR-Bunjie/JBR-Bunjie/main/back.jpg","text":"1.2 Creating A Window The first thing we need to do before we start creating stunning graphics is to create an OpenGL context and an applica...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"TA","slug":"TA","count":14,"path":"api/categories/TA.json"}],"tags":[{"name":"Opengl","slug":"Opengl","count":14,"path":"api/tags/Opengl.json"},{"name":"Shader","slug":"Shader","count":14,"path":"api/tags/Shader.json"}],"author":{"name":"JBR_Bunjie","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/90251718?v=4","link":"/","description":"仿生程序员会在光环上遇见AI乐正绫吗？","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/415377461"},"github":{"icon":"/svg/social_github.svg","link":"https://github.com/JBR-Bunjie"}}}}}}