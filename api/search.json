[{"id":"fa3249ce619228ad8d74e7a819afc946","title":"Regex","content":"Regex正则运用当你使用多个捕获组时，请务必小心NULL！这是某个捕获组未能捕获任何内容的结果！\n验证：是否有bug\n在线正则表达式测试 中文 (oschina.net)\n在线正则验证 英文 regex101: build, test, and debug regex\n在线验证正则表达式结构：Regexper\nregex_match - C++ Reference (cplusplus.com)\n第 6 章 正则表达式 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly (changkun.de)\nc++ 正则表达式 高性能 - Bing\nc++ locale - Bing\n（为什么Fuck Locale）\n[‐\\-a-zA-Z0-9\\.]+\n\n正则提速\n让匹配更快失败，尤其是匹配很长的字符串时，匹配失败的位置要比成功的位置多得多。\n\n以简单、必须的字元开始，排除明显不匹配的位置，如锚点(^或$)，特殊字符(x或\\u263A)字符类([a-z]或\\d之类的速记符)，和单词边界(\\b)；尽量避免使用分组、选择、重复量词开头，如/one|two/、\\s、\\s{1,}等。\n\n使用量词模式时，尽量让重复部分具体化，让字元互斥，如用”[^”\\r\\n]”代替”.?”（这个依赖回溯）。\n\n减少分支数量、缩小分支范围，用字符集和选项组件来减少分支的出现，或把分支在正则上出现的位置推后，把分支中最常出现的情况放在分支的最前面。\ncat|bat -&gt; [cb]at;red|read -&gt; rea?d;red|raw -&gt; r(?:ed|aw); \n\n(.|\\r|\\n) -&gt; [\\s\\S]\n精确匹配需要的文本以减少后续的处理，如果需要引用匹配的一部分，可使用捕获，然后通过反向引用来处理。\n\n暴露必需的字元，用/^(ab|cd)/而不是/(^ab|^cd)/。\n\n使用合适的量词，基于预期的回溯数量，使用合适的量词类型。\n\n把正则表达式赋值给变量以便复用和提升提升性能，这样可以让正则减少不必要的编译过程。while (/regex1/.test(str1)) {/regex2/.exec(str2);…}用下面的代替上面的   var regex1 = /regex1/,regex2 = /regex2/;while (regex1.test(str1)) {regex2.exec(str2);…}\n\n将复杂的正则表达式拆分成简单的片段，每个正则只在上一个成功的匹配中查找，更高效，而且可以减少回溯。\n\n使用非捕获组，因为捕获组需要消耗时间和内存来记录反向引用，并不断更新，如果不需要反向引用，可用非捕获组(?:…)代替捕获组(…)；当需要全文匹配的反向引用时，可用regex.exec()返回的结果或者在替换字符串是使用$&amp;。   此优化在firefox中效果较小，但其他浏览器中处理长字符串时有较大影响\n\n\nAnd More？\n觉得正则表达式太慢？这里有一个提速100倍的方案！ - 知乎 (zhihu.com)\n项目地址\nvi3k6i5/flashtext: Extract Keywords from sentence or Replace keywords in sentences. (github.com)\n","slug":"Algorithm/String Processing/Regex","date":"2023-03-08T02:22:54.000Z","categories_index":"Algorithm","tags_index":"String Processing,Regex","author_index":"JBR_Bunjie"},{"id":"d309579445aab8e475b1a200f76bbffc","title":"learningOpenGl 0","content":"OpenGL学习记录这份笔记对应的教程来自网站：LearnOpenGL-CN，是Learn OpenGL, extensive tutorial resource for learning Modern OpenGL的早期译文\n同时辅以视频教程：\n\n[傅老師/OpenGL教學 第一章] OpenGL自製3D遊戲引擎 (已更畢)_哔哩哔哩_bilibili\n[傅老師/OpenGL教學 第二章][10/16晚間更新] OpenGL自製3D遊戲引擎_哔哩哔哩_bilibili\n[傅老師/OpenGL教學 第三章] [01/08晚間更新] OpenGL自製3D遊戲引擎(已更畢)_哔哩哔哩_bilibili\n\n当然，现在是21/12/2022，就现在而言，这份教程已经有些老了。\n该仓库已经停止维护，并且对应的英文站点已经更新了更多额外的内容，对于这些内容，有做一定的穿插。\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/ReadMe","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"84a91876a3b2e3a40cf47c0b0209858c","title":"learningOpenGl Chapter 1.1","content":"当你使用多个捕获组时，请务必小心NULL！这是某个捕获组未能捕获任何内容的结果！\n验证：是否有bug\n在线正则表达式测试 中文 (oschina.net)\n在线正则验证 英文 regex101: build, test, and debug regex\n在线验证正则表达式结构：Regexper\nregex_match - C++ Reference (cplusplus.com)\n第 6 章 正则表达式 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly (changkun.de)\nc++ 正则表达式 高性能 - Bing\nc++ locale - Bing\n（为什么Fuck Locale）\n[‐-a-zA-Z0-9.]+\n1.1 Getting Started - OpenGL1.1.1 OpenGL\n\n\n\n\n\n\n\n\n\n什么是opengl？\n\n是一个API(Application Programming Interface, 应用程序编程接口)\n包含了一系列可以操作图形、图像的函数\n然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范。也就是说，OpenGL并非是一个“唯一的”框架，它在不同系统、平台、设备上都可能有不同的表现——因为OpenGL规范并没有规定实现的细节。具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配。OpenGL规范只规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定。\n\n\n\n\n\n\n\n\n\n实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。\nSince most implementations are built by graphics card manufacturers, whenever there is a bug in the implementation this is usually solved by updating your video card drivers; those drivers include the newest versions of OpenGL that your card supports. This is one of the reasons why it’s always advised to occasionally update your graphic drivers.\nKhronos publicly hosts all specification documents for all the OpenGL versions. The interested reader can find the OpenGL specification of version 3.3 (which is what we’ll be using) here which is a good read if you want to delve into the details of OpenGL (note how they mostly just describe results and not implementations). The specifications also provide a great reference for finding the exact workings of its functions.\n\n\n\n\n\n\n\n\n\n\n有点c之于编译器的意思\n编程时主要按c标准编写，厂商提供编译器，等到实际在执行的时候，再考虑“实际内容”（如1.1.3 拓展）\n\n1.1.2 Core-profile vs Immediate mode\n\n\n\n\n\n\n\n\n核心模式与立即渲染模式\n\nImmediate mode - 固定管线 - 早期\nCore-profile - 可编程管线 - 现代 - 灵活、高效、\n\n\n\n\n\n\n\n\n\n\n注意兼容性：\nWhen using functionality from the most recent version of OpenGL, only the most modern graphics cards will be able to run your application. This is often why most developers generally target lower versions of OpenGL and optionally enable higher version functionality.\n1.1.3 ExtensionsOpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。\nThe developer has to query whether any of these extensions are available before using them (or use an OpenGL extension library). This allows the developer to do things better or more efficient, based on whether an extension is available:\nif(GL_ARB_extension_name) &#123;\n    &#x2F;&#x2F; Do cool new and modern stuff supported by hardware\n&#125; else &#123;\n    &#x2F;&#x2F; Extension not supported: do it the old way\n&#125;\n\n1.1.4 State machineOpenGL自身是一个巨大的状态机：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。\nWhenever we tell OpenGL that we now want to draw lines instead of triangles for example, we change the state of OpenGL by changing some context variable that sets how OpenGL should draw. As soon as we change the context by telling OpenGL it should draw lines, the next drawing commands will now draw lines instead of triangles.\nWhen working in OpenGL we will come across several state-changing functions that change the context and several state-using functions that perform some operations based on the current state of OpenGL. As long as you keep in mind that OpenGL is basically one large state machine, most of its functionality will make more sense.\n1.1.5 ObjectsOpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。\nAn object in OpenGL is a collection of options that represents a subset of OpenGL’s state. \nFor example, we could have an object that represents the settings of the drawing window; we could then\n\nset its size, \nhow many colors it supports \nand so on. \n\nOne could visualize an object as a C-like struct:\nstruct object_name &#123;\n    float  option1;\n    int    option2;\n    char[] name;\n&#125;;\n\n\n\n\n\n\n\n\n\n\n基元类型(Primitive Type)\n使用OpenGL时，建议使用OpenGL定义的基元类型。比如使用float时我们加上前缀GL（因此写作GLfloat）。int、uint、char、bool等等也类似。OpenGL定义的这些GL基元类型的内存布局是与平台无关的，而int等基元类型在不同操作系统上可能有不同的内存布局。使用GL基元类型可以保证你的程序在不同的平台上工作一致。\n1.1.6 使用OpenGL的大致方法当我们使用一个对象时，通常看起来像如下一样（把OpenGL上下文看作一个大的结构体）：\n&#x2F;&#x2F; OpenGL的状态\nstruct OpenGL_Context \n&#123;\n    ...\n    object* object_Window_Target;\n    ...     \n&#125;;\n\n&#x2F;&#x2F; 创建对象\nGLuint objectId &#x3D; 0;\nglGenObject(1, &amp;objectId);\n&#x2F;&#x2F; 绑定对象至上下文\nglBindObject(GL_WINDOW_TARGET, objectId);\n&#x2F;&#x2F; 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项\nglSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);\nglSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);\n&#x2F;&#x2F; 将上下文对象设回默认\nglBindObject(GL_WINDOW_TARGET, 0);\n\n这一小段代码展现了你以后使用OpenGL时常见的工作流。\n\n我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。\n然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。\n接下来我们设置窗口的选项。\n最后我们将目标位置的对象id设回0，解绑这个对象。\n\n设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。\n\n\n\n\n\n\n\n\n\n使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。\n1.1.7 epilogue - 尾声\n\n\n\n\n\n\n\n\n让我们开始吧你现在已经知道一些OpenGL的相关知识了，OpenGL规范和库，OpenGL幕后大致的运作流程，以及OpenGL使用的一些传统技巧。不要担心你还没有完全消化它们，后面的教程我们会仔细地讲解每一个步骤，你会通过足够的例子来真正掌握OpenGL。如果你已经做好了开始下一步的准备，我们可以在[这里](https://learnopengl-cn.readthedocs.io/zh/latest/01 Getting started/02 Creating a window/)开始创建OpenGL上下文以及我们的第一个窗口了。\n附加资源\nopengl.org：OpenGL官方网站。\nOpenGL registry：包含OpenGL各版本的规范和扩展。\n\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/00.OpenGL","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"840d5a833aff18f2fbd4e2e8f83d93a6","title":"learningOpenGl Chapter 1.3","content":"1.3 你好，窗口1.3.1 引入库，并作基本初始化Let’s see if we can get GLFW up and running. First, create a .cpp file and add the following includes to the top of your newly created file.\n#include &lt;glad&#x2F;glad.h&gt;\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\n\n\n\n\n\n\n\n\n\n请确认在包含GLFW的头文件之前包含了GLEW的头文件。在包含glew.h头文件时会引入许多OpenGL必要的头文件（例如GL/gl.h），所以你需要在包含其它依赖于OpenGL的头文件之前先包含GLEW\nNext, we create the main function where we will instantiate the GLFW window:\nint main()\n&#123;\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    &#x2F;&#x2F;glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n  \n    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);\n    \n    return 0;\n&#125;\n\nIn the main function \n\nwe first initialize GLFW with glfwInit, \n\nafter which we can configure GLFW using glfwWindowHint. \n\nThe first argument of glfwWindowHint tells us what option we want to configure, where we can select the option from a large enum of possible options prefixed with GLFW_. \nThe second argument is an integer that sets the value of our option. A list of all the possible options and its corresponding values can be found at GLFW’s window handling documentation. \n\nIf you try to run the application now and it gives a lot of undefined reference errors it means you didn’t successfully link the GLFW library.\n\n\nSince the focus of this book is on OpenGL version 3.3 we’d like to tell GLFW that 3.3 is the OpenGL version we want to use. This way GLFW can make the proper arrangements when creating the OpenGL context. This ensures that when a user does not have the proper OpenGL version GLFW fails to run. We set the major and minor version both to 3. We also tell GLFW we want to explicitly use the core-profile, 并且不允许用户调整窗口的大小。Telling GLFW we want to use the core-profile means we’ll get access to a smaller subset of OpenGL features without backwards-compatible features we no longer need.\n1.3.2 创建窗口对象并设为进程的主要上下文接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到。\nGLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, nullptr, nullptr);\nif (window &#x3D;&#x3D; nullptr)\n&#123;\n    std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;\n    glfwTerminate();\n    return -1;\n&#125;\nglfwMakeContextCurrent(window);\n\nThe glfwCreateWindow function requires \n\nthe window width and height as its first two arguments respectively. \nThe third argument allows us to create a name for the window; for now we call it &quot;LearnOpenGL&quot; but you’re allowed to name it however you like. \nWe can ignore the last 2 parameters. \nThe function returns a GLFWwindow object that we’ll later need for other GLFW operations. After that we tell GLFW to make the context of our window the main context on the current thread (glfwMakeContextCurrent()).\n\n1.3.3 初始化GLEW\n\n\n\n\n\n\n\n\n在之前的教程中已经提到过，GLEW是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLEW。\nglewExperimental &#x3D; GL_TRUE;\nif (glewInit() !&#x3D; GLEW_OK)\n&#123;\n    std::cout &lt;&lt; &quot;Failed to initialize GLEW&quot; &lt;&lt; std::endl;\n    return -1;\n&#125;\n\n这样我们在后面就可以跳过对OpenGL的函数的查找过程快速调用了\n\n\n\n\n\n\n\n\n\n请注意，我们在初始化GLEW之前设置glewExperimental变量的值为GL_TRUE，这样做能让GLEW在管理OpenGL的函数指针时更多地使用现代化的技术，如果把它设置为GL_FALSE的话可能会在使用OpenGL的核心模式时出现一些问题。\n1.3.4 设置视口(Viewport)？你需要知道，在你已经创建好的窗口里，不是所有内容都是可以用来作画的，对于该window的实际可用来渲染的区域的大小，我们必须手动指定。\n注：视口的起点与窗口起点总是一致的。\n在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL渲染窗口的尺寸大小，这样OpenGL才只能知道怎样相对于窗口大小显示数据和坐标。我们可以通过调用glViewport函数来设置窗口的维度(Dimension)：\nint width, height;\nglfwGetFramebufferSize(window, &amp;width, &amp;height);\n\nglViewport(0, 0, width, height);\n\nglViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素），这里我们是直接从GLFW中获取的。我们从GLFW中获取视口的维度而不设置为800*600是为了让它在高DPI的屏幕上（比如说Apple的视网膜显示屏）也能正常工作。\n我们实际上也可以将视口的维度设置为比GLFW的维度小，这样子之后所有的OpenGL渲染将会在一个更小的窗口中显示，这样子的话我们也可以将一些其它元素显示在OpenGL视口之外。\n1.3.5 准备好你的引擎我们总是希望程序在明确地被关闭之前，能不断绘制图像并能够接受用户输入。因此我们需要一个while循环——让它在GLFW退出前一直保持运行，我们可以把它称之为游戏循环(Game Loop)。下面几行的代码就实现了一个简单的游戏循环：\nwhile(!glfwWindowShouldClose(window))\n&#123;\n    glfwPollEvents();\n    glfwSwapBuffers(window);\n&#125;\n\n\nglfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后游戏循环便结束了，之后为我们就可以关闭应用程序了。\nglfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等），然后调用对应的回调函数（可以通过回调方法手动设置）。我们一般在游戏循环的开始调用事件处理函数。\nglfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。\n\n1.3.6 最后一件事当游戏循环结束后我们需要正确释放/删除之前的分配的所有资源。我们可以在main函数的最后调用glfwTerminate函数来释放GLFW分配的内存。\nglfwTerminate();\nreturn 0;\n\n这样便能清理所有的资源并正确地退出应用程序。这时运行这份代码，你可以看到一个黑窗口。\n1.3.7 输入通过GLFW的回调函数(Callback Function)，我们可以实现一些用户控制。\n回调函数事实上是一个函数指针，当我们设置好后，GLWF会在合适的时候调用它。其中， 按键回调(KeyCallback)是众多回调函数中的一种。当我们设置了按键回调之后，GLFW会在用户有键盘交互时调用它。该回调函数的原型如下所示：\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);\n\n按键回调函数接受\n\n一个GLFWwindow指针作为它的第一个参数；\n\n第二个整形参数用来表示按下的按键；\n\naction参数表示这个按键是被按下还是释放；\n\n最后一个整形参数表示是否有Ctrl、Shift、Alt、Super等按钮的操作。\n\n\nGLFW会在合适的时候调用它，并为各个参数传入适当的值。\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)\n&#123;\n    &#x2F;&#x2F; 当用户按下ESC键,我们设置window窗口的WindowShouldClose属性为true\n    &#x2F;&#x2F; 关闭应用程序\n    if(key &#x3D;&#x3D; GLFW_KEY_ESCAPE &amp;&amp; action &#x3D;&#x3D; GLFW_PRESS)\n        glfwSetWindowShouldClose(window, GL_TRUE);\n&#125;\n\n在我们（新创建的）key_callback函数中，我们检测了键盘是否按下了Escape键。如果键的确按下了(不释放)，我们使用glfwSetwindowShouldClose函数设定WindowShouldClose属性为true从而关闭GLFW。main函数的while循环下一次的检测将为失败，程序就关闭了。\n最后一件事就是通过GLFW注册我们的函数至合适的回调，代码是这样的:\nglfwSetKeyCallback(window, key_callback);  \n\n除了按键回调函数之外，我们还能我们自己的函数注册其它的回调。例如，我们可以注册一个回调函数来处理窗口尺寸变化、处理一些错误信息等。我们可以在创建窗口之后，开始游戏循环之前注册各种回调函数。\n1.3.8 渲染我们要把所有的渲染(Rendering)操作放到游戏循环中，因为我们想让这些渲染指令在每次游戏循环迭代的时候都能被执行。代码将会是这样的：\n&#x2F;&#x2F; 程序循环\nwhile(!glfwWindowShouldClose(window))\n&#123;\n    &#x2F;&#x2F; 检查事件\n    glfwPollEvents();\n\n    &#x2F;&#x2F; 渲染指令\n    ...\n\n    &#x2F;&#x2F; 交换缓冲\n    glfwSwapBuffers(window);\n&#125;\n\n为了测试一切都正常工作，我们使用一个自定义的颜色清空屏幕。在每个新的渲染迭代开始的时候我们总是希望清屏，否则我们仍能看见上一次迭代的渲染结果（这可能是你想要的效果，但通常这不是）。我们可以通过调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。\nglClearColor(0.2f, 0.3f, 0.3f, 1.0f);\nglClear(GL_COLOR_BUFFER_BIT);\n\n注意，除了glClear之外，我们还调用了glClearColor来设置清空屏幕所用的颜色。当调用glClear函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为glClearColor里所设置的颜色。在这里，我们将屏幕设置为了类似黑板的深蓝绿色。\n附录：完整代码：#include &lt;iostream&gt;\n\n&#x2F;&#x2F; GLEW\n#define GLEW_STATIC\n#include &lt;GL&#x2F;glew.h&gt;\n\n&#x2F;&#x2F; GLFW\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\n\n&#x2F;&#x2F; Function prototypes\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);\n\n&#x2F;&#x2F; Window dimensions\nconst GLuint WIDTH &#x3D; 800, HEIGHT &#x3D; 600;\n\n&#x2F;&#x2F; The MAIN function, from here we start the application and run the game loop\nint main()\n&#123;\n    std::cout &lt;&lt; &quot;Starting GLFW context, OpenGL 3.3&quot; &lt;&lt; std::endl;\n    &#x2F;&#x2F; Init GLFW\n    glfwInit();\n    &#x2F;&#x2F; Set all the required options for GLFW\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);\n\n    &#x2F;&#x2F; Create a GLFWwindow object that we can use for GLFW&#39;s functions\n    GLFWwindow* window &#x3D; glfwCreateWindow(WIDTH, HEIGHT, &quot;LearnOpenGL&quot;, nullptr, nullptr);    \n    if (window &#x3D;&#x3D; nullptr)\n    &#123;\n        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;\n        glfwTerminate();\n        return -1;\n    &#125;\n    glfwMakeContextCurrent(window);\n    &#x2F;&#x2F; Set the required callback functions\n    glfwSetKeyCallback(window, key_callback);\n\n    &#x2F;&#x2F; Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions\n    glewExperimental &#x3D; GL_TRUE;\n    &#x2F;&#x2F; Initialize GLEW to setup the OpenGL Function pointers\n    if (glewInit() !&#x3D; GLEW_OK)\n    &#123;\n        std::cout &lt;&lt; &quot;Failed to initialize GLEW&quot; &lt;&lt; std::endl;\n        return -1;\n    &#125;    \n\n    &#x2F;&#x2F; Define the viewport dimensions\n    int width, height;\n    glfwGetFramebufferSize(window, &amp;width, &amp;height);  \n    glViewport(0, 0, width, height);\n\n    &#x2F;&#x2F; Game loop\n    while (!glfwWindowShouldClose(window))\n    &#123;\n        &#x2F;&#x2F; Check if any events have been activiated (key pressed, mouse moved etc.) and call corresponding response functions\n        glfwPollEvents();\n\n        &#x2F;&#x2F; Render\n        &#x2F;&#x2F; Clear the colorbuffer\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        &#x2F;&#x2F; Swap the screen buffers\n        glfwSwapBuffers(window);\n    &#125;\n\n    &#x2F;&#x2F; Terminate GLFW, clearing any resources allocated by GLFW.\n    glfwTerminate();\n    return 0;\n&#125;\n\n&#x2F;&#x2F; Is called whenever a key is pressed&#x2F;released via GLFW\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)\n&#123;\n    std::cout &lt;&lt; key &lt;&lt; std::endl;\n    if (key &#x3D;&#x3D; GLFW_KEY_ESCAPE &amp;&amp; action &#x3D;&#x3D; GLFW_PRESS)\n        glfwSetWindowShouldClose(window, GL_TRUE);\n&#125;\n\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/02.Hello Window","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"fc711215d7019d15e7fa23ec8cb6e4d7","title":"learningOpenGl Chapter 1.2","content":"1.2 Creating A Window\n\n\n\n\n\n\n\n\nThe first thing we need to do before we start creating stunning graphics is to create an OpenGL context and an application window to draw in. However, those operations are specific per operating system and OpenGL purposefully tries to abstract itself from these operations. This means we have to create a window, define a context, and handle user input all by ourselves.\nLuckily, there are quite a few libraries out there that provide the functionality we seek, some specifically aimed at OpenGL. Those libraries save us all the operation-system specific work and give us a window and an OpenGL context to render in. Some of the more popular libraries are GLUT, SDL, SFML and GLFW. On LearnOpenGL we will be using GLFW. Feel free to use any of the other libraries, the setup for most is similar to GLFW’s setup.\n在我们画出出色的效果之前，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象(Abstract)出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。\n幸运的是，有一些库已经提供了我们所需的功能，其中一部分是特别针对OpenGL的。这些库节省了我们书写操作系统相关代码的时间，提供给我们一个窗口和上下文用来渲染。最流行的几个库有GLUT，SDL，SFML和GLFW。在教程里我们将使用GLFW。\n1.2.1 Using GLFW\n\n\n\n\n\n\n\n\nGLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。\n\n\n\n\n\n\n\n\n\n配置教程可以参考傅老师视频\n1.2.2 Using GLEW到这里，我们仍然有一件事要做。因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上会是类似这样：\n&#x2F;&#x2F; 定义函数原型\ntypedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);\n&#x2F;&#x2F; 找到正确的函数并赋值给函数指针\nGL_GENBUFFERS glGenBuffers  &#x3D; (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);\n&#x2F;&#x2F; 现在函数可以被正常调用了\nGLuint buffer;\nglGenBuffers(1, &amp;buffer);\n\n你可以看到代码非常复杂，而且很繁琐，我们需要对每个可能使用的函数都要重复这个过程。幸运的是，有些库能简化此过程，其中GLEW是目前最新，也是最流行的库。\n编译和链接GLEWGLEW是OpenGL Extension Wrangler Library的缩写，它能解决我们上面提到的那个繁琐的问题。因为GLEW也是一个库，我们同样需要构建并将其链接进工程。GLEW可以从这里下载，你同样可以选择下载二进制版本，如果你的目标平台列在上面的话，或者下载源码编译，步骤和编译GLFW时差不多。记住，如果不确定的话，选择32位的二进制版本。\n我们使用GLEW的静态版本glew32s.lib（注意这里的“s”），将库文件添加到你的库目录，将include内容添加到你的include目录。接下来，在VS的链接器选项里加上glew32s.lib。注意GLFW3（默认）也是编译成了一个静态库。\n\n\n\n\n\n\n\n\n\n静态(Static)链接是指编译时就将库代码里的内容整合进你的二进制文件。优点就是你不需要管理额外的文件了，只需要发布你单独的一个二进制文件就行了。缺点就是你的可执行文件会变得更大，另外当库有升级版本时，你必须重新进行编译整个程序。\n动态(Dynamic)链接是指一个库通过.dll或.so的方式存在，它的代码与你的二进制文件的代码是分离的。优点是使你的二进制文件大小变小并且更容易升级，缺点是你最终发布程序时必须带上这些DLL。\n\n\n\n\n\n\n\n\n\n如果你希望静态链接GLEW，必须在包含GLEW头文件之前定义预处理器宏GLEW_STATIC：\n&gt;#define GLEW_STATIC\n&gt;#include &lt;GL&#x2F;glew.h&gt;\n\n如果你希望动态链接，那么你可以省略这个宏。但是记住使用动态链接的话你需要拷贝一份.DLL文件到你的应用程序目录。\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/01.CreateAWindow","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"4fc32846a71333fda5c166e6a4c0c980","title":"learningOpenGl Chapter 1.4","content":"1.4 绘制三角形\n\n\n\n\n\n\n\n\n在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。\n\n\n\n\n\n\n\n\n\n3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。\n图形渲染管线可以被划分为两个主要部分：\n\n第一部分把你的3D坐标转换为2D坐标；\n第二部分是把2D坐标转变为实际的有颜色的像素。\n\n这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。\n\n\n\n\n\n\n\n\n\n\n注意：2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。\n\n1.4.1 浅谈图形渲染管线\n图形渲染管线接受一组3D坐标，然后把它们转变为屏幕上的有色2D像素输出。\n图形渲染管线可以分为多个阶段，每个阶段的输出都会用作下个阶段的输入\n管线的各个阶段很容易并行执行——这样能充分发挥GPU的效能。不同阶段有着不同的功能，这也意味着每个阶段所执行的程序都不同，这种在GPU的渲染管线上运行的程序即为Shader。\n并非是所有Shader都是可以配置的：\nVertex Shader\nTessellation Shader\nGeometry Shader\nFragment Shader\n\n\n\n1.4.2 实现基本的管线1.4.2.0 在管线处理之前\n\n\n\n\n\n\n\n\n标准化设备坐标\n在开始执行依次图形渲染管线之前，我们需要先向程序灌入可用的顶点\nGLfloat vertices[] &#x3D; &#123;\n    -0.5f, -0.5f, 0.0f,\n     0.5f, -0.5f, 0.0f,\n     0.0f,  0.5f, 0.0f\n&#125;;\n\n这样的顶点数据会被直接发送给我们渲染管线的第一个阶段：Vertex Shader——它会在GPU上创建内存用于储存我们的顶点数据。当然我们还需要还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。\n1.4.2.1 数据类型1.4.2.1.1 VBO创建VBO: Vertex Buffer Objects, VBO, 顶点缓冲对象\n我们利用VBO来存储我们发送到GPU的大量顶点。\n\n顶点从CPU发送到GPU相对较慢，所以我们应该一次性且大量地将顶点数据从CPU传送到GPU上\nVS可以很快速地访问显存中的顶点数据\n\n与OpenGL中的其它对象一样，VBO对象也有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个ID组合一个VBO对象：\nGLuint VBO[1]; &#x2F;&#x2F;这个缓冲有一个独一无二的ID\nglGenBuffers(1, VBO);  &#x2F;&#x2F;在对应位置上生成缓冲\nglBindBuffer(GL_ARRAY_BUFFER, VBO[0]); &#x2F;&#x2F;给缓冲指定类型\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#x2F;&#x2F;把已定义的顶点数据复制到VBO中\n\nOpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。\n我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标(上下文)上。之后我们使用的任何在GL_ARRAY_BUFFER上的缓冲调用都会用来配置当前绑定的VBO。\n然后我们就可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。\n\n它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。\n\n第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。\n\n第三个参数是我们希望发送的实际数据。\n\n第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：\n\nGL_STATIC_DRAW ：数据不会或几乎不会改变。\n\nGL_DYNAMIC_DRAW：数据会被改变很多。\n\nGL_STREAM_DRAW ：数据每次绘制时都会改变。\n\n\n三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。\n\n\n1.4.2.1.2 VBO调用顶点数据以VBO形式加载完成时，它是这样子的：\n\n\n位置数据被储存为32-bit（4字节）浮点值: 每个分量如 point1的x坐标：float类型，4Byte = 32bit;\n每个位置包含3个这样的值: 1个point共3个坐标值\n在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列: 见数组，我们写下point1的坐标后立即跟上的是point2而不是point1的其他如颜色等信息\n数据中第一个值在缓冲开始的位置: 也就是没有偏移量。\n\n根据以上信息：我们便可以着手解析VBO数据以供OpenGL使用了\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);\nglEnableVertexAttribArray(0); &#x2F;&#x2F; 启用这个顶点属性\n\nglVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们：\n\n第一个参数指定我们要配置的顶点属性，这关系着我们将要在具体哪里(哪个顶点属性上)存储这份数据。这关系到我们在VS里调用该数据时所用的数据位置即layout位置：layout(location = 0)即代表该数据的顶点属性的位置值为0。\n第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。\n第三个参数指定数据类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。\n下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。\n第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个GLfloat之后，我们把步长设置为3 * sieof(GLfloat)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子(译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节)。\n最后一个参数的类型是GLvoid*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。\n\n\n\n\n\n\n\n\n\n\n现在我们已经定义了OpenGL该如何解释顶点数据，并启用了对应的顶点属性（顶点属性默认是禁用的）。\n自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。在OpenGL中绘制一个物体，代码会像是这样：\n&gt;&#x2F;&#x2F; 0. 复制顶点数组到缓冲中供OpenGL使用\n&gt;glBindBuffer(GL_ARRAY_BUFFER, VBO);\n&gt;glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n&gt;&#x2F;&#x2F; 1. 设置顶点属性指针\n&gt;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);\n&gt;glEnableVertexAttribArray(0);\n&gt;&#x2F;&#x2F; 2. 当我们渲染一个物体时要使用着色器程序\n&gt;glUseProgram(shaderProgram);\n&gt;&#x2F;&#x2F; 3. 绘制物体\n&gt;someOpenGLFunctionThatDrawsOurTriangle();\n\n每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？\n1.4.2.1.3 VAO\n\n\n\n\n\n\n\n\n顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中\n\nOpenGL的核心模式要求我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。\n\n一个顶点数组对象会储存以下这些内容：\n\nglEnableVertexAttribArray和glDisableVertexAttribArray的调用。\n通过glVertexAttribPointer调用设置的顶点属性配置。\n通过glVertexAttribPointer调用进行的顶点缓冲对象与顶点属性链接。\n\n\n创建一个VAO和创建一个VBO很类似：\nGLuint VAO; &#x2F;&#x2F; ID\nglGenVertexArrays(1, &amp;VAO); &#x2F;&#x2F; 对象  \n\n要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：\n&#x2F;&#x2F; ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..\n&#x2F;&#x2F; 1. 绑定VAO\nglBindVertexArray(VAO);\n    &#x2F;&#x2F; 2. 把顶点数组复制到缓冲中供OpenGL使用\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n    &#x2F;&#x2F; 3. 设置顶点属性指针\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);\n    glEnableVertexAttribArray(0);\n&#x2F;&#x2F;4. 解绑VAO\nglBindVertexArray(0);\n\n[...]\n\n&#x2F;&#x2F; ..:: 绘制代（游戏循环中） :: ..\n&#x2F;&#x2F; 5. 绘制物体\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nsomeOpenGLFunctionThatDrawsOurTriangle();\nglBindVertexArray(0);\n\n1.4.2.1.4 EBO在渲染顶点这一话题上我们还有最有一个需要讨论的东西——索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：\nGLfloat vertices[] &#x3D; &#123;\n    &#x2F;&#x2F; 第一个三角形\n    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角\n    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角\n    -0.5f, 0.5f, 0.0f,  &#x2F;&#x2F; 左上角\n    &#x2F;&#x2F; 第二个三角形\n    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角\n    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角\n    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角\n&#125;;\n\n可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？\n很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（独一无二的）顶点，和绘制出矩形所需的索引：\nGLfloat vertices[] &#x3D; &#123;\n    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角\n    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角\n    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角\n    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角\n&#125;;\n\nGLuint indices[] &#x3D; &#123; &#x2F;&#x2F; 注意索引从0开始! \n    0, 1, 3, &#x2F;&#x2F; 第一个三角形\n    1, 2, 3  &#x2F;&#x2F; 第二个三角形\n&#125;;\n\n你可以看到，当时用索引的时候，我们只定义了4个顶点，而不是6个。下一步我们需要创建索引缓冲对象：\n&#x2F;&#x2F; almost as same as VBO; notice third and forth lines that use different_缓冲目标: GL_ELEMENT_ARRAY_BUFFER\nGLuint EBO; \nglGenBuffers(1, &amp;EBO);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); \n\n最后，用glDrawElements函数绘图：\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\n\n\n第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。\n第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。\n第三个参数是索引的类型，这里是GL_UNSIGNED_INT。\n最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。\n\nglDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。\n\n最后的初始化和绘制代码现在看起来像这样：\n&#x2F;&#x2F; ..:: 初始化代码 :: ..\n&#x2F;&#x2F; 1. 绑定顶点数组对象\nglBindVertexArray(VAO);\n    &#x2F;&#x2F; 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n    &#x2F;&#x2F; 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n    &#x2F;&#x2F; 3. 设定顶点属性指针\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);\n    glEnableVertexAttribArray(0);\n&#x2F;&#x2F; 4. 解绑VAO（不是EBO！）\nglBindVertexArray(0);\n\n[...]\n\n&#x2F;&#x2F; ..:: 绘制代码（游戏循环中） :: ..\n\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\nglBindVertexArray(0);\n\n1.4.2.2 Vertex Shader1.4.2.2.1 编写VS#version 330 core &#x2F;&#x2F;版本信息声明，每个着色器都起始于一个版本声明\n\nlayout (location &#x3D; 0) in vec3 position; \n&#x2F;&#x2F;这里有两个要点\n&#x2F;&#x2F; 1* layout 关键字：指定了输入变量所在的“位置”\n&#x2F;&#x2F; 2* in 关键字 ：这声明了这是一个从app阶段传入的属性\n\t&#x2F;&#x2F;我们应在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)，这里我们先只使用position\n\nvoid main()&#123; &#x2F;&#x2F; shader程序主函数\n    gl_Position &#x3D; vec4(position.x, position.y, position.z, 1.0);\n    &#x2F;&#x2F;将3维的position转为了一个4维向量以用于矩阵变换\n    \n    &#x2F;&#x2F; 我们并没有利用out关键字定义gl_Position就可以直接使用的原因是：这是一个predefined variable\n&#125;\n\n1.4.2.2.2 编译VS为了在我们的opengl程序中使用这个VS，我们需要在main.c内读取这个VS并且编译执行它：\nGLuint vertexShader; &#x2F;&#x2F;仍然优先创建ID\nvertexShader &#x3D; glCreateShader(GL_VERTEX_SHADER); &#x2F;&#x2F;在ID上创建一个Shader“对象”。由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER。\nglShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); &#x2F;&#x2F; “转移代码”，“转存”\n&#x2F;&#x2F; 保存着色器源码的着色器对象作为第一个参数；Specifies the handle of the shader object whose source code is to be replaced\n&#x2F;&#x2F; 第二参数指定了传递的源码字符串数量，这里只有一个\n&#x2F;&#x2F; 第三个参数是顶点着色器真正的源码; Specifies an array of pointers to strings containing the source code to be loaded into the shader\n&#x2F;&#x2F; 第四个参数我们先设置为NULL\n\nglCompileShader(vertexShader); &#x2F;&#x2F; 最终编译\n\n1.4.2.2.3 检验编译成果\n\n\n\n\n\n\n\n\n你可能会希望检测在调用glCompileShader后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：\n&gt;GLint success;\n&gt;GLchar infoLog[512];\n&gt;glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);\n\n首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用glGetShaderiv检查是否编译成功。如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。\n&gt;if(!success)\n&gt;&#123;\n   glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);\n   std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;\n&gt;&#125;\n\n如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。\n1.4.2.3 Fragment Shader\n\n\n\n\n\n\n\n\n片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器全是关于计算你的像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。\n\n在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！\n\n#version 330 core &#x2F;&#x2F; same as VS\n\nout vec4 color; &#x2F;&#x2F; out，表示输出用向量；vec4，vec4类型\n\nvoid main()\n&#123;\n    color &#x3D; vec4(1.0f, 0.5f, 0.2f, 1.0f); &#x2F;&#x2F; 写死颜色；RGBA\n&#125;\n\n编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型：\nGLuint fragmentShader; &#x2F;&#x2F; ID\nfragmentShader &#x3D; glCreateShader(GL_FRAGMENT_SHADER); &#x2F;&#x2F; 对象\nglShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, null); &#x2F;&#x2F; 转存\nglCompileShader(fragmentShader); &#x2F;&#x2F; 编译\n\n1.4.2.4 着色器对象与连接着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。\n当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。\n创建一个程序对象流程如下：\nGLuint shaderProgram; &#x2F;&#x2F; ID\nshaderProgram &#x3D; glCreateProgram(); &#x2F;&#x2F; 对象\nglAttachShader(shaderProgram, vertexShader); &#x2F;&#x2F; 装载VS；\nglAttachShader(shaderProgram, fragmentShader); &#x2F;&#x2F; 装载FS\nglLinkProgram(shaderProgram); &#x2F;&#x2F; 使用glLinkProgram来连接这个program对象，这会对已装载的shader做一些处理并解锁一些功能\n\n此时程序对象创建完毕，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：\nglUseProgram(shaderProgram);\n\n在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。\n\n\n\n\n\n\n\n\n\n对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：\n&gt;glDeleteShader(vertexShader);\n&gt;glDeleteShader(fragmentShader);\n现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。\n1.4.2.5 完成绘制要想绘制我们想要的物体，OpenGL给我们提供了glDrawArrays函数，它使用当前激活的着色器，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawArrays(GL_TRIANGLES, 0, 3);\nglBindVertexArray(0);  \n\n\nglDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。\n第二个参数指定了顶点数组的起始索引，我们这里填0。\n最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。\n\n完整的程序源码可以在这里找到。\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/03.Hello Triangle","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"eb947faf7dc84fa49cb79bdd22ec183a","title":"learningOpenGl Chapter 1.5","content":"1.5 Shaders\n\n\n\n\n\n\n\n\n着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。\n从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。\n1.5.1 GLSLOpenGL中的Shader是用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。\n着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。一个典型的着色器有下面的结构：\n#version version_number\n\nin type in_variable_name;\nin type in_variable_name;\n\nout type out_variable_name;\n\nuniform type uniform_name;\n\nint main()\n&#123;\n  &#x2F;&#x2F; 处理输入并进行一些图形操作\n  ...\n  &#x2F;&#x2F; 输出处理过的结果到输出变量\n  out_variable_name &#x3D; weird_stuff_we_processed;\n&#125;\n\n特别的，当我们特别谈论到顶点着色器的时候，每个输入变量也叫顶点属性(Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限：\nGLint nrAttributes;\nglGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);\nstd::cout &lt;&lt; &quot;Maximum nr of vertex attributes supported: &quot; &lt;&lt; nrAttributes &lt;&lt; std::endl;\n\n通常情况下它至少会返回16个，大部分情况下是够用了。\n1.5.2 数据类型GLSL有数据类型可以来指定变量的种类。\nGLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。\nGLSL也有两种特殊的但是容器类型，分别是向量(Vector)和矩阵(Matrix)\n1.5.2.1 向量容器\n\n\n\n\n\n\n\n\n向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。\n1.5.2.1.1 向量容器的存在形式\n\n\n\n\n\n\n\n\nGLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。\n在GLSL中，向量容器中可以容纳的基本内容可以是：\n\n\n\n类型\n含义\n\n\n\nvecn\n包含n个float分量的默认向量\n\n\nbvecn\n包含n个bool分量的向量\n\n\nivecn\n包含n个int分量的向量\n\n\nuvecn\n包含n个unsigned int分量的向量\n\n\ndvecn\n包含n个double分量的向量\n\n\n1.5.2.1.2 向量容器内容获取以vec4类型的向量”test”为例，想要获取其中的各个分量，可以使用：\ntest.x; test.y; test.z; test.w （位置坐标）\n这种分量的获取方式，完全等同于 rgba（颜色值） 与 stpq（纹理坐标），但是为了维护程序良好的可读性，请务必根据具体数据类型选择分量的获取方式\n1.5.2.1.3 Swizzling: 向量容器内容的“重组”向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法：\nvec2 someVec;\nvec4 differentVec &#x3D; someVec.xyxx;\nvec3 anotherVec &#x3D; differentVec.zyw;\nvec4 otherVec &#x3D; someVec.xxxx + anotherVec.yxzy;\n\n你可以使用上面4个字母任意组合来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，你不允许在一个vec2向量中去获取.z元素。我们也可以把一个向量作为一个参数传给不同的向量构造函数，以减少需求参数的数量：\nvec2 vect &#x3D; vec2(0.5f, 0.7f);\nvec4 result &#x3D; vec4(vect, 0.0f, 0.0f);\nvec4 otherResult &#x3D; vec4(result.xyz, 1.0f);\n\n1.5.2.2 矩阵1.5.3 数据输入与输出\n\n\n\n\n\n\n\n\n虽然Shader是各自独立的小程序，但是它们都是渲染管线上的一小部分，出于这样的原因，我们希望每个Shader都有输入和输出，这样才能进行数据交流和传递。GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。\n顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，layout (location = 0)。顶点着色器需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据。\n\n\n\n\n\n\n\n\n\nVertex Shader - OpenGL Wiki (khronos.org)\nFragment Shader - OpenGL Wiki (khronos.org)\nopengl - How does the fragment shader know what variable to use for the color of a pixel? - Stack Overflow\n如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。\n示例如下：\n&#x2F;&#x2F; 顶点着色器\n#version 330 core\nlayout (location &#x3D; 0) in vec3 position; &#x2F;&#x2F; position变量的属性位置值为0\nout vec4 vertexColor; &#x2F;&#x2F; 为片段着色器指定一个颜色输出\nvoid main() &#123;\n    gl_Position &#x3D; vec4(position, 1.0); &#x2F;&#x2F; 注意我们如何把一个vec3作为vec4的构造器的参数\n    vertexColor &#x3D; vec4(0.5f, 0.0f, 0.0f, 1.0f); &#x2F;&#x2F; 把输出变量设置为暗红色\n&#125;\n\n&#x2F;&#x2F; 片段着色器\n#version 330 core\nin vec4 vertexColor; &#x2F;&#x2F; 从顶点着色器传来的输入变量（名称相同、类型相同）\nout vec4 color; &#x2F;&#x2F; 片段着色器输出的变量名可以任意命名，但类型必须是vec4\nvoid main() &#123;\n    color &#x3D; vertexColor;\n&#125;\n\n1.5.4 Uniform\n\n\n\n\n\n\n\n\nUniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)，这意味着它可以被着色器程序的任意着色器在任意阶段访问。在完成一次设置（赋值）后，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。\n我们可以在一个着色器中添加uniform关键字至类型和变量名前来声明一个GLSL的uniform。\n示例如下：我在片段着色器中声明一个uniform vec4的变量，并把片段着色器的输出颜色设置为该变量的值。\n#version 330 core\nout vec4 color;\n\nuniform vec4 ourColor; &#x2F;&#x2F; 在OpenGL程序代码中设定这个变量\n\nvoid main() &#123;\n    color &#x3D; ourColor;\n&#125;  \n\n由于uniform变量是全局变量，因此我们可以在任何shader中定义它们，而无需像1.5.3那样用in out作为中介来传递到目标Shader中。因此，既然顶点着色器中不需要这个uniform，那我们便不在那里定义它。\n:warning:如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量\n而在shader中写下的ourColor，只是一个声明/定义，这个uniform现在还是空的，我们还没有给它添加任何数据。还记得吗：“Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式”，也就是说，Uniform的具体定义及实现应该在CPU也就是main.c里完成而不是Shader中\n我们可以这样：\n...(game loop); &#x2F;&#x2F; 做底色等等\n\nGLint vertexColorLocation &#x3D; glGetUniformLocation(shaderProgram, &quot;ourColor&quot;); &#x2F;&#x2F; 在CPU阶段，查找对应Uniform定义\n&#x2F;&#x2F; 拿到该Uniform变量后，我们就可以对其进行处理。\n\nGLfloat timeValue &#x3D; glfwGetTime(); &#x2F;&#x2F; 获取时间\nGLfloat greenValue &#x3D; (sin(timeValue) &#x2F; 2) + 0.5; &#x2F;&#x2F; 对时间求sin，结果在(-1, 1)，值在(0, 1)波动\n\nglUseProgram(shaderProgram); &#x2F;&#x2F; 先激活着色器(Use)，再更新Uniform\nglUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n\n...(draw&amp;call); &#x2F;&#x2F; draw call在这之后\n\n1.5.5 解决更多属性\n\n\n\n\n\n\n\n\n如有必要，请重新回看1.4部分\n在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：\nGLfloat vertices[] &#x3D; &#123;\n    &#x2F;&#x2F; 位置              &#x2F;&#x2F; 颜色\n     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   &#x2F;&#x2F; 右下\n    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   &#x2F;&#x2F; 左下\n     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    &#x2F;&#x2F; 顶部\n&#125;;\n\n根据我们的数据，我们需要做的修改如下：\n\nVS，接收新的Color信息\nFS，接受该Color信息\nmain.c，对该数据进行解析，配置VAO指针等\n\n特别注意，glVertexAttribPointer函数有两处修改：\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));\n&#x2F;&#x2F; 1. 修改了步长\n&#x2F;&#x2F; 2. 修改了偏移量，注意偏移量的具体格式与计算思路（对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以偏移量就是3 * sizeof(GLfloat)，用字节来计算就是12字节）\n\n这个图片可能不是你所期望的”只有3个颜色”(因为我们只提供了3个颜色)，这是一个大调色板——这是在片段着色器中进行的所谓片段插值(Fragment Interpolation)的结果。\n\n\n\n\n\n\n\n\n\n当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。基于这些位置，它会插值(Interpolate)所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是30%蓝 + 70%绿。\n这正是在这个三角形中发生了什么。我们有3个顶点，和相应的3个颜色，从这个三角形的像素来看它可能包含50000左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。\n1.5.6 我们自己的着色器类\n\n\n\n\n\n\n\n\n编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。\n我们会把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。我们先来添加必要的include，并定义类结构：\n&gt;#ifndef SHADER_H\n&gt;#define SHADER_H\n\n&gt;#include &lt;string&gt;\n&gt;#include &lt;fstream&gt;\n&gt;#include &lt;sstream&gt;\n&gt;#include &lt;iostream&gt;\n\n&gt;#include &lt;GL&#x2F;glew.h&gt;; &#x2F;&#x2F; 包含glew来获取所有的必须OpenGL头文件\n\n&gt;class Shader\n&gt;&#123;\n&gt;public:\n   &#x2F;&#x2F; 程序ID\n   GLuint Program;\n   &#x2F;&#x2F; 构造器读取并构建着色器\n   Shader(const GLchar* vertexPath, const GLchar* fragmentPath);\n   &#x2F;&#x2F; 使用程序\n   void Use();\n&gt;&#125;;\n\n&gt;#endif\n\n:warning:在上面，我们在头文件顶部使用了几个预处理指令(Preprocessor Directives)。这些预处理指令会告知你的编译器只在它没被包含过的情况下才包含和编译这个头文件，即使多个文件都包含了这个着色器头文件。它是用来防止链接冲突的。\n着色器类储存了着色器程序的ID。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。我们还添加了一个Use函数，它其实不那么重要，但是能够显示这个自造类如何让我们的生活变得轻松（虽然只有一点）。\n从文件读取我们使用C++文件流读取着色器内容，储存到几个string对象里：\n&gt;Shader(const GLchar* vertexPath, const GLchar* fragmentPath)\n&gt;&#123;\n   &#x2F;&#x2F; 1. 从文件路径中获取顶点&#x2F;片段着色器\n   std::string vertexCode;\n   std::string fragmentCode;\n   std::ifstream vShaderFile;\n   std::ifstream fShaderFile;\n   &#x2F;&#x2F; 保证ifstream对象可以抛出异常：\n   vShaderFile.exceptions(std::ifstream::badbit);\n   fShaderFile.exceptions(std::ifstream::badbit);\n   try \n   &#123;\n       &#x2F;&#x2F; 打开文件\n       vShaderFile.open(vertexPath);\n       fShaderFile.open(fragmentPath);\n       std::stringstream vShaderStream, fShaderStream;\n       &#x2F;&#x2F; 读取文件的缓冲内容到流中\n       vShaderStream &lt;&lt; vShaderFile.rdbuf();\n       fShaderStream &lt;&lt; fShaderFile.rdbuf();       \n       &#x2F;&#x2F; 关闭文件\n       vShaderFile.close();\n       fShaderFile.close();\n       &#x2F;&#x2F; 转换流至GLchar数组\n       vertexCode &#x3D; vShaderStream.str();\n       fragmentCode &#x3D; fShaderStream.str();     \n   &#125;\n   catch(std::ifstream::failure e)\n   &#123;\n       std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot; &lt;&lt; std::endl;\n   &#125;\n   const GLchar* vShaderCode &#x3D; vertexCode.c_str();\n   const GLchar* fShaderCode &#x3D; fragmentCode.c_str();\n   [...]\n\n下一步，我们需要编译和链接着色器。注意，我们也将检查编译/链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）：\n&gt;&#x2F;&#x2F; 2. 编译着色器\n&gt;GLuint vertex, fragment;\n&gt;GLint success;\n&gt;GLchar infoLog[512];\n\n&gt;&#x2F;&#x2F; 顶点着色器\n&gt;vertex &#x3D; glCreateShader(GL_VERTEX_SHADER);\n&gt;glShaderSource(vertex, 1, &amp;vShaderCode, NULL);\n&gt;glCompileShader(vertex);\n&gt;&#x2F;&#x2F; 打印编译错误（如果有的话）\n&gt;glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success);\n&gt;if(!success)\n&gt;&#123;\n   glGetShaderInfoLog(vertex, 512, NULL, infoLog);\n   std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;\n&gt;&#125;;\n\n&gt;&#x2F;&#x2F; 片段着色器也类似\n&gt;[...]\n\n&gt;&#x2F;&#x2F; 着色器程序\n&gt;this-&gt;Program &#x3D; glCreateProgram();\n&gt;glAttachShader(this-&gt;Program, vertex);\n&gt;glAttachShader(this-&gt;Program, fragment);\n&gt;glLinkProgram(this-&gt;Program);\n&gt;&#x2F;&#x2F; 打印连接错误（如果有的话）\n&gt;glGetProgramiv(this-&gt;Program, GL_LINK_STATUS, &amp;success);\n&gt;if(!success)\n&gt;&#123;\n   glGetProgramInfoLog(this-&gt;Program, 512, NULL, infoLog);\n   std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;\n&gt;&#125;\n\n&gt;&#x2F;&#x2F; 删除着色器，它们已经链接到我们的程序中了，已经不再需要了\n&gt;glDeleteShader(vertex);\n&gt;glDeleteShader(fragment);\n\n最后我们也会实现Use函数：\n&gt;void Use()\n&gt;&#123;\n   glUseProgram(this-&gt;Program);\n&gt;&#125;\n\n现在我们就写完了一个完整的着色器类。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了：\n&gt;Shader ourShader(&quot;path&#x2F;to&#x2F;shaders&#x2F;shader.vs&quot;, &quot;path&#x2F;to&#x2F;shaders&#x2F;shader.frag&quot;);\n&gt;...\n&gt;while(...)\n&gt;&#123;\n   ourShader.Use();\n   glUniform1f(glGetUniformLocation(ourShader.Program, &quot;someUniform&quot;), 1.0f);\n   DrawStuff();\n&gt;&#125;\n\n我们把顶点和片段着色器储存为两个叫做shader.vs和shader.frag的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用.vs和.frag作为扩展名很直观。\n源码：使用新着色器类的程序，着色器类，顶点着色器，和片段着色器。\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/04Shaders","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"09d4101db265eb203c19a059d113fd7c","title":"learningOpenGl Chapter 1.8","content":"Coordinate Systemscategories请主要注意这中间的MVP变换与最后的视口变换\n\n&#x2F;&#x2F; final tranformation looks like:\nlayout (location &#x3D; 0) in vec3 Position;\n...\ngl_Position &#x3D; Project * View * Model * Move * Rotate * Translate * vec4(Position, 1.0f);\n\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/07Coordinate Systems","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"a30ae670e7580d885c145007ff8514b4","title":"learningOpenGl Chapter 2.1","content":"Define a rule如果我要使用向量A(1.0, 0.8, 0.6)来乘以B(0.8, 0.6, 0.4)，我定义：$$vector A = &lt;1.0, 0.8, 0.6&gt;\\vector B = &lt;0.8, 0.6, 0.4&gt;\\\\A * B = &lt;1.0 * 0.8, 0.8 * 0.6, 0.6 * 0.4&gt; = &lt;0.8, 0.48, 0.24&gt;$$这与点积的区别在于：该运算的结果是向量，而点积的结果是一个具体数据。\n利用这个关系，我们可以计算光照关系：$$RealTimeColor = RealColor * AmbientColor$$\nWhat we need to do in this section在本节中，我们要实现一个光照场景来为后续步骤提供便利。这会用到我们定义的规则。\n此时，我们需要做的包括：\n\n制作一个light source(LS)\n制作一个object(OB)\n\n此时，为了方便以后的更多操作，我们需要区别LS和OB的Shader：\n分别为LS和OB搭起一套Shader程序，依次调用他们的shader.use并且投入相应的数据，最终确保：\n\nColor of LS hardly change\nColor of OB will changed because of our rules\n\nFinally, we can get a pic like:\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/02Lighting/00.Colors","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"e4e32fc3ec80a57afe53517f515d2f2d","title":"learningOpenGl Chapter 2.2","content":"Phong lighting model裴祥风提出的标准光照模型背后的理念。\n\n\n\n\n\n\n\n\n\n把进入到摄像机内的光线分为4个部分：\n\nemissive - 自发光部分，用于描述当给定一个方向时，一个表面本身回向该方向发射多少辐射量。\nspecular - 高光反射部分，用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量\ndiffuse - 漫反射部分，用于描述当光线从光环照射到模型表面时，该表面会向每个方向散射多少辐射量\nambient - 环境光部分，用于描述其他所有的间接光照\n\n\n\n值得注意的是，如果没有使用全局光照(global illumination)的话，自发光的表面并不会真的照亮周围物体，只是它本身看起来更亮了而已\n着色逐顶点光照 - Gouraud Shading - 高洛德着色逐片元着色 - Phong Shading - 冯氏着色兰伯特番外 1：Global Light - 全局光照《Real-Time Rendering 3rd》 提炼总结 第九章 全局光照:光线追踪、路径追踪与GI技术进化编年史 - 毛星云的文章 - 知乎 https://zhuanlan.zhihu.com/p/29418992\n番外 2：Fresnel - 菲涅尔效应现象表述：当视线垂直于表面时，反射较弱，而当视线与表面呈一定夹角时，夹角越小，反射就越明显。\n\n\n\n\n\n\n\n\n\n\n\n同一个地方的湖面，在不同的位置去观察它，总能看到它在不同位置所呈现的效果是不一样的，近处看可以看到清澈见底的湖水，远处看却是波光粼粼的湖面。\n应用菲涅尔反射是什么？ - BurningMountion的回答 - 知乎 https://www.zhihu.com/question/53022233/answer/399310332\nShader实验室:菲涅尔效应 - Shader实验室的文章 - 知乎 https://zhuanlan.zhihu.com/p/151375798\n【Blender教程】刻晴丝袜效果案例_哔哩哔哩_bilibili\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/02Lighting/01.Basic Lighting","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"77ec7ccacfb72fa4bd2436c5873c81ff","title":"learningOpenGl Chapter 2.3","content":"一个场景中，我们可能同时使用多个物体，而这些物体对光的特性各不相同——我们需要建立“材质”属性，统一地管理物体的三种光照关系\n构建思路：我们利用struct来管理物体的对应情况下的“颜色“来代替笼统的”objectColor“\nstruct Material&#123;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n&#125;\nuniform Material material;\n\n\n\n\n\n\n\n\n\n\n我们为每个冯氏光照模型的元素都定义一个颜色向量。\n\nambient材质向量定义了在环境光照下这个物体反射的是什么颜色；通常这是和物体颜色相同的颜色。\ndiffuse材质向量定义了在漫反射光照下物体的颜色。漫反射颜色被设置为(和环境光照一样)我们需要的物体颜色。\nspecular材质向量设置的是物体受到的镜面光照的影响的颜色(或者可能是反射一个物体特定的镜面高光颜色)。\nshininess则影响镜面高光的散射/半径。\n\n这四个元素定义了一个物体的材质，通过它们我们能够模拟很多真实世界的材质。\n定义了物体本身的材质的同时，我们还有一件事情要做：定义光源对物体材质的各个内容上的强度——光源对环境、漫反射和镜面元素，应该同时具有不同的强度：\n这样，我们还需要一个struct来管理光线强度，这样我们就可以在不改变物体材质(物体的真实颜色)的条件下，通过改变光源的颜色去改变物体各个元素的强度，来产生很多的效果\nstruct Light\n&#123;\n    vec3 position;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n&#125;;\nuniform Light light;\n\n\n\n\n\n\n\n\n\n\n一个光源的ambient、diffuse和specular光都有不同的亮度。\n\n环境光通常设置为一个比较低的亮度，因为我们不希望环境色太过显眼。\n光源的diffuse元素通常设置为我们希望光所具有的颜色；经常是一个明亮的白色。\nspecular元素通常被设置为vec3(1.0f)类型的全强度发光。\n要记住的是我们同样把光的位置添加到结构体中。\n\n参考：http://devernay.free.fr/cours/opengl/materials.html\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/02Lighting/02.Materials","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"ad9f08ec3444afaa1c2eddcf989f6462","title":"learningOpenGl Chapter 2.4","content":"使用：“光照贴图”\nProblem 4:\n\n\n\n\n\n\n\n\nAlso add something they call an emission map which is a texture that stores emission values per fragment. Emission values are colors an object may emit as if it contains a light source itself; this way an object can glow regardless of the light conditions. Emission maps are often what you see when objects in a game glow (like eyes of a robot, or light strips on a container). Add the following texture (by creativesam) as an emission map onto the container as if the letters emit light: solution; result:\n\n重点：Matrix贴图并没有出现在铁边上！也就是说，这并不是直接读入并应用一个贴图那么简单。\n为了实现这点，我们需要做“判断”。但是！在glsl中使用分支会直接导致极低的运行效率，而且if语句在早期GPU上是不受支持的——我们应当尽量避免使用if语句，此处我们将这个if语句变成了三个step和一次计算：\nvec3 emission &#x3D; texture(material.emission, Texcoord).rgb * diff * max(light.diffuse, vec3(0.7f));\nfloat temp &#x3D; step(spec_tex.r, 0.0f);  &#x2F;&#x2F; if spec_tex.r &gt; 0.0f, then return 0 else 1\ntemp &#x3D; min(step(spec_tex.g, 0.0f), temp);\ntemp &#x3D; min(step(spec_tex.b, 0.0f), temp); &#x2F;&#x2F; temp &#x3D;&#x3D; 0: spec_tex is not black; 1: black;\n\n&#x2F;&#x2F; we complete the problem four without using if sentence.\nemission &#x3D; emission * temp;\n\nstep - OpenGL 4 Reference Pages (khronos.org)\nOpenGL shader性能优化策略（一）：减少分支语句 - 腾讯云开发者社区-腾讯云 (tencent.com)\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/02Lighting/03.Lighting maps","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"38c975c13d700e0f4a358527ea875949","title":"learningOpenGl Chapter 2.5","content":"Light Casters - 投光物\n\n\n\n\n\n\n\n\nAll the lighting we’ve used so far came from a single source that is a single point in space. It gives good results, but in the real world we have several types of light that each act different. A light source that casts light upon objects is called a light caster. In this chapter we’ll discuss several different types of light casters. Learning to simulate different light sources is yet another tool in your toolbox to further enrich your environments.\nWe’ll first discuss a directional light, then a point light which is an extension of what we had before, and lastly we’ll discuss spotlights. In the next chapter we’ll combine several of these different light types into one scene.\nDirectional Light\n\n\n\n\n\n\n\n\n示例：太阳光\n光源的作用效果只受光源摆放角度的影响，摆放的具体位置一般不会对Directional Light造成影响\n\n\n\n\n\n\n\n\n\n只有一个点的Directional Light和Point Light的区别：\nPoint Light的效果会随着距离而衰减，但Directional Light不会，这也是它们效果不同的直接成因\nPoint Lights\n\n\n\n\n\n\n\n\n示例：无罩电灯泡\n光源的作用效果同时受摆放的角度和位置的影响\nAttenuationChoosing the right valuesImplementing attenuationSpotlight\n\n\n\n\n\n\n\n\n示例：舞台聚光灯\n光源的作用效果同时受摆放的角度和位置的影响\nFlashlightSmooth/Soft edges","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/02Lighting/04.Light casters","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"59e0ee426fc499572e79ecdf9cee6601","title":"learningOpenGl Chapter 1.6","content":"1.6 Texture1.6.1 纹理坐标与纹理的应用1.6.1.1 定义纹理坐标\n\n\n\n\n\n\n\n\n我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。\n艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（不过也有1D&amp;3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。\n现在我们利用纹理，给三角形贴上一张砖墙图片。\n\n为了能够把纹理映射(Map)到该三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。\n纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。\n\n我们为三角形指定了3个纹理坐标点。如上图所示：\n\n我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；\n三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；\n同理右下方的顶点设置为(1, 0)。\n\n我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。\n纹理坐标看起来就像这样：\nGLfloat texCoords[] &#x3D; &#123;\n    0.0f, 0.0f, &#x2F;&#x2F; 左下角\n    1.0f, 0.0f, &#x2F;&#x2F; 右下角\n    0.5f, 1.0f &#x2F;&#x2F; 上中\n&#125;;\n\n1.6.1.2 使用纹理类似于Shader程序，使用纹理之前我们应该先把它们加载到我们的（main.c CPU部分）应用中。\n纹理图像可能被储存为各种各样的格式，每种都有自己特别的数据结构和排列，为了方便地将图像加载到应用中，一个可行的解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。这里又会涉及到很多问题，比如文件格式的选择甚至设计，图像加载器的性能？多格式支持？而且鉴于纹理使用的广泛程度，这些东西的设计和项目的成败都可以说是息息相关。\n不过，这里为避免麻烦，我们选择直接借用参考答案：使用一个支持多种流行格式的图像加载库来为我们解决这个问题。比如：\n1.6.1.2.1: Use stb_image.h to load image：\n\n\n\n\n\n\n\n\nstb_image.h is a very popular single header image loading library by Sean Barrett that is able to load most popular file formats and is easy to integrate in your project(s). stb_image.h can be downloaded from here. Simply download the single header file, add it to your project as stb_image.h, and create an additional C++ file with the following code:\n在stb_image.h中，可以发现使用该头文件所需要的引用与定义：\n#define STB_IMAGE_IMPLEMENTATION\n#include &quot;stb_image.h&quot;\n\nBy defining STB_IMAGE_IMPLEMENTATION the preprocessor modifies the header file such that it only contains the relevant definition source code, effectively turning the header file into a .cpp file, and that’s about it. Now simply include stb_image.h somewhere in your program and compile.\nFor the following texture sections we’re going to use an image of a wooden container. To load an image using stb_image.h we use its stbi_load function:\nint width, height, nrChannels;\nunsigned char *data &#x3D; stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0); \n\nThe function first takes as input the location of an image file. It then expects you to give three ints as its second, third and fourth argument that stb_image.h will fill with the resulting image’s width, height and number of color channels. We need the image’s width and height for generating textures later on.\n1.6.1.2.2: Generate Texture在前面，我们已经完成了对图片数据的读取，此时就应该回到OpenGL上来——开始准备生成纹理了\nGLuint texture; &#x2F;&#x2F; ID\nglGenTexture(1, &amp;texture); &#x2F;&#x2F; The glGenTextures function first takes as input how many textures we want to generate and stores them in a unsigned int array given as its second argument (in our case just a single unsigned int). \n\n&#x2F;&#x2F; Just like other objects we need to bind it, so any subsequent texture commands will configure the currently bound texture:\nglBindTexture(GL_TEXTURE_2D, texture[0]);\n\n&#x2F;&#x2F; 为当前绑定的纹理对象设置环绕、过滤方式\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n&#x2F;&#x2F; 生成纹理\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\nglGenerateMipmap(GL_TEXTURE_2D); &#x2F;&#x2F; 多层渐变纹理\n\nglTexImage2D参数不少：\n\n第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。\n第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。\n第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有RGB值，因此我们也把纹理储存为RGB值。\n第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。\n下个参数应该总是被设为0（历史遗留问题）。\n第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值。\n最后一个参数是真正的图像数据。\n\n当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。\nAfter we’re done generating the texture and its corresponding mipmaps, it is good practice to free the image memory:\nstbi_image_free(data);\nglBindTexture(GL_TEXTURE_2D, 0);\n\n1.6.2 纹理采样方式\n\n\n\n\n\n\n\n\n纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：\n\n\n\n环绕方式(Wrapping)\n描述\n\n\n\nGL_REPEAT\n对纹理的默认行为。重复纹理图像。\n\n\nGL_MIRRORED_REPEAT\n和GL_REPEAT一样，但每次重复图片是镜像放置的。\n\n\nGL_CLAMP_TO_EDGE\n纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。\n\n\nGL_CLAMP_TO_BORDER\n超出的坐标为用户指定的边缘颜色。\n\n\n当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子：\n\n\n\n\n\n\n\n\n\n\nglTexParameter - OpenGL 4 Reference Pages (khronos.org)\nopengl - What does changing GL_TEXTURE_WRAP)_(S/T) do? - Game Development Stack Exchange\n前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）：\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);\n\n\n第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。\n第二个参数需要我们指定，设置的选项 与 应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴。\n最后一个参数需要我们传递一个环绕方式，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。\n\n\n\n\n\n\n\n\n\n\n如果我们选择GL_CLAMP_TO_BORDER选项，我们需要执行的步骤是这些：指定一个边缘的颜色，使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项：\n&gt;float borderColor[] &#x3D; &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;\n&gt;glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);\n1.6.3 纹理过滤\n\n\n\n\n\n\n\n\n插值办法\nOpenGL需要知道怎样将纹理像素（Texture Pixel、Texel、纹素）映射到纹理坐标。这在物体较大而纹理的分辨率较低时十分重要。\n\n\n\n\n\n\n\n\n\nTexture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。\nGL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：\n\nGL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：\n\n那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：\n\nGL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。\n当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n1.6.4 多级渐远纹理想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色，这在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。\nOpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：\n\n手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。\n在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：\n\n\n\n过滤方式\n描述\n\n\n\nGL_NEAREST_MIPMAP_NEAREST\n使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样\n\n\nGL_LINEAR_MIPMAP_NEAREST\n使用最邻近的多级渐远纹理级别，并使用线性插值进行采样\n\n\nGL_NEAREST_MIPMAP_LINEAR\n在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样\n\n\nGL_LINEAR_MIPMAP_LINEAR\n在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样\n\n\n就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。\n","slug":"Technical Artist/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/05Texture","date":"2023-03-08T02:21:08.000Z","categories_index":"TA","tags_index":"Opengl,Shader","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Flask如何处理请求一个简单但完整的示例from flask import Flask, jsonify\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    return jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n此时，当我们访问/api时，应用会返回一个JSON映射。\n\n变量__name__\n\n\n\n\n\n\n\n\n\n\n变量__name__是这个应用软件包的名称，而当运行一个单独的Python模块时，变量__name__会赋值为__main__\nFlask会使用这个变量实例化一个新的日志日志记录器(logger)，并在磁盘上定位这个模块所在文件的路径。\nFlask将使用该文件的目录作为助手程序的根目录(例如与应用程序相关的配置文件)，并根据此目录确定静态文件目录(static)与模板目录(templates)的默认存放位置\n在shell中运行当前模块时，Flask会运行其中的内置Web服务器，并在默认在5000端口监听传入的请求\n\n访问/api\n\nroot@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask# curl -v http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api\n*   Trying 127.0.0.1:5000...\n* Connected to 127.0.0.1 (127.0.0.1) port 5000 (#0)\n&gt; GET &#x2F;api HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5000\n&gt; User-Agent: curl&#x2F;7.81.0\n&gt; Accept: *&#x2F;*\n&gt; \n* Mark bundle as not supporting multiuse\n&lt; HTTP&#x2F;1.1 200 OK\n&lt; Server: Werkzeug&#x2F;2.2.2 Python&#x2F;3.10.4\n&lt; Date: Sat, 10 Sep 2022 11:43:02 GMT\n&lt; Content-Type: application&#x2F;json\n&lt; Content-Length: 19\n&lt; Connection: close\n&lt; \n&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\n* Closing connection 0\n\n可以发现，我们得到了一个合法的JSON响应和正确的消息头。\n\njsonity函数\n\n该函数会将Python字典类型转换为合法的JSON响应，并在添加适当的Content-Type消息头后，将映射信息存储到响应体中\nrequest对象与大多数Web框架不同，flask不需要显示地将request对象传递到代码中——它隐式地提供了一个全局的request变量，并用该全局的变量来指向当前的request对象。Flask把传入的HTTP请求解析为WSGI环境字典，并利用它来创建这个对象\n这样：当服务器的响应不依赖请求的内容时，就没必要处理它。视图只需要确保返回了客户端应该获取的内容，并确保内容能够被Flask序列化即可\n了解底层到底发生了什么增加print方法，了解curl访问具体过程\nfrom flask import Flask, jsonify, request\n\napp &#x3D; Flask(__name__)\n\n\n@app.route(&#39;&#x2F;api&#39;)\ndef my_microservice():\n    print(request)\n    print(request.environ)\n    response &#x3D; jsonify(&#123;&#39;Hello&#39;: &#39;World!&#39;&#125;)\n    print(response)\n    print(response.data)\n    return response\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(app.url_map)\n    app.run()\n\n有：\n(venv) root@BUNJIESP8:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;m1518&#x2F;Project&#x2F;flask&#x2F;chapter2# python app.py \nMap([&lt;Rule &#39;&#x2F;static&#x2F;&lt;filename&gt;&#39; (OPTIONS, GET, HEAD) -&gt; static&gt;,\n &lt;Rule &#39;&#x2F;api&#39; (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])\n * Serving Flask app &#39;app&#39;\n * Debug mode: off\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n * Running on http:&#x2F;&#x2F;127.0.0.1:5000\nPress CTRL+C to quit\n&lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;\n&#123;&#39;wsgi.version&#39;: (1, 0), &#39;wsgi.url_scheme&#39;: &#39;http&#39;, &#39;wsgi.input&#39;: &lt;_io.BufferedReader name&#x3D;4&gt;, &#39;wsgi.errors&#39;: &lt;_io.TextIOWrapper name&#x3D;&#39;&lt;stderr&gt;&#39; mode&#x3D;&#39;w&#39; encoding&#x3D;&#39;utf-8&#39;&gt;, &#39;wsgi.multithread&#39;: True, &#39;wsgi.multiprocess&#39;: False, &#39;wsgi.run_once&#39;: False, &#39;werkzeug.socket&#39;: &lt;socket.socket fd&#x3D;4, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 5000), raddr&#x3D;(&#39;127.0.0.1&#39;, 54614)&gt;, &#39;SERVER_SOFTWARE&#39;: &#39;Werkzeug&#x2F;2.2.2&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_NAME&#39;: &#39;&#39;, &#39;PATH_INFO&#39;: &#39;&#x2F;api&#39;, &#39;QUERY_STRING&#39;: &#39;&#39;, &#39;REQUEST_URI&#39;: &#39;&#x2F;api&#39;, &#39;RAW_URI&#39;: &#39;&#x2F;api&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: 54614, &#39;SERVER_NAME&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;5000&#39;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39;, &#39;HTTP_HOST&#39;: &#39;127.0.0.1:5000&#39;, &#39;HTTP_USER_AGENT&#39;: &#39;curl&#x2F;7.81.0&#39;, &#39;HTTP_ACCEPT&#39;: &#39;*&#x2F;*&#39;, &#39;werkzeug.request&#39;: &lt;Request &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;api&#39; [GET]&gt;&#125;\n&lt;Response 19 bytes [200 OK]&gt;\nb&#39;&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\\n&#39;\n127.0.0.1 - - [10&#x2F;Sep&#x2F;2022 22:55:47] &quot;GET &#x2F;api HTTP&#x2F;1.1&quot; 200 -\n\n路由匹配路由匹配发生在app.url_map中，这是Werzeug中Map类的一个实例。Map([&lt;Rule &#39;/static/&lt;filename&gt;&#39; (OPTIONS, GET, HEAD) -&gt; static&gt;, &lt;Rule &#39;/api&#39; (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])\n该类使用正则表达式来判定被@app.route装饰的函数时候与传入的请求匹配，路由匹配只会姜茶route调用里的路径参数来判断函数时候匹配客户端的请求，默认情况下，声明式路由只支持GET, OPTIONS, HEAD方法的调用，如果使用了不支持的HTTP方法，则会出现405Method Not Allowed响应，并在Allow响应头中返回其所支持的HTTP方法列表（正常访问不会出现Allow响应头）\n当需要支持指定HTTP请求方式时，我们需要给装饰器增加额外的参数：\n@app.route(&#39;&#x2F;api&#39;, method&#x3D;[&#39;POST&#39;, &#39;DELETE&#39;, &#39;GET&#39;])\n\n\n\n不过，\n变量与转换器路由系统支持变量如：/person/&lt;person_id&gt;\n请求响应Flask的内置特性微服务骨架拓展：\n这个 name 变量可能取什么值？\n当你直接执行一段脚本的时候，这段脚本的 **name**变量等于 ‘main‘，当这段脚本被导入其他程序的时候，name 变量等于脚本本身的名字。\n这个 name 拿来做什么的？\n作为 Python 的内置变量，**name**变量（前后各有两个下划线）还是挺特殊的。它是每个 Python 模块必备的属性，但它的值取决于你是如何执行这段代码的。\n在许多情况下，你的代码不可能全部都放在同一个文件里，或者你在这个文件里写的函数，在其他地方也可以用到。为了更高效地重用这些代码，你需要在 Python 程序中导入来自其他文件的代码。\n所以，在**name** 变量的帮助下，你可以判断出这时代码是被直接运行，还是被导入到其他程序中去了。\nPython 的 name 变量，到底是个什么东西？ - 知乎 (zhihu.com)\n","slug":"Web Dev/Back End/flask/tutorial/setup_your_flask","date":"2023-03-08T00:30:41.957Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"需要安装的内容：\nDjango本体\n","slug":"Web Dev/Back End/django/Python Django Web典型模块开发实战/总述及django安装","date":"2023-03-08T00:30:41.954Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"官网原教程：PART 1：Writing your first Django app, part 1 | Django documentation | Django (djangoproject.com)\n概述：\n概述教程内容\n使用startproject命令创建的项目的基本内容介绍\n通过mange.py启动刚刚创建的新项目\n通过startapp命令新建应用，并对project与app作区分\n介绍url与view\n\n复述：1. quick the installation and version of djangopython -m django --version\n\nIf Django is installed, you should see the version of your installation. If it isn’t, you’ll get an error telling “No module named django”.\n2. creating a projectUse the command line to auto-generate some code that establishes a Django project – a collection of settings for an instance of Django, including database configuration, Django-specific options and application-specific settings to finish some initial setup.\ndjango-admin startproject &lt;mysite&gt;\n\nThis will create a mysite directory in your current directory.\n\n\n\n\n\n\n\n\n\nAnd the folder created by startproject looks like:\n\nmysite/manage.pymysite/  init.py  settings.py  urls.py  asgi.py  wsgi.py\nThese files are:\n\nThe outer mysite/ root directory is a container for your project. Its name doesn’t matter to Django; you can rename it to anything you like.\nmanage.py: A command-line utility that lets you interact with this Django project in various ways. You can read all the details about manage.py in django-admin and manage.py.\nThe inner mysite/ directory is the actual Python package for your project. Its name is the Python package name you’ll need to use to import anything inside it (e.g. mysite.urls).\nmysite/__init__.py: An empty file that tells Python that this directory should be considered a Python package. If you’re a Python beginner, read more about packages in the official Python docs.\nmysite/settings.py: Settings/configuration for this Django project. Django settings will tell you all about how settings work.\nmysite/urls.py: The URL declarations for this Django project; a “table of contents” of your Django-powered site. You can read more about URLs in URL dispatcher.\nmysite/asgi.py: An entry-point for ASGI-compatible web servers to serve your project. See How to deploy with ASGI for more details.\nmysite/wsgi.py: An entry-point for WSGI-compatible web servers to serve your project. See How to deploy with WSGI for more details.\n\n\n3. start your projectpython manage.py runserver\n# you can pass server&#39;s port and so on as a command-line argument behind &#39;runserver&#39;\n\nYou’ll see the output which includes:\n\n\n\n\n\n\n\n\n\n…Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C.\n4. create new app\n\n\n\n\n\n\n\n\nWhat’s the difference between a project and an app? An app is a web application that does something – e.g., a blog system, a database of public records or a small poll app. A project is a collection of configuration and apps for a particular website. A project can contain multiple apps. An app can be in multiple projects.\npy manage.py startapp polls\n\nThat will create a new directory like:\n\n\n\n\n\n\n\n\n\npolls/   init.py   admin.py   apps.py   migrations/       init.py   models.py   tests.py   views.py\nThis directory structure will house the poll application.\n5. write your own view and set it urlOpen the file polls/views.py and put the following Python code in it:\nfrom django.http import HttpResponse\n\ndef index(request):\n    return HttpResponse(&quot;Hello, world. You&#39;re at the polls index.&quot;)\n\nThis is the simplest view possible in Django. To call the view, we need to map it to a URL - and for this we need a URLconf.\nTo create a URLconf in the polls directory, create a file called urls.py. Your app directory should now look like:\n\n\n\n\n\n\n\n\n\npolls/   init.py   admin.py   apps.py   migrations/       init.py   models.py   tests.py   urls.py   views.py\nIn the polls/urls.py file include the following code:\nfrom django.urls import path\nfrom . import views\n\nurlpatterns &#x3D; [path(&#39;&#39;, views.index, name&#x3D;&#39;index&#39;),]\n\nThe next step is to point the root URLconf at the polls.urls module. In mysite/urls.py, add an import for django.urls.include and insert an include() in the urlpatterns list, so you have:\nfrom django.contrib import admin\nfrom django.urls import include, path\n\nurlpatterns &#x3D; [\n    path(&#39;polls&#x2F;&#39;, include(&#39;polls.urls&#39;)),\n    path(&#39;admin&#x2F;&#39;, admin.site.urls),\n]\n\nThe include() function allows referencing other URLconfs. Whenever Django encounters include(), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing. See more about -&gt; include()\nYou should always use include() when you include other URL patterns. admin.site.urls is the only exception to this.\nNow restart your server and go to http://localhost:8000/polls/ in your browser, and you should see the text “*Hello, world. You’re at the polls index.*”, which you defined in the index view.\nSee more about path()\n\n\n\n\n\n\n\n\n\npath() argument: route¶\nroute is a string that contains a URL pattern. When processing a request, Django starts at the first pattern in urlpatterns and makes its way down the list, comparing the requested URL against each pattern until it finds one that matches.\nPatterns don’t search GET and POST parameters, or the domain name. For example, in a request to https://www.example.com/myapp/, the URLconf will look for myapp/. In a request to https://www.example.com/myapp/?page=3, the URLconf will also look for myapp/.\n\n\n\n\n\n\n\n\n\npath() argument: view¶\nWhen Django finds a matching pattern, it calls the specified view function with an HttpRequest object as the first argument and any “captured” values from the route as keyword arguments. We’ll give an example of this in a bit.\n\n\n\n\n\n\n\n\n\npath() argument: kwargs¶\nArbitrary keyword arguments can be passed in a dictionary to the target view. We aren’t going to use this feature of Django in the tutorial.\n\n\n\n\n\n\n\n\n\npath() argument: name¶\nNaming your URL lets you refer to it unambiguously from elsewhere in Django, especially from within templates. This powerful feature allows you to make global changes to the URL patterns of your project while only touching a single file.\nWhen you’re comfortable with the basic request and response flow, read part 2 of this tutorial to start working with the database.\n- \n","slug":"Web Dev/Back End/django/official website basic tutorial/official_website_basic_tutorial-part_1","date":"2023-03-08T00:30:41.952Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"官网原教程：PART 2：Writing your first Django app, part 2 | Django documentation | Django (djangoproject.com)\n概述：\n建立数据库：基于sqlite数据库，介绍project module下settings中包括如何更换其他数据库的部分内容，并通过migrate命令快速创建所需数据库\n\n\n复述：1. 建立数据库a. 确认数据库设置Django默认使用SQLite作为默认数据库，因为这是Python内置的数据库。\n如果需要更换别的数据库的话，首先需要安装合适的database bindings，然后改变project module下settings文件中的设置文件中 DATABASES &#39;default&#39; 项目中的一些键值，包括：\n\n\n\n\n\n\n\n\n\n\nENGINE – Either &#39;django.db.backends.sqlite3&#39;, &#39;django.db.backends.postgresql&#39;, &#39;django.db.backends.mysql&#39;, or &#39;django.db.backends.oracle&#39;. Other backends are also available.\nNAME – The name of your database. If you’re using SQLite, the database will be a file on your computer; in that case, NAME should be the full absolute path, including filename, of that file. The default value, BASE_DIR / &#39;db.sqlite3&#39;, will store the file in your project directory.\n\n并且如果不使用 SQLite，则必须添加更多内容，比如 USER 、 PASSWORD 、 HOST 等。更多内容请查阅文档：DATABASES 。\n\n\n\n\n\n\n\n\n\n如果你使用了 SQLite 以外的数据库，请确认在使用前已经创建了数据库。你可以通过在你的数据库交互式命令行中使用 “CREATE DATABASE database_name;“ 命令来完成这件事。\n另外，还要确保该数据库用户中提供 mysite/settings.py 具有 “create database” 权限。这使得自动创建的 test database 能被以后的教程使用。\n如果你使用 SQLite，那么你不需要在使用前做任何事——数据库会在需要的时候自动创建。\nb. 按规则设置时区注意时区属性的格式\nc. check INSTALLED_APPS itemsthe item, INSTALLED_APPS setting at the top of the file, holds the names of all Django applications that are activated in this Django instance. \nApps can be used in multiple projects, and you can package and distribute them for use by others in their projects.\n\n\n\n\n\n\n\n\n\nBy default, INSTALLED_APPS contains the following apps, all of which come with Django:\n\ndjango.contrib.admin – The admin site. You’ll use it shortly.\ndjango.contrib.auth – An authentication system.\ndjango.contrib.contenttypes – A framework for content types.\ndjango.contrib.sessions – A session framework.\ndjango.contrib.messages – A messaging framework.\ndjango.contrib.staticfiles – A framework for managing static files.\n\nThese applications are included by default as a convenience for the common case.\nSome of these applications make use of at least one database table, though, so we need to create the tables in the database before we can use them. To do that, run the following command:\npy manage.py migrate\n\nas we said before “the database file will be created automatically when it is needed.”, the sqlite database finally appeared with those tables above.\n\n\n\n\n\n\n\n\n\nThe migrate command looks at the INSTALLED_APPS setting and creates any necessary database tables according to the database settings in your mysite/settings.py file and the database migrations shipped with the app (we’ll cover those later). You’ll see a message for each migration it applies. If you’re interested, run the command-line client for your database and type \\dt (PostgreSQL), SHOW TABLES; (MariaDB, MySQL), .tables (SQLite), or SELECT TABLE_NAME FROM USER_TABLES; (Oracle) to display the tables Django created.\n2. model文件编写\n\n\n\n\n\n\n\n\nNow we’ll define your models – essentially, your database layout, with additional metadata.\n在 Django 里写一个数据库驱动的 Web 应用的第一步是定义模型 - 也就是数据库结构设计和附加的其它元数据。\na. 什么是一个model？\n\n\n\n\n\n\n\n\nPhilosophy\nA model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you’re storing. Django follows the DRY Principle. The goal is to define your data model in one place and automatically derive things from it.\nThis includes the migrations - unlike in Ruby On Rails, for example, migrations are entirely derived from your models file, and are essentially a history that Django can roll through to update your database schema to match your current models.\nb. examplesIn our poll app, we’ll create two models: Question and Choice. \n\nA Question has a question and a publication date. \nA Choice has two fields: the text of the choice and a vote tally. Each Choice is associated with a Question.\n\nThese concepts are represented by Python classes. Edit the polls/models.py file so it looks like this:\nfrom django.db import models\n\nclass Question(models.Model):\n    question_text &#x3D; models.CharField(max_length&#x3D;200)\n    pub_date &#x3D; models.DateTimeField(&#39;date published&#39;)\n\nclass Choice(models.Model):\n    question &#x3D; models.ForeignKey(Question, on_delete&#x3D;models.CASCADE)\n    choice_text &#x3D; models.CharField(max_length&#x3D;200)\n    votes &#x3D; models.IntegerField(default&#x3D;0)\n\nHere, each model is represented by a class that subclasses django.db.models.Model. Each model has a number of class variables, each of which represents a database field in the model.\nEach field is represented by an instance of a Field class – e.g., CharField for character fields and DateTimeField for datetimes. This tells Django what type of data each field holds.\nThe name of each Field instance (e.g. question_text or pub_date) is the field’s name, in machine-friendly format. You’ll use this value in your Python code, and your database will use it as the column name.\nYou can use an optional first positional argument to a Field to designate a human-readable name. That’s used in a couple of introspective parts of Django, and it doubles as documentation. If this field isn’t provided, Django will use the machine-readable name. In this example, we’ve only defined a human-readable name for Question.pub_date. For all other fields in this model, the field’s machine-readable name will suffice as its human-readable name.\nSome Field classes have required arguments. CharField, for example, requires that you give it a max_length. That’s used not only in the database schema, but in validation, as we’ll soon see.\nA Field can also have various optional arguments; in this case, we’ve set the default value of votes to 0.\nFinally, note a relationship is defined, using ForeignKey. That tells Django each Choice is related to a single Question. Django supports all the common database relationships: many-to-one, many-to-many, and one-to-one.\n3. 激活你的model\n\n\n\n\n\n\n\n\nThat small bit of model code gives Django a lot of information. With it, Django is able to:\n\nCreate a database schema (CREATE TABLE statements) for this app.\nCreate a Python database-access API for accessing Question and Choice objects.\n\nfirst we need to tell our project that the polls app is installed.\n\nadd the &#39;polls.apps.PollsConfig&#39; (see polls/apps.py) to INSTALLED_APPS\nrun the command py manage.py makemigrations polls, you should see the output like:\n\n\n\n\n\n\n\n\nMigrations for &#39;polls&#39;:\n\n   polls/migrations/0001_initial.py\n     \\- Create model Question\n       \\- Create model Choice\n\n\n\n\n\n\n\n\n\n\n\n\n\nmore about command makemigrations:\nBy running makemigrations, you’re telling Django that you’ve made some changes to your models (in this case, you’ve made new ones) and that you’d like the changes to be stored as a migration.\nMigrations are how Django stores changes to your models (and thus your database schema) - they’re files on disk. You can read the migration for your new model if you like; it’s the file polls/migrations/0001_initial.py. Don’t worry, you’re not expected to read them every time Django makes one, but they’re designed to be human-editable in case you want to manually tweak how Django changes things.\n\nTo run the migrations and manage your database schema automatically - using the command migrate first. let’s see what SQL that migration would run. The sqlmigrate command takes migration names and returns their SQL:\n\npy manage.py sqlmigrate polls 0001\n\n\n\n\n\n\n\n\n\nYou should see something similar to the following (we’ve reformatted it for readability):\nBEGIN;\n--\n-- Create model Question\n--\nCREATE TABLE &quot;polls_question&quot; (\n    &quot;id&quot; serial NOT NULL PRIMARY KEY,\n    &quot;question_text&quot; varchar(200) NOT NULL,\n    &quot;pub_date&quot; timestamp with time zone NOT NULL\n);\n--\n-- Create model Choice\n--\nCREATE TABLE &quot;polls_choice&quot; (\n    &quot;id&quot; serial NOT NULL PRIMARY KEY,\n    &quot;choice_text&quot; varchar(200) NOT NULL,\n    &quot;votes&quot; integer NOT NULL,\n    &quot;question_id&quot; integer NOT NULL\n);\nALTER TABLE &quot;polls_choice&quot;\n  ADD CONSTRAINT &quot;polls_choice_question_id_c5b4b260_fk_polls_question_id&quot;\n    FOREIGN KEY (&quot;question_id&quot;)\n    REFERENCES &quot;polls_question&quot; (&quot;id&quot;)\n    DEFERRABLE INITIALLY DEFERRED;\nCREATE INDEX &quot;polls_choice_question_id_c5b4b260&quot; ON &quot;polls_choice&quot; (&quot;question_id&quot;);\n\nCOMMIT;\n\nNote the following:\n\nThe exact output will vary depending on the database you are using. The example above is generated for PostgreSQL.\nTable names are automatically generated by combining the name of the app (polls) and the lowercase name of the model – question and choice. (You can override this behavior.)\nPrimary keys (IDs) are added automatically. (You can override this, too.)\nBy convention, Django appends &quot;_id&quot; to the foreign key field name. (Yes, you can override this, as well.)\nThe foreign key relationship is made explicit by a FOREIGN KEY constraint. Don’t worry about the DEFERRABLE parts; it’s telling PostgreSQL to not enforce the foreign key until the end of the transaction.\nIt’s tailored to the database you’re using, so database-specific field types such as auto_increment (MySQL), serial (PostgreSQL), or integer primary key autoincrement (SQLite) are handled for you automatically. Same goes for the quoting of field names – e.g., using double quotes or single quotes.\nThe sqlmigrate command doesn’t actually run the migration on your database - instead, it prints it to the screen so that you can see what SQL Django thinks is required. It’s useful for checking what Django is going to do or if you have database administrators who require SQL scripts for changes.\n\nIf you’re interested, you can also run python manage.py check; this checks for any problems in your project without making migrations or touching the database.\nNow, run migrate again to create those model tables in your database:\n\npy manage.py migrate\n\n\n\n\n\n\n\n\n\nThe migrate command takes all the migrations that haven’t been applied (Django tracks which ones are applied using a special table in your database called django_migrations) and runs them against your database - essentially, synchronizing the changes you made to your models with the schema in the database.\nMigrations are very powerful and let you change your models over time, as you develop your project, without the need to delete your database or tables and make new ones - it specializes in upgrading your database live, without losing data. We’ll cover them in more depth in a later part of the tutorial, but for now, remember the three-step guide to making model changes:\n\nChange your models (in models.py).\nRun python manage.py makemigrations to create migrations for those changes\nRun python manage.py migrate to apply those changes to the database.\n\nThe reason that there are separate commands to make and apply migrations is because you’ll commit migrations to your version control system and ship them with your app; they not only make your development easier, they’re also usable by other developers and in production.\nRead the django-admin documentation for full information on what the manage.py utility can do.\n\n\n4. 完善model，初试apiNow, let’s hop into the interactive Python shell and play around with the free API Django gives you. To invoke the Python shell, use this command:\npy manage.py shell\n\nWe’re using this instead of simply typing “python”, because manage.py sets the DJANGO_SETTINGS_MODULE environment variable, which gives Django the Python import path to your mysite/settings.py file.\nYou can try these database api below:\n&gt;&gt;&gt; from polls.models import Choice, Question  # Import the model classes we just wrote.\n\n# No questions are in the system yet.\n&gt;&gt;&gt; Question.objects.all()\n&lt;QuerySet []&gt;\n\n# Create a new Question.\n# Support for time zones is enabled in the default settings file, so\n# Django expects a datetime with tzinfo for pub_date. Use timezone.now()\n# instead of datetime.datetime.now() and it will do the right thing.\n&gt;&gt;&gt; from django.utils import timezone\n&gt;&gt;&gt; q &#x3D; Question(question_text&#x3D;&quot;What&#39;s new?&quot;, pub_date&#x3D;timezone.now())\n\n# Save the object into the database. You have to call save() explicitly.\n&gt;&gt;&gt; q.save()\n\n# Now it has an ID.\n&gt;&gt;&gt; q.id\n1\n\n# Access model field values via Python attributes.\n&gt;&gt;&gt; q.question_text\n&quot;What&#39;s new?&quot;\n&gt;&gt;&gt; q.pub_date\ndatetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo&#x3D;&lt;UTC&gt;)\n\n# Change values by changing the attributes, then calling save().\n&gt;&gt;&gt; q.question_text &#x3D; &quot;What&#39;s up?&quot;\n&gt;&gt;&gt; q.save()\n\n# objects.all() displays all the questions in the database.\n&gt;&gt;&gt; Question.objects.all()\n&lt;QuerySet [&lt;Question: Question object (1)&gt;]&gt;\n\n\n我们可以为类内添加__str__()方法来快速查看项目内容\n\n\n\n\n\n\n\n\n\nPython str() 方法 (runoob.com)\nfrom django.db import models\n\nclass Question(models.Model):\n    # ...\n    def __str__(self):\n        return self.question_text # Choice类同理\n\n这样当我们查看内容时就能看到\n\n\n\n\n\n\n\n\n\n&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: What’s up?&gt;]&gt;\n当然也可以添加别的“正常的功能”，如：\nclass Question(models.Model):\n    # ...\n    def was_published_recently(self):\n        return self.pub_date &gt;&#x3D; timezone.now() - datetime.timedelta(days&#x3D;1)\n\n\n\n更多操作:\n&gt;&gt;&gt; from polls.models import Choice, Question\n\n# Make sure our __str__() addition worked.\n&gt;&gt;&gt; Question.objects.all()\n&lt;QuerySet [&lt;Question: What&#39;s up?&gt;]&gt;\n\n# Django provides a rich database lookup API that&#39;s entirely driven by\n# keyword arguments.\n&gt;&gt;&gt; Question.objects.filter(id&#x3D;1)\n&lt;QuerySet [&lt;Question: What&#39;s up?&gt;]&gt;\n&gt;&gt;&gt; Question.objects.filter(question_text__startswith&#x3D;&#39;What&#39;)\n&lt;QuerySet [&lt;Question: What&#39;s up?&gt;]&gt;\n\n# Get the question that was published this year.\n&gt;&gt;&gt; from django.utils import timezone\n&gt;&gt;&gt; current_year &#x3D; timezone.now().year\n&gt;&gt;&gt; Question.objects.get(pub_date__year&#x3D;current_year)\n&lt;Question: What&#39;s up?&gt;\n\n# Request an ID that doesn&#39;t exist, this will raise an exception.\n&gt;&gt;&gt; Question.objects.get(id&#x3D;2)\nTraceback (most recent call last):\n    ...\nDoesNotExist: Question matching query does not exist.\n\n# Lookup by a primary key is the most common case, so Django provides a\n# shortcut for primary-key exact lookups.\n# The following is identical to Question.objects.get(id&#x3D;1).\n&gt;&gt;&gt; Question.objects.get(pk&#x3D;1)\n&lt;Question: What&#39;s up?&gt;\n\n# Make sure our custom method worked.\n&gt;&gt;&gt; q &#x3D; Question.objects.get(pk&#x3D;1)\n&gt;&gt;&gt; q.was_published_recently()\nTrue\n\n# Give the Question a couple of Choices. The create call constructs a new\n# Choice object, does the INSERT statement, adds the choice to the set\n# of available choices and returns the new Choice object. Django creates\n# a set to hold the &quot;other side&quot; of a ForeignKey relation\n# (e.g. a question&#39;s choice) which can be accessed via the API.\n&gt;&gt;&gt; q &#x3D; Question.objects.get(pk&#x3D;1)\n\n# Display any choices from the related object set -- none so far.\n&gt;&gt;&gt; q.choice_set.all()\n&lt;QuerySet []&gt;\n\n# Create three choices.\n&gt;&gt;&gt; q.choice_set.create(choice_text&#x3D;&#39;Not much&#39;, votes&#x3D;0)\n&lt;Choice: Not much&gt;\n&gt;&gt;&gt; q.choice_set.create(choice_text&#x3D;&#39;The sky&#39;, votes&#x3D;0)\n&lt;Choice: The sky&gt;\n&gt;&gt;&gt; c &#x3D; q.choice_set.create(choice_text&#x3D;&#39;Just hacking again&#39;, votes&#x3D;0)\n\n# Choice objects have API access to their related Question objects.\n&gt;&gt;&gt; c.question\n&lt;Question: What&#39;s up?&gt;\n\n# And vice versa: Question objects get access to Choice objects.\n&gt;&gt;&gt; q.choice_set.all()\n&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;\n&gt;&gt;&gt; q.choice_set.count()\n3\n\n# The API automatically follows relationships as far as you need.\n# Use double underscores to separate relationships.\n# This works as many levels deep as you want; there&#39;s no limit.\n# Find all Choices for any question whose pub_date is in this year\n# (reusing the &#39;current_year&#39; variable we created above).\n&gt;&gt;&gt; Choice.objects.filter(question__pub_date__year&#x3D;current_year)\n&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;\n\n# Let&#39;s delete one of the choices. Use delete() for that.\n&gt;&gt;&gt; c &#x3D; q.choice_set.filter(choice_text__startswith&#x3D;&#39;Just hacking&#39;)\n&gt;&gt;&gt; c.delete()\n\n\n\n5. 试用admin端create a admin user\npy manage.py createsuperuser\n\nStart your server, make sure you have added the admin site to urls.py. Then follow the urls to open the admin page, you will see the login page. After that, you should see the Django admin index page, without your polls app though(if you follow the tutorial completely)     \n\n\n\n\n\n\n\n\n\nOnly one more thing to do: we need to tell the admin that Question objects have an admin interface. To do this, open the polls/admin.py file, and edit it to look like this:\n&gt;from django.contrib import admin\n\n&gt;from .models import Question\n\n&gt;admin.site.register(Question)\nNow that we’ve registered Question, Django knows that it should be displayed on the admin index page.\n","slug":"Web Dev/Back End/django/official website basic tutorial/official_website_basic_tutorial-part_2","date":"2023-03-08T00:30:41.949Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"官网原教程：PART 3：Writing your first Django app, part 3 | Django documentation | Django (djangoproject.com)\n概述：\n编写处理http请求的函数\n在urls中，添加视图内容\n\n\n复述：1. 编写处理http请求的函数：示例函数：\nfrom django.http import HttpResponse\nfrom .models import Question\n\ndef index(request):\n    latest_question_list &#x3D; Question.objects.order_by(&#39;-pub_date&#39;)[:5]\n    output &#x3D; &#39;, &#39;.join([q.question_text for q in latest_question_list])\n    return HttpResponse(output)\n# 我们也可以使用这样的方式：在html文件中编写特殊语句并通过render函数及HttpResponse返回给前端\n# 需要额外引入：&#96;from django.template import loader&#96;\n#   template &#x3D; loader.get_template(&#39;polls&#x2F;index.html&#39;)\n#   context &#x3D; &#123;\n#       &#39;latest_question_list&#39;: latest_question_list,\n#   &#125;\n#   return HttpResponse(template.render(context, request))\n\n# 当然也可以使用shortcuts中的render函数：https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;zh-hans&#x2F;4.0&#x2F;intro&#x2F;tutorial03&#x2F;#a-shortcut-render\ndef detail(request, question_id):\n    try:\n        question &#x3D; Question.objects.get(pk&#x3D;question_id)\n    except Question.DoesNotExist:\n        raise Http404(&quot;Question does not exist&quot;)\n    return render(request, &#39;polls&#x2F;detail.html&#39;, &#123;&#39;question&#39;: question&#125;)\n\ndef results(request, question_id):\n    response &#x3D; &quot;You&#39;re looking at the results of question %s.&quot;\n    return HttpResponse(response % question_id)\n\ndef vote(request, question_id):\n    return HttpResponse(&quot;You&#39;re voting on question %s.&quot; % question_id)\n\n这些函数实际需要做的只有两件事：\n\n按需求处理请求，或者抛出异常\n返回处理结果或者错误信息\n\n在处理的过程中，我们从数据库里读取必要信息以参与处理，以达成我们的目的。以上方代码中的index函数为例，我们读取了数据库中以日期为序的最近5个问题，并在后续处理中进行合并并以逗号,分割，最后返回一个HttpResponse对象来完成本次请求。\n如果收到的请求无效，我们应当以适当的方式抛出错误，请注意在处理时将model层和view层相分离：\n\n\n\n\n\n\n\n\n\n为什么我们使用辅助函数 get_object_or_404() 而不是自己捕获 ObjectDoesNotExist 异常呢？还有，为什么模型 API 不直接抛出 ObjectDoesNotExist 而是抛出 Http404 呢？\n因为这样做会增加模型层和视图层的耦合性。指导 Django 设计的最重要的思想之一就是要保证松散耦合。一些受控的耦合将会被包含在 django.shortcuts 模块中。\n编写你的第一个 Django 应用，第 3 部分 | Django 文档 | Django (djangoproject.com)\n为了便于构建views，django提供了一套template系统:，可至模板 | Django 文档 | Django (djangoproject.com)查看\n2. 编写urls编写好对应请求的处理函数后，自然要把它们挂载到对应的url路径上，此时便需要修改project module和当前app中的urls文件\nproject module内urls - 示例内容：\nurlpatterns &#x3D; [\n    path(&#39;admin&#x2F;&#39;, admin.site.urls),\n    path(&#39;polls&#x2F;&#39;, include(&#39;polls.urls&#39;))\n]\n\napp内urls - 示例内容：\nfrom django.urls import path\nfrom . import views\n\nurlpatterns &#x3D; [\n    # ex: &#x2F;polls&#x2F;\n    path(&#39;&#39;, views.index, name&#x3D;&#39;index&#39;),\n    # ex: &#x2F;polls&#x2F;5&#x2F;\n    path(&#39;&lt;int:question_id&gt;&#x2F;&#39;, views.detail, name&#x3D;&#39;detail&#39;),\n    # ex: &#x2F;polls&#x2F;5&#x2F;results&#x2F;\n    path(&#39;&lt;int:question_id&gt;&#x2F;results&#x2F;&#39;, views.results, name&#x3D;&#39;results&#39;),\n    # ex: &#x2F;polls&#x2F;5&#x2F;vote&#x2F;\n    path(&#39;&lt;int:question_id&gt;&#x2F;vote&#x2F;&#39;, views.vote, name&#x3D;&#39;vote&#39;),\n]\n\n如果你转到 “/polls/34/“ ，Django 将会运行 detail() 方法并且展示你在 URL 里提供的问题 ID。也就是说当某人请求你网站的某一页面时——比如”/polls/34/“，那么Django 将会根据配置项 ROOT_URLCONF 中的设置载入 mysite.urls 模块，然后寻找名为 urlpatterns 变量并且按序匹配正则表达式。在找到匹配项 &#39;polls/&#39;，它切掉了匹配的文本（&quot;polls/&quot;），将剩余文本——&quot;34/&quot;，发送至 ‘polls.urls’ URLconf 做进一步处理。在这里剩余文本匹配了 &#39;&lt;int:question_id&gt;/&#39;，使得我们 Django 以如下形式调用 detail():\ndetail(request&#x3D;&lt;HttpRequest object&gt;, question_id&#x3D;34)\n\n这样便完成了基本的前后端交互\n","slug":"Web Dev/Back End/django/official website basic tutorial/official_website_basic_tutorial-part_3","date":"2023-03-08T00:30:41.946Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"Web Dev/Back End/django/official website basic tutorial/official_website_basic_tutorial-part_4","date":"2023-03-08T00:30:41.944Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"YARNyarn介绍：\n类型——包管理工具，类同npm\n出品方：脸书\n\n安装yarnnpm install -g yarn\n\n查看并配置：yarn -v # 查看yarn版本\nyarn config list # 查看所有yarn配置\nyarn config set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F; # 设为淘宝源\nyarn config set registry https:&#x2F;&#x2F;registry.yarnpkg.com # 设为默认源\nyarn config set global-folder &quot;D:\\RTE\\Yarn\\global&quot; # 请修改具体目录\nyarn config set prefix &quot;D:\\RTE\\Yarn\\global\\&quot; # 但是好像prefix作为全局变量保存地无法使用？注意global-folder中也有保存cmd文件的文件夹，还可以使用后者\nyarn config set cache-folder &quot;D:\\RTE\\Yarn\\cache&quot; # 请修改具体目录\nyarn global dir # 查看全局安装目录\nyarn global bin # 查看全局bin位置\n\n显示命令列表：yarn help            \n\n官网https://www.yarnpkg.cn/getting-started/usage\n可参考地址https://www.cnblogs.com/hellomrr/p/13237653.html\nhttps://zhuanlan.zhihu.com/p/108370177\n","slug":"Web Dev/Front End/Yarn/基本命令与配置","date":"2023-03-08T00:28:44.435Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"this.$router.pushthis.$router.go&#x2F;&#x2F; 字符串\nthis.$router.push(&#39;&#x2F;home&#x2F;first&#39;)\n&#x2F;&#x2F; 对象\nthis.$router.push(&#123; path: &#39;&#x2F;home&#x2F;first&#39; &#125;)\n&#x2F;&#x2F; 命名的路由\nthis.$router.push(&#123; name: &#39;home&#39;, params: &#123; myid: id &#125;&#125;)\n\n\n\n&lt;!----&gt;\n&lt;button @click&#x3D;&quot;goback&quot;&gt;返回上页&lt;&#x2F;button&gt;\n\nmethods:&#123;\n  goback()&#123;\n    this.$router.go(-1)\n  &#125;\n&#125;\n\n\n\n&lt;!-- jump to certain page --&gt;\n&lt;button @click&#x3D;&quot;goToLink&quot;&gt;返回page1&lt;&#x2F;button&gt;\n\nmethods:&#123;\n  goToLink()&#123;\n    this.$router.push(&#39;&#x2F;page1&#39;)\n&#125;\n&lt;!-- &#x3D;&#x3D; --&gt;\nthis.$router.push(&#123;name:&#39;page1&#39;&#125;)\n\n\n\n1、作用：this.$router.push() 可以通过修改url实现路由跳转。\n2、push 后面可以是对象，也可以是字符串：\n.Params\n由于动态路由也是传递params的，所以在 this.$router.push() 方法中path不能和params一起使用，否则params将无效。需要用name来指定页面。\n及通过路由配置的name属性访问\n在路由配置文件中定义参数：\n通过name获取页面，传递params：\n在目标页面通过this.$route.params获取参数：{path: ‘/detail/:myid’, // 动态路由name: ‘home’, // 命名路由component: Detail},\nVue 动态路由 与 命名路由","slug":"Web Dev/Front End/VUE/page jump","date":"2023-03-08T00:28:44.433Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Problems in Vue projects you may meet1. your Vue is blank&lt;template&gt;\n\n&lt;!-- notice! you should know that the router view is the most important label in the parent page, if it doesn&#39;t exist, you can only see the blank page! ---&gt;\n\t&lt;router-view&#x2F;&gt;\n\t&lt;!-- notice! you should know that the router view is the most important label in the parent page, if it doesn&#39;t exist, you can only see the blank page! ---&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &quot;defaultPage&quot;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n\n&lt;&#x2F;style&gt;\n\n不管你创建的是第几级路由，总要有一个该级别的路由总页面，并且在这个总页面上要存在 &lt;router-view&gt; 标签来指明展示子级页面\n","slug":"Web Dev/Front End/VUE/ProblemsMeetInVue","date":"2023-03-08T00:28:44.431Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"vue-router：404页面路由配置&#123;\n    name:&#39;404&#39;,\n    path:&#39;&#x2F;404.html&#39;,\n    component: resolve &#x3D;&gt; require([&#39;..&#x2F;page&#x2F;NotFound&#x2F;view.vue&#39;], resolve),\n&#125;,\n&#123;\n     path:&#39;*&#39;,\n     redirect:&#123;\n         name:&quot;404&quot;\n     &#125;\n&#125;\n\n","slug":"Web Dev/Front End/VUE/Router","date":"2023-03-08T00:28:44.428Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"These dependencies were not found:&lt;template&gt;\n  &lt;router-view&#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &quot;defaultPage&quot;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n\n&lt;&#x2F;style&gt;\n","slug":"Web Dev/Front End/VUE/These dependencies were not found","date":"2023-03-08T00:28:44.425Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"Web Dev/Front End/VUE/Vue入门","date":"2023-03-08T00:28:44.423Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"vue父子组件之间的传值\n\n\n\n\n\n\n\n\n本章主要说下父子组件的传值。 Github：https://github.com/Ewall1106/mall\n父组件向子组件传值\n第一个就是要明白怎么在父页面中向子组件中传值？你可以给子组件传入一个静态的值：\n\n\n图片来自vue官网\n\n但我们一般都是需要传动态的值，所以需要v-bind绑定，当然，你传的值可以是数字、对象、数组等等，参见vue官网。\n\n\n图片来自vue官网\n\n第二个就是要知道如何在子组件中接受父页面传过来的值，有几点需要了解：\n组件实例的作用域是孤立的。\n子组件要显式的用props选项声明它预期的数据，如：\n\n\n\n&#x2F;&#x2F; 某个子组件中：\nexport default &#123;\n  props: &#123;\n    title: &#123;\n      type: String,\n      default: &#39;hello world&#39;\n    &#125;\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n以上就是单向数据流的一般表现了： 父级 prop 的更新会向下流动到子组件中，但是反过来则不行。\n子组件向父组件传值那么我们延伸一下，子组件怎么向父组件传值？\n1. 基本概念\n在vue中，父子组件的关系可以总结为prop向下传递，事件向上传递。父组件通过prop给子组件下发数据，子组件通过事件给父组件发送信息。\n\n\nprops down , events up\n\n每个Vue实例都实现了事件接口：使用$on(evntName)监听事件；使用$emit(eventName,optionalPayload)触发事件。另外，父组件可以在使用子组件的地方直接用v-on来监听子组件触发的事件。\n\n2. 举例说明\n父组件在组件上定义了一个自定义事件childFn，事件名为parentFn用于接受子组件传过来的message值。\n\n&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n    &lt;div class&#x3D;&quot;test&quot;&gt;\n      &lt;test-com @childFn&#x3D;&quot;parentFn&quot;&gt;&lt;&#x2F;test-com&gt;\n      &lt;br&#x2F;&gt; \n      子组件传来的值 : &#123;&#123;message&#125;&#125;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n    &#x2F;&#x2F; ...\n    data() &#123;\n        return &#123;\n             message: &#39;&#39;\n        &#125;\n    &#125;,\n    methods: &#123;\n       parentFn(payload) &#123;\n        this.message &#x3D; payload;\n      &#125;\n    &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n子组件是一个buttton按钮，并为其添加了一个click事件，当点击的时候使用$emit()触发事件，把message传给父组件。\n\n&lt;!-- 子组件 --&gt;\n&lt;template&gt; \n&lt;div class&#x3D;&quot;testCom&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot; &#x2F;&gt;\n    &lt;button @click&#x3D;&quot;click&quot;&gt;Send&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n    &#x2F;&#x2F; ...\n    data() &#123;\n        return &#123;\n          &#x2F;&#x2F; 默认\n          message: &#39;我是来自子组件的消息&#39;\n        &#125;\n    &#125;,\n    methods: &#123;\n      click() &#123;\n            this.$emit(&#39;childFn&#39;, this.message);\n        &#125;\n    &#125;    \n&#125;\n&lt;&#x2F;script&gt;\n\n\n这样我们就基本实现了子组件向父组件发送值了:\n\n点击send发送\n\n\n\n父组件接收组件传过来的值\n小结\n通过&quot;props down , events up&quot;我们就简单的实现了父子组件之间的双向传值，这是很基本的知识点，其它还有$invoke等等方法，大家可以去官网好好看看。\n关于通信和状态管理就必须了解vuex了，后面我们在项目中当涉及了再好好讲。\n\nvue中 关于$emit的用法1、父组件可以使用 props 把数据传给子组件。 2、子组件可以使用 $emit 触发父组件的自定义事件。\nvm.$emit( event, arg ) //触发当前实例上的事件\nvm.$on( event, fn );//监听event事件后运行 fn； \n图一：点击之前例如：子组件：\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;train-city&quot;&gt;\n    &lt;h3&gt;父组件传给子组件的toCity:&#123;&#123;sendData&#125;&#125;&lt;&#x2F;h3&gt; \n    &lt;br&#x2F;&gt;&lt;button @click&#x3D;&#39;select(&#96;大连&#96;)&#39;&gt;点击此处将‘大连’发射给父组件&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n  export default &#123;\n    name:&#39;trainCity&#39;,\n    props:[&#39;sendData&#39;], &#x2F;&#x2F; 用来接收父组件传给子组件的数据\n    methods:&#123;\n      select(val) &#123;\n        let data &#x3D; &#123;\n          cityname: val\n        &#125;;\n        this.$emit(&#39;showCityName&#39;,data);&#x2F;&#x2F;select事件触发后，自动触发showCityName事件\n      &#125;\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\n父组件：\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;div&gt;父组件的toCity&#123;&#123;toCity&#125;&#125;&lt;&#x2F;div&gt;\n        &lt;train-city @showCityName&#x3D;&quot;updateCity&quot; :sendData&#x3D;&quot;toCity&quot;&gt;&lt;&#x2F;train-city&gt;\n    &lt;&#x2F;div&gt;\n&lt;template&gt;\n&lt;script&gt;\n  import TrainCity from &quot;.&#x2F;train-city&quot;;\n  export default &#123;\n    name:&#39;index&#39;,\n    components: &#123;TrainCity&#125;,\n    data () &#123;\n      return &#123;\n        toCity:&quot;北京&quot;\n      &#125;\n    &#125;,\n    methods:&#123;\n      updateCity(data)&#123;&#x2F;&#x2F;触发子组件城市选择-选择城市的事件\n        this.toCity &#x3D; data.cityname;&#x2F;&#x2F;改变了父组件的值\n        console.log(&#39;toCity:&#39;+this.toCity)\n      &#125;\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\n图一：点击之前的数据的数据\n\n图二：点击之后的数据\n\n","slug":"Web Dev/Front End/VUE/父子组件交互","date":"2023-03-08T00:28:44.418Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\nbeforeCreate( 创建前 )在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。\ncreated ( 创建后 ）实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成\nbeforeMount挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。\nmounted挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。\nbeforeUpdate在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程\nupdated（更新后）在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用\nbeforeDestroy（销毁前）在实例销毁之前调用，实例仍然完全可用，\n这一步还可以用this来获取实例，一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件\ndestroyed（销毁后）在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用\n","slug":"Web Dev/Front End/VUE/生命周期","date":"2023-03-08T00:28:44.416Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"NPM基本命令修改npm源设置npm下载来源为淘宝源\n查看当前源npm config get registry \n设置为淘宝源\n\nnpm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org  \n\n临时使用源（适用于一次性使用）\n\nnpm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install XXX（module name）\n还原默认源：npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F;\n\n采用cnpm\ncnpm介绍：淘宝搭建的一个国内的npm服务器，以10分钟每次的速度将npm仓库中的所有内容“搬运”到国内\ncnpm安装：npm install -g cnpm –registry=https://registry.npm.taobao.org\ncnpm与npm的关系：cnpm就是npm的另一个版本，是node中一个不同的下载器，只包含了npm的下载功能\n\nnrm\nnrm介绍：nrm是npm注册表的管理工具，可以添加、删除、查询、切换npm注册表。 什么是nrm nrm 是一个npm源管理器，允许你快速地在npm源间切换。\nnrm简单使用：\n\n修改NPM的缓存以及全局安装地址：\n查看设置\n\nnpm config ls\n\n\n设置全局安装地址：\n\nnpm config set prefix &quot;D:&#x2F;npm&#x2F;npm_Download&quot;\n\n\n设置缓存地址\n\nnpm config set cache &quot;D:&#x2F;npm&#x2F;npm_Cache&quot;\n\n\n清除缓存：\n\nnpm cache clean --force\n\t&#96;&#96;&#96;npm WARN using --force I sure hope you know what you are doing.\n\n\n\nNPM管理安装包：\n查看已经安装的包：\n\nnpm list -g --depth 0\n\n更新包：npm update -g xxx\n卸载包：npm uninstall -g xxx\n\n","slug":"Web Dev/Front End/NPM/基本命令与配置","date":"2023-03-08T00:28:44.413Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"API 中文手册 · d3/d3 Wiki (github.com)\n","slug":"Web Dev/Front End/D3/00.d3手册","date":"2023-03-08T00:28:44.411Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"D3.js - Data-Driven Documents (d3js.org)\nHome · d3/d3 Wiki (github.com)\nLearn D3: Introduction / D3 / Observable (observablehq.com)\nD3库中所有函数都在“d3”命名空间内。\nD3 使用语义版本命名。 你可以使用“d3.version”查看D3的最新版本\nD3 API总览\n\n核心 - 包括选择器，过渡，数据处理，本地化，颜色等。\n地理 - 球面坐标，经纬度运算。\n几何 - 提供绘制2D几何图形的实用工具。\n布局 - 推导定位元素的辅助数据。\n比例尺 - 数据编码和视觉编码之间转换。\n可缩放矢量图形 - 提供用于创建可伸缩矢量图形的实用工具。\n时间 - 解析或格式化时间，计算日历的时间间隔等。\n行为 - 可重用交互行为\n\n","slug":"Web Dev/Front End/D3/01.d3是怎样运作的","date":"2023-03-08T00:28:44.409Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"THE DEFFERENCE BETWEEN SVG ELEMENT(CODE) AND SVG FILE\nreference: \n\nHow can I save svg code as a .svg image? - Stack Overflow\n\nconclusions:\n\n“Just had to make sure it has attribute: xmlns and versions, and then save it in a text file and give it a .svg extension. Also make sure to add xml tag a the top of the svg file just before pasting the svg tag &lt;?xml version=”1.0” encoding=”utf-8”?&gt;“\nSAVE (RATHER: DOWNLOAD) THE SVG ELEMENT:\nrefenece: javascript - How do I save/export an SVG file after creating an SVG with D3.js (IE, safari and chrome)? - Stack Overflow\n\ncode (which was  used in NeatSankey) :\n\n\nfunction save_as_svg()&#123;\n        var svg_data &#x3D; document.getElementById(&quot;svg&quot;).innerHTML &#x2F;&#x2F;put id of your svg element here\n\n        var head &#x3D; &#39;&lt;svg title&#x3D;&quot;graph&quot; version&#x3D;&quot;1.1&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;&gt;&#39;\n\n        &#x2F;&#x2F;if you have some additional styling like graph edges put them inside &lt;style&gt; tag\n\n        var style &#x3D; &#39;&lt;style&gt;&lt;&#x2F;style&gt;&#39;\n\n        var full_svg &#x3D; head +  style + svg_data + &quot;&lt;&#x2F;svg&gt;&quot;\n        var blob &#x3D; new Blob([full_svg], &#123;type: &quot;image&#x2F;svg+xml&quot;&#125;);  \n        saveAs(blob, &quot;graph.svg&quot;);\n&#125;;\n\nMETHOD NOT EXAMINED:\nreference: URL.createObjectURL() - Web API 接口参考 | MDN (mozilla.org)\n\ncode:\n\n\nvar svgData &#x3D; $(&quot;#figureSvg&quot;)[0].outerHTML;\nvar svgBlob &#x3D; new Blob([svgData], &#123;type:&quot;image&#x2F;svg+xml;charset&#x3D;utf-8&quot;&#125;);\nvar svgUrl &#x3D; URL.createObjectURL(svgBlob);\nvar downloadLink &#x3D; document.createElement(&quot;a&quot;);\n\ndownloadLink.href &#x3D; svgUrl;\ndownloadLink.download &#x3D; &quot;newesttree.svg&quot;;\ndocument.body.appendChild(downloadLink);\ndownloadLink.click();\ndocument.body.removeChild(downloadLink);\n\n\n\nMORE RESOURCE\neligrey/FileSaver.js: An HTML5 saveAs() FileSaver implementation (github.com)\n\njimmywarting/StreamSaver.js: StreamSaver writes stream to the filesystem directly asynchronous (github.com)\n\nFileSaver.js 介绍 - yunser_blog - 博客园 (cnblogs.com)\n\n\n\nWorking with files - Mozilla | MDN\n\n","slug":"Web Dev/Front End/D3/download svg pic","date":"2023-03-08T00:28:44.405Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"#🐒\n#D3的命名含义\n\n示例：v3.0.0\n含义：主版本号.次版本号.修订号\n解释：\n主版本号：当你做了不兼容的API修改\n次版本号：当你做了向下兼容的功能性更新\n修订号：当你做了向下兼容的问题修正\n\n\n\n#可视化的过程\n\n获取 ———— Acquire\n分析 ———— Parse\n过滤 ———— Filter\n挖掘 ———— Mine\n表现 ———— Represent\n改善 ———— Refine\n交互 ———— Interact\n\n#js基础\n\n变量的数据类型：\nundefined：未初始化或者未赋值的变量都是undefined，当然，你也可以将变量初始化为undefined\nnull：null表示一个空对象，也可以拿它对变量赋初值\nboolean：布尔类型，只有两个值：true和false  **在条件语句（如if）种，所有值都会被转化为布尔值(对策见右)**：0, NaN, undefined, null, “”(空字符串) =&gt; false；其他所有值 =&gt; true  -number：支持十进制、八进制、十六进制\nstring：单引号和双引号作用相同，两个字符串还可以通过“ + ”来拼接\nobject：对象类型，是拥有属性和方法的数据类型\n\n\n操作符：\n算数操作符：+、-、*、/\n赋值操作符：+=、-=、*=、/=、=\n布尔操作符：！、&amp;&amp;、||、\n关系操作符：&gt;、&lt;、&gt;=、&lt;=、!=、==\n条件操作符(只有一个)：？  var result &#x3D; 5 &gt; 3 ? true : false;\t\t&#x2F;&#x2F;true\n&#x2F;&#x2F;如果问号前为true，则返回冒号前的值(true)，否则返回冒号后的值(false)\n\n\n常见语句\nif else语句\nwhile、do while语句\nfor和for in语句\nswitch语句\nbreak、continue、label语句\n\n\n定义函数\nfunction语句  可以将一个函数赋给一个变量！  ```html\n      var add = function(num1, num2)&#123;\n          return num1 + num2;\n      &#125;\n      \n      console.log(add(1,2))                                    //在控制台打印 3\n  ```//将一个无名函数的功能赋给了add变量\n\n\n\n\n\n\n","slug":"Web Dev/Front End/D3/d3","date":"2023-03-08T00:28:44.402Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"今日开发重点：登陆页面重要的知识点：\n如下所示，是css中简单的样式，用css可以大幅降低js的难度！\n 1、a:link{color:#fff}  未访问时的状态（鼠标点击前显示的状态）\n 2、a:hover{color:#fff}  鼠标悬停时的状态\n 3、a:visited{color:#fff}  已访问过的状态（鼠标点击后的状态）\n 4、a:active{color:#fff}  鼠标点击时的状态\n 5、a:focus{color:#fff}  点击后鼠标移开保持鼠标点击时的状态（只有在时标签中有效）\n\n只有前端哟！要努力做后端了！\n\n整个页面的状态！通用选择器？\n\n跨设备的适配！头大\n\n\n\n\n\n\n\n\n\ninput::-webkit-input-placeholder\ninput::-moz-placeholder\n\n\n日记部分：​    这种日记，是从今天——2021/2/21日重新开机的，我已经很久，很久很久没有写过日记了，其实吧，我觉得还是纸质的日记更好一点，电子的胜在方便，确实，这是互联网设备的生命线\n​    那么，这样子又是一天了，这样子还蛮充实的:)\n 和cpu斗智斗勇挺不错的，不过也确实应该积极运动，完全可以把！一部分！时间用在别的地方\n\n​    阿里啊，技术还行，不过也确实怪不得他们，上有政策，哎，这也是我的疏忽，就当是花钱打水漂了\n​    真是让人摸不着头脑，我又不是违法公民，凭什么剥夺我做blog的权利？\n​    高校的课程真的忙吗？\n​    抓紧时间了！我们还有比赛呢！\n","slug":"Web Dev/Front End/blog开发日志/2021.2.21","date":"2023-03-08T00:28:44.398Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\nMaven Command\nDescription\n\n\n\nmvn –version\nPrints out the version of Maven you are running.\n\n\nmvn clean\nClears the target directory into which Maven normally builds your project.\n\n\nmvn package\nBuilds the project and packages the resulting JAR file into the target directory.\n\n\nmvn package -Dmaven.test.skip=true\nBuilds the project and packages the resulting JAR file into the target directory - without running the unit tests during the build.\n\n\nmvn clean package\nClears the target directory and Builds the project and packages the resulting JAR file into the target directory.\n\n\nmvn clean package - Dmaven.test.skip=true\nClears the target directory and builds the project and packages the resulting JAR file into the target directory - without running the unit tests during the build.\n\n\nmvn verify\nRuns all integration tests found in the project.\n\n\nmvn clean verify\nCleans the target directory, and runs all integration tests found in the project.\n\n\nmvn install\nBuilds the project described by your Maven POM file and installs the resulting artifact (JAR) into your local Maven repository\n\n\nmvn install -Dmaven.test.skip=true\nBuilds the project described by your Maven POM file without running unit tests, and installs the resulting artifact (JAR) into your local Maven repository\n\n\nmvn clean install\nClears the target directory and builds the project described by your Maven POM file and installs the resulting artifact (JAR) into your local Maven repository\n\n\nmvn clean install -Dmaven.test.skip=true\nClears the target directory and builds the project described by your Maven POM file without running unit tests, and installs the resulting artifact (JAR) into your local Maven repository\n\n\nmvn dependency:copy-dependencies\nCopies dependencies from remote Maven repositories to your local Maven repository.\n\n\nmvn clean dependency:copy-dependencies\nCleans project and copies dependencies from remote Maven repositories to your local Maven repository.\n\n\nmvn clean dependency:copy-dependencies package\nCleans project, copies dependencies from remote Maven repositories to your local Maven repository and packages your project.\n\n\nmvn dependency:tree\nPrints out the dependency tree for your project - based on the dependencies configured in the pom.xml file.\n\n\nmvn dependency:tree -Dverbose\nPrints out the dependency tree for your project - based on the dependencies configured in the pom.xml file. Includes repeated, transitive dependencies.\n\n\nmvn dependency:tree -Dincludes=com.fasterxml.jackson.core\nPrints out the dependencies from your project which depend on the com.fasterxml.jackson.core artifact.\n\n\nmvn dependency:tree -Dverbose -Dincludes=com.fasterxml.jackson.core\nPrints out the dependencies from your project which depend on the com.fasterxml.jackson.core artifact. Includes repeated, transitive dependencies.\n\n\nmvn dependency:build-classpath\nPrints out the classpath needed to run your project (application) based on the dependencies configured in the pom.xml file.\n\n\n","slug":"Web Dev/Back End/MAVEN/COMMAND","date":"2023-03-08T00:28:44.393Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"Web Dev/Back End/SpringBoot/FirstSpringBootApplication","date":"2023-03-08T00:28:44.385Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"pom.xml Structure![(project .  CInodeIVersion&gt;4. O.  i transwarD. I earn  (version&gt; I.  &lt;pmpert  (dependenci  (dependency)  d) groupld)  (art i fact I t Id)  (version) I. ](C:\\Users\\m1518\\OneDrive\\文档\\Document\\Web Dev\\Back End\\MAVEN\\MAVEN-poml-file_Structure_PIC00.png)\n其中，groupId类似于Java的包名，通常是公司或组织名称\nartifactId类似于Java的类名，通常是项目名称\n再加上version\n一个Maven工程就是由groupId，artifactId和version作为唯一标识。\n我们在引用其他第三方库的时候，也是通过这3个变量确定。\n例如，依赖commons-logging：![ep end enc y)  (art fac t art fac t  (version&gt;l.  c/dependency&gt; ](C:\\Users\\m1518\\OneDrive\\文档\\Document\\Web Dev\\Back End\\MAVEN\\MAVEN-poml-file_Structure_PIC01.png)\n使用&lt;\\dependency&gt;声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。\n但是version target is not necessary！\n但是，并不是所有依赖都需要声明version，\n","slug":"Web Dev/Back End/MAVEN/MAVEN-poml-file_Structure","date":"2023-03-08T00:28:42.161Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Maven官方的中央仓库：Central Repository: (apache.org)\nStructuresMaven项目结构\n一个使用Maven管理的普通的Java项目，它的目录结构默认如下：\n![IMG](C:\\Users\\m1518\\OneDrive\\文档\\Document\\Web Dev\\Back End\\MAVEN\\MAVEN-Project_Structure00.png)\n项目的根目录a-maven-project是项目名\n有一个项目描述文件pom.xml，存放Java源码的目录是src/main/java\n存放资源文件的目录是src/main/resources\n存放测试源码的目录是src/test/java\n存放测试资源的目录是src/test/resources\n最后，所有编译、打包生成的文件都放在target目录里\n这些就是一个Maven项目的标准目录结构\n","slug":"Web Dev/Back End/MAVEN/MAVEN-Project_Structure","date":"2023-03-08T00:28:42.159Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"How to Deploy Flask Application with Nginx and Gunicorn on Ubuntu 20.04 - RoseHosting\n","slug":"Web Dev/Back End/flask/DEPLOY","date":"2023-03-08T00:28:42.155Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"快速上手对应的官网页面：快速上手 — Flask 中文文档 (2.0.2) (dormousehole.readthedocs.io)\n一个最小的应用一个最小的 Flask 应用如下：\nfrom flask import Flask\n\napp &#x3D; Flask(__name__)\n\n@app.route(&quot;&#x2F;&quot;)\ndef hello_world():\n    return &quot;&lt;p&gt;Hello, World!&lt;&#x2F;p&gt;&quot;\n\n那么，这些代码是什么意思呢？\n\n首先我们导入了 Flask 类。该类的实例将会成为我们的 WSGI 应用。\n接着我们创建一个该类的实例。第一个参数是应用模块或者包的名称。 __name__ 是一个适用于大多数情况的快捷方式。有了这个参数， Flask 才能知道在哪里可以找到模板和静态文件等东西。\n然后我们使用 route() 装饰器来告诉 Flask 触发函数 的 URL 。\n函数返回需要在用户浏览器中显示的信息。默认的内容类型是 HTML ，因此字 符串中的 HTML 会被浏览器渲染。\n\n把它保存为 hello.py 或其他类似名称。\n\n\n\n\n\n\n\nWARNING\n请不要使用 flask.py 作为应用名称，这会与 Flask 本身发生冲突。\n\n\n可以使用 flask 命令或者 python 的 -m 开关来运行这个应 用。在运行应用之前，需要在终端里导出 FLASK_APP 环境变量：\nPowershell\n&gt; $env:FLASK_APP &#x3D; &quot;hello&quot;\n&gt; flask run\n * Running on http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;\n\n应用发现行为\n作为一个捷径，如果文件名为 app.py 或者 wsgi.py ，那么您不 需要设置 FLASK_APP 环境变量。详见 命令行接口 。\n这样就启动了一个非常简单的内建的服务器。这个服务器用于测试应该是足够了， 但是用于生产可能是不够的。关于部署的有关内容参见 部署方式 。\n现在在浏览器中打开 http://127.0.0.1:5000/ ，应该可以看到 Hello World! 字样。\n外部可见的服务器\n运行服务器后，会发现只有您自己的电脑可以使用服务，而网络中的其他电脑却 不行。缺省设置就是这样的，因为在调试模式下该应用的用户可以执行您电脑中 的任意 Python 代码。\n如果您关闭了调试器或信任您网络中的用户，那么可以让服务器被公开访问。 只要在命令行上简单的加上 --host=0.0.0.0 即可:\n$ flask run --host&#x3D;0.0.0.0\n\n这行代码告诉您的操作系统监听所有公开的 IP 。\n如果服务器不能启动怎么办假如运行 python -m flask 命令失败或者 flask 命令 不存在，那么可能会有多种原因导致失败。首先应该检查错误信息。\n老版本的 Flask版本低于 0.11 的 Flask，启动应用的方式是不同的。\n简单的说就是 flask 和 python -m flask 命令都无法使用。在这种情 况下有两个选择：一是升级 Flask 到更新的版本，二是参阅 开发服务器 ， 学习其他启动服务器的方法。\n非法导入名称FLASK_APP 环境变量中储存的是模块的名称，运行 flask run 命令就 会导入这个模块。如果模块的名称不对，那么就会出现导入错误。出现错误的时机是在 应用开始的时候。如果调试模式打开的情况下，会在运行到应用开始的时候出现导入 错误。出错信息会告诉您尝试导入哪个模块时出错，为什么会出错。\n最常见的错误是因为拼写错误而没有真正创建一个 app 对象。\n调试模式flask run 命令不只可以启动开发服务器。如果您打开调试模式，那么服务 器会在修改应用代码之后自动重启，并且当请求过程中发生错误时还会在浏览器 中提供一个交互调试器。\n\n:::Warning\n调试器允许执行来自浏览器的任意 Python 代码。虽然它由一个 pin 保护， 但仍然存在巨大安全风险。不要在生产环境中运行开发服务器或调试器。\n:::\n如果需要打开所有开发功能，那么需要在运行 flask run 之前设置 FLASK_ENV 环境变量为 development 。\nPowershell\n&gt; $env:FLASK_ENV &#x3D; &quot;development&quot;\n&gt; flask run\n\n另见：\n\n开发服务器 和 命令行接口 包含有关开发模式运行的内容。\n调试应用程序错误 包含有关内置调试器和其他调试器的内容。\n日志 和 应用错误处理 包含有关日志记录和显示友好 的出错信息页面的内容\n\nHTML 转义当返回 HTML （ Flask 中的默认响应类型）时，为了防止注入攻击，所有用户提供的值在输出渲染前必须被转义。使用 Jinja （这个稍后会介绍）渲染的 HTML 模板会自动执行此操作。\n在下面展示的 escape() 可以手动转义。因为保持简洁的原因，在多数示例中它被省略了，但您应该始终留心处理不可信的数据。\nfrom markupsafe import escape\n\n@app.route(&quot;&#x2F;&lt;name&gt;&quot;) # 在这里定义了一个&lt;name&gt;来接收用用户内容\ndef hello(name):\n    return f&quot;Hello, &#123;escape(name)&#125;!&quot;\n\n如果一个用户想要提交其名称为 &lt;script&gt;alert(&quot;bad&quot;)&lt;/script&gt; ，那么 宁可转义为文本，也好过在浏览器中执行脚本。\n路由中的 &lt;name&gt; 从 URL 中捕获值并将其传递给视图函数。这些变量规则见 下文。\n路由现代 web 应用都使用有意义的 URL ，这样有助于用户记忆，网页会更得到用户的青睐， 提高回头率。\n使用 route() 装饰器来把函数绑定到 URL:\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return &#39;Index Page&#39;\n\n@app.route(&#39;&#x2F;hello&#39;)\ndef hello():\n    return &#39;Hello, World&#39;\n\n但是能做的不仅仅是这些！您可以动态变化 URL 的某些部分， 还可以为一个函数指定多个规则。\n变量规则通过把 URL 的一部分标记为 &lt;variable_name&gt; 就可以在 URL 中添加变量。标记的部分会作为关键字参数传递给函数。通过使用 &lt;converter:variable_name&gt; ，可以 选择性的 加上一个转换器，为变量指定规则。请看下面的例子:\nfrom markupsafe import escape\n\n@app.route(&#39;&#x2F;user&#x2F;&lt;username&gt;&#39;)\ndef show_user_profile(username):\n    # show the user profile for that user\n    return f&#39;User &#123;escape(username)&#125;&#39;\n\n@app.route(&#39;&#x2F;post&#x2F;&lt;int:post_id&gt;&#39;)\ndef show_post(post_id):\n    # show the post with the given id, the id is an integer\n    return f&#39;Post &#123;post_id&#125;&#39;\n\n@app.route(&#39;&#x2F;path&#x2F;&lt;path:subpath&gt;&#39;)\ndef show_subpath(subpath):\n    # show the subpath after &#x2F;path&#x2F;\n    return f&#39;Subpath &#123;escape(subpath)&#125;&#39;\n\n转换器类型：\n\n\n\nstring\n（缺省值） 接受任何 不包含斜杠 的文本\n\n\n\nint\n接受 正 整数\n\n\nfloat\n接受 正 浮点数\n\n\npath\n类似 string ，但可以包含斜杠\n\n\nuuid\n接受 UUID 字符串\n\n\n唯一的 URL / 重定向行为以下两条规则的不同之处在于是否使用尾部的斜杠。:\n@app.route(&#39;&#x2F;projects&#x2F;&#39;)\ndef projects():\n    return &#39;The project page&#39;\n\n@app.route(&#39;&#x2F;about&#39;)\ndef about():\n    return &#39;The about page&#39;\n\nprojects 的 URL 是中规中矩的，尾部有一个斜杠，看起来就如同一个文件 夹。\n访问一个没有斜杠结尾的 URL （ /projects ）时 Flask 会自动进行重定向，帮您在尾部加上一个斜杠（ /projects/ ）\nabout 的 URL 没有尾部斜杠，因此其行为表现与一个文件类似。如果访问这 个 URL 时添加了尾部斜杠（/about/ ）就会得到一个 404 “未找到” 错 误。这样可以保持 URL 唯一，并有助于搜索引擎重复索引同一页面。\nURL 构建url_for() 函数用于构建指定函数的 URL。它把函数名称作为第一个 参数。它可以接受任意个关键字参数，每个关键字参数对应 URL 中的变量。未知变量 将添加到 URL 中作为查询参数。\n为什么不在把 URL 写死在模板中，而要使用反转函数 url_for() 动态构建？\n\n反转通常比硬编码 URL 的描述性更好。\n您可以只在一个地方改变 URL ，而不用到处乱找。\nURL 创建会为您处理特殊字符的转义，比较直观。\n生产的路径总是绝对路径，可以避免相对路径产生副作用。\n如果您的应用是放在 URL 根路径之外的地方（如在 /myapplication 中，不在 / 中）， url_for() 会为您妥善处理。\n\n例如，这里我们使用 test_request_context() 方法来尝试使用 url_for() 。 test_request_context() 告诉 Flask 正在处理一个请求，而实际上也许我们正处在交互 Python shell 之中， 并没有真正的请求。参见 本地环境 。\nfrom flask import url_for\n\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return &#39;index&#39;\n\n@app.route(&#39;&#x2F;login&#39;)\ndef login():\n    return &#39;login&#39;\n\n@app.route(&#39;&#x2F;user&#x2F;&lt;username&gt;&#39;)\ndef profile(username):\n    return f&#39;&#123;username&#125;\\&#39;s profile&#39;\n\nwith app.test_request_context():\n    print(url_for(&#39;index&#39;))\n    print(url_for(&#39;login&#39;))\n    print(url_for(&#39;login&#39;, next&#x3D;&#39;&#x2F;&#39;))\n    print(url_for(&#39;profile&#39;, username&#x3D;&#39;John Doe&#39;))\n&#x2F;\n&#x2F;login\n&#x2F;login?next&#x3D;&#x2F;\n&#x2F;user&#x2F;John%20Doe\n\nHTTP 方法Web 应用使用不同的 HTTP 方法处理 URL 。当您使用 Flask 时，应当熟悉 HTTP 方法。 缺省情况下，一个路由只回应 GET 请求。 可以使用 route() 装饰器的 methods 参数来处理不同的 HTTP 方法:\nfrom flask import request\n\n@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])\ndef login():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        return do_the_login()\n    else:\n        return show_the_login_form()\n\n如果当前使用了 GET 方法， Flask 会自动添加 HEAD 方法支持，并且同时还会 按照 HTTP RFC 来处理 HEAD 请求。同样， OPTIONS 也会自动实现。\n静态文件动态的 web 应用也需要静态文件，一般是 CSS 和 JavaScript 文件。理想情况下您的服务器已经配置好了为您的提供静态文件的服务。但是在开发过程中， Flask 也能做好这项工作。只要在您的包或模块旁边创建一个名为 static 的文件夹就行了。 静态文件位于应用的 /static 中。\n使用特定的 &#39;static&#39; 端点就可以生成相应的 URL\nurl_for(&#39;static&#39;, filename&#x3D;&#39;style.css&#39;)\n\n这个静态文件在文件系统中的位置应该是 static/style.css \n渲染模板在 Python 内部生成 HTML 不好玩，且相当笨拙。因为您必须自己负责 HTML 转义， 以确保应用的安全。因此， Flask 自动为您配置 Jinja2 模板引擎。\n使用 render_template() 方法可以渲染模板，您只要提供模板名称和需要 作为参数传递给模板的变量就行了。下面是一个简单的模板渲染例子:\nfrom flask import render_template\n\n@app.route(&#39;&#x2F;hello&#x2F;&#39;)\n@app.route(&#39;&#x2F;hello&#x2F;&lt;name&gt;&#39;)\ndef hello(name&#x3D;None):\n    return render_template(&#39;hello.html&#39;, name&#x3D;name)\n\nFlask 会在 templates 文件夹内寻找模板。因此，如果您的应用是一个模块， 那么模板文件夹应该在模块旁边；如果是一个包，那么就应该在包里面：\n情形 1 : 一个模块:\n&#x2F;application.py\n&#x2F;templates\n    &#x2F;hello.html\n\n情形 2 : 一个包:\n&#x2F;application\n    &#x2F;__init__.py\n    &#x2F;templates\n        &#x2F;hello.html\n\n您可以充分使用 Jinja2 模板引擎的威力。更多内容，详见官方 Jinja2 模板文档 。\n模板示例：\n&lt;!doctype html&gt;\n&lt;title&gt;Hello from Flask&lt;&#x2F;title&gt;\n&#123;% if name %&#125;\n  &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;&#x2F;h1&gt;\n&#123;% else %&#125;\n  &lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;\n&#123;% endif %&#125;\n\n在模板内部可以像使用 url_for() 和 get_flashed_messages() 函数一样访问 config 、 request 、 session 和 g 1 对象。\n模板在继承使用的情况下尤其有用。其工作原理参见 模板继承 。简单的说，模板继承可以使每个页面 的特定元素（如页头、导航和页尾）保持一致。\n自动转义默认开启。因此，如果 name 包含 HTML ，那么会被自动转义。如 果您可以信任某个变量，且知道它是安全的 HTML （例如变量来自一个把 wiki 标记转换为 HTML 的模块），那么可以使用 Markup 类把 它标记为安全的，或者在模板中使用 |safe 过滤器。更多例子参见 Jinja 2 文档。\n下面 Markup 类的基本使用方法:\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; Markup(&#39;&lt;strong&gt;Hello %s!&lt;&#x2F;strong&gt;&#39;) % &#39;&lt;blink&gt;hacker&lt;&#x2F;blink&gt;&#39;\nMarkup(&#39;&lt;strong&gt;Hello &lt;blink&gt;hacker&lt;&#x2F;blink&gt;!&lt;&#x2F;strong&gt;&#39;)\n&gt;&gt;&gt; Markup.escape(&#39;&lt;blink&gt;hacker&lt;&#x2F;blink&gt;&#39;)\nMarkup(&#39;&lt;blink&gt;hacker&lt;&#x2F;blink&gt;&#39;)\n&gt;&gt;&gt; Markup(&#39;&lt;em&gt;Marked up&lt;&#x2F;em&gt; &amp;raquo; HTML&#39;).striptags()\n&#39;Marked up \\xbb HTML&#39;\n\nChangelog\n\n\n1\n不确定 g 对象是什么？它是某个可以根据需要储存信 息的东西，详见 g 对象的文档和 使用 SQLite 3 。\n\n\n操作请求数据对于 web 应用来说对客户端向服务器发送的数据作出响应很重要。在 Flask 中 由全局对象 request 来提供请求信息。如果您有一些 Python 基础，那么可能 会奇怪：既然这个对象是全局的，怎么还能保持线程安全？答案 是本地环境：\n本地环境内部信息\n如果您想了解工作原理和如何使用本地环境进行测试，那么请阅读本节， 否则可以跳过本节。\n某些对象在 Flask 中是全局对象，但不是通常意义下的全局对象。这些对象实际上是 特定环境下本地对象的代理。真拗口！但还是很容易理解的。\n设想现在处于处理线程的环境中。一个请求进来了，服务器决定生成一个新线程（或者 叫其他什么名称的东西，这个下层的东西能够处理包括线程在内的并发系统）。当 Flask 开始其内部请求处理时会把当前线程作为活动环境，并把当前应用和 WSGI 环境绑定到 这个环境（线程）。它以一种聪明的方式使得一个应用可以在不中断的情况下调用另一个 应用。\n这对您有什么用？基本上您可以完全不必理会。这个只有在做单元测试时才有用。在测试 时会遇到由于没有请求对象而导致依赖于请求的代码会突然崩溃的情况。对策是自己创建 一个请求对象并绑定到环境。最简单的单元测试解决方案是使用 test_request_context() 环境管理器。通过使用 with 语句 可以绑定一个测试请求，以便于交互。例如:\nfrom flask import request\n\nwith app.test_request_context(&#39;&#x2F;hello&#39;, method&#x3D;&#39;POST&#39;):\n    # now you can do something with the request until the\n    # end of the with block, such as basic assertions:\n    assert request.path &#x3D;&#x3D; &#39;&#x2F;hello&#39;\n    assert request.method &#x3D;&#x3D; &#39;POST&#39;\n\n另一种方式是把整个 WSGI 环境传递给 request_context() 方法:\nwith app.request_context(environ):\n    assert request.method &#x3D;&#x3D; &#39;POST&#39;\n\n请求对象请求对象在 API 一节中有详细说明这里不细谈（参见 Request ）。 这里简略地谈一下最常见的操作。首先，您必须从 flask 模块导入请求对象:\nfrom flask import request\n\n通过使用 method 属性可以操作当前请求方法，通过使用 form 属性处理表单数据（在 POST 或者 PUT 请求 中传输的数据）。以下是使用上述两个属性的例子:\n@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;POST&#39;, &#39;GET&#39;])\ndef login():\n    error &#x3D; None\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        if valid_login(request.form[&#39;username&#39;],\n                       request.form[&#39;password&#39;]):\n            return log_the_user_in(request.form[&#39;username&#39;])\n        else:\n            error &#x3D; &#39;Invalid username&#x2F;password&#39;\n    # the code below is executed if the request method\n    # was GET or the credentials were invalid\n    return render_template(&#39;login.html&#39;, error&#x3D;error)\n\n当 form 属性中不存在这个键时会发生什么？会引发一个 KeyError 。 如果您不像捕捉一个标准错误一样捕捉 KeyError ，那么会显示一个 HTTP 400 Bad Request 错误页面。因此，多数情况下您不必处理这个问题。\n要操作 URL （如 ?key=value ）中提交的参数可以使用 args 属性:\nsearchword &#x3D; request.args.get(&#39;key&#39;, &#39;&#39;)\n\n用户可能会改变 URL 导致出现一个 400 请求出错页面，这样降低了用户友好度。因此， 我们推荐使用 get 或通过捕捉 KeyError 来访问 URL 参数。\n完整的请求对象方法和属性参见 Request 文档。\n文件上传用 Flask 处理文件上传很容易，只要确保不要忘记在您的 HTML 表单中设置 enctype=&quot;multipart/form-data&quot; 属性就可以了。否则浏览器将不会传送您的文件。\n已上传的文件被储存在内存或文件系统的临时位置。您可以通过请求对象 files 属性来访问上传的文件。每个上传的文件都储存在这个 字典型属性中。这个属性基本和标准 Python file 对象一样，另外多出一个 用于把上传文件保存到服务器的文件系统中的 save() 方法。下例展示其如何运作:\nfrom flask import request\n\n@app.route(&#39;&#x2F;upload&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])\ndef upload_file():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        f &#x3D; request.files[&#39;the_file&#39;]\n        f.save(&#39;&#x2F;var&#x2F;www&#x2F;uploads&#x2F;uploaded_file.txt&#39;)\n    ...\n\n如果想要知道文件上传之前其在客户端系统中的名称，可以使用 filename 属性。但是请牢记这个值是 可以伪造的，永远不要信任这个值。如果想要把客户端的文件名作为服务器上的文件名， 可以通过 Werkzeug 提供的 secure_filename() 函数:\nfrom werkzeug.utils import secure_filename\n\n@app.route(&#39;&#x2F;upload&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])\ndef upload_file():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        file &#x3D; request.files[&#39;the_file&#39;]\n        file.save(f&quot;&#x2F;var&#x2F;www&#x2F;uploads&#x2F;&#123;secure_filename(file.filename)&#125;&quot;)\n    ...\n\n更好的例子参见 上传文件 。\nCookies要访问 cookies ，可以使用 cookies 属性。可以使用响应 对象 的 set_cookie 方法来设置 cookies 。请求对象的 cookies 属性是一个包含了客户端传输的所有 cookies 的字典。在 Flask 中，如果使用 会话 ，那么就不要直接使用 cookies ，因为 会话 比较安全一些。\n读取 cookies:\nfrom flask import request\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    username &#x3D; request.cookies.get(&#39;username&#39;)\n    # use cookies.get(key) instead of cookies[key] to not get a\n    # KeyError if the cookie is missing.\n\n储存 cookies:\nfrom flask import make_response\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    resp &#x3D; make_response(render_template(...))\n    resp.set_cookie(&#39;username&#39;, &#39;the username&#39;)\n    return resp\n\n注意， cookies 设置在响应对象上。通常只是从视图函数返回字符串， Flask 会把它们转换为响应对象。如果您想显式地转换，那么可以使用 make_response() 函数，然后再修改它。\n使用 doc:patterns/deferredcallbacks 方案可以在没有响应对象的情况下设 置一个 cookie 。\n另见 关于响应 。\n重定向和错误使用 redirect() 函数可以重定向。使用 abort() 可以 更早退出请求，并返回错误代码:\nfrom flask import abort, redirect, url_for\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return redirect(url_for(&#39;login&#39;))\n\n@app.route(&#39;&#x2F;login&#39;)\ndef login():\n    abort(401)\n    this_is_never_executed()\n\n上例实际上是没有意义的，它让一个用户从索引页重定向到一个无法访问的页面（401 表示禁止访问）。但是上例可以说明重定向和出错跳出是如何工作的。\n缺省情况下每种出错代码都会对应显示一个黑白的出错页面。使用 errorhandler() 装饰器可以定制出错页面:\n@app.errorhandler(404)\ndef page_not_found(error):\n    return render_template(&#39;page_not_found.html&#39;), 404\n\n注意 render_template() 后面的 404 ，这表示页面对就的出错 代码是 404 ，即页面不存在。缺省情况下 200 表示：一切正常。\n详见 应用错误处理 。\n关于响应视图函数的返回值会自动转换为一个响应对象。如果返回值是一个字符串，那么会被 转换为一个包含作为响应体的字符串、一个 200 OK 出错代码 和一个 text/html 类型的响应对象。如果返回值是一个字典，那么会调用 jsonify() 来产生一个响应。以下是转换的规则：\n\n如果视图返回的是一个响应对象，那么就直接返回它。\n如果返回的是一个字符串，那么根据这个字符串和缺省参数生成一个用于返回的 响应对象。\n如果返回的是一个字典，那么调用 jsonify 创建一个响应对象。\n如果返回的是一个元组，那么元组中的项目可以提供额外的信息。元组中必须至少 包含一个项目，且项目应当由 (response, status) 、 (response, headers) 或者 (response, status, headers) 组成。 status 的值会重载状态代码， headers 是一个由额外头部值组成的列表 或字典。\n如果以上都不是，那么 Flask 会假定返回值是一个有效的 WSGI 应用并把它转换为 一个响应对象。\n\n如果想要在视图内部掌控响应对象的结果，那么可以使用 make_response() 函数。\n设想有如下视图:\n@app.errorhandler(404)\ndef not_found(error):\n    return render_template(&#39;error.html&#39;), 404\n\n可以使用 make_response() 包裹返回表达式，获得响应对象，并对该对象 进行修改，然后再返回:\n@app.errorhandler(404)\ndef not_found(error):\n    resp &#x3D; make_response(render_template(&#39;error.html&#39;), 404)\n    resp.headers[&#39;X-Something&#39;] &#x3D; &#39;A value&#39;\n    return resp\n\nJSON 格式的 APIJSON 格式的响应是常见的，用 Flask 写这样的 API 是很容易上手的。如果从视图 返回一个 dict ，那么它会被转换为一个 JSON 响应。\n@app.route(&quot;&#x2F;me&quot;)\ndef me_api():\n    user &#x3D; get_current_user()\n    return &#123;\n        &quot;username&quot;: user.username,\n        &quot;theme&quot;: user.theme,\n        &quot;image&quot;: url_for(&quot;user_image&quot;, filename&#x3D;user.image),\n    &#125;\n\n如果 dict 还不能满足需求，还需要创建其他类型的 JSON 格式响应，可以使用 jsonify() 函数。该函数会序列化任何支持的 JSON 数据类型。 也可以研究研究 Flask 社区扩展，以支持更复杂的应用。\n@app.route(&quot;&#x2F;users&quot;)\ndef users_api():\n    users &#x3D; get_all_users()\n    return jsonify([user.to_json() for user in users])\n\n\n\n会话除了请求对象之外还有一种称为 session 的对象，允许您在不同请求 之间储存信息。这个对象相当于用密钥签名加密的 cookie ，即用户可以查看您的 cookie ，但是如果没有密钥就无法修改它。\n使用会话之前您必须设置一个密钥。举例说明:\nfrom flask import session\n\n# Set the secret key to some random bytes. Keep this really secret!\napp.secret_key &#x3D; b&#39;_5#y2L&quot;F4Q8z\\n\\xec]&#x2F;&#39;\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    if &#39;username&#39; in session:\n        return f&#39;Logged in as &#123;session[&quot;username&quot;]&#125;&#39;\n    return &#39;You are not logged in&#39;\n\n@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])\ndef login():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        session[&#39;username&#39;] &#x3D; request.form[&#39;username&#39;]\n        return redirect(url_for(&#39;index&#39;))\n    return &#39;&#39;&#39;\n        &lt;form method&#x3D;&quot;post&quot;&gt;\n            &lt;p&gt;&lt;input type&#x3D;text name&#x3D;username&gt;\n            &lt;p&gt;&lt;input type&#x3D;submit value&#x3D;Login&gt;\n        &lt;&#x2F;form&gt;\n    &#39;&#39;&#39;\n\n@app.route(&#39;&#x2F;logout&#39;)\ndef logout():\n    # remove the username from the session if it&#39;s there\n    session.pop(&#39;username&#39;, None)\n    return redirect(url_for(&#39;index&#39;))\n\n如何生成一个好的密钥\n生成随机数的关键在于一个好的随机种子，因此一个好的密钥应当有足够的随机性。 操作系统可以有多种方式基于密码随机生成器来生成随机数据。使用下面的命令 可以快捷的为 Flask.secret_key （ 或者 SECRET_KEY ）生成值:\n$ python -c &#39;import os; print(os.urandom(16))&#39;\nb&#39;_5#y2L&quot;F4Q8z\\n\\xec]&#x2F;&#39;\n\n基于 cookie 的会话的说明： Flask 会取出会话对象中的值，把值序列化后储存到 cookie 中。在打开 cookie 的情况下，如果需要查找某个值，但是这个值在请求中 没有持续储存的话，那么不会得到一个清晰的出错信息。请检查页面响应中的 cookie 的大小是否与网络浏览器所支持的大小一致。\n除了缺省的客户端会话之外，还有许多 Flask 扩展支持服务端会话。\n消息闪现一个好的应用和用户接口都有良好的反馈，否则到后来用户就会讨厌这个应用。 Flask 通过闪现系统来提供了一个易用的反馈方式。闪现系统的基本工作原理是 在请求结束时记录一个消息，提供且只提供给下一个请求使用。通常通过一个布 局模板来展现闪现的消息。\nflash() 用于闪现一个消息。在模板中，使用 get_flashed_messages() 来操作消息。完整的例子参见 消息闪现 。\n日志Changelog\n\n有时候可能会遇到数据出错需要纠正的情况。例如因为用户篡改了数据或客户端 代码出错而导致一个客户端代码向服务器发送了明显错误的 HTTP 请求。多数时 候在类似情况下返回 400 Bad Request 就没事了，但也有不会返回的时候， 而代码还得继续运行下去。\n这时候就需要使用日志来记录这些不正常的东西了。自从 Flask 0.3 后就已经为 您配置好 了一个日志工具。\n以下是一些日志调用示例:\napp.logger.debug(&#39;A value for debugging&#39;)\napp.logger.warning(&#39;A warning occurred (%d apples)&#39;, 42)\napp.logger.error(&#39;An error occurred&#39;)\n\nlogger 是一个标准的 Logger Logger 类，更多信息详见官方的 logging 文档。\n参见 应用错误处理 。\n集成 WSGI 中间件如果想要在应用中添加一个 WSGI 中间件，那么可以用应用的 wsgi_app 属性 来包装。例如，假设需要在 Nginx 后面使用 ProxyFix 中间件，那么可以这样做:\nfrom werkzeug.middleware.proxy_fix import ProxyFix\napp.wsgi_app &#x3D; ProxyFix(app.wsgi_app)\n\n用 app.wsgi_app 来包装，而不用 app 包装，意味着 app 仍旧指向您 的 Flask 应用，而不是指向中间件。这样可以继续直接使用和配置 app 。\n使用 Flask 扩展扩展是帮助完成公共任务的包。例如 Flask-SQLAlchemy 为在 Flask 中轻松使用 SQLAlchemy 提供支持。\n更多关于 Flask 扩展的内容请参阅 扩展 。\n部署到网络服务器已经准备好部署您的新 Flask 应用了？请移步 部署方式 。\n","slug":"Web Dev/Back End/flask/start","date":"2023-03-08T00:28:42.152Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"单体应用有很多显而易见的好处\n\n项目起步简单，\n易于部署\n\n但是\n\n项目通常都会增长，比最初计划的要大，最终演变成失控性增长\n\n","slug":"Web Dev/Back End/flask/why we need microservices","date":"2023-03-08T00:28:42.150Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"注意你的sql文件\n当你犯错时，不妨再去看看语法：\nDROP TABLE IF EXISTS user;\nDROP TABLE IF EXISTS post;\n\nCREATE TABLE user (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    username TEXT UNIQUE NOT NULL,\n    password TEXT NOT NULL, &#x2F;&#x2F; 不应该有 ,\n);\n\nCREATE TABLE post (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    author_id INTEGER NOT NULL,\n    created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    title TEXT NOT NULL,\n    body TEXT NOT NULL,\n    FOREIGN KEY (author_id) REFERENCES user (id)\n) &#x2F;&#x2F;应该加上 ;\n\n\n\n\n\n\n\n\n\n","slug":"Web Dev/Back End/flask/坑","date":"2023-03-08T00:28:42.148Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"django项目的创建：创建好的项目目录如下\nbysms&#x2F;\t\t\t\t\t\t\t\t&#x2F;&#x2F;整体的项目名称\n    manage.py\t\t\t\t\t\t&#x2F;&#x2F;项目中的管理文件\n    bysms&#x2F;\t\t\t\t\t\t\t&#x2F;&#x2F;实际构建网站的文件的二级目录\n        __init__.py\t\t\t\t\t\n        settings.py\t\t\t\t\t&#x2F;&#x2F;Django 项目的配置文件\n        urls.py\t\t\t\t\t\t&#x2F;&#x2F;负责网站访问中的路由分发\n        wsgi.py\t\t\t\t\t\t&#x2F;&#x2F;以wsgi规范构建网站\n\n\n\ndjango的url分发策略：\n按层级分发：\n​    ——项目下的同名文件夹的urls作一级分发\n示例：\n\npath(‘login/‘, include(‘login.urls’))\npath(‘admin/‘, include(‘admin.urls’))\npath(‘莫斯提马/‘, include(‘莫斯提马.urls’))\n\n注意：要先from django.urls import path, include\n\n直接访问：\n\npath(‘login/‘, login)\n\n注意：此时要求在当前文件目录下的views.py文件中要存在对应的已经定义好的，能返回HttpResponse()的函数\n\n```pythondef login(request):return HttpResponse( ··· )\n\n\n  但是在使用之前，要从根目录开始引入这个函数\n\n+ &#96;&#96;&#96;python\n  from login.views import login\n\n\n\ndjango配合数据库：","slug":"Web Dev/Back End/django/2021 3 13","date":"2023-03-08T00:28:42.145Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n\n\n\n\n\n\nremeber: we always do makemigrations and migrate when we change the models\nStep 1. create an appdjango-amdin startapp &lt;YourAppName&gt;\n\nThen we got an essential app with the structure like below:\n\n\n\n\n\n\n\n\n\n- &lt;YourAppName&gt;:  - migrations  - __init__.py  - admin.py  - apps.py  - models.py  - tests.py  - views.py\nStep 2. change your models and save the changesobviously, if we want a good backend, we need a database. And in that case, we need to write a good model file\nsideshow: Use The Python Shell to Control Djangouse command python manage.py shell to enter the special python shell\nfor example: \nwe have a model in an app named product like this:\n&gt;&gt;&gt; from products.models import product as pd\n&gt;&gt;&gt; pd.objects.all()  # check all the data related with class product, using the method __str__\n# add:\n&gt;&gt;&gt; pd.objects.create(&lt;pd_attr1&gt;&#x3D;&quot;...&quot;, [...])  # add a new data into the table\n# delete\n&gt;&gt;&gt; pd.objects.\n# change\n&gt;&gt;&gt;\n# search\n&gt;&gt;&gt;\n\n\n\nif we want to change the fields of vars in models, we must make sure that the data is fixable in new field:In certain time, we need to change the data:\nof course you can change it in software like sqlitestudio, but how about with shell?\n","slug":"Web Dev/Back End/django/BuildUpYourApps","date":"2023-03-08T00:28:42.143Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Django Model参考文档\n模型 | Django 文档 | Django (djangoproject.com)\n详解Django的Models（django基础四）_Charles-Su的博客-CSDN博客_django model\n\n\n内容：Model在项目中的意义模型准确且唯一的描述了数据。它包含储存数据的重要字段和行为。\n一般来说，每一个模型都映射一张数据库表。\n基础：\n\n每个模型都是一个 Python 的类，这些类继承 django.db.models.Model\n模型类的每个属性都相当于一个数据库的字段。\n利用这些，Django 提供了一个自动生成访问数据库的 API；请参阅 执行查询。\n\nModel的构建继承来源：我们可以继承 models.Model ,  AbstractUser 等来构建我们的新Model类\n其中\nmodels.Model:Models则是通用的模型类，自定义模型都需要继承这个\nAbstractUser:AbstractUser要记得在setting.py里面加上AUTH_USER_MODEL = ‘users.UserProfile’\nAbstractUser是内置的用户类，当要继承内置的用户模型并进行扩展时，就使用它\nInner Class – Meta：Model metadata is “anything that’s not a field”, such as ordering options (ordering), database table name (db_table), or human-readable singular and plural names (verbose_name and verbose_name_plural). None are required, and adding class Meta to a model is completely optional.\nA complete list of all possible Meta options can be found in the model option reference.\n基本属性与字段：1.field类型AutoField:一个自动递增的整形字段，通常用于主键\nCharField：字符串字段，用于输入较短的字符，对应与HTML里面&lt;input type=’text’&gt;\nTextField：文本字段，用于输入较多的字符，对应html标签 &lt;input type = “textarea”&gt;；\nEmailField：邮箱字段，用于输入带有Email格式的字符\nDateFiled\nTimeFiled\nDateTimeField：日期字段，支持时间输入\nImageField：用于上传图片并验证图片合法性，需定义upload_to参数，使用本字段需安装python pillow等图片库\nIntegerField：整数字段，用于保持整数信息\nfield属性primary_key：设置True or False，定义此字段是否为主键\ndefault：设置默认值，可以设置默认的文本、时间、图片、时间等\nnull：设置True or False，是否允许数据库字段为Null，默认为False\nblank：设置True or False，定义是否运行用户不输入，默认为False；若为True，则用户可以不输入此字段\nmax_length：设置默认长度，一般在CharField、TextField、EmailField等文本字段设置\nverbose_name：设置该字段的名称，所有字段都可以设置，在Web页面会显示出来（例如将英文显示为中文）\nchoices：设置该字段的可选值，本字段的值是一个二维元素的元祖；元素的第1个值为实际存储的值，第2个值为HTML页面显示的值\nupload_to：设置上传路径，ImageField和FileField字段需要设置此参数,如果路径不存在，会自动创建\nMeta类属性verbose_name：设置对象名称（例如usecms），若没有设置，则默认为该类名的小写分词形式，例如类名为CamelCase会被转换为camel case；\nverbose_name_plural：设置对象名称复数（例如usercms），一般设置跟verbose_name一样，\nverbose_name_plural=verbose_name否则会默认加s；\ndb_table：设置映射的数据表名，默认为“应用名_模型名”，即用该模型所在app的名称加本模型类的名称\nproxy：设置True or False，设置本模型及所有继承本模型的子模型是否为代理模型；\nabstract：设置True or False，设置本模型类是否为抽象基类；如果是抽象基类，那么是不会创建这张表的，这张表用来作为基类被其他的表继承\nmodel层的命令详解python manage.py makemigrations+名字:# 生成数据库表的初始化文件initial.py文件\npython manage.py migrate# # 基于数据库表初始化文件initial.py文件，正式生成数据表\npython manage.py sqlmigrate polls 0001查看数据库的生成语句，因为initial.0001是数据库表的初始化文件\n基本设计思路：","slug":"Web Dev/Back End/django/Django Model","date":"2023-03-08T00:28:42.137Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Python 虚拟环境Python 之所以强大，除了语言本身的特性外，更重要的是拥有无所不及的第三方库。\n依赖问题？\n包python 包库包库或者叫软件源是 Python 第三方软件的库的集合，或者市场，可以发布、下载和管理软件包，其中 pypi (Python Package Index) https://pypi.org/ 是官方指定的软件包库，基于其上的 pip 工具就是从这里查找、下载安装软件包的。为了提高下载速度，世界上有很多 Pypi 的镜像服务器，在国内也有多个软件源，例如阿里的软件源是：http://mirrors.aliyun.com/pypi/simple/。 除此之外，还有其他软件源，如正对科学计算的 anaconda 的软件源 https://repo.anaconda.com/\npython 包管理器软件包源中的软件包数量巨大，版本多样，所以需要借助于软件源管理工具，例如 pip、conda、Pipenv、Poetry 等\n\npip 是最常用的包管理工具，通过 pip install &lt;packagename&gt; 命令格式来安装软件包，使用的是 pypi 软件包源\nconda 多用作科学计算领域的包管理工具，功能丰富且强大，使用的软件包源是 Anaconda repository 和 Anaconda Cloud，conda 不仅支持 Python 软件包，还可以安装 C、C++ 、R 以及其他语言的二定制软件包。除了软件包管理外，还能提供相互隔离的软件环境。\nPipenv 是 Kenneth Reitz 在2017年1月发布的Python依赖管理工具，现在由PyPA维护。Pipenv 会自动帮你管理虚拟环境和依赖文件，并且提供了一系列命令和选项来帮助你实现各种依赖和环境管理相关的操作\nPoetry 和 Pipenv 类似，是一个 Python 虚拟环境和依赖管理工具，另外它还提供了包管理功能，比如打包和发布。你可以把它看做是 Pipenv 和 Flit 这些工具的超集。它可以让你用 Poetry 来同时管理 Python 库和 Python 程序\n\n很多包管理工具不仅提供了基本的包管理功能，还提供了虚拟环境构建，程序管理的等功能\nPython 虚拟环境Python 应用经常需要使用一些包第三方包或者模块，有时需要依赖特定的包或者库的版本，所以不能有一个能适应所有 Python 应用的软件环境，很多时候不同的 Python 应用所依赖的版本是冲突的，满足了其中一个，另一个则无法运行，解决这一问题的方法是 虚拟环境。 虚拟环境是一个包含了特定 Python 解析器以及一些软件包的自包含目录，不同的应用程序可以使用不同的虚拟环境，从而解决了依赖冲突问题，而且虚拟环境中只需要安装应用相关的包或者模块，可以给部署提供便利\n构建虚拟环境原理虚拟环境并不是什么新技术，主要是利用了操作系统中环境变量以及进程间环境隔离的特性\n操作系统的环境变量可以为程序提供信息和做信息交换介质，进程可以共享操作系统中的环境变量，也可以为进程指定环境变量，其中 PATH 是很重要的环境变量，用于为操作系统和程序提供可执行文件的访问路径，例如写一个程序 a.exe，存放在 D:\\MyProgram 中，在命令行中执行 a.exe ，会得到提示“ 无法找到程序 a.exe”，为了让系统找到，可以将 D:\\MyProgram 路径加入到 PATH 环境变量中，当输入 a.exe 时，操作系统就会从 PATH 所提供的路径中逐个查找，这时就可以找到了。Linux 和 MacOS 具有相似的特性，甚至比 Windows 的功能更丰富。\nPython 虚拟环境就是利用这个特性构建的，在激活虚拟环境之时，激活脚本会将当前命令行程序的 PATH 修改为虚拟环境的，这样执行命令就会在被修改的 PATH 中查找，从而避免了原本 PATH 可以找到的命令，从而实现了 Python 环境的隔离。\n为了让开发这容易区分当前环境是否虚拟环境以及是那个虚拟环境，命令提示符前会加上特殊标记，例如:\n\n创建virtualenv 工具在 python3.3 之前，只能通过 virtualenv 创建虚拟环境，首先需要安装 virtualenv\npip install virtualenv \n\n安装完后，在当前目录下创建一个名为 myvenv 的虚拟环境:\nvirtualenv --no-site-packages myvenv \n\n参数 --no-site-packages 的意思是创建虚拟环境时，不复制主环境中安装的第三方包，也就是创建一个 “干净的” 虚拟环境\nvirtualenv 还有很多参数，用于不同的使用场景，例如:\n\n-p: 用于指定 Python 解析器，就是安装好的 Python 应用程序，默认为当前环境中的 Python\n–no-pip：不需要安装 pip，默认为安装\n–clear：如果创建虚拟环境的目录已经有了其他虚拟环境，清楚重建\n\nvenv 模块Python3.3 之后，可以用模块 venv 代替 virtualenv 工具，好处时不用单独安装，3.3 及之后的版本，都可以通过安装好的 Python 来创建虚拟环境:\npython -m venv myvenv\n\n可以在当前目录创建一个名为 myvenv 的虚拟环境\nvenv 有些才参数，不过相比 virtualenv 少了些，这里简单介绍几个：\n\n–without-pip: 不需要安装 pip，默认为安装\n–clear：如果创建虚拟环境的目录已经有了其他虚拟环境，清楚重建\n\n因为 venv 是依附于一个 Python 解析器创建的，所以不需要指定 Python 解释器版本\n激活虚拟环境创建好后，需要激活才能在当前命令行中使用，可以理解成将当前命令行环境中 PATH 变量的值替换掉\n通过 virtualenv 和 模块 venv 创建的虚拟环境，激活方式是一样的，即运行激活脚本\n\nWindows 系统中，激活脚本路径是 &lt;myvenv&gt;\\Scripts\\activate.bat，如果是 powershell 命令行，脚本换成 Activate.ps1 , 注意将 &lt;myvenv&gt; 换成你自己的虚拟环境目录\n\nLinux 系统中，激活脚本路径是 &lt;myvenv&gt;/bin/activate，默认脚本没有执行权限，要么设置脚本为可执行，要么用 source 命令执行，例如\n$ source myvenv/bin/activate \n\n\n激活后，可以在命令行行头看到虚拟环境标记\n与开发工具配合虽然通过激活脚本，很容易切换到虚拟环境，但是在实际开发中，还是不够方便，而且现在很多开发工具，特别是提供 Python 解析环境的开发工具，都可以和虚拟环境配合，在开发过程中几乎无感，对开发工作是很大的帮助\nVisual Studio CodeVS Code 是个后起之秀，功能强大且具有丰富的插件资源，无疑是这两年发展最快的综合开发工具。现在的版本配置 Python 虚拟环境很简单，只需要选择一个 Python 解释器就好了\n同时按下 Ctrl+Shift+P, 在弹出的命令窗口中输入 “解析器”，然后在下拉列表中选择 “Python:选择解析器”，这里会缓存一些已经创建好的解析器，如果没有想要的，可以选择 “Enter interpreter path” 来选择解析器路径，即已经创建好的虚拟环境脚本文件夹中的 Python 程序，就可以创建一个新的解析器\n\n如果编辑的是 Python 代码文件，在状态栏中也可以选择和切换解释器，更为方便\n\nPycharmPycharm 应该是功能最好的 Python 开发工具，转为 Python 开发而生，除了基本的开发功能外，还提供项目创建、打包、测试等丰富功能，有很大的市场占有率\n创建项目时，在项目创建对话框中，可以创建或者选择已经已有的解析器\n\n选择创建新的解析器时，需要选择创建虚拟环境的工具，如 virtualenv；指定虚拟环境的目录；选择 Python 基础解析器，同 virtualenv 工具的 -p 参数的效果；以及是否要继承基础解析器的第三方库 和 是否将这个虚拟环境作为默认环境，即创建其他项目时默认选择\n如果选择已存在的解析器，和 VS Code 差不多，可以选择已经缓存的或者指定解析器的路径\n部署虚拟环境之所以在开发时选择虚拟环境，除了避免库之间的冲突，还有重要的原因时方便部署，因为虚拟环境时独立的，仅包含了项目相关的依赖库，所以部署的效率更高，风险更小\n一般部署流程是：\n\n开发完成后，使用 pip freeze &gt; requirements.txt 命令将项目的库依赖导出，作为代码的一部分\n将代码上传到服务器\n在服务器上创建一个虚拟环境\n激活虚拟环境，执行 pip install -r requirements.txt，安装项目依赖\n\n怎么运行项目，需要看项目的具体情况\n\nWeb 项目 Web 项目一般使用 Django、Flask 的 Web 开发的提供 Web 服务的项目，部署时需要一个 Web 容器，作为程序的运行环境，容器的配置中都有一个虚拟环境的设置，其实是指定 Python 解析器的路径，将其设置为虚拟环境的目录或者 Python 解析器就可以了，启动时就用使用虚拟环境，并与其他环境隔离。例如 uWSGI 配置文件中 home 参数是用来指定解析器的。\n服务类项目 服务类项目就是需要以服务的形式长时间运行的，例如之前介绍的 公交闹钟，或者一些定时爬虫之类的，对于 Linux 而言，当前主流的服务方式是 Systemd，是一种比 init 更先进的服务管理工具，在服务脚本中， 设置 ExecStart 执行命令为全路径的虚拟环境的 Python 解析器，服务启动时，使用独立的虚拟环境了。 Windows 服务，对于达成 EXE 包的，不需要配置虚拟环境，因为打包时已经考虑了环境问题了，如果时脚本运行的话，需要指定全路径的 Python 解析器\n单次运行项目 对于一些测试或者实验性质的项目，大多数情况下手动执行，只要在激活的虚拟环境下，或者用特定的 Python 解析器运行就好了，和在开发过程中运行区别不大\n\n其他虚拟环境管理工具\nvirtualenvwrapper： 是对 virtualenv 的一个封装，还有针对 vim 用户和 emacs 用户的 扩展，能支持 bash/ksh/zsh\nvirtualenvwrapper-win： 针对 Windows batch shell 的 virtualenvwrapper\npyenv： 用来解决这类问题。它可以安装、卸载、编译、管理多个 python 版本，并随时将其中一个设置为工作环境\npyenv-win： 针对 Windows 的 pyenv\n\n","slug":"Web Dev/Back End/django/使用当前目录里venv中的python","date":"2023-03-08T00:28:42.134Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Eclipse中有如下一些和运行调试相关的快捷键。 \n\n【Ctrl+Shift+B】：在当前行设置断点或取消设置的断点。 \n【F11】：调试最后一次执行的程序。 \n【Ctrl+F11】：运行最后一次执行的程序。 \n【F5】：跟踪到方法中，当程序执行到某方法时，可以按【F5】键跟踪到方法中。\n\n","slug":"Language Learning/Java/JavaProject/eclipse","date":"2023-03-08T00:28:39.774Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"module 本模块的名称&#123;\n\texports 对外暴露的包路径;\n\trequires 需要依赖的其他模块名称;\n&#125;\n\n\n\n\n\n一、什么是Java module？与Java 中的package有些类似，module引入了Java代码分组的另一个级别。每个这样的分组（module）都包含许多子package包。通过在一个模块的源代码文件package的根部，添加文件module-info.java来声明该文件夹及其子文件夹为一个模块。该文件语法如下：\nmodule xxx.yyy&#123;\n \t....\n&#125;\n\n其中xxx.yyy是模块module声明的名称，不是package名称。\n二、模块导出package文件module-info.java可以指定该模块下面的哪些package对外可见、可访问。通过一个新的关键字exports来实现该功能。\nmodule xxx.yyy&#123;\n\texports com.zimug.java9;\n&#125;\n\ncom.zimug.java9代表一个package。\n\n\n\n\n\n\n\n\n\n需要注意的是：即使给定package包中的类是public的，如果未通过’exports’显式导出其程序包，则它们在模块外部也是不可见的（在编译时和运行时都是如此）。\n三、模块导入package如果另一个模块想要使用被导出的package包中的类，可以用requires关键字在其module-info.java文件中来导入（读取）目标模块的package包。\nmodule def.stu&#123;\n\trequires xxx.yyy;\n&#125;\n\n四、Java module的意义在笔者看来，Java 9引入module 模块化管理系统，更多的是从安全性的角度考虑。Java 代码中90%以上的漏洞都是由反射和访问权限控制粒度不足引起的，Java 9的模块化系统正好能解决这个问题。Java 9 module提供另一个级别的Java 代码可见性、可访问性的控制。\n比如说：我们都知道当一个class被修饰为private的时候，意味着这个类是内部类。对于顶级类(外部类)来说，只有两种修饰符：public和默认(default)。这也就意味着一个问题，有些public class我们本来是打算在jar包定义的范围内使用的，但是结果却是任何引入了这个jar的项目都可以使用这个jar里面所有的public class代码。\n也就是我们的原意是在有限范围内提供公开访问，结果却是无限制的对外公开。在引入Java 9模块化之后，可以实现有限范围内的代码public访问权限，将代码公开区分为：模块外部有限范围的公开访问和模块内部的公开访问。\n五、实例在此示例中，我将创建两个模块“ common.widget”和“ data.widget”，并将它们放置在单个文件夹“ modules-examples/src”下。文件“ module-info.java”将放置在每个模块的根文件夹下。文件及目录格式如下：\nD:\\modules-example&gt;tree &#x2F;F &#x2F;A\n\\---src\n    +---common.widget\n    |   |   module-info.java\n    |   |   \n    |   +---com\n    |   |   \\---zimug\n    |   |           RendererSupport.java\n    |   |           \n    |   \\---org\n    |       \\---jwidgets\n    |               SimpleRenderer.java\n    |               \n    \\---data.widget\n        |   module-info.java\n        |   \n        \\---com\n            \\---example\n                    Component.java\n\n第一个模块本代码文件目录：modules-example/src/common.widget/org/jwidgets/SimpleRenderer.java。这个package在后文中没有被exports。\npackage org.jwidgets;\n\npublic class SimpleRenderer &#123;\n  public void renderAsString(Object object) &#123;\n      System.out.println(object);\n  &#125;\n&#125;\n\n本代码文件目录：modules-example/src/common.widget/com/zimug/RendererSupport.java。这个package在后文中被exports了。\npackage com.zimug;\n\nimport org.jwidgets.SimpleRenderer;\n\npublic class RendererSupport &#123;\n\tpublic void render(Object object) &#123;\n        new SimpleRenderer().renderAsString(object);\n  \t&#125;\n&#125;\n\n模块导出，本代码文件目录：modules-example/src/common.widget/module-info.java。只导出com.zimug包,没有导出 org.jwidgets包。导出的模块名称为common.widget\nmodule common.widget&#123;\n  \texports com.zimug;\n&#125;\n\n第二个模块模块导入common.widget，本代码文件目录：modules-example/src/data.widget/module-info.java\nmodule data.widget &#123;\n\trequires common.widget;\n&#125;\n\n使用导入模块common.widget中的package:com.zimug。本代码文件路径： modules-example/src/data.widget/com/example/Component.java\npackage com.example;\n\nimport com.zimug.RendererSupport;\n\npublic class Component &#123;\n  \tpublic static void main(String[] args) &#123;\n     \tRendererSupport support &#x3D; new RendererSupport();\n      \tsupport.render(&quot;Test Object&quot;);\n  \t&#125;\n&#125;\n\n正常编译执行，结果如下：\nTest Object\n\n尝试使用未被exports的package代码由于包“ org.jwidgets”尚未通过“ common.widget”模块导出，因此另一个模块“ data.widget”无法使用该package包下的类SimpleRenderer。我们做一个反例，看看会发生什么：\npackage com.example;\nimport org.jwidgets.SimpleRenderer;\n\npublic class Component &#123;\n  \tpublic static void main(String[] args) &#123;\n    \tSimpleRenderer simpleRenderer &#x3D; new SimpleRenderer(); \n    \tsimpleRenderer.renderAsString(&quot;Test Object&quot;);\n  \t&#125;\n&#125;\n\n编译报错信息如下：\nD:\\modules-example\\src\\data.widget\\com\\example\\Component.java:3: error: package org.jwidgets is not visible\nimport org.jwidgets.SimpleRenderer;\n          ^\n  (package org.jwidgets is declared in module common.widget, which does not export it)\n1 error\n\n正如我们所看到的，未被exports的package下面的class即使是public的也不能被访问。\n","slug":"Language Learning/Java/JavaProject/module_info文件有什么用","date":"2023-03-08T00:28:39.771Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"mipmap-mdpi：108 * 108\nmipmap-hdpi：162 * 162\nmipmap-xhdpi：216* 216\nmipmap-xxhdpi：324 * 324\nmipmap-xxxhdpi：432 * 432\nmipmap-mdpi 48ic_launcher.png/ic_launcher_round.png\nmipmap-hdpi 72ic_launcher.png/ic_launcher_round.png\nmipmap-xhdpi 96ic_launcher.png/ic_launcher_round.png\nmipmap-xxhdpi 144ic_launcher.png/ic_launcher_round.png\nmipmap-xxxhdpi 192ic_launcher.png/ic_launcher_round.png\nDPI:每英寸像素数\n简单的屏幕分辨率计算方法：\nDisplayMetrics metrics = this.getResources().getDisplayMetrics();float density = metrics.density;int dpi = metrics.densityDpi;int heightPixels = metrics.heightPixels;int widthPixels = metrics.widthPixels;Log.e(“—metrics—“, “比例:”+density+”dpi:”+dpi+”高像素:”+heightPixels+”宽像素:”+widthPixels);\n图片大小适应不同屏幕：\nimg.post(new Runnable() &#123;\n   @Override\n\tpublic void run() &#123;\n\tint spec &#x3D; View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);\n\timg.measure(spec,spec);\n\tint measuredWidth&#x3D;img.getMeasuredWidth();int measuredHeight&#x3D;img.getMeasuredHeight();&#x2F;&#x2F;原始大小\n\tif (measuredWidth&#x3D;&#x3D;0)&#123;\n\t\treturn;\n  \t&#125;\n \n    int width&#x3D;img.getWidth();int height&#x3D;img.getHeight();&#x2F;&#x2F;真实大小\n    LinearLayout.LayoutParams lp&#x3D;(LinearLayout.LayoutParams)img.getLayoutParams();\n\tlp.width&#x3D;width;\n\tlp.height&#x3D;width*(measuredHeight &#x2F; measuredWidth);\n\timg.setLayoutParams(lp);&#x2F;&#x2F;设置大小\n\t&#125;\n&#125;);\n\ndp与px计算图（mdpi  1dp=1px）：\nldpi:1dp=0.75px  mdpi:1dp=1px  hdpi:1dp=1.5px  xhdpi:1dp=2px  xxhdpi:1dp=3px  xxxhdpi:1dp=4px\nAndroid手机屏幕标准            对应图标尺寸标准    屏幕密度     比例\nxxxhdpi 38402160              192192       640      16\nxxhdpi 19201080               144144       480      12\nxhdpi  1280720               9696        320      8\nhdpi  480800               7272        240      6\nmdpi  480320               4848        160      4\nldpi  320240               3636        120      3\n注：Android studio mipmap文件夹只存放启动图标icon\nhttp://blog.csdn.net/a704755096/article/details/46342689\n屏幕横竖屏布局切换：\n1)单个布局xml直接横竖屏切换，不重新加载数据：android:configChanges=”orientation|keyboardHidden|screenSize”\n2)layout-land和layout-port布局横竖屏切换，不重新加载数据：FragmentActivity重写onRetainCustomNonConfigurationInstance()\nActivity 重写onRetainNonConfigurationInstance()保存数据，在onCreate()时判断getLastNonConfigurationInstance()是否null:\nJava代码 \n\n@Override \npublic void onCreate(Bundle savedInstanceState) { \n  super.onCreate(savedInstanceState); \n  setContentView(R.layout.main); \n\n  Object data = getLastNonConfigurationInstance(); \n  if (data == null) { \n​    findviewbyidLoadMyData(); \n  } \n  … \n}  \n\n更多：安卓图片动画（http://www.open-open.com/lib/view/open1335777066015.html）、点九图工具：\n1.打开Android 工程包 SDK文件，tools文件，双击draw9patch.bat\n2.弹出的窗口点击 File，点击要编辑的图片open 9patch \n3.编辑。鼠标左键：划线   /   shift + 鼠标左键：删除划线\n4.保存。点击save 9patch\n","slug":"Language Learning/Java/AndroidProject/App logo","date":"2023-03-08T00:28:39.768Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n\n\n\n\n\n\nflutter sdk 版本升级到2.0或者更高的版本后就发现运行时会报错：\nError: Cannot run with sound null safety, because the following dependencies\ndon&#39;t support null safety:\n\n - package:loading_indicator_view\n - package:flutter_swiper\n - package:flutter_page_indicator\n - package:transformer_page_view\n\nFor solutions, see https:&#x2F;&#x2F;dart.dev&#x2F;go&#x2F;unsound-null-safety\n\n\nFAILURE: Build failed with an exception.\n\n也就是说以上有些包不支持 safety模式。\n解决方案：--no-sound-null-safety\nrunflutter run --no-sound-null-safety\nbuildflutter build apk --no-sound-null-safety\n\n","slug":"Language Learning/Java/AndroidProject/Flutter Error","date":"2023-03-08T00:28:39.765Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"“Failed to install the following Android SDK packages as some licences have not been accepted” error - Stack Overflow\n","slug":"Language Learning/Java/AndroidProject/Flutter","date":"2023-03-08T00:28:39.762Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"folder.gradle与.ideaandroid自动生成的文件夹\ngradlegradle是android项目的类似maven的包管理工具，自动配置\napp具体的代码资源，工作的核心目录\nbuildmake project或run project生成的，可以从中找到apk文件\n转移工程时可以删除\nlibs第三方jar包存储位置\nsrcandroidTestmainjavarestestfiles.gitignoreproject/app版本控制\nbuild.gradle全局/app构建脚本\ngradle.properties全局gradle的配置文件\ngradlew与gradlws.batgradle命令的具体实现脚本\nlocal.properties指定sdk路径等\n## This file is automatically generated by Android Studio.\n\nsettings.gradle用来指定项目中所有指定的模块\n","slug":"Language Learning/Java/AndroidProject/project structure","date":"2023-03-08T00:28:39.760Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"install certain python version in Linux-1: for Ubuntu:just: apt install python3.8\nZero, try to download python3.8 through yumyum list | grep python3\n\nfind no python38, so choose to setup python3.8 through make install\nFirst, download the python filego to website: https://www.python.org/ftp/python to choose correct file\n\n\n\n\n\n\n\n\n\nexample: https://www.python.org/ftp/python/3.8.10/Python-3.8.10.tgz\nwget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.8.10&#x2F;Python-3.8.10.tgz\n\nunzip, make and install\n在编译前先在/usr/local建一个文件夹python3（作为python的安装路径，以免覆盖老的版本）\n\nmkdir &#x2F;usr&#x2F;local&#x2F;python3\n\n\n解压：\n\ntar -zxvf Python-3.8.10.tgz\n\n\n进行指定目录的编译安装\n\n.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3 # 设置编译安装路径\n\nmake # 编译\n\nmake install # 安装 \n\n\n\n\n创建软链接\n\nln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3  &#x2F;usr&#x2F;bin&#x2F;python3.8\n\n# 修改旧版本软连接：ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3  &#x2F;usr&#x2F;bin&#x2F;pythonv\n\n\n\n检验安装python3.8 -V\n# Python 3.8.10\n\n\n\n\n\ncentOS下升级python版本，详细步骤 - leon-zyl - 博客园 (cnblogs.com)\n","slug":"Language Learning/Python/install certain python version in Linux","date":"2023-03-08T00:26:24.438Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"浅谈响应式Web设计与实现思路 - 知乎 (zhihu.com)\n","slug":"Web Dev/Front End/web网页设计思路","date":"2023-03-08T00:26:14.947Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"#HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。/* 其实可以修改更多包括————   改变html内容 ，  改变 CSS 样式 ，  改变 HTML 属性 ，  创建新的 HTML 元素 ，  删除已有的 HTML 元素 ，  改变事件（处理程序）  */\n###DOM 节点\n\n根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点!\n整个文档是一个文档节点\n每个 HTML 元素是元素节点\nHTML 元素内的文本是文本节点\n每个 HTML 属性是属性节点\n注释是注释节点\n\n\n节点的级别\n用父（parent）、子（child）和同胞（sibling）等术语来描述这些关系。\n父节点拥有子节点,同级的子节点被称为同胞（兄弟或姐妹）\n\n\n节点范例\n代码示例：  &lt;html&gt;\n  &lt;head&gt;\n\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t&lt;title&gt;DOM 教程&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n\t&lt;h1&gt;DOM 课程1&lt;&#x2F;h1&gt;\n\t&lt;p&gt;Hello world!&lt;&#x2F;p&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n 节点没有父节点；它是根节点\n 和  的父节点是  节点\n文本节点 “Hello world!” 的父节点是  节点\n\n\nDOM处理中的常见错误就是希望元素包含文本\n解释：  text is always stored in text nodes  A common error in DOM processing is to expect an element node to contain text  However, the text of an element node is stored in a text node.  In this example: &lt;year&gt;2005&lt;/year&gt;, the element node , holds a text node with the value “2005”.  “2005” is not the value of the  element\n即：文本只在文本节点中，而文本节点只是属于的子节点，year并不包含”2005”,”2005”是专属于文本节点的值\n\n\n可通过 JavaScript （以及其他编程语言）对 HTML DOM 进行访问。\n\n###DOM方法HTML DOM 方法是我们可以在节点（HTML 元素）上执行的动作。→方法是我们能够执行的动作（比如添加或修改元素）。\n\ngetElementById(id) - 获取带有指定id的节点（元素）\n  /* 返回值类型为元素对象，只返回指定ID的元素，如果在后面用.value是可以的，但是将.value赋给一个变量就不行，原因不明 */\n\ngetElementsByTagName() - 返回带有指定标签名的所有元素/* document.getElementsByTagName(“p”); */\n  /* document.getElementById(“main”).getElementsByTagName(“p”); //   元素应该是 id=”main” 的元素的后代 */\n\nThe getElementsByClassName() - 查找带有相同类名的所有 HTML 元素\n\nappendChild(node) - 插入新的子节点（元素）\n\nremoveChild(node) - 删除子节点（元素）\n\ncreateElement() - \n\n\n###DOM属性HTML DOM 属性是我们可以在节点（HTML 元素）设置和修改的值。→属性是我们能够获取或设置的值（比如节点的名称或内容）。\n\ninnerHTML - 节点（元素）的文本值（或者是————获取html元素的内容）/* innerHTML 属性可用于获取或改变任意 HTML 元素，包括  和  */\n\nparentNode - 节点（元素）的父节点\n\nchildNodes - 节点（元素）的子节点\n\nattributes - 节点（元素）的属性节点\n\nnodeName - 规定节点的名称 - 只读\n  /* 元素节点的 nodeName 与标签名相同,  属性节点的 nodeName 与属性名相同, 文本节点的 nodeName 始终是 #text, 文档节点的 nodeName 始终是 #document */\n\nnodeValue - 规定节点的值\n  /* 元素节点的 nodeValue 是 undefined 或 null, 文本节点的 nodeValue 是文本本身,属性节点的 nodeValue 是属性值 */\n\nnodeType - 返回节点的类型 - 只读\n  /* 元素节点反1， 属性节点反2， 文本节点反3， 注释节点反8，文档节点反9  */\n\n\n###DOM事件使用 JavaScript 向 HTML 元素分配事件：\n\nonclick - 鼠标点击触发事件\n\nonload - 用户进入界面触发事件/* onload 事件可用于检查访客的浏览器类型和版本，以便基于这些信息来加载不同版本的网页。 */\n\nonunload - 用户离开页面触发事件\n\nonload 和 onunload 事件可用于处理 cookies。\n   /* 实例见下 */\n\n\n\nonchange - 当用户改变输入字段的内容时，将调用事件\n\n实例见下20\n\n\nonmouseover - \n\nonmouseout - \n\nonmousedown - \n\nonmouseup - \n\n\n/* DOM方法与属性综合使用简单实践 */    &lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t&lt;&#x2F;head&gt;\n\t\n\t&lt;body&gt;\n\t\t&lt;p id&#x3D;&quot;intro&quot;&gt;Hello World!&lt;&#x2F;p&gt;\n\t\t&lt;script&gt;\n\t\t\tvar txt&#x3D;document.getElementById(&quot;intro&quot;).innerHTML;&#x2F;* getElementById是方法， 而innerHtml是属性 *&#x2F;\n\t\t\tdocument.write(txt);&#x2F;* innerHTML直接使用：***document.getElementById(&quot; ~~xxx的id~~ &quot;).innerHTML*** &#x3D; &quot; hello world &quot; *&#x2F;\n\t\t&lt;&#x2F;script&gt; &#x2F;* 作用很明了————捕获id为 &quot;intro&quot; 的元素，将它的值赋给txt， 并在文件中打印一次txt*&#x2F;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n/* nodeName、nodeType、nodeValue 应用实例 */    &lt;!DOCTYPE html&gt;\n\t&lt;html&gt;\n\t\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\n\t\t&lt;p id&#x3D;&quot;intro&quot;&gt;Hello World!&lt;&#x2F;p&gt;\n\n\t\t&lt;script&gt;\n\t\t\tx&#x3D;document.getElementById(&quot;intro&quot;);\n\t\t\tdocument.write(x.firstChild.nodeName&#x2F;* nodeType *&#x2F;&#x2F;* nodeValue *&#x2F;);\n\t\t&lt;&#x2F;script&gt;\n\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n/* innerHTML 实例//改变 HTML 内容 */    &lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;p id&#x3D;&quot;p1&quot;&gt;Hello World!&lt;&#x2F;p&gt;\t\t\n\t\t&lt;script&gt;\n\t\t\tdocument.getElementById(&quot;p1&quot;).innerHTML&#x3D;&quot;新文本!&quot;;\n\t\t&lt;&#x2F;script&gt;&#x2F;* p1 原本的文字并没有消失，它是在文档渲染中进行的实时替换的，仍然存在且仍然可以被利用，但是利用的js代码必须在替换之前！！！ *&#x2F;\n\t\t&lt;p&gt;段落通过脚本来修改内容。&lt;&#x2F;p&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n/* 改变 HTML 样式 */    \t&lt;p id&#x3D;&quot;p1&quot;&gt;Hello world!&lt;&#x2F;p&gt;\n\t&lt;p id&#x3D;&quot;p2&quot;&gt;Hello world!&lt;&#x2F;p&gt;\n\n&#96;&#96;&#96;html\n&lt;script&gt;\ndocument.getElementById(&quot;p2&quot;).style.color&#x3D;&quot;blue&quot;;\ndocument.getElementById(&quot;p2&quot;).style.fontFamily&#x3D;&quot;Arial&quot;;\ndocument.getElementById(&quot;p2&quot;).style.fontSize&#x3D;&quot;larger&quot;;\n&lt;&#x2F;script&gt;\n&#96;&#96;\n/* 使用事件 /1.    &lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&quot;document.body.style.backgroundColor&#x3D;&#39;lavender&#39;;&quot; value&#x3D;&quot;修改背景颜色&quot;&gt;也可以用函数执行:    &lt;script&gt;\n\tfunction ChangeBackground()\n\t&#123;\n\t\tdocument.body.style.backgroundColor&#x3D;&quot;lavender&quot;;\n\t&#125;\n&lt;&#x2F;script&gt;\n&lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&quot;ChangeBackground()&quot; value&#x3D;&quot;修改背景颜色&quot; &#x2F;&gt;        /         常见html事件的例子           - 当用户点击鼠标时           - 当网页已加载时           - 当图片已加载时           - 当鼠标移动到元素上时           - 当输入字段被改变时           - 当 HTML 表单被提交时           - 当用户触发按键时        /2.    &lt;h1 onclick&#x3D;&quot;this.innerHTML&#x3D;&#39;Ooops!&#39;&quot;&gt;点击文本!&lt;&#x2F;h1&gt;&#x2F;* 没有定义函数，直接在元素里完成脚本编写 *&#x2F;也可以用函数执行    &lt;script&gt;\n\tfunction changetext(id)&#123;\n\t\tid.innerHTML&#x3D;&quot;Ooops!&quot;;\n\t&#125;\n&lt;&#x2F;script&gt;\n&lt;h1 onclick&#x3D;&quot;changetext(this)&quot;&gt;点击文本!&lt;&#x2F;h1&gt;等于    &lt;script&gt;\n\tfunction changetext()\n\t&#123;\n\t\tdocument.getElementById(1).innerHTML&#x3D;&quot;Ooops!&quot;;\n\t&#125;\n&lt;&#x2F;script&gt;\n\t&lt;h1 onclick&#x3D;&quot;changetext()&quot; id&#x3D;&quot;1&quot;&gt;点击文本!&lt;&#x2F;h1&gt;3.    \t/ 创建新的HTML元素 - createElement() // 特点：将新元素作为父元素的最后一个子元素进行添加 /        &lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;div1&quot;&gt;\n\t\t&lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;\n\t\t&lt;p id&#x3D;&quot;p2&quot;&gt;这是另一个段落。&lt;&#x2F;p&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;script&gt;\n\t\t\tvar para&#x3D;document.createElement(&quot;p&quot;);\n\t\t\tvar node&#x3D;document.createTextNode(&quot;这是一个新段落。&quot;);\n\t\t\tpara.appendChild(node);\n\t\t\tvar element&#x3D;document.getElementById(&quot;div1&quot;);\n\t\t\telement.appendChild(para);\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;    / 实例解析    这段代码创建了一个新的  元素：                                            先新建你要添加的元素    var para=document.createElement(“p”);\n如需向 &lt;p&gt; 元素添加文本，您首先必须创建文本节点。这段代码创建文本节点：        必须创建文字节点来存储字符\nvar node=document.createTextNode(&quot;这是一个新段落。&quot;);\n\n然后您必须向 &lt;p&gt; 元素追加文本节点：                                        向元素节点追加文字节点\npara.appendChild(node);\n\n最后，您必须向已有元素追加这个新元素。                                        向已有元素追加新元素\n这段代码查找到一个已有的元素：\nvar element=document.getElementById(&quot;div1&quot;);\n\n这段代码向这个已存在的元素追加新元素：\nelement.appendChild(para); */\n\n/* 创建新的 HTML 元素 - insertBefore() // 特点：新元素添加时可以自选位置 */\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;div1&quot;&gt;\n\t\t\t&lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;\n\t\t\t&lt;p id&#x3D;&quot;p2&quot;&gt;这是另外一个段落。&lt;&#x2F;p&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;script&gt;\n\t\t\tvar para&#x3D;document.createElement(&quot;p&quot;);\t\t\t\t\t\t\t先新建你要添加的元素\n\t\t\tvar node&#x3D;document.createTextNode(&quot;这是一个新段落。&quot;);\t\t\t\t必须创建文字节点来存储字符\n\t\t\tpara.appendChild(node);\t\t\t\t\t\t\t\t\t\t\t向元素节点追加文字节点\n\t\t\tvar element&#x3D;document.getElementById(&quot;div1&quot;);\t\t\t\t\t找到新元素的插入指向的父元素\n\t\t\tvar child&#x3D;document.getElementById(&quot;p1&quot;);\t\t\t\t\t\t找到具体子元素中的插入位置(before)\n\t\t\telement.insertBefore(para,child);\t\t\t\t\t\t\t\t向已有元素追加新元素\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n/* 删除已有的 HTML 元素 */\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;div1&quot;&gt;\n\t\t\t&lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;\n\t\t\t&lt;p id&#x3D;&quot;p2&quot;&gt;这是另一个段落。&lt;&#x2F;p&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;script&gt;\n\t\t\tvar parent&#x3D;document.getElementById(&quot;div1&quot;);\t\t\t\t\t\t找到要删除元素的父元素\n\t\t\tvar child&#x3D;document.getElementById(&quot;p1&quot;);\t\t\t\t\t\t找到具体要删除的元素\n\t\t\tparent.removeChild(child);\t\t\t\t\t\t\t\t\t\t执行删除\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n/* 替换 HTML 元素 */\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;div1&quot;&gt;\n\t\t\t&lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;\n\t\t\t&lt;p id&#x3D;&quot;p2&quot;&gt;这是另外一个段落。&lt;&#x2F;p&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;script&gt;\n\t\t\tvar parent&#x3D;document.getElementById(&quot;div1&quot;);\t\t\t\t\t\t找父\n\t\t\tvar child&#x3D;document.getElementById(&quot;p1&quot;);\t\t\t\t\t\t找子\n\t\t\tvar para&#x3D;document.createElement(&quot;p&quot;);\t\t\t\t\t\t\t新子\n\t\t\tvar node&#x3D;document.createTextNode(&quot;这是一个新的段落。&quot;);\t\t\t新子内文本\n\t\t\tpara.appendChild(node);\t\t\t\t\t\t\t\t\t\t\t文本与子绑定\n\t\t\tparent.replaceChild(para,child);\t\t\t\t\t\t\t\t替换\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n/* onchange事件实例 */\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;\n\t\t&lt;script&gt;\n\t\t\tfunction myFunction()\n\t\t\t&#123;\n\t\t\t\tvar x&#x3D;document.getElementById(&quot;fname&quot;);\n\t\t\t\tx.value&#x3D;x.value.toUpperCase();\n\t\t\t&#125;\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t输入你的名字: &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;fname&quot; onchange&#x3D;&quot;myFunction()&quot;&gt;\t\n\t\t&lt;p&gt;当你离开输入框后，函数将被触发，将小写字母转为大写字母。&lt;&#x2F;p&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n/* onload事件实例（类推onunload） */\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body onload&#x3D;&quot;checkCookies()&quot;&gt;\n\t\t&lt;script&gt;\n\t\t\tfunction checkCookies()\n\t\t\t&#123;\n\t\t\t\tif (navigator.cookieEnabled&#x3D;&#x3D;true)&#x2F;* navigator是js中的一个对象(Navigator 对象包含有关浏览器的信息)，cookieEnabled是其一个属性 *&#x2F;\n\t\t\t\t&#123;\n\t\t\t\t\talert(&quot;Cookie 可用&quot;)\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\talert(&quot;Cookie 不可用&quot;)\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&lt;&#x2F;script&gt;\n\t\t&lt;p&gt;页面载入时，弹出浏览器 Cookie 可用状态。&lt;&#x2F;p&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n/* onmouseover 和 onmouseout 事件 及可类推的 onmousedown、onmouseup 以及 onclick 事件 */\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div onmouseover&#x3D;&quot;mOver(this)&quot; onmouseout&#x3D;&quot;mOut(this)&quot; style&#x3D;&quot;background-color:#D94A38;width:120px;height:20px;padding:40px;&quot;&gt;Mouse Over Me&lt;&#x2F;div&gt;\n\t\t&lt;script&gt;\n\t\t\tfunction mOver(obj)\n\t\t\t&#123;\n\t\t\t\tobj.innerHTML&#x3D;&quot;Thank You&quot;\n\t\t\t&#125;\n\t\t\tfunction mOut(obj)\n\t\t\t&#123;\n\t\t\t\tobj.innerHTML&#x3D;&quot;Mouse Over Me&quot;\n\t\t\t&#125;\n\t\t&lt;&#x2F;script&gt;\n\t\t\t&#x2F;* \t\t\n\t\t\t\t\t&lt;div onmousedown&#x3D;&quot;mDown(this)&quot; onmouseup&#x3D;&quot;mUp(this)&quot; style&#x3D;&quot;background-color:#D94A38;width:90px;height:20px;padding:40px;&quot;&gt;Click Me&lt;&#x2F;div&gt;\n\t\t\t\t\t&lt;script&gt;\n\t\t\t\t\t function mDown(obj)\n\t\t\t\t\t &#123;\n\t\t\t\t\t\tobj.style.backgroundColor&#x3D;&quot;#1ec5e5&quot;;\n\t\t\t\t\t\tobj.innerHTML&#x3D;&quot;Release Me&quot;\n\t\t\t\t\t &#125;\n\t\t\t\t\t \n\t\t\t\t\t function mUp(obj)\n\t\t\t\t\t &#123;\n\t\t\t\t\t\tobj.style.backgroundColor&#x3D;&quot;#D94A38&quot;;\n\t\t\t\t\t\tobj.innerHTML&#x3D;&quot;Thank You&quot;\n\t\t\t\t\t &#125;\n\t\t\t\t\t&lt;&#x2F;script&gt;\n\t\t\t*&#x2F;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n备注一些单位：\n\n\n\n\n\n\n\n\nem\n相对于父元素的字体大小\n\n\npx\n相对于屏幕分辨率\n\n\n%\n相对于父元素\n\n\ncm\n即厘米\n\n\nmm\n即毫米\n\n\nin\n即英寸\n\n\npt\n1/72 英寸\n\n\npc\n1/21\n\n\n","slug":"Web Dev/Front End/01. html_dom","date":"2023-03-08T00:26:14.936Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\nsvg————可缩放矢量模型（scalable vector graphics）\nsvg的主要意义：svg生成矢量图，它不会随着图片的缩放而发生失真##使用svg\n使用  标签导入 &lt;embed src&#x3D;&quot;circle1.svg&quot; type&#x3D;&quot;image&#x2F;svg+xml&quot; &#x2F;&gt;\n直接在html中嵌入svg代码 &lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n   &lt;circle cx&#x3D;&quot;100&quot; cy&#x3D;&quot;50&quot; r&#x3D;&quot;40&quot; stroke&#x3D;&quot;black&quot; stroke-width&#x3D;&quot;2&quot; fill&#x3D;&quot;red&quot; &#x2F;&gt;\n&lt;&#x2F;svg&gt;\n链接svg文件 &lt;a href&#x3D;&quot;circle1.svg&quot;&gt;View SVG file&lt;&#x2F;a&gt;\n##svg的图形元素\n\n引出：svg有很多预定义的形状元素，可以直接被开发者使用和操作！\n\n矩形————\n\n\n\n\n\n\n\n\n\n用  标签来创建矩形        /* 见示例1 */\n\n圆形————\n\n\n\n\n\n\n\n\n\n用 标签来创建圆            /* 见示例二 */\n\n椭圆————\n\n\n\n\n\n\n\n\n\n用 标签来创建椭圆        /* 见示例三 */\n\n直线————\n\n\n\n\n\n\n\n\n\n用 标签来创建直线            /* 见示例四 */\n\n多边形————\n\n\n\n\n\n\n\n\n\n用 标签来创建含有不少于三个边的图形            /* 见示例五 */\n\n曲线————\n\n\n\n\n\n\n\n\n\n用 标签来创建曲线        /* 见示例六 /            / 确切的说，应该算是个折线 */\n\n路径———— \n\n\n\n\n\n\n\n\n\n用 标签来定义一个路径        /* 见示例七 */以下的命令可用于路径数据\n\nM = move to                                        /* 两个参数表示点————移动画笔至一个点 */\nL = line to                                        /* 两个参数表示点————在前后两点间连一条直线 */\nH = horizontal line to                            /* 一个参数表示线————绘制竖直线 */\nV = vertical line to                                /* 一个参数表示线————绘制水平线 */\nC = curve to                                        /* 三个参数————定义两个控制点和一个点————“绘制平滑曲线的命令”————绘制三次贝塞尔曲线C */\nS = smooth curve to\nQ = quadratic Bézier curve                        /* “绘制平滑曲线的命令”————绘制二次贝塞尔曲线Q */\nT = smooth quadratic Bézier curve to\nA = elliptical Arc                                /* 弧形命令 */\nZ = close path                                    /* 无参数————闭合路径命令 // 以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位（例如：从上一个点开始，向上移动10px，向左移动7px） // 元素是SVG基本形状中最强大的一个。  你可以用它创建线条, 曲线, 弧形等等 */\n\n\n\n##svg文本：元素引出：元素用于定义文本见示例8\n\n\n\n\n\n\n\n\n\n8.1 书写文本8.2 字体旋转8.3 路径上的文字8.4 与元素联合8.5 作为连接文本（与元素联合）\n##svg滤镜种类多样!\n\n\n\n\n\n\n\n\n\nfeBlend - 与图像相结合的滤镜feColorMatrix - 用于彩色滤光片转换feComponentTransferfeCompositefeConvolveMatrixfeDiffuseLightingfeDisplacementMapfeFloodfeGaussianBlur - 用于图像的模糊处理（高斯模糊）feImagefeMergefeMorphologyfeOffset - 过滤阴影feSpecularLightingfeTilefeTurbulencefeDistantLight - 用于照明过滤fePointLight - 用于照明过滤feSpotLight - 用于照明过滤/* 按照示例9，依葫芦画瓢 */\n###svg模糊：实质上是一种滤镜 和 ：互联网的svg滤镜统一定义在中，是用于元素定义并含有特殊元素的定义而svg的滤镜必须定义在中，且标签必须使用id属性来定义图形应用应该指向那个滤镜/* xml的id使用见示例8，9 */\n###svg阴影仍用 和 使用  滤镜或与其他滤镜（如滤镜）组合使用/* 见示例10 */\n##svg属性\n\nstroke属性\n\n\n\n\n\n\n\n\nstroke属性                定义一条线，文本或元素轮廓的颜色stroke-width属性        定义了一条线，文本或元素轮廓的厚度stroke-linecap属性        定义不同类型的开放路径的结束方式stroke-dasharray属性    用于创建虚线（此四属性统一见示例）stroke-opacity属性        定义轮廓透明度（该属性运用见示例1.2）\n\nfill属性\nfill-rull属性&#x2F;* 示例1：创建矩形 *&#x2F;\n\t1. \n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;rect width&#x3D;&quot;300&quot; height&#x3D;&quot;100&quot; style&#x3D;&quot;fill:#66ccff;stroke-width:1;stroke:rgb(0,0,0)&quot;&#x2F;&gt;\n\t\t&lt;&#x2F;svg&gt;\n\t\t&#x2F;* \t1. rect 元素的 width 和 height 属性可定义矩形的高度和宽度\n\t\t\t2. style 属性用来定义 CSS 属性\n\t\t\t3. CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）&#x2F;* 3 是重点！ *&#x2F;\n\t\t\t4. CSS 的 stroke-width 属性定义矩形边框的宽度\n\t\t\t5. CSS 的 stroke 属性定义矩形边框的颜色&#x2F;* 详见stroke元素 *&#x2F;\n\t\t*&#x2F;\n\t2. \n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;rect x&#x3D;&quot;50&quot; y&#x3D;&quot;20&quot; width&#x3D;&quot;150&quot; height&#x3D;&quot;150&quot; style&#x3D;&quot;fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9&quot;&#x2F;&gt;\n\t\t&lt;&#x2F;svg&gt;\n\t\t&#x2F;* \t1. x 属性定义矩形的左侧位置（例如，x&#x3D;&quot;0&quot; 定义矩形到浏览器窗口左侧的距离是 0px）\n\t\t\t2. y 属性定义矩形的顶端位置（例如，y&#x3D;&quot;0&quot; 定义矩形到浏览器窗口顶端的距离是 0px）\n\t\t\t3. CSS 的 fill-opacity 属性定义填充颜色透明度（合法的范围是：0 - 1）&#x2F;* 1为完全不透明！ *&#x2F;\n\t\t\t4. CSS 的 stroke-opacity 属性定义轮廓颜色的透明度（合法的范围是：0 - 1）&#x2F;* 1为完全不透明！ *&#x2F;\n\t\t*&#x2F;\n\t   \n\t   &#x2F;* 对于 2 ，还可以使用 style&#x3D;&quot;opacity: 0.x&quot;&#x2F;* opacity值范围0-1 *&#x2F;来定义整个元素的不透明度，1为完全不透明！ *&#x2F;\n\t3. 创建一个圆角矩形\n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;rect x&#x3D;&quot;50&quot; y&#x3D;&quot;20&quot; rx&#x3D;&quot;20&quot; ry&#x3D;&quot;20&quot; width&#x3D;&quot;150&quot; height&#x3D;&quot;150&quot; style&#x3D;&quot;fill:red;stroke:black;stroke-width:5;opacity:0.5&quot;&#x2F;&gt;\n\t\t&lt;&#x2F;svg&gt;\n\t\t&#x2F;* rx 和 ry 属性可使矩形产生圆角。 *&#x2F;\n\n&#x2F;* 示例2：创建圆形 *&#x2F;\n\t1. \n\t\t&lt;!DOCTYPE html&gt;\n\t\t&lt;html&gt;\n\t\t\t&lt;body&gt;\n\t\t\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t\t\t&lt;circle cx&#x3D;&quot;100&quot; cy&#x3D;&quot;50&quot; r&#x3D;&quot;40&quot; stroke&#x3D;&quot;black&quot; stroke-width&#x3D;&quot;2&quot; fill&#x3D;&quot;red&quot; &#x2F;&gt;\n\t\t\t\t&lt;&#x2F;svg&gt; \n\t\t\t&lt;&#x2F;body&gt;\n\t\t&lt;&#x2F;html&gt;\n\t\t&#x2F;* \t1. cx和cy属性定义圆心的x和y坐标。如果省略cx和cy，圆心会被设置为(0, 0)\n\t\t\t2. r属性定义圆的半径\n\t\t*&#x2F;\n\n&#x2F;* 示例3：创建一个椭圆 *&#x2F;\n\t1.\n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;ellipse cx&#x3D;&quot;300&quot; cy&#x3D;&quot;80&quot; rx&#x3D;&quot;100&quot; ry&#x3D;&quot;50&quot; style&#x3D;&quot;fill:yellow;stroke:purple;stroke-width:2&quot;&#x2F;&gt;\n\t\t&lt;&#x2F;svg&gt;\n\t\t&#x2F;* \n\t\t\t1. CX属性定义的椭圆中心的x坐标\n\t\t\t2. CY属性定义的椭圆中心的y坐标\n\t\t\t3. RX属性定义的水平半径（半长轴）\n\t\t\t4. RY属性定义的垂直半径（半短轴）\n\t\t*&#x2F;\n\t2. 三个“层叠而上的”椭圆\n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;ellipse cx&#x3D;&quot;240&quot; cy&#x3D;&quot;100&quot; rx&#x3D;&quot;220&quot; ry&#x3D;&quot;30&quot; style&#x3D;&quot;fill:purple&quot; &#x2F;&gt;\n\t\t\t&lt;ellipse cx&#x3D;&quot;220&quot; cy&#x3D;&quot;70&quot; rx&#x3D;&quot;190&quot; ry&#x3D;&quot;20&quot; style&#x3D;&quot;fill:lime&quot; &#x2F;&gt;\n\t\t\t&lt;ellipse cx&#x3D;&quot;210&quot; cy&#x3D;&quot;45&quot; rx&#x3D;&quot;170&quot; ry&#x3D;&quot;15&quot; style&#x3D;&quot;fill:yellow&quot; &#x2F;&gt;\n\t\t&lt;&#x2F;svg&gt;\n\t3. 椭圆“组合”（或者叫“嵌套”？）\n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;ellipse cx&#x3D;&quot;240&quot; cy&#x3D;&quot;50&quot; rx&#x3D;&quot;220&quot; ry&#x3D;&quot;30&quot; style&#x3D;&quot;fill:yellow&quot;&#x2F;&gt;\n\t\t\t&lt;ellipse cx&#x3D;&quot;220&quot; cy&#x3D;&quot;50&quot; rx&#x3D;&quot;190&quot; ry&#x3D;&quot;20&quot; style&#x3D;&quot;fill:white&quot;&#x2F;&gt;\n\t\t&lt;&#x2F;svg&gt;\n\n&#x2F;* 示例4：创建一条直线 *&#x2F;\n\t1. \n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;line x1&#x3D;&quot;0&quot; y1&#x3D;&quot;0&quot; x2&#x3D;&quot;200&quot; y2&#x3D;&quot;200&quot; style&#x3D;&quot;stroke:rgb(255,0,0);stroke-width:2&quot;&#x2F;&gt;\n\t\t&lt;&#x2F;svg&gt;\n\t&#x2F;* \t1. x1 属性在 x 轴定义线条的开始&#x2F;* x轴————浏览器左上角向右延伸 *&#x2F;\n\t\t2. y1 属性在 y 轴定义线条的开始&#x2F;* y轴————浏览器左上角向下延伸 *&#x2F;\n\t\t3. x2 属性在 x 轴定义线条的结束\n\t\t4. y2 属性在 y 轴定义线条的结束\n\t*&#x2F;\n\n&#x2F;* 示例5：创建一个多边形 *&#x2F;\n\t1. 三角形\n\t&lt;svg  height&#x3D;&quot;210&quot; width&#x3D;&quot;500&quot;&gt;\n\t\t&lt;polygon points&#x3D;&quot;200,10 250,190 160,210&quot; style&#x3D;&quot;fill:lime;stroke:purple;stroke-width:1&quot;&#x2F;&gt;\n\t&lt;&#x2F;svg&gt;\n\t&#x2F;* \t1. points 属性定义多边形每个角的 x 和 y 坐标\n\t*&#x2F;\n   2. 四边形\n   &lt;svg height&#x3D;&quot;250&quot; width&#x3D;&quot;500&quot;&gt;\n\t\t&lt;polygon points&#x3D;&quot;220,10 300,210 170,250 123,234&quot; style&#x3D;&quot;fill:lime;stroke:purple;stroke-width:1&quot; &#x2F;&gt;\n   &lt;&#x2F;svg&gt;\n   3. 五角星_1\n\t&lt;svg height&#x3D;&quot;210&quot; width&#x3D;&quot;500&quot;&gt;\n\t\t&lt;polygon points&#x3D;&quot;100,10 40,198 190,78 10,78 160,198&quot; style&#x3D;&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;&quot; &#x2F;&gt;\n\t&lt;&#x2F;svg&gt;\n\t&#x2F;* 1. 出现五角星内有对角线的原因————svg 与多边形的产生方式有关!\n\t\t\t\tsvg 多边形是通过 前一个点 连接 后一个点 来产生连线来勾勒出多边形的，它一定会去连接下一个被定义的点并产生 stroke !\n\t*&#x2F;\n\t&#x2F;* \t1. fill-rule:nonzero; \n\t*&#x2F;\n   4. 五角星_2\n   &lt;svg height&#x3D;&quot;210&quot; width&#x3D;&quot;500&quot;&gt;\n\t\t&lt;polygon points&#x3D;&quot;100,10 40,198 190,78 10,78 160,198&quot; style&#x3D;&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; &#x2F;&gt;\n   &lt;&#x2F;svg&gt;\n   &#x2F;* \t1. fill-rule:evenodd;\n   *&#x2F;\n  &#x2F;* [fill-rule 介绍：](http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2008&#x2F;REC-CSS2-20080411&#x2F;cascade.html#value-def-inherit) *&#x2F;\n  &#x2F;*  *&#x2F;\n\n&#x2F;* 示例6：曲线的实际应用 *&#x2F;\n\t1. \n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;polyline points&#x3D;&quot;20,20 40,25 60,40 80,120 120,140 200,10&quot; style&#x3D;&quot;fill:none;stroke:black;stroke-width:3&quot; &#x2F;&gt;\n\t&lt;&#x2F;svg&gt;\n\t&#x2F;* \t1. 第一个点是起始位置(都是绝对位置！)\n\t\t2. 第二个点往后是折线段的\n\t\t3. 最后一个点是灭点\n\t*&#x2F;\n\n&#x2F;* 示例7：路径path的实际使用 *&#x2F;\n\t1. \n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;path d&#x3D;&quot;M150 0 L75 200 L225 200 Z&quot; &#x2F;&gt;\n\t&lt;&#x2F;svg&gt;\n\t&#x2F;* \t1. d是&lt;path&gt;中完成绘制工作的属性，它包含了一系列的用于绘制的命令\n\t\t2. M是绝对路径上的点，可以通过M（move to）来实现移动画笔，但是这个 “ M ” ，它也只移动画笔，不会去画线！ 所以 M 命令一般出现在路径的开始处，用来指明从何处开始画\n\t\t3. L是用虚画笔来完成连线的，path中最常用的命令，会在当前位置和它之后给出的新位置之间画一条线段（x0 y0 L x y (从点(x0,y0)出发连一条线到(x,y))）\n\t*&#x2F;\n\n&#x2F;* 示例8 *&#x2F;\n\t1. 写一个文本：\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;text x&#x3D;&quot;0&quot; y&#x3D;&quot;15&quot; fill&#x3D;&quot;red&quot;&gt;I love SVG&lt;&#x2F;text&gt;\n\t&lt;&#x2F;svg&gt;\n\t2. 旋转的文字：\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;text x&#x3D;&quot;0&quot; y&#x3D;&quot;15&quot; fill&#x3D;&quot;red&quot; transform&#x3D;&quot;rotate(30 20,40)&quot;&gt;I love SVG&lt;&#x2F;text&gt;\n\t&lt;&#x2F;svg&gt;\n\t\n\t\n&gt; 划重点！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n\t3. 路径上的文字：\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot;&gt;\n\t\t&lt;defs&gt;\n\t\t\t&lt;path id&#x3D;&quot;path1&quot; d&#x3D;&quot;M75,20 a1,1 0 0,0 100,0&quot; &#x2F;&gt;\n\t\t&lt;&#x2F;defs&gt;\n\t\t&lt;text x&#x3D;&quot;10&quot; y&#x3D;&quot;100&quot; style&#x3D;&quot;fill:red;&quot;&gt;\n\t\t\t&lt;textPath xlink:href&#x3D;&quot;#path1&quot;&gt;I love SVG I love SVG&lt;&#x2F;textPath&gt;\n\t\t&lt;&#x2F;text&gt;\n\t&lt;&#x2F;svg&gt;\n&gt; 划重点！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n\n\n\t4. 安排任何分小组与&lt;tspan&gt; 元素的数量。每个&lt;tspan&gt; 元素可以包含不同的格式和位置。几行文本(与 &lt;tspan&gt; 元素):\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;text x&#x3D;&quot;10&quot; y&#x3D;&quot;20&quot; style&#x3D;&quot;fill:red;&quot;&gt;Several lines:\n\t\t\t&lt;tspan x&#x3D;&quot;10&quot; y&#x3D;&quot;45&quot; style&#x3D;&quot;fill:blue;&quot;&gt;First line&lt;&#x2F;tspan&gt;\n\t\t\t&lt;tspan x&#x3D;&quot;10&quot; y&#x3D;&quot;70&quot; style&#x3D;&quot;fill:green;&quot;&gt;Second line&lt;&#x2F;tspan&gt;\n\t\t&lt;&#x2F;text&gt;\n\t&lt;&#x2F;svg&gt;\n\t5. 作为链接文本（ &lt;a&gt; 元素）：\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot;&gt;\n\t\t&lt;a xlink:href&#x3D;&quot;http:&#x2F;&#x2F;www.w3schools.com&#x2F;svg&#x2F;&quot; target&#x3D;&quot;_blank&quot;&gt;\n\t\t\t&lt;text x&#x3D;&quot;0&quot; y&#x3D;&quot;15&quot; fill&#x3D;&quot;red&quot;&gt;I love SVG&lt;&#x2F;text&gt;\n\t\t&lt;&#x2F;a&gt;\n\t&lt;&#x2F;svg&gt;\n\n&#x2F;* 示例9：svg的模糊效果 *&#x2F;\n\t1. &lt;feGaussianBlur&gt;元素（用于创建模糊效果）\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;defs&gt;\n\t\t\t&lt;filter id&#x3D;&quot;f1&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot;&gt;\n\t\t\t\t&lt;feGaussianBlur in&#x3D;&quot;SourceGraphic&quot; stdDeviation&#x3D;&quot;15&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;filter&gt;\n\t\t&lt;&#x2F;defs&gt;\n\t\t&lt;rect width&#x3D;&quot;90&quot; height&#x3D;&quot;90&quot; stroke&#x3D;&quot;green&quot; stroke-width&#x3D;&quot;3&quot; fill&#x3D;&quot;yellow&quot; filter&#x3D;&quot;url(#f1)&quot; &#x2F;&gt;\n\t&lt;&#x2F;svg&gt;\n\t&#x2F;* \t1. &lt;filter&gt;元素id属性定义一个滤镜的唯一名称\n\t\t2. &lt;feGaussianBlur&gt;元素定义模糊效果\n\t\t3. in&#x3D;&quot;SourceGraphic&quot;这个部分定义了由整个图像创建效果\n\t\t4. stdDeviation属性定义模糊量\n\t\t5. &lt;rect&gt;元素的滤镜属性用来把元素链接到&quot;f1&quot;滤镜\n\t*&#x2F;\n\n&#x2F;* 示例10：svg阴影 *&#x2F;\n\t1.\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;defs&gt;\n\t\t\t&lt;filter id&#x3D;&quot;f1&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;200%&quot; height&#x3D;&quot;200%&quot;&gt;\n\t\t\t\t&lt;feOffset result&#x3D;&quot;offOut&quot; in&#x3D;&quot;SourceGraphic&quot; dx&#x3D;&quot;20&quot; dy&#x3D;&quot;20&quot; &#x2F;&gt;\n\t\t\t\t&lt;feBlend in&#x3D;&quot;SourceGraphic&quot; in2&#x3D;&quot;offOut&quot; mode&#x3D;&quot;normal&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;filter&gt;\n\t\t&lt;&#x2F;defs&gt;\n\t\t&lt;rect width&#x3D;&quot;90&quot; height&#x3D;&quot;90&quot; stroke&#x3D;&quot;green&quot; stroke-width&#x3D;&quot;3&quot; fill&#x3D;&quot;yellow&quot; filter&#x3D;&quot;url(#f1)&quot; &#x2F;&gt;\n\t&lt;&#x2F;svg&gt;\n\t&#x2F;* &lt;filter&gt;元素id属性定义一个滤镜的唯一名称，&lt;rect&gt;元素的滤镜属性用来把元素链接到&quot;f1&quot;滤镜 *&#x2F;\n\t2.\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;defs&gt;\n\t\t\t&lt;filter id&#x3D;&quot;f1&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;200%&quot; height&#x3D;&quot;200%&quot;&gt;\n\t\t\t\t&lt;feOffset result&#x3D;&quot;offOut&quot; in&#x3D;&quot;SourceGraphic&quot; dx&#x3D;&quot;20&quot; dy&#x3D;&quot;20&quot; &#x2F;&gt;\n\t\t\t\t&lt;feGaussianBlur result&#x3D;&quot;blurOut&quot; in&#x3D;&quot;offOut&quot; stdDeviation&#x3D;&quot;10&quot; &#x2F;&gt;\n\t\t\t\t&lt;feBlend in&#x3D;&quot;SourceGraphic&quot; in2&#x3D;&quot;blurOut&quot; mode&#x3D;&quot;normal&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;filter&gt;\n\t\t&lt;&#x2F;defs&gt;\n\t\t&lt;rect width&#x3D;&quot;90&quot; height&#x3D;&quot;90&quot; stroke&#x3D;&quot;green&quot; stroke-width&#x3D;&quot;3&quot; fill&#x3D;&quot;yellow&quot; filter&#x3D;&quot;url(#f1)&quot; &#x2F;&gt;\n\t&lt;&#x2F;svg&gt;\n\t&#x2F;* &lt;feGaussianBlur&gt;元素的stdDeviation属性定义了模糊量 *&#x2F;\n\t3.\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;defs&gt;\n\t\t\t&lt;filter id&#x3D;&quot;f1&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;200%&quot; height&#x3D;&quot;200%&quot;&gt;\n\t\t\t\t&lt;feOffset result&#x3D;&quot;offOut&quot; in&#x3D;&quot;SourceAlpha&quot; dx&#x3D;&quot;20&quot; dy&#x3D;&quot;20&quot; &#x2F;&gt;\n\t\t\t\t&lt;feGaussianBlur result&#x3D;&quot;blurOut&quot; in&#x3D;&quot;offOut&quot; stdDeviation&#x3D;&quot;10&quot; &#x2F;&gt;\n\t\t\t\t&lt;feBlend in&#x3D;&quot;SourceGraphic&quot; in2&#x3D;&quot;blurOut&quot; mode&#x3D;&quot;normal&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;filter&gt;\n\t\t&lt;&#x2F;defs&gt;\n\t\t&lt;rect width&#x3D;&quot;90&quot; height&#x3D;&quot;90&quot; stroke&#x3D;&quot;green&quot; stroke-width&#x3D;&quot;3&quot; fill&#x3D;&quot;yellow&quot; filter&#x3D;&quot;url(#f1)&quot; &#x2F;&gt;\n\t&lt;&#x2F;svg&gt;\n\t&#x2F;* &lt;feOffset&gt;元素的属性改为&quot;SourceAlpha&quot;在Alpha通道使用残影，而不是整个RGBA像素。 *&#x2F;\n\t4.\n\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t&lt;defs&gt;\n\t\t\t&lt;filter id&#x3D;&quot;f1&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;200%&quot; height&#x3D;&quot;200%&quot;&gt;\n\t\t\t\t&lt;feOffset result&#x3D;&quot;offOut&quot; in&#x3D;&quot;SourceGraphic&quot; dx&#x3D;&quot;20&quot; dy&#x3D;&quot;20&quot; &#x2F;&gt;\n\t\t\t\t&lt;feColorMatrix result&#x3D;&quot;matrixOut&quot; in&#x3D;&quot;offOut&quot; type&#x3D;&quot;matrix&quot; values&#x3D;&quot;0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0&quot; &#x2F;&gt;\n\t\t\t\t&lt;feGaussianBlur result&#x3D;&quot;blurOut&quot; in&#x3D;&quot;matrixOut&quot; stdDeviation&#x3D;&quot;10&quot; &#x2F;&gt;\n\t\t\t\t&lt;feBlend in&#x3D;&quot;SourceGraphic&quot; in2&#x3D;&quot;blurOut&quot; mode&#x3D;&quot;normal&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;filter&gt;\n\t\t&lt;&#x2F;defs&gt;\n\t\t&lt;rect width&#x3D;&quot;90&quot; height&#x3D;&quot;90&quot; stroke&#x3D;&quot;green&quot; stroke-width&#x3D;&quot;3&quot; fill&#x3D;&quot;yellow&quot; filter&#x3D;&quot;url(#f1)&quot; &#x2F;&gt;\n\t&lt;&#x2F;svg&gt;\n\t&#x2F;* &lt;feColorMatrix&gt;过滤器是用来转换偏移的图像使之更接近黑色的颜色。 &#39;0.2&#39;矩阵的三个值都获取乘以红色，绿色和蓝色通道。降低其值带来的颜色至黑色（黑色为0） *&#x2F;\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例8 *&#x2F;\n\t\n\n&#x2F;* 示例1：stroke属性示例 *&#x2F;\n1. stroke\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;body&gt;\n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;g fill&#x3D;&quot;none&quot;&gt;\n\t\t\t\t&lt;path stroke&#x3D;&quot;red&quot; d&#x3D;&quot;M5 20 l215 0&quot; &#x2F;&gt;\n\t\t\t\t&lt;path stroke&#x3D;&quot;black&quot; d&#x3D;&quot;M5 40 l215 0&quot; &#x2F;&gt;\n\t\t\t\t&lt;path stroke&#x3D;&quot;blue&quot; d&#x3D;&quot;M5 60 l215 0&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;g&gt;&#x2F;* stroke 可以直接在&lt;g&gt;标签中统一定义！ *&#x2F;\n\t\t&lt;&#x2F;svg&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n2. stroke-width\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;body&gt;\n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;g fill&#x3D;&quot;none&quot; stroke&#x3D;&quot;black&quot;&gt;\n\t\t\t\t&lt;path stroke-width&#x3D;&quot;2&quot; d&#x3D;&quot;M5 20 l215 0&quot; &#x2F;&gt;\n\t\t\t\t&lt;path stroke-width&#x3D;&quot;4&quot; d&#x3D;&quot;M5 40 l215 0&quot; &#x2F;&gt;\n\t\t\t\t&lt;path stroke-width&#x3D;&quot;6&quot; d&#x3D;&quot;M5 60 l215 0&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;g&gt;&#x2F;* 同样的，stroke-width 也可以直接在&lt;g&gt;标签中统一定义！ *&#x2F;\n\t\t&lt;&#x2F;svg&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n3. stroke-linecap\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;body&gt;\n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;g fill&#x3D;&quot;none&quot; stroke&#x3D;&quot;black&quot; stroke-width&#x3D;&quot;6&quot;&gt;\n\t\t\t\t&lt;path stroke-linecap&#x3D;&quot;butt&quot; d&#x3D;&quot;M5 20 l215 0&quot; &#x2F;&gt;\n\t\t\t\t&lt;path stroke-linecap&#x3D;&quot;round&quot; d&#x3D;&quot;M5 40 l215 0&quot; &#x2F;&gt;\n\t\t\t\t&lt;path stroke-linecap&#x3D;&quot;square&quot; d&#x3D;&quot;M5 60 l215 0&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;g&gt;&#x2F;* 同上 *&#x2F;\n\t\t&lt;&#x2F;svg&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n4. stroke-dasharray\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;body&gt;\n\t\t&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;\n\t\t\t&lt;g fill&#x3D;&quot;none&quot; stroke&#x3D;&quot;black&quot; stroke-width&#x3D;&quot;4&quot;&gt;\n\t\t\t\t&#x2F;* 1号 *&#x2F;&lt;path stroke-dasharray&#x3D;&quot;5,5&quot; d&#x3D;&quot;M5 20 l215 0&quot; &#x2F;&gt;\n\t\t\t\t&#x2F;* 2号 *&#x2F;&lt;path stroke-dasharray&#x3D;&quot;10,10&quot; d&#x3D;&quot;M5 40 l215 0&quot; &#x2F;&gt;\n\t\t\t\t&#x2F;* 3号 *&#x2F;&lt;path stroke-dasharray&#x3D;&quot;20,10,5,5,5,10&quot; d&#x3D;&quot;M5 60 l215 0&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;g&gt;&#x2F;* 同上 *&#x2F;\n\t\t&lt;&#x2F;svg&gt;&#x2F;* stroke-dasharray中，对于1、2号来讲：第一个参数是一条虚线上 单条短实线的长度， 第二个参数是一条虚线上 各个短实线之间的间隔长度 *&#x2F;\n\t&lt;&#x2F;body&gt;&#x2F;* 而对于3号（多参数）来讲，其顺序是：短实线长，间隔长，短实线长，间隔长，短实线长，间隔长······如此循环，事实上1、2号也遵守此规律 *&#x2F;\n&lt;&#x2F;html&gt;","slug":"Web Dev/Front End/02. svg","date":"2023-03-08T00:26:14.934Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"#什么是jQuery：\n\n\n\n\n\n\n\n\n\njQuery 库是一个 JavaScript 文件，您可以使用 HTML 的标签来引用它：\n&lt;head&gt;\n\t&lt;script src&#x3D;&quot;jquery-1.10.2.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n/* JavaScript 是 HTML5 以及所有现代浏览器中的默认脚本语言！ */\n/* 所以没有必要再于&lt;script&gt;标签中写上：type=&quot;text/javascript&quot; 了 */\n\n##学习jQuery:\n\n查看当前jq版本：在控制台中，使用$.fn.jquery命令，即可调用出当前页面的jq版本\n\njq语法：\n\n\n/* 使用jq的代替方案————CDN(内容分发网络)，即，通过CDN来就近引用服务器中存有的jQuery // 1. Staticfile CDN: /    &lt;head&gt;\n\t&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.10.2&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;/ 2. 百度 CDN: /    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;apps.bdimg.com&#x2F;libs&#x2F;jquery&#x2F;2.1.4&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;/ 3. 又拍云 CDN: /    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;upcdn.b0.upaiyun.com&#x2F;libs&#x2F;jquery&#x2F;jquery-2.0.2.min.js&quot;&gt;&lt;&#x2F;script&gt;/ 4. 新浪 CDN: /    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;lib.sinaapp.com&#x2F;js&#x2F;jquery&#x2F;2.0.2&#x2F;jquery-2.0.2.min.js&quot;&gt;&lt;&#x2F;script&gt;/ 5. Google CDN: /    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;ajax.googleapis.com&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;1.10.2&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;/ 6. Microsoft CDN: /    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;ajax.aspnetcdn.com&#x2F;ajax&#x2F;jquery&#x2F;jquery-1.9.0.min.js&quot;&gt;&lt;&#x2F;script&gt;/ 使用CDN的两个优势 // 1. 用户在访问其他站点时，已经从CDN处加载过 jQuery。所以结果是，当他们访问您的站点时，会从CDN的缓存中加载 jQuery，这样可以减少加载时间。 // 2. 大多数 CDN 都可以确保当用户向其请求文件时，会从离用户最近的服务器上返回响应，这样也可以提高加载速度。 */\n","slug":"Web Dev/Front End/jQuery","date":"2023-03-08T00:26:14.932Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"响应式（Responsive）响应式是什么呢？顾名思义，响应式，肯定会自动响应，响应什么？应用程序是在终端屏幕窗口中展示给用户，被用户访问的，那么就是响应屏幕的变化，不同终端屏幕尺寸大小不一致，需要针对不同尺寸屏幕进行不同的展示响应。\n响应式（Responsive web design, RWD），是指一套应用程序用户界面（User Interface）能自动响应不同设备窗口或屏幕尺寸（screen size）并且内容，布局渲染表现良好。自适应（Adaptive）在响应式设计（RWD）之外，还有一种适配多设备屏幕的方式，自适应设计（Adaptive web design， AWD）。\n自适应设计(AWD)，是指一个应用程序使用多版本用户界面，针对不同设备屏幕，服务器端返回不同版本用户界面，供用户访问。\nDesign UI For Mobile Phone网页自适应手机端的方式有两种：\n\nPC端的设计与手机端相差不大，利用 @media媒体查询 调整百分比\n\nPC端与手机端的设计分离，利用判断设备的方式做301跳转\n\n\n下面就结合源代码讲一讲如何实际实现这两种方案：\nMethod1Step1在html代码中添加如下代码\n&lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;\n&lt;meta content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot; name&#x3D;&quot;viewport&quot;&gt;\n&lt;meta content&#x3D;&quot;yes&quot; name&#x3D;&quot;apple-mobile-web-app-capable&quot;&gt;\n&lt;meta content&#x3D;&quot;yes&quot; name&#x3D;&quot;apple-touch-fullscreen&quot;&gt;\n&lt;meta content&#x3D;&quot;black&quot; name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot;&gt;\n&lt;meta content&#x3D;&quot;320&quot; name&#x3D;&quot;MobileOptimized&quot;&gt;\n\nStep2设置PC端内容区域width:1100px，添加如下代码：\n.container&#123; width:1100px; max-width:100%; &#125;\n.container img&#123; max-width:100%; &#125;\n \n@media only screen and (max-width: 480px) &#123;\n           &#x2F;&#x2F;此适配不同手机型号下文字，图片的大小\n&#125;\n \n@media only screen and (max-width: 375px) &#123;\n \n            &#x2F;&#x2F;此适配不同手机型号下文字，图片的大小\n&#125;\n \n..&#x2F;&#x2F;可继续\n\nMethod2在PC端公共Header中，添加如下JS\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n        if (window.location.toString().indexOf(&#39;pref&#x3D;padindex&#39;) !&#x3D; -1) &#123; &#125; else &#123;\n            if (&#x2F;AppleWebKit.*Mobile&#x2F;i.test(navigator.userAgent) || (&#x2F;MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE&#x2F;.test(navigator.userAgent))) &#123;\n                if (window.location.href.indexOf(&quot;?mobile&quot;) &lt; 0) &#123;\n                    try &#123;\n                        if (&#x2F;Android|Windows Phone|webOS|iPhone|iPod|BlackBerry&#x2F;i.test(navigator.userAgent)) &#123;\n                            window.location.href &#x3D; &quot;手机端链接&quot;;\n                        &#125; else if (&#x2F;iPad&#x2F;i.test(navigator.userAgent)) &#123;\n                        &#125; else &#123;\n                        &#125;\n                    &#125; catch (e) &#123;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n&lt;&#x2F;script&gt;    ","slug":"Web Dev/Front End/UIDesign","date":"2023-03-08T00:26:14.930Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"用idea创建前后端分离的Java项目idea创建带springboot框架的项目使用maven管理项目","slug":"Web Dev/Vue与SpringBoot/用idea创建项目","date":"2023-03-08T00:26:14.928Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"动画模板：AnimateAnimate.css | A cross-browser library of CSS animations.\nUI框架：Vuetify\nVue Material Design Component Framework — Vuetify.js\nBootstrap \nBootstrap · The most popular HTML, CSS, and JS library in the world. (getbootstrap.com)\nBuefyBuefy: lightweight UI components for Vue.js based on Bulma\nElement UIA Desktop UI Toolkit for Web | Element Plus (element-plus.org)\nQuasar FrameWork不止Web UI\nQuasar Framework\nQuasar Framework 中文网 (quasarchs.com)\nLayUI基于JQ的前端框架，一个时代的尾声\nGitHub - sentsin/layui: 采用自身模块规范编写的前端 UI 框架，遵循原生 HTML/CSS/JS 的书写形式，极低门槛，拿来即用。\n\n","slug":"Web Dev/Front End/前端框架","date":"2023-03-08T00:26:12.577Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"载入内容的防止缓存策略在HTML页面更新后浏览器存在大部分时机影响更新页面的使用，非技术人员根本意识不到内容是否有更新\n&lt;head&gt; \n    &lt;!--  --&gt;\n    &lt;meta http-equiv&#x3D;&quot;Expires&quot; content&#x3D;&quot;0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;Pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;Cache-control&quot; content&#x3D;&quot;no-cache&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;Cache&quot; content&#x3D;&quot;no-cache&quot;&gt;\n\n    &lt;!-- 动态加载js以更新数据与控制逻辑 --&gt;\n    &lt;script&gt;\n        document.write(&#39;&lt;script src&#x3D;&quot;&#x2F;static&#x2F;js&#x2F;basicScatter.js?adv&#x3D;&#39;+Math.random()+&#39;&quot;&gt;&lt;\\&#x2F;script&gt;&#39;);\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n\n由于加入了随机数，每次都会载入“全新的目标文件”，阻止了网页缓存，保证修改的及时展示\nDebugger只要在代码中添加debugger，chrome在运行的时候会自动停在那里。还可以用条件语句把它包裹起来，这样就可以在需要的时候才执行它。\nif (true) &#123;\n  debugger;\n&#125;\n\n\n\nConsole2.1 console.log在console.log()中，可以用%s设置字符串，**%i设置数字，%c设置自定义样式，console.log()**接受的两个参数，前者是描述性的语言，而第二个参数是与第一个参数位置对应的字符\nconsole.log(&#39; %c %s %s %s&#39;, &#39;color: yellow; background-color: black;&#39;, &#39;–&#39;, &#39;测试信息&#39;, &#39;–&#39;);\n\n2.2 console.table()很多的时候，你可能会有一堆对象需要查看。可以用console.log把每一个对象都输出出来，也可以用console.table语句直接把所有的对象都直接输出成为一个表格\n\n2.3 console.time()和console.timeEnd()当想知道某些代码的执行时间的时候这个工具将会非常有用，特别是当你定位很耗时的循环的时候。\n\n2.4 console.trace()**console.trace()**会显示函数调用的完整的堆栈轨迹信息\ngetTopN2(arr, n) &#123;\n  &#x2F;&#x2F; sort参数返回值大于1，就交换位置\n  console.trace(&#39;getTopN2&#39;);\n  return [...arr].sort((a, b) &#x3D;&gt; b - a).slice(0, n)\n&#125;\n\n结果如下：\n\n(14 封私信 / 80 条消息) 前端页面，用 JavaScript 在调试 Bug 时有哪些奇技淫巧？ - 知乎 (zhihu.com)\n","slug":"Web Dev/Front End/奇技淫巧","date":"2023-03-08T00:26:12.574Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"建立一个个人网站吧感想：这是本站的第一篇文章，这篇文章的上传意味着——这个站子正式成立了！\n前言：本文是在“云服务器”上建立个人网站的基础向教程，并不要求有什么编程基础缘由：我个人中二的以为，建立一个个人网站，即使是在大学里，都是很装逼的事注意事项：你可能需要准备","slug":"Web Dev/Front End/建立一个个人网站吧","date":"2023-03-08T00:26:12.572Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n如果是对同一个表进行数据操作，应该使用同一条API，然后根据method的不同，进行不同的操作\nGET&#x2F;POST&#x2F;PUT&#x2F;DELETE&#x2F;PATCH\n面向资源编程，通过API提交的参数最好是名词如name，尽量少用动词\nhttp:&#x2F;&#x2F;www.abc.com&#x2F;name\n体现版本，在API中加入像v1, v2这样的版本代号\nhttp:&#x2F;&#x2F;www.abc.com&#x2F;v1&#x2F;name\nhttp:&#x2F;&#x2F;www.abc.com&#x2F;v2&#x2F;name\n体现API，让使用者一眼能看出这是API而不是URL，应该在API中加入提示：\nhttp:&#x2F;&#x2F;www.abc.com&#x2F;api&#x2F;v1&#x2F;name\nhttp:&#x2F;&#x2F;www.abc.com&#x2F;api&#x2F;v2&#x2F;name\n使用HTTPS\nhttps:&#x2F;&#x2F;www.abc.com&#x2F;api&#x2F;v1&#x2F;name\nhttps:&#x2F;&#x2F;www.abc.com&#x2F;api&#x2F;v2&#x2F;name\n响应式设置状态码\nreturn HttpResponse(&#39;abcde&#39;, status&#x3D;200)\nAPI的参数里加入筛选条件参数，也可以理解为获取资源优先选择GET的方式\nhttps:&#x2F;&#x2F;www.abc.com&#x2F;api&#x2F;v2&#x2F;name?page&#x3D;1&amp;size&#x3D;10\n返回值的规范，对不同的请求method，做出相应的响应值如：\n-&gt; https:&#x2F;&#x2F;www.abc.com&#x2F;api&#x2F;v1&#x2F;name\n\n- GET: 所有列表\n- POST: 新增的数据\n\n-&gt; https:&#x2F;&#x2F;www.abc.com&#x2F;api&#x2F;v1&#x2F;name&#x2F;1\n\n- GET: 单条数据\n- PUT: 更新，返回更新的数据\n- PATCH: 局部更新，返回更新的数据\n- DELETE: 删除，返回空文档\n返回错误信息，包括错误代号等，让用户直接看出是哪种类型错误\nret &#123;\n    code: 1000,\n    data: &#123;\n        1: &#123;&#39;id&#39;: 1, &#39;title&#39;: &#39;lala&#39;&#125;\n    &#125;\n&#125;\n返回的详细信息，应该以字典的形式存放在data中\nret &#123;\n    code: 1000,\n    data: &#123;\n        1: &#123;&#39;id&#39;: 1, &#39;title&#39;: &#39;lala&#39;, &#39;detail&#39;: &#39;lalalalala&#39;&#125;\n    &#125;\n&#125;\n\n","slug":"Web Dev/Back End/RESTful规范 - 如何写API","date":"2023-03-08T00:26:12.570Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"Web Dev/Back End/WSGI","date":"2023-03-08T00:26:12.567Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"关联视频地址：【Unity教程搬运】学习如何在Unity2022制作一个2D平台游戏 - 完整的游戏开发课程！_哔哩哔哩_bilibili\n要点速览给项目做好预设做出一个基本界面尝试parallax effect式的background在使用了parallax effect，设定：最远的后，我们往往能发现，\ntilemapsPlayer Logic我们需要实现的是一个经典的2d rpg character\n对于这种character，我们需要做的有：\nPlayer InputPlayer ColliderPlayer Animator and StatesEnemy ai敌人的animator敌人的hitbox敌人的detect box","slug":"Technical Artist/YourFirstGame/ReadMe","date":"2023-03-08T00:26:12.565Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"Technical Artist/RenderingPipline/00.General","date":"2023-03-08T00:26:12.562Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"应用阶段应用阶段的主要任务是把需要显示在屏幕上的几何信息输入到渲染管线的下一阶段。\n应用阶段其实就是指Unity中用C#编程的阶段，通过代码控制的程序变化，但是并不似所有变化都会影响到接下来的渲染阶段，只有做了与渲染相关的操作才会影响接下来的阶段。比如控制摄像机的位置，物体的旋转、颜色等都能影响姐接下来的渲染阶段。\n我们在写Shader的时候，会看到一个叫appdata的结构体，而结构体所定义的数据就是从应用阶段传过来的数据。\n struct appdata_t &#123;\n  float4 vertex: POSITION;\n  float4 color: COLOR;\n  float2 texcoord: TEXCOORD0;\n&#125;;\n\n\n\n应用阶段会提供大致以下数据：\n\n顶点（网格）\n颜色\n纹理的UV坐标\nMVP矩阵\n光源位置\n\n好多书中都会写应用阶段是通过软件方式来实现的阶段，开发者在应用阶段有完全的控制权。\n我理解的软件方式指的是CPU负责的事情，在Unity中游戏逻辑，编码、资产处理都是CPU去处理的。而“开发者”在游戏引擎指的是引擎的开发者和使用者，开发者决定了引擎的渲染方式，提供的渲染路径，如何触发批处理等，而使用者可以控制物体本身的属性和渲染相关的脚本编写。\n所以说应用阶段我们使用了游戏引擎提供的相关功能加上我们自己的编码和设置来控制最终给下一个阶段提供的数据信息。\n[(12 封私信 / 80 条消息) 渲染管线 应用阶段 - 搜索结果 - 知乎 (zhihu.com)](https://www.zhihu.com/search?type=content&amp;q=渲染管线 应用阶段)\n","slug":"Technical Artist/RenderingPipline/01.Application","date":"2023-03-08T00:26:12.559Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"Technical Artist/RemakeDarkSoul/ReadMe","date":"2023-03-08T00:26:11.173Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"浅谈《原神》中的图形渲染技术_AkagiSenpai的博客-CSDN博客_原神渲染技术\n\n\n\n(12 封私信 / 80 条消息) 大学4年想成为一个优秀的技术美术（偏技术），该怎么做？ - 知乎 (zhihu.com)\n","slug":"Technical Artist/BlogCollection/综述","date":"2023-03-08T00:26:11.170Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"Softwares/Windows/Bat脚本编写","date":"2023-03-08T00:26:11.168Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"介绍——什么是PowerShell？\n什么是 PowerShell？ - PowerShell | Microsoft Docs\n\nPowerShell和CMD的关系：\n\n\n在Windows下，简单的说，PowerShell可以近似认为是cmd的超集，换句话说，PowerShell几乎兼容所有cmd命令。cmd能做的事情，PowerShell都能做，但是PowerShell还能额外做许多cmd不能做的活。\n\n\n\n（来源：PowerShell 命令称为 cmdlet（读作 command-let）。 除了 cmdlet 外，使用 PowerShell 还可以在系统上运行任何可用命令。）\n\n但是PowerShell对于某些CMD中某些命令有更加严格的限制，比如你用npm全局安装的包，默认不能在Powershell上面直接运行\n\n！！！！存在部分CMD命令无法直接在PowerShell上运行！！！！\n\nPowershell特点：\n\n\nPowerShell      是新式命令 shell，其中包括其他常用 shell 的最佳功能。 与大多数仅接受并返回文本的 shell 不同，PowerShell 接受并返回 .NET 对象\n是一种脚本语言shell，可以用于自动执行系统管理。如和office套件联动\nPowerShell跨平台\n\n\n\n","slug":"Softwares/Windows/PowerShell","date":"2023-03-08T00:26:11.166Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Windows Terminal\n创建新窗口（控制台）ctrl + shift + 对应窗口预设的数字\n快速切换窗口ctrl +     alt + 窗口顺序对应数字\n横向打开相同的控制台alt + shift + +/=\n纵向打开相同的控制台alt + shift + -/_\n-&gt; 在3、4中创建订单新控制台仍隶属于原控制台，且默认是powershell，对于这些子控制台，有这些命令：\n\n（本标签内）切换控制台：alt + 方向键\n（）控制控制台尺寸：shift + alt + 方向键\n\n关闭当前控制台ctrl + shift + w\n","slug":"Softwares/Windows/Windows Terminal快捷键","date":"2023-03-08T00:26:11.164Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"如何在 Windows 中启用详细登录消息？\n麻烦up置顶一下，一键添加的cmd命令：reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v VerboseStatus /t REG_DWORD /d 1\n有用！不过要提权顺便科普下：右键单击 System 项，选择“权限”，然后选择“高级”-&gt;“添加”-&gt;”选择主体”-&gt;输入”ev”然后“确定”-&gt;勾选“完全控制”然后一路确定即可\n组策略里启用:非常详细的信息。就行了\n组策略→管理模板→所有设置→输入“显示”会自动跳转\n使用组策略也可以依次找到“计算机配置-管理模板-系统”，在右侧找到“显示非常详细的状态信息”然后，在弹出的对话窗口中选择“已启用”选项，点击“应用→确定”就OK了\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\n","slug":"Softwares/Windows/windows 显示详细登录消息","date":"2023-03-08T00:26:11.159Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Windows 命令 | Microsoft Docs\n搜索文件中文本的模式\n| findstr\n# https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;windows-server&#x2F;administration&#x2F;windows-commands&#x2F;findstr\n\n搜索文件中的文本字符串，并显示包含指定字符串的文本行\n| find\n# https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;windows-server&#x2F;administration&#x2F;windows-commands&#x2F;find\n\n\n\n显示当前进程\ntasklist\n\n\n杀死某个进程\ntaskkill &lt;exe程序名&#x2F;PID&gt;\n\n\n\n\n历史命令记录\n# PowerShell获取当前会话中输入的命令\nhistory\nget-history\n# PowerShell获取当前会话中输入的命令的全部信息\nGet-History | Format-List -Property *\n# CMD获取当前会话中输入的命令\ndoskey &#x2F;h\n\n# 查阅总的命令历史记录：\ncat %USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt\n\n# https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;powershell&#x2F;module&#x2F;Microsoft.PowerShell.Core&#x2F;about&#x2F;about_history?view&#x3D;powershell-7.2\n\n\n\n生成随机数# cmd窗口直接输入：\nset &#x2F;a %random%%10+1\n# bat文件：\nset &#x2F;a rnd&#x3D;%random%%%10+1\necho %rnd%\n\n# PowerShell\n# 使用内置函数：Get-Random\nGet-Random\n# This command gets a random integer between 0 (zero) and Int32.MaxValue.\nGet-Random -Maximum 100\n# This command gets a random integer between 0 (zero) and 99.\nGet-Random -Minimum 10.7 -Maximum 20.93\n# This command gets a random floating-point number greater than or equal to 10.7 and less than 20.92.\nGet-Random -InputObject 1, 2, 3, 5, 8, 13 -Count 3 \n# This command gets three randomly selected numbers in random order from the array.\n\n\n\n\n\narp -\n\n","slug":"Softwares/Windows/一些PowerShell·CMD命令","date":"2023-03-08T00:26:11.154Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"其他的字符终端文本编辑器用法简单了解即可\nnano是一个字符终端的文本编辑器，但它比vi/vim要简单得多，比较适合Linux初学者使用。某些Linux发行版的默认编辑器就是nano。\n移动\n移动光标：使用用方向键移动。\n选择文字：按住鼠标左键拖到。\n\n复制粘贴\n复制一整行：Alt+6\n剪贴一整行：Ctrl+K\n粘贴：Ctrl+U\n\n如果需要复制／剪贴多行或者一行中的一部分，先将光标移动到需要复制／剪贴的文本的开头，按Ctrl+6（或者Alt+A）做标记，然后移动光标到 待复制／剪贴的文本末尾。这时选定的文本会反白，用Alt+6来复制，Ctrl+K来剪贴。若在选择文本过程中要取消，只需要再按一次Ctrl+6。\n搜索按Ctrl+W，然后输入你要搜索的关键字，回车确定。这将会定位到第一个匹配的文本，接着可以用Alt+W来定位到下一个匹配的文本。\n翻页\nCtrl+Y到上一页\n\nCtrl+V到下一页\n\n\n保存使用Ctrl+O来保存所做的修改\n退出按Ctrl+X\n如果你修改了文件，下面会询问你是否需要保存修改。输入Y确认保存，输入N不保存，按Ctrl+C取消返回。如果输入了Y，下一步会让你输入想要保存的文件名。如果不需要修改文件名直接回车就行；若想要保存成别的名字（也就是另存为）则输入新名称然后确 定。这个时候也可用Ctrl+C来取消返回。\n","slug":"Softwares/vim/-1.otherEditor","date":"2023-03-08T00:26:11.152Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"vi/vim命令：\n\n\n\n经典版：\n\n\n\n\n编辑模式\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Softwares/vim/00.pic","date":"2023-03-08T00:26:11.149Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Vim教程：\nVim Tutorial (tutorialspoint.com)\nVim is acronym for Vi IMproved.\nVim官网：\nwelcome home : vim online\n一个Vim相关的小游戏：https://vim-adventures.com/\n一个配置文件：https://github.com/MarsWang42/My-Vim-Conf\nVimAwesome网站：https://vimawesome.com/\nVim Plug Github页面：https://github.com/junegunn/vim-plug\n","slug":"Softwares/vim/01.start","date":"2023-03-08T00:26:11.146Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Windows省略\nLinux确保vim安装：\nwhich vim\n\n在当前用户根目录下的.vimrc文件中存储它的具体配置文件，我们可以进行手动配置\n#没有.vimrc文件，手动进行创建\ntouch .vimrc #\nvim .vimrc\n\n#写入命令：\nset nu\n\n#这个配置会使令vim编辑器在每行开头都显示行号\n\n\n\n\n\n若没有安装：\n#redhat\nyum install vim\n\n#debian\napt update\napt install vim\n\n","slug":"Softwares/vim/02.installation","date":"2023-03-08T00:26:11.142Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"vim一共有6中模式\n\n\n\n进入方式\n对应模式\n\n\n\nn\nNormal mode\n\n\nv\nVisual mode\n\n\ni\nInsert mode\n\n\nc\nCommand-line mode\n\n\nh\nall previous modes when in a help file\n\n\na\nall previous modes\n\n\nr\nfor hit-enter prompt\n\n\n其中，normal mode，insert mode，command-line mode是我们的常用模式\nnormal mode这是进入vim后的默认模式\n我们可以在这个模式下执行复制，粘贴，删除，替换等许多操作\nInsert mode在command mode下按i或功能键insert后进入的模式\n通过Esc退回到command mode\nCommand line mode执行具体命令的模式，在command mode下按下:来输入命令\n例如，我们可以通过:edit message.txt来对当前目录下的message.txt文件进行编辑，若不存在此文件则先进行创建\n:edit message.txt # 运行vim命令时的目录下的message.txt\n:edit &#x2F;root&#x2F;message.txt # 指定位置的message.txt\n\nVisual mode在command mode下按下v可进入\nreadonly modevim -R message.txt\n# or\nview message.txt\n","slug":"Softwares/vim/03.modules","date":"2023-03-08T00:26:11.140Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"前言当你没有任何头绪的时候，不妨输入\n:help &lt;topic-name&gt; \n\n试试\nIn above command replace  with topic in which you are interested. Forinstance to access help about vim mode, execute following command\n:help modes\n\nSearch help phrase in manual如果你知道对应主题的名字的话，直接搜索对应内容当然是最好的\n但是当我们不知道我们所需要信息的准确名称时，我们就需要对topic进行检索\n我们可以使用下面的命令：\nYou can search specific topic only if you know its name. But what if, you don’t know the exact name of help topic. In that case you can use below command −\n:helpgrep &lt;phrase&gt;\n\nFor instance, to access help about navigation in Vim execute below command\n:helpgrep navigation\n\n退出help:\n:helpclose 或者直接 :q\n\n\n\n","slug":"Softwares/vim/04.help","date":"2023-03-08T00:26:11.134Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"edit综述总览：Vim provides many commands which make editing functionality really powerful. In this chapter, we will discuss following items −\n\nInsert\nAppend\nOpen new line\nSubstitute\nChange\nReplace\nJoin\n\n插入——i：Insert text before cursorTo insert text before cursor perform following steps −\n\nTo insert text before cursor perform following steps\nSwitch to insert mode\n\ni\n\n\n\n追加——a：Append text after cursorTo append text after cursor perform following steps\n\nSwitch to command mode and move cursor to appropriate position\n\nEsc\n\n\nSwitch to insert mode\n\na\n\n头插——I：Insert text at the beginning of lineLet us suppose you are in the middle of line and you want to insert text at the beginning of current line then perform following steps −\n\nSwitch to command mode\n\nEsc\n\n\nActivate insert mode\n\nI\n\nThis action will move cursor to the beginning of current line and switch Vim in insert mode\n尾插——A：Append text at the end of lineLet us suppose you are in the middle of line and you want to append text at the end of current line then perform following steps −\n\nSwitch to command mode\n\nEsc\n\n\nSwitch to insert mode\n\nA\n\nThis action will move cursor to the end of line and switch Vim in insert mode\n另起行——在光标当前行下新起一行并进入insert模式——o：Open new line below cursorLet us suppose you are in the middle of line and you want to open new line below current line then perform following steps −\n\nSwitch to command mode\n\nEsc\n\n\nSwitch to insert mode\n\no\n\n\nThis action will insert blank line below current line and switch Vim in insert mode\n另起行——将当前行下移一行并进入insert模式——O：Open new line above cursorLet us suppose you are in the middle of line and you want to open new line above current line then perform following steps −\n\nSwitch to command mode\n\nEsc\n\n\nSwitch to insert mode\n\no\n\nThis action will insert blank line above current line and switch Vim in insert mode\n替换——替换(删)当前字插入——s：Substitute one characterLet us suppose you want to substitute single character then perform following steps −\n\nSwitch to command mode\n\nEsc\n\n\nSwitch to insert mode\n\ns\n\nThis action will delete character under cursor and switch Vim in insert mode To substitute entire line use −\n替换——替换(删)当前行插入——S：Substitute entire lineor you want to substitute entire line - \n\nSwitch to command mode\n\nEsc\n\n\nSwitch to insert mode\n\nS\nThis action will delete entire line and switch Vim in insert mode.\n修改——改变文字(删)——cc：Change entire lineLet us suppose you want to change text in current line then perform following steps −\n\nSwitch to command mode\n\nEsc\n\n\nExecute following command −\n\ncc\n\nThis is similar to substitute action using S\n修改——从当前位置起改变文字(删)——C：change text from current cursor positionexecute following command - \nC\n\nThis action will delete text after current cursor position and switch Vim in insert mode.\n替换——代替当前光标所指字符——r：To replace single character perform following steps −\n\nSwitch to command mode\n\nEsc\n\n\nMove cursor to appropriate position\nExecute following command −\n\nr\n\n\nEnter character to be substituted.\n\nNote that this command will not switch Vim in insert mode\n替换——直接进入替换编辑模式——R/hit insert button twice：To replace entire line execute −\nR\n\nIt will switch Vim in replace mode as shown in below image −\n合并——合并当前行与下一行——J：Join textTo join two lines perform following steps −\n\nSwitch to command mode\n\nEsc\n\n\nMove cursor to appropriate line\nExecute following command −\n\nJ\n\n\n\n\n\n编辑进化——重新审视编辑——Revisiting Editing：BufferBuffer is temporary memory used by Vim. When we open a file in editor, Vim loads its contents from disk drive. These contents are stored in memory (RAM) whenever we edit a file we are actually editing file from buffer. Once we finish editing and save file that time only buffer contents are transferred to appropriate file.\nSwapSwap area is a file created by Vim to store buffer contents periodically. While editing file our changes may be lost because of any reasons and Vim provides swap files to provide data recovery.\nTo get actual name of swap file execute following command −\n:swapname\n\nCut, Copy and paste actionsWe often perform cut, copy and paste actions on text. Vim provides following commands to perform these actions (y stands for yank and p stands for paste action) −\n\n\n\nCommand\nDescription\n\n\n\nx\nDelete character from cursor position\n\n\nX\nDelete previous character from cursor position\n\n\ny\nCopy single character from cursor position\n\n\np\nPaste character after cursor position\n\n\nP\nPaste character before cursor position\n\n\nd\ncut\n\n\nMulti-position commandWe can use cut, copy and paste commands with words and sentences as well. Below table shows this −\n\n\n\nCommand\nDescription\n\n\n\ndw\nDelete word from cursor position\n\n\nD\nDelete entire line from cursor position\n\n\ndd\nDelete entire line\n\n\nY\nCopies entire line\n\n\nyy\nCopies entire line\n\n\nTo perform multi-line/multi-word actions just use numbers with command. You can use this syntax with other commands as well. For instance, to delete 3 words use −\n3dw\n\nUndoWe can undo single or multiple actions. To perform one time undo action execute −\nu\n\nTo perform multiple undo action, use number with same command. For instance, below command will undo last 3 actions −\n3u\n\nIn addition to this, to undo all execute following command −\nU\n\nRedoRedo is apposite action of undo. Execute any of the command to perform redo action.\nCtrl + r\n# OR\n:red\n","slug":"Softwares/vim/05.editing","date":"2023-03-08T00:26:09.086Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"移动光标\n\n\n具体按键\n描述 Description\n\n\n\nh\n左移 Move cursor to left by one position\n\n\nj\n下移 Move cursor to downward by one position\n\n\nk\n上移 Move cursor to upward direction by one line\n\n\nl\n右移 Move cursor to right direction by one line\n\n\n可以通过数字键+移动键实现快速移动，如向下移动十行：\nTo perform multi-position navigation use number with these commands. For instance to navigate cursor 10 line below from current line, execute following command −\n10j # 先按数字键1 0 后按 j\n\n\n有一些特殊”数字”：| command | Description || —- | ————————————————- || 0    | Move cursor to the beginning of current line || $    | Move cursor to the end of current line       || Ctrl + f    | Scroll down entire page               || Ctrl + b    | Scroll up entire page                 |\nNavigate to linesBelow command can be used to navigate to specific line −\n\n\n\nCommand\nDescription\n\n\n\n:[lineNumber]\nJump to the certain line\n\n\n:0\nJump to the start of file\n\n\n:$\nJump to the end of file\n\n\nWord navigationWe can use following commands for word navigation −\n\n\n\nCommand\nDescription\n\n\n\nw\nMove cursor to the beginning of the next word\n\n\ne\nMove cursor to the end of the current word\n\n\nb\nMove cursor to the beginning of the previous word\n\n\nUsing jumpsVim keeps track of your navigation using a jump list. You can go backward and forward through that list.\nThe jump list keeps tracks of all the places you’ve been to by tracking file name, line number and column number.\nTo view jump list execute following command −\n:jumps\n\nFollowing command are based on jump list −\n\n\n\nCommand\nDescription\n\n\n\nCtrl + o\nJump back to the previous position\n\n\nCtrl + i\nJump to the next position\n\n\n退出:jumps一般不要使用:q作退出！很可能直接关闭文件！\n","slug":"Softwares/vim/06.navigation","date":"2023-03-08T00:26:09.084Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"进行相关设置——Search related settings启用增量搜索——To perform incremental search execute following command −\n:set incsearch\n\n启用内容高亮——To highlight search execute following command −\n:set hlsearch\n\nThis command will automatically highlight current matches. For instance in below image fox word is highlighted −\nTo disable incremental and highlighted search execute following commands −\n:set noincsearch\n:set nohlsearch\n\n当前文件搜索——Search in current file向后搜索——Search in forward directionUse following commands to perform search in forward direction −\n\n\n\nCommand\nDescription\n\n\n\n/\nSearch expression in forward direction\n\n\nn\nFind next occurrence. This is same and find next\n\n\nN\nFind previous occurrence. This is same as find previous\n\n\n//\nRepeat previous forward search\n\n\n向前搜索——Search in backward directionUse following commands to perform search in backward direction\n\n\n\nCommand\nDescription\n\n\n\n?\nSearch expression in backward direction\n\n\nn\nFind previous occurrence. This is same and find previous\n\n\nN\nFind next occurrence. This is same as find next\n\n\n??\nRepeat previous backward search\n\n\n指针后搜索——Search word under cursorPlace cursor under any word and execute following commands to perform search operation −\n\n\n\nCommand\nDescription\n\n\n\n*****\nSearch next occurrence of current word\n\n\n#\nSearch previous occurrence of current word\n\n\n多文件搜索——Search in multiple filesUsing vimgrep command we can search  in multiple files. For instance below command searches string - Jarvis in all text files.\n:vimgrep Jarvis *.txt\n\nNote that to go to next and previous occurrence we have to use following commands −\n\n\n\nCommand\nDescription\n\n\n\n:cn\nGo to next occurrence of expression\n\n\n:cN\nGo to previous occurrence of expression\n\n\n","slug":"Softwares/vim/07.Searching","date":"2023-03-08T00:26:09.081Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Working With Multiple Things打开新文件——Multiple filesLet us suppose you are editing a file and you want to open another file in same Vim session. \nIn that case, you can use Vim’s edit command. Below table shows these commands\n\n\n\nCommand\nDescription\n\n\n\n:e\nLoad new file in buffer for editing\n\n\n:edit\nSame as :e\n\n\n:e \nList the files for editing from current directory\n\n\n:edit \nSame as :e \n\n\n打开新文件并保持旧文件——Multiple buffers\n\n\nCommand\nDescription\n\n\n\n:badd \nAdd file into new buffer\n\n\n:bN\nSwitch to Nth buffer. For instance to switch to 3rd buffer use :b3\n\n\n:bnext\nMove to the next buffer in buffer list\n\n\n:bprevious\nMove to the previous buffer in buffer list\n\n\n:buffers\nList all buffers\n\n\n:bfirst\nMove to the first buffer\n\n\n:blast\nMove to the last buffer\n\n\n:ball\nLoad all buffers\n\n\n在我们可以使用\n:buffers 或 :ls\n\n来查看我们所打开的全部文件\n多标签页——Multiple tabsLike other editors we can also open multiple tabs in Vim. Below table describes tab related commands −\n\n\n\nCommand\nDescription\n\n\n\n:tabnew\nOpen new tab\n\n\n:tabnew \nOpen new file in tab\n\n\n:tabclose(acronym: :tabc)\nClose current tab\n\n\n:tabo\nclose all the tabs except the first one\n\n\n:tabnext\nMove to the next tab\n\n\n:tabprevious\nMove to the previous tab\n\n\n:tabfirst\nMove to the first tab\n\n\n:tablast\nMove to the last tab\n\n\n多窗口：Multiple windowsIn Vim we can create new window using following commands −\n开启多窗\n\n\nCommand\nDescription\n\n\n\n:new \nOpen file in new window(横向)\n\n\n:split+窗口名(acronym:sp+窗口名)\n横向切割窗口\n\n\n:vsplit+窗口名(acronym:vsp+窗口名)\n纵向切割窗口\n\n\n窗口切换\n:ctrl+w+h/j/k/l 左下上右切换窗口\n\n快速双击ctrl+w 依次切换窗口\n\n\n窗口大小调整纵向调整\n\n\ncommand\ndescription\n\n\n\n:ctrl+w +\n纵向扩大（行数增加）\n\n\n:ctrl+w -\n纵向缩小 （行数减少）\n\n\n:res(ize) num\n把当前窗口显示行数调整为num行\n\n\n:res(ize)+num\n把当前窗口高度增加num行\n\n\n:res(ize)-num\n把当前窗口高度减少num行\n\n\n横向调整\n\n\ncommand\ndescription\n\n\n\n:vertical res(ize) num\n指定当前窗口为num列\n\n\n:vertical res(ize)+num\n把当前窗口增加num列\n\n\n:vertical res(ize)-num\n把当前窗口减少num列\n\n\n关闭多窗\n\n\nCommand\nDescription\n\n\n\n:close/:q!\n关闭多窗口使用close只是暂时关闭窗口，其内容还在缓存中，只有使用q!等才能真正退出。\n\n\n","slug":"Softwares/vim/08.multiplefiles","date":"2023-03-08T00:26:09.078Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"比较文件差异——Show difference本质是在vim中新开一个窗口，\nTo show differences between files execute below command −\n$ vimdiff &lt;file&gt; &lt;file&gt; \nOR \n$ vim –d &lt;file&gt; &lt;file&gt;\n\nvim内比较\n:diffsplit filename # 横向窗口\n:vert :diffsplit filename # 纵向窗口\n\n相同的部分无颜色表示，不同的部分会进行高亮\n修改处跳转——Jump to previous changeIn diff window, execute following command to jump to previous change −\n[c\n\nJump to next changeIn diff window, execute following command to jump to next change −\n]c","slug":"Softwares/vim/09.diff","date":"2023-03-08T00:26:09.075Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"vim内进行文件浏览:Ex 开启目录浏览器，可以浏览当前目录下的所有文件，并可以选择:Sex 水平分割当前窗口，并在一个窗口中开启目录浏览器\nvim与shell切换:shell 可以在不关闭vi的情况下切换到shell命令行exit 从shell回到vi\n","slug":"Softwares/vim/10.commandswithshell","date":"2023-03-08T00:26:09.071Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"增加PowerPoint撤回次数Options-&gt;Advanced-&gt;Editing options-&gt;Maximum number of undos\ndefault: 20, Maximum: 150\n自动保存两个自动保存方式：\n\nOptions -&gt; Save -&gt; Save AutoRecover information every: [ ] minutes 自动保存到本地的崩溃前副本\nAutosave Option button 使用onedrive进行自动保存\n\n防止ppt压缩图片Options -&gt; Advanced -&gt; Do not compress images in file\n字体嵌入Options -&gt; Save -&gt; Embed fonts in the file\n导出Through Export, PPT现可以导出为：\n\nPDF/XPS\nVideo\nAnimated GIF\nCD (?\nIMAGE: PNG, JPG…\nand more…\n\n参考线View -&gt; Rules, Gridlines, Guides\n快速添加\n默认字体Design -&gt; Variants -&gt; Fonts (-&gt; Customize Fonts)\n默认样式建立一个自己想要的图形样式，right-click, select: Set as default shape 即可\n设置幻灯片模板View -&gt; Master Views\n","slug":"Softwares/PowerPoint/01.Change Default Settings","date":"2023-03-08T00:26:09.069Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"尝试进行\n数据类型：\n整数？、字符串\n整数计算 - expr command (evaluate expressions)：\nexpr 1 + 2\n\n\nattention to the space\nuse \\ in your command to make a reverse, for example \\* and \\(\n\nn&#x3D;&#96;expr 1 \\* 2&#96;\necho $&#123;n&#125;\n\n相似的运算符有：(()), let, $[]\n\n(()):\n\nfor((i&#x3D;0;i&lt;num;i++))\ndo\n\t((total+&#x3D;i))\ndone\n# 该语句是对shell中算数及赋值运算的拓展，其中的所有表达式与c几乎一致，能够进行逻辑及四则运算\n\n\nlet:\n\ni&#x3D;0\nwhile((i&lt;&#x3D;5))\ndo\n\techo $i\n\tlet i++\ndone\n# 1. let无需间隔每个字符\n# 2. let\n\n\n$[]\n\necho $[3+5]\n# 1. $[]会对表达式进行整数运算计算\n# 2. $[]中的变量无需手动加上$，当然，你可以选择加上\n# 3. $[]中的数字无需间隔\n# 4. $[]不能单独使用，必须让计算结果有所指向\n\n\n\n\n\nString\n执行：\nsource, exec及shell运行的区别\nsh方式\nsource方式\nexec方式\n","slug":"Softwares/Linux/Bash shell","date":"2023-03-08T00:26:09.056Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"apt什么是apt apt（Advanced Packaging Tool）基于 DEB 包管理，是一个常见于 Debian 和 Ubuntu 中的软件包管理器，也用于 Kali 等系统中\n对应着dpkg\napt和apt-get的关系虽然有些微小的差异，但也可以认为：apt 是 apt-get 的超集，它包含 apt-get、apt-cache 和 apt-config 中最常用命令选项的集合。\n一般的应用场景下 apt 和 apt-get 可以互用\n不过也确实可以作一些区分：\n\n\n\n\n\n\n\n\n\nWARNING : apt does not have a stable CLI interface.\n编写高可靠需求的自动化脚本时，使用apt-get；其余时候可以使用更简练的apt命令\n常用命令\n\n\ncommand\ndescription\n\n\n\nsudo apt update\n列出所有可更新的软件清单命令\n\n\nsudo apt upgrade\n升级软件包\n\n\napt list –upgradeable\n列出可更新的软件包及版本信息\n\n\nsudo apt full-upgrade\n升级软件包，升级前先删除需要更新软件包\n\n\nsudo apt install \n安装指定的软件命令\n\n\nsudo apt install   \n安装多个软件包\n\n\nsudo apt update \n更新指定的软件命令\n\n\nsudo apt show \n显示软件包具体信息,例如：版本号，安装大小，依赖关系等等\n\n\nsudo apt remove \n删除软件包命令\n\n\nsudo apt autoremove\n清理不再使用的依赖和库文件\n\n\nsudo apt purge \n移除软件包及配置文件\n\n\nsudo apt search &lt;keyword&gt;\n从软件源中查找软件包\n\n\napt list –installed\n列出所有已安装的包\n\n\napt list –all-versions\n列出所有已安装的包的版本信息\n\n\napt help\n帮助\n\n\n\napt-get update：是同步/etc/apt/sources.list和/etc/apt/sources.list.d中列出的软件源的软件包版本，这样才能获取到最新的软件包。\napt-get upgrade：是更新已安装的所有或者指定软件包，升级之到本地索引中的对应版本。因此，在执行 upgrade 之前一般要执行update，这样安装的才是最新的版本。\n\n编辑source.list文件以 ubuntu20.04lts 为例\n在使用apt时，我们需要维护一个存储着源地址信息的文本文件：/etc/apt/source.list，\napt可以通过这些地址来查询软件最新版本并通过他们进行更新\nsource.list内容(已去除部分注释)：\ndeb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal main restricted\n# deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal main restricted\ndeb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal-updates main restricted\n# deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal-updates main restricted\ndeb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal universe\n# deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal universe\ndeb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal-updates universe\n# deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal-updates universe\ndeb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal multiverse\n# deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal multiverse\ndeb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal-updates multiverse\n# deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal-updates multiverse\ndeb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse\n# deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; focal-backports main restricted universe multiverse\ndeb http:&#x2F;&#x2F;security.ubuntu.com&#x2F;ubuntu&#x2F; focal-security main restricted\n# deb-src http:&#x2F;&#x2F;security.ubuntu.com&#x2F;ubuntu&#x2F; focal-security main restricted\ndeb http:&#x2F;&#x2F;security.ubuntu.com&#x2F;ubuntu&#x2F; focal-security universe\n# deb-src http:&#x2F;&#x2F;security.ubuntu.com&#x2F;ubuntu&#x2F; focal-security universe\ndeb http:&#x2F;&#x2F;security.ubuntu.com&#x2F;ubuntu&#x2F; focal-security multiverse\n# deb-src http:&#x2F;&#x2F;security.ubuntu.com&#x2F;ubuntu&#x2F; focal-security multiverse\n\n解析规则：\n总的来说，解析list时遵循以下规则：\nuri + “dists” + ubuntu版本信息 + 索引分类 + 仓库类型\n\n仓库类型：\n\ndeb： 二进制包仓库\ndeb-src： 二进制包的源码库\n\nuri：\n\nURI：库所在的地址，可以是网络地址，也可以是本地的镜像地址\n\n版本信息：\n\n就是当前Ubuntu对应的版本代号。可以用命令lsb_release -sc来查看当前系统的代号。\n20.04lts的代号是 focal，所以所有的uri后都会有 focal\n具体则有五种后缀：\n\n无后缀 - 一般不考虑的随发布的source\n\nSecurity - Important Security Updates.\n\nUpdates - Recommended Updates.\n\nProposed - Pre-released Updates.\n\nBackports - Unsupported Updates.\n\n\n\n索引分类：\n\ncomponents： 软件的性质（free或non-free等）\n共有四种：\n\nmain: 完全的自由软件。\n\nrestricted: 不完全的自由软件。\n\nuniverse: Ubuntu官方不提供支持与补丁，全靠社区支持。\n\nmultiverse：非自由软件，完全不提供支持和补丁。\n\n\n例如，现有一个源配置如下：\n\n\n\n\n\n\n\n\n\ndeb http://archive.ubuntu.com/ubuntu/ focal main restricted\n那么，解析出的结果为：\nhttp://cn.archive.ubuntu.com/ubuntu/dists/focal/main\nhttp://cn.archive.ubuntu.com/ubuntu/dists/focal/restricted\n\n\ndeb-src 会对应 source，deb 则会对应 binary-xxx，xxx 就是 arch，比如 i386 (32位)或是 amd64 (64位)。\n如需指定 arch，则对应：\n\n\n\n\n\n\n\n\n\ndeb [arch=amd64] http://cn.archive.ubuntu.com/ubuntu/ focal main\n会指向：\n\n\n\n\n\n\n\n\n\nhttp://cn.archive.ubuntu.com/ubuntu/dists/focal/main/binary-amd64/\n编辑 /etc/apt/sources.list.d/ 目录和sources.list功能一样的是/etc/apt/sources.list.d目录 \n在此目录下，我们可以随意定制我们所指定的软件源，只要以 .list 结尾即可\nsources.list.d 目录下的 .list 文件为软件源的管理提供了全新的思路，我们亦可以用此来安装第三方的软件。\n示例：\n用 /etc/apt/sources.list.d/google-chrome.list 文件来暂存 google chrome 的源\n&gt;&gt; cat google-chrome.list\ndeb http:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;chrome&#x2F;deb&#x2F; stable main\n\nyum介绍：yum(Yellow dog Updater, Modified)基于 RPM 包管理，是一个应用在 Fedora 和 RedHat 系Linux中的软件包管理器。\n对应着rpm\n常用命令：\n\n\ncommand\ndescription\n\n\n\nyum search\n使用 yum (在源内)查找软件包\n\n\nyum install &lt;package_name&gt;\n仅安装指定的软件命令\n\n\nyum update &lt;package_name&gt;\n仅更新指定的软件命令\n\n\nyum remove &lt;package_name&gt;\n删除软件包命令\n\n\nyum list\n列出(源内)所有可安装的软件包\n\n\nyum list updates\n列出所有可更新的软件包\n\n\nyum list installed\n列出所有已安装的软件包\n\n\nyum list extras\n列出所有已安装但不在 Yum Repository 内的软件包\n\n\nyum info\n使用 YUM 获取软件包信息\n\n\nyum info updates\n列出所有可更新的软件包信息\n\n\nyum info installed\n列出所有已安装的软件包信息\n\n\nyum info extras\n列出所有已安装但不在 Yum Repository 内的软件包信息\n\n\nyum provides\n列出软件包提供哪些文件\n\n\n修改yum源：\n进入yum源配置目录： \ncd &#x2F;etc&#x2F;yum.repos.d\n备份原配置文件：\n\n\nsudo mv CentOS-Base.repo CentOS-Base.repo.backup\n\n\n下载新配置文件：\n\nsudo wget -O CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo\n# http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo先找到对应系统，这里是centos7\n# 没有wget就用curl，一定要用就在mv前线下载wget\n\n\n清除缓存\n\nsudo yum clean all\nsudo yum makecache\n\n\n查看是否更新成功\n\nyum repolist\n\n\n更新所有软件\n\nyum update -y \n\n当然，我们也可以使用yum自带的插件——fastest-mirror\n\n\n\n\n\n\n\n\n\n\nThe fastest mirror plugin is designed for use in repository configurations where you have more than 1 mirror in a repo configuration.\nAfter fastestmirror is installed, make sure that it is enabled. \nEdit the file /etc/yum/pluginconf.d/fastestmirror.conf and ensure that it contains the following lines:\n[main]\nverbose &#x3D; 0\nsocket_timeout &#x3D; 3\nenabled &#x3D; 1\nhostfilepath &#x3D; &#x2F;var&#x2F;cache&#x2F;yum&#x2F;timedhosts.txt\nmaxhostfileage &#x3D; 1\n\nTo exclude a specific mirror, TLD, or something in between, add an ‘exclude=’ line to /etc/yum/pluginconf.d/fastestmirror.conf:\n[main]\n...\nexclude&#x3D;.gov, facebook, myspace, junk-mirror.com\n\n[PackageManagement/Yum/FastestMirror - CentOS Wiki](https://wiki.centos.org/PackageManagement/Yum/FastestMirror#:~:text=fastestmirror The fastest mirror plugin is designed for,by fastest to slowest for use by yum.)\ndnf——新一代的RPM软件包管理器：DNF 包管理器作为 YUM 包管理器的升级替代品，它能自动完成更多的操作。\nDNF/zh-cn - Fedora Project Wiki\n一些对比\n\n\n对比项\nrpm\nyum\ndpkg\napt\n\n\n\n系列\nRedHat系\nRedHat系\nDebian系\nDebian系\n\n\n区别\n包安装工具\n依赖管理工具\n包安装工具\n依赖管理工具\n\n\n查询已安装\nrpm -qa\nyum list installed\ndkpg -l\napt list –installed\n\n\n安装\nrpm -i package.rpm 或 rpm –ivh http://www.xxx.net/package.rpm\nyum install\ndpkg -i package.deb\napt install package\n\n\n更新\nrpm –U software.rpm\nyum update\n\napt upgrade\n\n\n移除软件包\nrpm -e [module1][module2]…\nyum remove\ndpkg -r package\napt remove package\n\n\n移除软件包及配置\n\n\ndpkg -P\napt purge package\n\n\n下载的包存放位置\n\n\n\n/var/cache/apt/archives\n\n\n软件安装默认位置\nrpm -ql\n\n\n/usr/share\n\n\n可执行文件位置\n/usr/bin\n\n\n/usr/bin\n\n\n配置文件位置\n/etc\n\n\n/etc\n\n\nlib文件位置\n/usr/lib\n\n\n\n\n\n使用手册\n/usr/share/doc\n\n\n\n\n\n帮助文档\n/usr/share/man\n\n\n\n\n\n更新\n\n\n\n\n\n\nyum与apt的区别_qq_26182553的博客-CSDN博客_yum和apt\nRPM介绍RPM简介与基本使用 - 大师兄啊哈 - 博客园 (cnblogs.com)\n","slug":"Softwares/Linux/compareAPTandYUM","date":"2023-03-08T00:26:09.050Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"KernalThe Linux Kernel Archives - Releases\nLinux内核 - 维基百科，自由的百科全书 (wikipedia.org)\n\nKernal团队所长期维护的内核并不一定和当前分发版内“长期维护”的内核相同\n\n\n\n\n\n\n\n\n\n\nMany Linux distributions provide their own “longterm maintenance” kernels that may or may not be based on those maintained by kernel developers. These kernel releases are not hosted at kernel.org and kernel developers can provide no support for them.\n版本号解读：\n# uname -r\n5.6.19-300.fc32.x86_64\n\n\n5 –内核版本\n6 –重大修订\n19 –轻微修订\n300 –错误修复\n\n更多内容随机器而定，本处是X86架构的64位fc32系统\n","slug":"Softwares/Linux/Kernal","date":"2023-03-08T00:26:09.047Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"1.停止Nginx服务方法\n立即停止服务这种方法比较强硬，无论进程是否在工作，都直接停止进程。\n\nnginx -s stop\n\n\n从容停止服务这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。\n\nnginx -s quit\n\n\nsystemctl 停止systemctl属于Linux命令\n\nsystemctl stop nginx.service\n\n\nkillall 方法杀死进程直接杀死进程，在上面无效的情况下使用，态度强硬，简单粗暴！\n\nkillall nginx\n\n2.启动Nginxnginx直接启动\nnginx\n\nsystemctl命令启动\nsystemctl start nginx.service\n\n3.查看启动后记录ps aux | grep nginx\n\n4.重启Nginx服务systemctl restart nginx.service\n\n5.重新载入配置文件当有系统配置文件有修改，用此命令，建议不要停止再重启，以防报错！\nnginx -s reload\n\n6.查看端口号netstat -tlnp","slug":"Softwares/NginxCommand/NginxCommand","date":"2023-03-08T00:26:09.044Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"killall -9 xeyes\nLinux中误删/root目录恢复方法 - alisapine - 博客园 (cnblogs.com)\n","slug":"Softwares/Linux/Linux 花里胡哨","date":"2023-03-08T00:26:06.589Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"apt切换国内源linux 系统默认使用的软件源都是国外源，国内访问速度过慢，所以改为国内镜像源\n\nsudo su进入root 模式\nvim /etc/apt/sources.list编辑软件源配置文件\n按 i 进入 vim 的编辑模式，用#将deb一行的内容注释掉，然后换成国内源地址,这里我直接用阿里云源\n\n官方源\ndeb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib\ndeb-src http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib\n中科大源\ndeb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib\ndeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib\n阿里云源\ndeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib\ndeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib\n清华大学源\ndeb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free\ndeb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free\n浙大源\ndeb http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free\ndeb-src http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free\n东软大学源\ndeb http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib\ndeb-src http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib\n新加坡kali源\ndeb http:&#x2F;&#x2F;mirror.nus.edu.sg&#x2F;kali&#x2F;kali&#x2F; kali main non-free contrib\ndeb-src http:&#x2F;&#x2F;mirror.nus.edu.sg&#x2F;kali&#x2F;kali&#x2F; kali main non-free contrib\n163 Kali源\ndeb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian wheezy main non-free contrib\ndeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian wheezy main non-free contrib\n\n之后 Esc，然后 :wq 保存退出即可\\4. apt-get update更新索引\\5. apt-get upgrade更新软件\n","slug":"Softwares/Linux/Linux学习-apt切换国内服务","date":"2023-03-08T00:26:06.588Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"ctrl+alt+t: open a new terminal\n","slug":"Softwares/Linux/Linux学习-快捷键与配置","date":"2023-03-08T00:26:06.583Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"用户In Linux, there are three types of owners: user, group, and others .\nLinux UserA user is the default owner and creator of the file. So this user is called owner as well.\n\n\n\n\n\n\n\n\n\nuser == owner\nLinux GroupA user-group is a collection of users. Users that belonging to a group will have the same Linux group permissions to access a file/ folder.\nYou can use groups to assign permissions in a bulk instead of assigning them individually. A user can belong to more than one group as well.\nOtherAny users that are not part of the user or group classes belong to this class.\n更换用户创建一个全新的用户账号：useradd + passwd\n更换：su命令：\nsu root\nsu - root # 不一样！\n# &quot;su r&quot;只是切换了用户，要想连shell环境一起切换就用后边的&quot;su - root&quot;。\n\n文件文件分类Linux共有七类文件\n普通文件类型 [-]:Linux中最多的一种文件类型, 包括 纯文本文件(ASCII)；二进制文件(binary)；数据格式的文件(data);各种压缩文件。其第一个属性为 [-]\n目录文件 [d]:就是目录， 能用 # cd 命令进入的。第一个属性为 [d]，例如 [drwxrwxrwx]\n块设备文件  [b]:块设备文件就是存储数据以供系统存取的接口设备，简单而言就是硬盘。\n例如一号硬盘的代码是 /dev/hda1等文件。第一个属性为 [b]\n字符设备 [c]:字符设备文件即串行端口的接口设备，例如键盘、鼠标等等。第一个属性为 [c]\n套接字文件 [s]:这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。\n第一个属性为 [s]，最常在 /var/run目录中看到这种文件类型\n管道文件 [p]:FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。\nFIFO是first-in-first-out(先进先出)的缩写。第一个属性为 [p]\n链接文件 [l]:类似Windows下面的快捷方式。第一个属性为 [l]，例如 [lrwxrwxrwx]\nHow to Change File Permissions and Ownership in Linuxchmod 与 chown的区别chmod - Used for Changing Permissions 用于改变 具体文件或目录 之于某个用户或用户组的 权限关系: permission\nchown - Used for Changing Ownership 用与改变  具体文件或目录 之于某个用户或用户组的 归属关系: ownership\nCHMOD PARTSyntaxchmod [-options] [permissions] [filename]\n\n\npermissions can be read, write, execute or a combination of them.\nfilename is the name of the file for which the permissions need to change. This parameter can also be a list if files to change permissions in bulk.\n\nWe can change permissions using two modes:\n\nSymbolic mode: this method uses symbols like u, g, o to represent users, groups, and others. Permissions are represented as  r, w, x for read write and execute, respectively. You can modify permissions using +, - and =.\nAbsolute mode: this method represents permissions as 3-digit octal numbers ranging from 0-7.\n\nExamplechmod u+x mymotd.sh\n# To add execution rights (x) to user(or-&gt; the file owner)(u) using symbolic mode, we can use the command above;\n\nchmod 777 test.txt\n# 把三个分区看作三段被拼接的二进制\n# 111 -&gt; 7, rwx, u, g, o;\n\nCHOWN PARTSyntax &amp; Examplechown [-options] [user:group] [filename]&#x2F;[path]\n\nchown -R root &#x2F;root&#x2F;test # 改变文件夹的归属\nchown :admins &#x2F;opt&#x2F;script # To change group ownership, we can use chown by preceding the group name by a colon &#39;:&#39;\n\n\n\n\n\n\n\nLinux中chown和chmod的区别和用法（转） - EasonJim - 博客园 (cnblogs.com)\nLinux chmod and chown – How to Change File Permissions and Ownership in Linux (freecodecamp.org)\n","slug":"Softwares/Linux/Linux学习-文件与权限","date":"2023-03-08T00:26:06.580Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"清空系统历史命令1. history -c该命令只清空本次登入的所有输出命令，且不清空.bash_history文件\n所以下次登陆后，旧命令还将出现，历史命令是存在于当前用户根目录下的./bash_history文件。\n2. echo &gt; $HOME/.bash_history每个用户根目录下都有一个.bash_history文件用于保存历史命令，当每次注销时，本次登陆所执行的命令将被写入该文件。所以可以清空该文件，下次登陆后上次保存的命令将消失，清空效果将在下次登陆生效。\n3. 利用设备黑洞对history文件执行文本清空\ncat &#x2F;dev&#x2F;null &gt; &#x2F;root&#x2F;.bash_history\n\n清空文件内容：\ncat &#x2F;dev&#x2F;null &gt; [yourfilename]\n\n","slug":"Softwares/Linux/Linux学习-系统日志","date":"2023-03-08T00:26:06.575Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"boot系统引导加载时的各文件\netc配置文件\nmnt挂载目录\nroot超级用户主目录\nusr存放系统应用程序\nlost+found系统非正常关机时存放一些不正常的文件\nopt额外安装软件的存放目录\nvar存放运行时需要改变数据的文件，以及各种服务的日志文件\nbin存放二进制可执行文件，系统所需的可执行文件\nsbin存放系统管理的二进制可执行文件\ndev设备文件\nlib存放程序运行时所需要的共享动态库及内核模块\nproc虚拟文件目录，内存映射文件信息\ntmp临时文件\nlib64mediarunsyssrvdatahome","slug":"Softwares/Linux/Linux学习-系统目录","date":"2023-03-08T00:26:06.572Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"你的 home 目录下藏着很多隐藏文件，而.bashrc就是其中之一\n.bashrc是什么及修改.bashrc能做到什么如果你运行一个基于 Unix 或者类 Unix 的操作系统，bash 很有可能是作为默认终端被安装的。虽然存在很多不同的 shell，bash 却是最常见或许也是最主流的。同时，bash 在每次启动时都会加载 .bashrc 文件的内容。每个用户的 home 目录都有这个 shell 脚本。它用来存储并加载你的终端配置和环境变量。\n也就是说，一般情况下，我们能通过修改.bashrc文件来定制我们当前账户的bash\n修改为命令设置别名：aliasalias ll &#x3D; &quot;ls -lha&quot;\n\n函数:function_name () &#123;\n\tcommand_1\n\tcommand_2\n&#125;\n\n# md () &#123;\n#   mkdir -p $1\n#   cd $1 \n# &#125;\n\n什么是 .bashrc，为什么要编辑 .bashrc？ | Linux 中国 - 知乎 (zhihu.com)\n更多的隐藏文件？补习：linux系统变量的类型按变量的生存周期划分：\n\n永久的：需要修改配置文件，变量永久生效。\n\n临时的：使用export命令声明即可，变量在关闭shell时失效。\n\n\n在配置永久的环境变量时，又可以按照作用范围分为：\n\n用户环境变量\n系统环境变量。\n\n系统环境变量对所有系统用户都有效，用户环境变量仅仅对当前的用户有效。\n设置环境变量直接运行export命令定义变量在shell的命令行下直接使用[export 变量名=变量值] 定义变量。该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。 \n修改系统环境变量系统环境变量一般保存在下面的文件中\n&#x2F;etc&#x2F;profile\n\n全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 \n&#x2F;etc&#x2F;bash.bashrc\n\n它也是全局（公有）的 bash执行时，不管是何种方式，都会读取此文件。\n&#x2F;etc&#x2F;environment\n\n不要轻易修改此文件\n修改用户环境变量用户环境变量通常被存储在下面的文件中：\n~&#x2F;.profile\n\n 若bash是以login方式执行时，读取~/.bash_profile，若它不存在，则读取~/.bash_login，若前两者不存在，读取~/.profile。\n~&#x2F;.bash_profile 或者~.&#x2F;bash_login\n\n若bash是以login方式执行时，读取/.bash_profile，若它不存,则读取/.bash_login，若前两者不存在，读取 /.profile。只有bash是以login形式执行时，才会读取.bash_profile，Unbutu默认没有此文件，可新建。 通常该配置文件还会配置成去读取/.bashrc。\n~&#x2F;.bashrc\n\n当bash是以non-login形式执行时，读取此文件。若是以login形式执行，则不会读取此文件。\n~/.bash_profile是交互式、login 方式进入 bash 运行的~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。\n修改环境变量配置文件如想将一个路径加入到环境变量（例如$PATH）中，可以像下面这样做（修改/etc/profile）：sudo vi /etc/profile以环境变量PATH为例子，环境变量的声明格式：\nPATH&#x3D;$PATH:PATH_1:PATH_2:PATH_3:------:PATH_N \nexport PATH\n\n你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效，如果想立刻生效，则可执行下面的语句：\n$source &#x2F;etc&#x2F;profile\n\n环境配置文件的区别profile、 bashrc、.bash_profile、 .bashrc介绍bash会在用户登录时，读取下列四个环境配置文件：\n全局环境变量设置文件：&#x2F;etc&#x2F;profile、&#x2F;etc&#x2F;bashrc。 \n用户环境变量设置文件：~&#x2F;.bash_profile、~&#x2F;.bashrc。\n\n读取顺序：① /etc/profile、② ~/.bash_profile、③ ~/.bashrc、④ /etc/bashrc。\n&#x2F;etc&#x2F;profile：此文件为系统的每个用户设置环境信息，系统中每个用户登录时都要执行这个脚本，如果系统管理员希望某个设置对所有用户都生效，可以写在这个脚本里，该文件也会从&#x2F;etc&#x2F;profile.d目录中的配置文件中搜集shell的设置。 \n~&#x2F;.bash_profile：每个用户都可使用该文件设置专用于自己的shell信息，当用户登录时，该文件仅执行一次。默认情况下，他设置一些环境变量，执行用户的.bashrc文件。 \n~&#x2F;.bashrc：该文件包含专用于自己的shell信息，当登录时以及每次打开新shell时，该文件被读取。 \n&#x2F;etc&#x2F;bashrc：为每一个运行bash shell的用户执行此文件，当bash shell被打开时，该文件被读取。\n\n.bashrc和.bash_profile的区别.bash_profile会用在登陆shell， .bashrc 使用在交互式非登陆 shell 。简单说来，它们的区别主要是.bash_profile是在你每次登录的时候执行的；.bashrc是在你新开了一个命令行窗口时执行的。\n当通过控制台进行登录（输入用户名和密码）：在初始化命令行提示符的时候会执行.bash_profile 来配置你的shell环境。但是如果已经登录到机器，在Gnome或者是KDE也开了一个新的终端窗口（xterm），这时，.bashrc会在窗口命令行提示符出现前被执行。当你在终端敲入/bin/bash时.bashrc也会在这个新的bash实例启动的时候执行。\n建议大多数的时候你不想维护两个独立的配置文件，一个登录的一个非登录的shell。当你设置PATH时，你想在两个文件都适用。可以在.bash_profile中调用.bashrc，然后将PATH和其他通用的设置放到.bashrc中。    \n要做到这几点，添加以下几行到.bash_profile中：\nif [ -f ~&#x2F;.bashrc ]; then\n    . ~&#x2F;.bashrc\nfi\n\n现在，当你从控制台登录机器的时候，.bashrc就会被执行。\n常用的环境变量\n\n\ncommand?\nDescription\n\n\n\nBASH\nBash Shell的全路径\n\n\nCDPATH\n用于快速进入某个目录。\n\n\nPATH\n决定了shell将到哪些目录中寻找命令或程序\n\n\nHOME\n当前用户主目录\n\n\nHISTSIZE\n历史记录数\n\n\nLOGNAME\n当前用户的登录名\n\n\nHOSTNAME\n指主机的名称\n\n\nSHELL\n当前用户Shell类型\n\n\nLANGUGE\n语言相关的环境变量，多语言可以修改此环境变量\n\n\nMAIL\n当前用户的邮件存放目录\n\n\nPS1\n基本提示符，对于root用户是#，对于普通用户是$\n\n\nReference[0] Linux的环境变量.bash_profile .bashrc profile文件 - lvmenghui001 - 博客园 (cnblogs.com)\n[1] /etc/profile、/etc/bashrc、/.bash_profile、/.bashrchttp://blog.chinaunix.net/uid-26435987-id-3400127.html[2] Linux如何修改env看到的环境变量？ .bashrc和.bash_profile区别http://blog.csdn.net/xifeijian/article/details/13355031[3] linux环境变量，bashrc与bashprofilehttp://blog.sina.com.cn/s/blog_43e5ad4e0101ei43.html\n","slug":"Softwares/Linux/用户根目录下的隐藏文件","date":"2023-03-08T00:26:06.570Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"git分区git一共有三个分区：\n工作区、暂存区和版本库\ngit的初始化（自报家门）\ngit config –global user.name “YOUR NAME”\ngit config –global user.email “&#x65;&#109;&#x61;&#105;&#108;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#99;&#111;&#x6d;“\n\n用git创建仓库(repository)\nmkdir repositoryExample（这只是生成了一个文件夹）\n\n进入仓库（文件夹）\ncd repositoryExample\n\n初始化仓库（仓库的正式建立）\ngit init\n\n注意：此举会在当前目录下生成一个.git文件夹，但是这是一个以.开头的隐藏文件夹，所以使用ls命令无法直接看到，你可以使用ls -a命令来查看这类隐藏的文件夹用git来记录变化\ngit add fileName\n可以使用git status  -s来查看更改**\n\n\n\n\n\n\n\n\n\n-A, –all             add changes from all tracked and untracked files\n-u, –update          update tracked files\n\ngit diff\n使用diff来查看已经做出的变化\n用git diff HEAD – filename来比较远程仓库和本地的文件的区别\n\ngit commit -m “本次提交的说明”\n\n\n\n\n**或者使用git commit -a命令来跳过add直接提交所有变动\n关于历史提交\n使用 git log 或者 git log –pretty=oneline 来查看\n使用 git reset + log中的每行前的如 d5d7e…版本号 来还原\ngit中，有 git reflog 命令来记录用户的每一次操作\ngit管理的是修改而不是文件！\n\n关于文件更改\ngit checkout – filename        //舍弃工作区的所有更改\n关于这个命令\n​    如果 filename 文件还没有被提交到暂存区（仍然停留在工作区），则git会立即撤销所有更改——即使已经在文件中保存\n​    如果 filename 文件已经用add命令提交过一次了，则git会将它重置为刚刚提交到缓存区中的状态\n\ngit reset HEAD filename\n通过这个命令，我们可以将已经提交到暂存区的 filename 文件回退到工作区\n\n\n文件删除\ngit rm filename\n注意: 删除文件也是一个修改，必须要提交才会被记录，但这里没有必要add，可以直接commit\n\ngit checkout – filename\n又见面了，再次用此命令来恢复文件，因为它的作用其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n\ngit rm - How do I delete a file from a Git repository? - Stack Overflow\n远程管理\n显示所有远程仓库：git remote -v\n添加远程版本库：git remote add [name] [url]\n删除远程仓库：git remote remove origin\n修改仓库名：git remove rename old_name new_name\n\n向远程库提交\ngit push -u [推送的主机] [推送的分支] ——例：origin main\n删除主机的分支：git push origin –delete master\n\n从远程库克隆\ngit clone git@项目仓库地址\n\n从远程获取代码并合并本地版本：\n规范：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;\n示例：git pull origin master:brantest \n​    ——将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并\n\n\n分支\n创建并切换到新分支：git checkout -b dev    或    git switch -c dev\n切换分支：git checkout dev    或    git switch master\n查看分支：git branch\n把分支合并到main上：git merge dev\n删除分支：git branch -d dev\n将分支推送到远程仓库：git push origin bunjie（同理呀！）\n\ngit push –set-upstream origin master\nssh-keygen -t rsa\nSet Proxy一文让你了解如何为 Git 设置代理 - Eric (ericclose.github.io)\n","slug":"Softwares/Git/Git Commmand","date":"2023-03-08T00:26:06.566Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"为什么使用Github作为博客的托管网站？怎么搭建你的博客？首先你需要一个github账号，并在其中创建一个全新的公开仓库\n创建公开仓库 xxx.github.io为你的github账号添加ssh keys什么是ssh keys？为什么需要ssh keys因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的\n这也是GitHub上的项目中，你可以准许或禁止某些人push新内容的原因\n怎么获取ssh keys如果你已经完成了本地git global user.name和user.email的设置的话\n你可以直接使用如下命令生成你的ssh keys：\n\n\n\n\n\n\n\n\n\nssh-keygen  #可选： -t rsa -C “你的邮箱地址”\n\n在此过程中，你可能会遇到要你选择保留公钥和私钥，设置密码的选项，直接回车就可以了，当然你也可以根据自己需要做出选择\n\nwin下生成的ssh keys会保存在C:\\Users\\当前用户\\lzw.ssh中，用记事本打开即可查看\n请不要将你的ssh keys密钥告诉别人\nlinux下生成的SSH key文件保存在中～/.ssh/id_rsa.pub\n怎么添加ssh keys\n进入Github Settings SSH and GPG keys页面SSH and GPG keys (github.com)\n\n选择New SSH Key\n\n自定义title，并将你的id_rsa.pub的全部内容复制到Key中，确定即可\n\n\n添加完ssh keys后，就可以在这台电脑上连接你的GitHub仓库了\n","slug":"Softwares/Git/从零开始的github blog","date":"2023-03-08T00:26:06.563Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"DOCKER QUICK GUIDE忘记教程，即刻上手docker主要依赖：\nPython3.10\nflask\ngunicorn\n\n项目内容：flask官方基础教程结果，见link1页面内的Tutorial部分。其中的主要内容为：\n\n了解flask项目的basic layout\n建立工厂函数\n建立并操作数据库\n了解 flask: blueprint 功能\n了解 flask: template 功能\n项目可安装化\n基础测试\n部署\n\nlink:\nWelcome to Flask — Flask Documentation (2.2.x) (palletsprojects.com)\nDocker Hub\nFlask + Docker 无脑部署新手教程 - 知乎 (zhihu.com)\n\n","slug":"Softwares/docker/quick_guide","date":"2023-03-08T00:26:06.559Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"numpyimport numpy as np\napi内容：&gt; 数组的创建：\nnp.array()\n\n\n\n\n\n\n\n\n\nnumpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)\n​    object: 数组或嵌套的数列\n​    dtype:数组元素的数据类型，可选\n​    copy:对象是否需要复制，可选\n​    order:创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）\n​    subok:默认返回一个与基类类型一致的数组\n​    ndmin:指定生成数组的最小维度\n&gt; a &#x3D; np.array([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ])\n&gt; a\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\nnp.zeros()\n\n\n\n\n\n\n\n\n\nnumpy.zeros(shape, dtype = float, order = ‘C’)\n​    shape:数组形状\n​    order:’C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组(C中的二维数组行优先，Fortran中的二维数组列优先)\n&gt; a &#x3D; np.zeros([3, 3])\n&gt; a\narray([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]]) #print(a[0][0])的结果是0.0 且 a[0][0] &#x3D;&#x3D; 0结果为True!\nnp.ones() \n\n\n\n\n\n\n\n\n\nnumpy.ones(shape, dtype = None, order = ‘C’)\n&gt; a &#x3D; np.ones([3, 3])\n&gt; a\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]]) #print(a[0][0])的结果是1.0 且 a[0][0] &#x3D;&#x3D; 1结果为True!\nnp.empty()\n\n\n\n\n\n\n\n\n\nnumpy.empty(shape, dtype = float, order = ‘C’)\n&gt; a &#x3D; np.empty([2, 2])\n&gt; a\narray([[1.18498951e-303, 5.97409933e-299],\n       [7.54793231e+168, 4.94065646e-324]]) #注意 − 数组元素为随机值，因为它们未初始化。\nnp.full()\n&gt; np.full([3, 3], 6)\narray([[6, 6, 6],\n       [6, 6, 6],\n       [6, 6, 6]])\nnp.eye()\n&gt; np.eye(4)\narray([[1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 1., 0.],\n       [0., 0., 0., 1.]]) # 生成的矩阵称为“对角矩阵”\nnp.arange()\n\n\n\n\n\n\n\n\n\nnp.arange(start, stop, step, dtype)\n\nnp.linspace()\n\n\n\n\n\n\n\n\n\nnp.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)\n用于创建等差数列\n\nnp.logspace()\n\n\n\n\n\n\n\n\n\nnp.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)\n用于创建等比数列\n\nnp.diag()\n&gt; np.diag([1, 2, 3])\narray([[1, 0, 0],\n       [0, 2, 0],\n       [0, 0, 3]])\nnp.tri()\n&gt; np.tri(3)\narray([[1., 0., 0.],\n       [1., 1., 0.],\n       [1., 1., 1.]]) #np.tri(3)[0][0] &#x3D;&#x3D; 1的结果为True!\nnp.vander()\n&gt; np.vander([3, 4, 5, 6])\narray([[ 27,   9,   3,   1],\n       [ 64,  16,   4,   1],\n       [125,  25,   5,   1],\n       [216,  36,   6,   1]])\n\n&gt; 数组属性：\n\n\n\n\n\n\n\n\n以array = np.vander([3, 4, 5, 6])生成的数组来做演示\n\narray.shape\n&gt; array.shape\n(4, 4) # type(array.shape)返回：&lt;class &#39;tuple&#39;&gt;——是“元组”\narray.size\n&gt; array.size\n16\narray.T\n&gt; array.T\narray([[ 27,  64, 125, 216],\n       [  9,  16,  25,  36],\n       [  3,   4,   5,   6],\n       [  1,   1,   1,   1]]) #即：矩阵的倒置\narray.real\n&gt; array.real\narray([[ 27,   9,   3,   1],\n       [ 64,  16,   4,   1],\n       [125,  25,   5,   1],\n       [216,  36,   6,   1]]) #复数的实部\narray.imag\n&gt; array.imag\narray([[0, 0, 0, 0],\n       [0, 0, 0, 0],\n       [0, 0, 0, 0],\n       [0, 0, 0, 0]]) #复数的虚部\narray.itemsize\n\narray.\n\narray.flags\n\narray.dtype\n\narray.ndim\n\n\n&gt; 数组的操作：\narray.copy() \n\n\n\n\n\n\n\n\n\n显式复制\n&gt; array &#x3D; np.vander([4, 4])\n\n&gt; cc &#x3D; array.copy()\n&gt; cc[0][0] &#x3D; 1000\n&gt; cc\narray([[1000,    9,    3,    1],\n       [  64,   16,    4,    1],\n       [ 125,   25,    5,    1],\n       [ 216,   36,    6,    1]])\n&gt; array\narray([[ 27,   9,   3,   1],\n       [ 64,  16,   4,   1],\n       [125,  25,   5,   1],\n       [216,  36,   6,   1]])\n\n&gt; cc &#x3D; array\n&gt; cc[0][0] &#x3D; 1000\n&gt; cc\narray([[1000,    9,    3,    1],\n       [  64,   16,    4,    1],\n       [ 125,   25,    5,    1],\n       [ 216,   36,    6,    1]])\n&gt; array\narray([[1000,    9,    3,    1],\n       [  64,   16,    4,    1],\n       [ 125,   25,    5,    1],\n       [ 216,   36,    6,    1]])\narray.reshape()\n&gt; array &#x3D; np.vander([3, 4, 5, 6])\n&gt; cc &#x3D; array.reshape(2, 8)\n&gt; cc\narray([[ 27,   9,   3,   1,  64,  16,   4,   1],\n       [125,  25,   5,   1, 216,  36,   6,   1]])\n&gt; array\narray([[ 27,   9,   3,   1],\n       [ 64,  16,   4,   1],\n       [125,  25,   5,   1],\n       [216,  36,   6,   1]])\narray.resize()\n# 接array.reshape()\n&gt; cc &#x3D; array.resize(2, 8)\n&gt; cc # 没有返回值！cc变为空！\n&gt; array\narray([[ 27,   9,   3,   1,  64,  16,   4,   1],\n       [125,  25,   5,   1, 216,  36,   6,   1]])\narray.flatten()\n# 另接array.reshape()\n&gt; cc &#x3D; array.flatten()\n&gt; cc\narray([ 27,   9,   3,   1,  64,  16,   4,   1, 125,  25,   5,   1, 216,\n        36,   6,   1])\n&gt; array\narray([[ 27,   9,   3,   1],\n       [ 64,  16,   4,   1],\n       [125,  25,   5,   1],\n       [216,  36,   6,   1]])\narray.max()\n\n\n\n\n\n\n\n\n\n取全数组的最大值\n\narray.min()\n\n\n\n\n\n\n\n\n\n取全数组的最小值\n\n\n&gt; 数组的索引：\n切片\n&gt; array &#x3D; np.vander([3, 4, 5, 6])\n&gt; array[1:3, 1:3]\narray([[16,  4],\n       [25,  5]])\n&gt; array[1:3, 1:3][0][0]\n16\n键值索引\n&gt; array &#x3D; np.vander([3, 4, 5, 6])\n&gt; array[0, 2]\n3\n&gt; array[0][2]\n3\n&gt; array[[0, 2], [1, 3]]\narray([9, 1]) #规则：array[Ⅰ,Ⅱ]两处，Ⅰ处一定是行坐标，如果此处是一个列表，则同时锁定列表中数字所指定的所有行，Ⅱ处一定是列坐标且应用规则同理！\nnp.ix_ 索引（键值索引加强版）\n\n\n\n\n\n\n\n\n\n解释：np.ix_() 是将前后两个[ ]中的所有内容全部一一配对！\n&gt; array &#x3D; np.vander([3, 4, 5, 6, 7, 8])\n&gt; array\narray([[  243,    81,    27,     9,     3,     1],\n       [ 1024,   256,    64,    16,     4,     1],\n       [ 3125,   625,   125,    25,     5,     1],\n       [ 7776,  1296,   216,    36,     6,     1],\n       [16807,  2401,   343,    49,     7,     1],\n       [32768,  4096,   512,    64,     8,     1]])\n&gt; array[np.ix_([0, 1, 2], [1, 2, 3])]\narray([[ 81,  27,   9],\n       [256,  64,  16],\n       [625, 125,  25]])\nnp.nditer 索引\n&gt; array &#x3D; np.np.vander([3, 4, 5])\n&gt; for i in array:\n    print(i)\n\n[9 3 1]\n[16  4  1]\n[25  5  1]\n&gt; for i in np.nditer(array):\n    print(i)\n   \n9\n3\n1\n16\n4\n1\n25\n5\n1\n\n&gt; 数组的拼接：\nvstack\n\n\n\n\n\n\n\n\n\nv: vertical \n&gt; array1 &#x3D; np.ones([3, 3])\n&gt; array2 &#x3D; zeros([3, 3])\n&gt; array &#x3D; np.vstack([array1, array2])\n&gt; array\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.],\n       [0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n&gt; array.shape\n(6, 3)\nhstack\n\n\n\n\n\n\n\n\n\nh: horizontal\n# 接vstack\n&gt; array &#x3D; np.hstack([array2, array1])\n&gt; array\narray([[0., 0., 0., 1., 1., 1.],\n       [0., 0., 0., 1., 1., 1.],\n       [0., 0., 0., 1., 1., 1.]])\n&gt; array.shape\n(3, 6)\nstack\n# 接vstack\n&gt; array &#x3D; np.stack([array1, array2])\n&gt; array\narray([[[1., 1., 1.],\n        [1., 1., 1.],\n        [1., 1., 1.]],\n       [[0., 0., 0.],\n        [0., 0., 0.],\n        [0., 0., 0.]]])\n&gt; array.shape\n(2, 3, 3)\n\n&gt; 数组的拆分：\n\n\n\n\n\n\n\n\n前提：\n/&gt; array = np.vander([3, 4, 5, 6])/&gt; array\narray([    [ 27,   9,   3,   1],               [ 64,  16,   4,   1],               [125,  25,   5,   1],               [216,  36,   6,   1]])\n\nvsplit\n&gt; np.vsplit(array, 2)\n[array([[27,  9,  3,  1],\n       [64, 16,  4,  1]]), array([[125,  25,   5,   1],\n       [216,  36,   6,   1]])]\nhsplit\n&gt; np.hsplit(array, 2)\n[array([[ 27,   9],\n       [ 64,  16],\n       [125,  25],\n       [216,  36]]),array([[3, 1],\n       [4, 1],\n       [5, 1],\n       [6, 1]])]\nsplit\n&gt; np.split(array, 2)\n[array([[27,  9,  3,  1],\n       [64, 16,  4,  1]]), array([[125,  25,   5,   1],\n       [216,  36,   6,   1]])]\n\n&gt; 从已有内容中创建numpy数组：\nnp.asarray()\n\n\n\n\n\n\n\n\nnumpy.asarray(a, dtype = None, order = None) \n​    a：任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组\n&gt; a &#x3D; [1, 2, 3]\n&gt; b &#x3D; np.array([1, 2, 3])\n&gt; type(a)\n&lt;class &#39;list&#39;&gt;\n&gt; type(b)\n&lt;class &#39;numpy.ndarray&#39;&gt;\n&gt; a &#x3D; np.asarray(a)\n&gt; type(a)\n&lt;class &#39;numpy.ndarray&#39;&gt;\n\n&gt; c &#x3D; (1, 2, 3)\n&gt; type(c)\n&lt;class &#39;tuple&#39;&gt;\n&gt; c &#x3D; np.asarray(c)\n&gt; type(c)\n&lt;class &#39;numpy.ndarray&#39;&gt;\nnp.frombuffer()\n\nnp.fromiter()\n\n\n\n","slug":"Language Learning/Python/numpy","date":"2023-03-08T00:26:04.326Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"install： pip install pyechartsNormal Process\nimport dependencies\n\nfrom pyecharts.charts import * # 引入所有图表类\nfrom pyecharts.components import Table # 引入table组件\nfrom pyecharts import options as opts # 引入options并rename\nfrom pyecharts.commons.utils import JsCode # 引入原生的js代码\n\nfrom snapshot_selenium import snapshot # 使用snapshot_selenium渲染图片\nfrom pyecharts.render import make_snapshot\n\nimport random\nimport datetime\n...\n\n\n对对象添加配置项：\n几乎所有配置项都会在\n\n全局配置项：通过配置全局项，可以更好的设置个性化图表，提供功能组件和更多信息\n\n\n\n\n\n\n\n\n\n\n在定义类的详细内容时使用：set_global_opts（function）来进行设定\n\n常用全局配置：\n\n&gt;init_opts&#x3D; # 这是一个例外：这个需要在Bar() 即新建类时调用，用于设定width等值\n\n&gt;title_opts&#x3D;\n&gt;toolbox_opts&#x3D;\n&gt;tooltip_opts&#x3D;\n&gt;visualmap_opts&#x3D;\n\n\n\n\n\n系列配置项：\n\n\n\n\nBasic ChartsCalendar：日历图1. class pyecharts.charts.Calendar\n\tclass Calendar(init_opts: opts.InitOpts &#x3D; opts.InitOpts())\n2. func pyeachrts.charts.Calendar.add\n\tyaxis_data: Sequence, # example: [(key, value), ...]\n    calendar_opts&#x3D;opts.CalendarOpts(\n        range_&#x3D;&quot;2017&quot;,\n    ),\n3. \n\nFunnel：漏斗图# 系列数据项，格式为 [(key1, value1), (key2, value2)]\n    data_pair: Sequence,\n\nGauge：仪表盘# 系列数据项，格式为 [(key1, value1), (key2, value2)]\n    data_pair: Sequence,\n\nGraph：关系图# 关系图节点数据项列表，参考 &#96;opts.GraphNode&#96;\nnodes: Sequence[Union[opts.GraphNode, dict]],\n\n# 关系图节点间关系数据项列表，参考 &#96;opts.GraphLink&#96;\nlinks: Sequence[Union[opts.GraphLink, dict]],\n\n# 关系图节点分类的类目列表，参考 &#96;opts.GraphCategory&#96;\ncategories: Union[Sequence[Union[opts.GraphCategory, dict]], None] &#x3D; None,\n\nLiquid: 水流图# 系列数据，格式为 [value1, value2, ....]\n    data: Sequence # normally： value1 &gt; value2 &gt; ...\n\nParallel: 平行坐标系# 轴定义：\nparallel_axis &#x3D; [&#123;&quot;dim&quot;: 0, &quot;name&quot;: &quot;Price&quot;&#125;,\n    &#123;&quot;dim&quot;: 1, &quot;name&quot;: &quot;Net Weight&quot;&#125;,\n    &#123;&quot;dim&quot;: 2, &quot;name&quot;: &quot;Amount&quot;&#125;,\n    &#123;   &quot;dim&quot;: 3,\n        &quot;name&quot;: &quot;Score&quot;,\n        &quot;type&quot;: &quot;category&quot;,\n        &quot;data&quot;: [&quot;Excellent&quot;, &quot;Good&quot;, &quot;OK&quot;, &quot;Bad&quot;],&#125;,]\n# 数据准备\ndata &#x3D; [(12.99, 100, 82, &quot;Good&quot;), (9.99, 80, 77, &quot;OK&quot;), (20, 120, 60, &quot;Excellent&quot;)]\n(\n    Parallel(init_opts&#x3D;opts.InitOpts(width&#x3D;&quot;1400px&quot;, height&#x3D;&quot;800px&quot;))\n    .add_schema(schema&#x3D;parallel_axis)\n    .add(\n        series_name&#x3D;&quot;&quot;,\n        data&#x3D;data\n    )\n    .render()\n)\n\nPie# 系列数据项，格式为 [(key1, value1), (key2, value2)]\ndata_pair: types.Sequence[types.Union[types.Sequence, opts.PieItem, dict]],\n\nPolar：极坐标系# 对数据存在一个add_schema来定义轴\n def add_schema(\n    radiusaxis_opts: Union[opts.RadiusAxisOpts, dict] &#x3D; opts.RadiusAxisOpts(),\n    angleaxis_opts: Union[opts.AngleAxisOpts, dict] &#x3D; opts.AngleAxisOpts(),\n)\n# 数据本身仍在add中引入\n    # 系列数据项\n    data: Sequence, # 数据形式是数组：[(key, value1), value2...]       \n    # 注意一个类型选项\n    type_&#x3D;&quot;bar&quot; # 支持ChartType.SCATTER, ChartType.LINE, ChartType.BAR，ChartType.EFFECT_SCATTER\n默认是极坐标形式的散点图\n\n    Polar()\n    .add_schema(\n        radiusaxis_opts&#x3D;opts.RadiusAxisOpts(type_&#x3D;&quot;category&quot;),\n        angleaxis_opts&#x3D;opts.AngleAxisOpts(is_clockwise&#x3D;True, max_&#x3D;10),\n    )\n    .add(&quot;A&quot;, [(&quot;周一&quot;, 1), 2, 3, 4, 3, 5, 1], type_&#x3D;&quot;bar&quot;)\n    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Polar-RadiusAxis&quot;))\n    .set_series_opts(label_opts&#x3D;opts.LabelOpts(is_show&#x3D;True))\n    .render()\n\nRadarv1 &#x3D; [(4300, 10000, 28000)]\nv2 &#x3D; [(5000, 14000, 28000)]\n(Radar(init_opts&#x3D;opts.InitOpts(width&#x3D;&quot;1280px&quot;, height&#x3D;&quot;720px&quot;, bg_color&#x3D;&quot;#CCCCCC&quot;))\n    .add_schema(\n        schema&#x3D;[\n            opts.RadarIndicatorItem(name&#x3D;&quot;销售（sales）&quot;, max_&#x3D;6500),\n            opts.RadarIndicatorItem(name&#x3D;&quot;研发（Development）&quot;, max_&#x3D;52000),\n            opts.RadarIndicatorItem(name&#x3D;&quot;市场（Marketing）&quot;, max_&#x3D;25000),\n        ],\n        splitarea_opt&#x3D;opts.SplitAreaOpts(\n            is_show&#x3D;True, areastyle_opts&#x3D;opts.AreaStyleOpts(opacity&#x3D;1)\n        ),\n        textstyle_opts&#x3D;opts.TextStyleOpts(color&#x3D;&quot;#fff&quot;),\n    )\n    .add(\n        series_name&#x3D;&quot;预算分配（Allocated Budget）&quot;,\n        data&#x3D;v1,\n        linestyle_opts&#x3D;opts.LineStyleOpts(color&#x3D;&quot;#CD0000&quot;),\n    )\n    .add(...)\n    .set_series_opts(label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False))\n    .set_global_opts(\n        title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;基础雷达图&quot;), \n    )\n    .render())\n\n    # 系列名称，用于 tooltip 的显示，legend 的图例筛选。\n    series_name: str,\n\nSankey：桑基图nodes &#x3D; [&#123;&quot;name&quot;: &quot;category1&quot;&#125;,\n    &#123;&quot;name&quot;: &quot;category2&quot;&#125;,\n    &#123;&quot;name&quot;: &quot;category3&quot;&#125;,\n    &#123;&quot;name&quot;: &quot;category4&quot;&#125;,\n    &#123;&quot;name&quot;: &quot;category5&quot;&#125;,\n    &#123;&quot;name&quot;: &quot;category6&quot;&#125;,]\nlinks &#x3D; [&#123;&quot;source&quot;: &quot;category1&quot;, &quot;target&quot;: &quot;category2&quot;, &quot;value&quot;: 10&#125;,\n    &#123;&quot;source&quot;: &quot;category2&quot;, &quot;target&quot;: &quot;category3&quot;, &quot;value&quot;: 15&#125;,\n    &#123;&quot;source&quot;: &quot;category3&quot;, &quot;target&quot;: &quot;category4&quot;, &quot;value&quot;: 20&#125;,\n    &#123;&quot;source&quot;: &quot;category5&quot;, &quot;target&quot;: &quot;category6&quot;, &quot;value&quot;: 25&#125;,]\n(Sankey().add(\n    series_name&#x3D;&quot;sankey&quot;,\n    nodes&#x3D;nodes,\n    links&#x3D;links,\n    pos_bottom&#x3D;50\n    # linestyle_opt&#x3D;opts.LineStyleOpts(opacity&#x3D;0.2, curve&#x3D;0.5, color&#x3D;&quot;source&quot;),\n    # label_opts&#x3D;opts.LabelOpts(position&#x3D;&quot;right&quot;),\n).set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Sankey-基本示例&quot;)).render())\n\nSunburst：旭日图 # 数据项1：\n    data &#x3D; [\n    &#123;\n        &quot;name&quot;: &quot;Flora&quot;,\n        &quot;itemStyle&quot;: &#123;&quot;color&quot;: &quot;#da0d68&quot;&#125;,\n        &quot;children&quot;: [\n            &#123;&quot;name&quot;: &quot;Black Tea&quot;, &quot;value&quot;: 1, &quot;itemStyle&quot;: &#123;&quot;color&quot;: &quot;#975e6d&quot;&#125;&#125;,\n            &#123;\n                &quot;name&quot;: &quot;Floral&quot;,\n                &quot;itemStyle&quot;: &#123;&quot;color&quot;: &quot;#e0719c&quot;&#125;,\n                &quot;children&quot;: [&#123;...&#125;,],\n            &#125;,\n        ],\n    &#125;,\n    &#123;...&#125;\n    # 数据项2。\n    data_pair: Sequence,\ndata &#x3D; [\n    opts.SunburstItem(\n        name&#x3D;&quot;Grandpa&quot;,\n        children&#x3D;[\n            opts.SunburstItem(\n                name&#x3D;&quot;Uncle Leo&quot;,\n                value&#x3D;15,\n                children&#x3D;[...],\n            ),\n            opts.SunburstItem(...),\n        ],),\n    opts.SunburstItem(),\n]\nsunburst &#x3D; (\n    Sunburst(init_opts&#x3D;opts.InitOpts(width&#x3D;&quot;1000px&quot;, height&#x3D;&quot;600px&quot;))\n    .add(series_name&#x3D;&quot;&quot;, data_pair&#x3D;data, radius&#x3D;[0, &quot;90%&quot;])\n    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Sunburst-基本示例&quot;))\n    .set_series_opts(label_opts&#x3D;opts.LabelOpts(formatter&#x3D;&quot;&#123;b&#125;&quot;))\n    .render(&quot;basic_sunburst.html&quot;)\n)\n\nThemeRiverWordCloud直角坐标系图表几乎所有表的数据要求特征相同，一般为xaxis赋字符串列表，而使用一条或多条yaxis来展示值\n1. markline\nmarkline_opts&#x3D;opts.MarkLineOpts(data&#x3D;[opts.MarkLineItem(type_&#x3D;&quot;average&quot;)]) # \n\n柱状图# 系列名称，用于 tooltip 的显示，legend 的图例筛选。\nseries_name: str,\n# 系列数据\nx&#x2F;y_axis: Sequence[Numeric, opts.BarItem, dict],\n\n热力图# Y 坐标轴数据\nyaxis_data: types.Sequence[types.Union[opts.HeatMapItem, dict]] # 例: Faker.week\n# 系列数据项\nvalue: [[0, 0, 18], ...]types.Sequence[types.Union[opts.HeatMapItem, dict]]\n\n箱形图v1 &#x3D; [[850, 740, 900, 1070, 930, 850, 950, 980, 980, 880, 1000, 980],]\nc &#x3D; Boxplot()\nc.add_xaxis([&quot;expr1&quot;])\nc.add_yaxis(&quot;A&quot;, c.prepare_data(v1))\nc.set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;BoxPlot-基本示例&quot;))\nc.render()\n\n散点图data &#x3D; [[10.0, 8.04],...]\nx_data &#x3D; [d[0] for d in data]\ny_data &#x3D; [d[1] for d in data]\n# 可能需要把global options中各轴的type设置为value\ntooltip_opts&#x3D;opts.TooltipOpts(is_show&#x3D;True)\n\n折线图Line()\n.add_xaxis(Faker.choose())\n.add_yaxis(&quot;商家A&quot;, Faker.values(), areastyle_opts&#x3D;opts.AreaStyleOpts(opacity&#x3D;0.5))\n.add_yaxis(&quot;商家B&quot;, Faker.values(), areastyle_opts&#x3D;opts.AreaStyleOpts(opacity&#x3D;0.5))\n.set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Line-面积图&quot;))\n.render()\n\n层叠图line.overlap(scatter).render() # line &#x3D; Line()... scatter &#x3D; Scatter()...\n","slug":"Language Learning/Python/pyecharts使用","date":"2023-03-08T00:26:04.324Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Python lambda表达式在Python中有两种函数，一种是def定义的函数，而另一种是lambda函数，也就是匿名函数。\n它可以接受任意数量的参数，但只能有一个表达式。\n示例x &#x3D; lambda a : a + 10\nprint(x(5))\n# 15\n\n语法lambda arguments : expression\n\n","slug":"Language Learning/Python/Python Function","date":"2023-03-08T00:26:04.321Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"深浅拷贝概念与使用Reference：\n彻底理解Python中的”指针”_杰克小麻雀的博客-CSDN博客_python有指针吗\n\n\ndeep copy and shallow copy浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用\n深拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中\nexamplesshallow copycodelist1 &#x3D; [[1, 2], (30, 40)]\nlist2 &#x3D; list(list1)\n\nlist1.append(100)\nprint(&quot;list1:&quot;,list1)  # [[1, 2], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nlist1[0].append(3)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2, 3], (30, 40)]\n\nlist1[1] +&#x3D; (50, 60)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40, 50, 60), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2, 3], (30, 40)]\n\nexplanationsin this program, we initial a list: list1 first which contains two elements: a list and a tuple.然后对 list1 执行浅拷贝，赋予 list2。因为浅拷贝里的元素是对原对象元素的引用，因此 list2 中的元素和 list1 指向同一个列表和元组对象。\nnext，list1.append(100). 表示对 list1 的列表新增元素 100。这个操作不会对 list2 产生任何影响，因为 list2 和 list1 作为整体是两个不同的对象，并不共享内存地址。操作过后 list2 不变，list1 会发生改变。\nthen，list1[0].append(3) 表示对 list1 中的第一个列表新增元素 3。因为 list2 是 list1 的浅拷贝，list2 中的第一个元素和 list1 中的第一个元素，共同指向同一个列表，因此 list2 中的第一个列表也会相对应的新增元素 3。\nat last,  list1[1] += (50, 60)，因为元组是不可变的，这里表示对 list1 中的第二个元组拼接，然后重新创建了一个新元组作为 list1 中的第二个元素，而 list2 中没有引用新元组，因此 list2 并不受影响。\ndeep copycodeimport copy\nlist1 &#x3D; [[1, 2], (30, 40)]\nlist2 &#x3D; copy.deepcopy(list1)\n\nlist1.append(100)\nprint(&quot;list1:&quot;,list1)  # [[1, 2], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nlist1[0].append(3)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nlist1[1] +&#x3D; (50, 60)\nprint(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40, 50, 60), 100]\nprint(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\n\nexplanationjust as the example code above, no matter how the list1 changes, list2 remains itself. 因为此时的 list1 和 list2 完全独立，没有任何联系。\n特例如果被深拷贝对象中存在指向自身的引用会怎么样？\nimport copy\nlist1 &#x3D; [1]\nlist1.append(list1)\nprint(list1)  # [1, [...]]\n\nlist2 &#x3D; copy.deepcopy(list1)\nprint(list2)  # [1, [...]]\n\n此例子中，列表 list1 中有指向自身的引用，因此 list1 是一个无限嵌套的列表。但是当深度拷贝 list1 到 list2 后，程序并没有出现栈溢出的现象。这是为什么呢？\n-&gt;因为 deepcopy 会自动维护一个字典，记录已经拷贝的对象与其 ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回。通过查看 deepcopy 函数实现的源码就会明白：\n赋值与拷贝的关系赋值只是复制了新对象的引用，不会开辟新的内存空间。\n拷贝创建新对象，具体内容视拷贝类型而定（深浅拷贝）\n所以赋值并不会产生一个独立的对象单独存在，只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。\n请注意区分浅拷贝与赋值——关键在是否有新对象被创建\n示例赋值操作：\na &#x3D; [1, 2, 3]\n\nb &#x3D; a\n# a.append(4)\n# print(b) # [1, 2, 3, 4]\n\n三种浅拷贝操作：\n切片操作：\nlst1 &#x3D; lst[:] 或者 lst1 &#x3D; [each for each in lst]\n\n工厂函数：\nlst1 &#x3D; list(lst)\n\ncopy函数：\nlst1 &#x3D; copy.copy(lst)\n\n三种，都是浅拷贝\n连续赋值在python中是可以使用连续赋值的方式来一次为多个变量进行赋值的(请注意，仍然是“赋值”！)，比如：\na &#x3D; b &#x3D; c &#x3D; 1\na, b, c &#x3D; 1, 1, 1\n\n这些都可以完成变量的赋值，但是就有一个问题了，比如：\na &#x3D; 3\na, b &#x3D; 1, a  # a &#x3D; 1, b &#x3D; 3\n\n如果按照正常的思维逻辑，先进行a = 1，在进行b = a，最后b应该等于1，但是这里b应该等于3，因为在连续赋值语句中等式右边其实都是局部变量，而不是真正的变量值本身，因此，上面例子中右边的a，在python解析的时候，只是把变量a的指向的变量3赋给b，而不是a=1之后a的结果。这里有一个Leetcode里链表的例子：\n\n\n\n\n\n\n\n\n\n假如要对一个链表进行翻转，就比如把1—&gt;2-&gt;3-&gt;4转化为4-&gt;3-&gt;2-&gt;1\n对于这个问题很简单，只要反转指针就可以了，假如链表结构为：\nclass ListNode:\n    def __init__(self, x):\n        self.val &#x3D; x\n        self.next &#x3D; None1234\n\n我们可以用很简单的三行代码完成这个过程：\ndef reverseList(self, head):\n        L &#x3D; ListNode(float(&quot;-inf&quot;))\n        while head:\n            L.next, head.next, head &#x3D; head, L.next, head.next\n        return L.next12345\n\n这里的L是指向一个新建的结点，因为python没有指针的概念，所以用一个额外的结点来代替头指针，这里的核心代码就是中间那一行三个变量的连续赋值，如果单独一句句来理解的话，最后肯定是想不通的，在这里，假设head结点是链表串’1-&gt;2-&gt;3-&gt;4’的头结点，先用新的L结点的next指针指向head的第一个结点‘1’，之后将L.next(第一次也就是空)赋给了head的next指针，之后再把head的next指针（注意，这里的next指针还是指向‘2’的，而不是空）赋给head，相当于next向前移一位，这一步相当于一个串变成了两个：\n\n\n\n\n\n\n\n\n\nL：‘-inf’-&gt;‘1’\nhead：‘2’-&gt;‘3’-&gt;‘4’-&gt;‘5’\n","slug":"Language Learning/Python/Python拷贝与赋值","date":"2023-03-08T00:26:02.009Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"第一步：引入包并准备临时存储数据的列表import urllib.request\nimport urllib.parse\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\nimport random, time # 设置每个网页之间的爬取间隔，防止被ban\n# import xlwt, xlwings, sqlite3\n# import selenium\n\n# 1.设定爬取网页对象\nurl &#x3D; &quot;&quot;\n# 2 准备临时保存数据的列表\nA &#x3D; []\nB &#x3D; []\n...\n# 3 文件保存路径\nsaveAddress &#x3D; &quot;D:\\\\project\\\\code\\\\python\\\\&quot;\n# 4 设立序号num\nnum &#x3D; 0\n\n\n\n第二步：获取网页内容（源代码）采用urllib\n使用手册：\n​    Python urllib | 菜鸟教程 (runoob.com)\n​    urllib.request — Extensible library for opening URLs — Python 3.9.6 documentation\n\n简明教程：\n\n\n\n\n\n\n\n\n\n\nurllib包内文件设计：\n\nurllib.request - 打开和读取 URL。它定义了一些打开 URL 的函数和类，包含授权验证、重定向、浏览器cookies等。\nurllib.error - 包含 urllib.request 抛出的异常。\nurllib.parse - 解析 URL。\nurllib.robotparser - 解析 robots.txt 文件。\n\n\n打开一个 URL：\nurllib.request.urlopen(url, data=None, [timeout, ], cafile=None, capath=None, cadefault=False, context=None)\n​    注意返回值：This function always returns an object which can work as a context manager and has the properties url, headers, and status.\n​    注意url对象：Open the URL url, which can be either a string or a Request object.\n\n解析urlopen()的返回值：（注意还要decode()）\n​    read( [length = number] )\n​    readline( )\n​    readlines( [ ] )：返回列表\n\n模拟头部信息（身份伪装）：\n​    urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)\n​    如果用到了Request对象，自然是直接将data放在这里面而不是在urlopen里\n\n\n\n\ndef ask_html(i):\n\t# 对基础url做处理，拿到新的、需要爬取的实际目标网页url，并在接下来对这个网址做处理\n\ttempUrl &#x3D; url + str(i * 25)\n\t# 伪装user-agent\n\theaders &#x3D; &#123;\n\t\t&quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) ......&quot;\n\t&#125;\n\t\t# # 用户表单信息\n\t\t# data &#x3D; bytes(urllib.parse.urlencode(&#123;&#39;user_name&#39;: &#39;bunjie&#39;&#125;), encoding&#x3D;&#39;utf-8&#39;)，是urlopen中的data参数，用来发送post请求，否则是get请求\n\t# 对爬虫身份做封装\n\tresponse &#x3D; urllib.request.Request(url&#x3D;url_now, headers&#x3D;headers, method&#x3D;&quot;GET&quot;) # 要发送表单信息的话，请使用POST\n\t# 进行网页爬取并解码\n\treq &#x3D; urllib.request.urlopen(response, timeout&#x3D;30)\n\thtml &#x3D; req.read().decode(&#39;utf-8&#39;)\n\t# 返回目标网页对应的html代码内容\n\treturn html\n\n采用requests\n\n\n\n\n\n\n\n\n\n官方示例：\n\n&gt;&gt;&gt; r &#x3D; requests.get(&#39;https:&#x2F;&#x2F;api.github.com&#x2F;user&#39;, auth&#x3D;(&#39;user&#39;, &#39;pass&#39;))\n&gt;&gt;&gt; r.status_code\n200\n&gt;&gt;&gt; r.headers[&#39;content-type&#39;]\n&#39;application&#x2F;json; charset&#x3D;utf8&#39;\n&gt;&gt;&gt; r.encoding\n&#39;utf-8&#39;\n&gt;&gt;&gt; r.text\n&#39;&#123;&quot;type&quot;:&quot;User&quot;...&#39;\n&gt;&gt;&gt; r.json()\n&#123;&#39;private_gists&#39;: 419, &#39;total_private_repos&#39;: 77, ...&#125;\n\n\n\n\n\n\n\n\n\n\n\n文档：\n​    Requests: HTTP for Humans™ — Requests 2.26.0 documentation (python-requests.org)\n​    Requests: 让 HTTP 服务人类 — Requests 2.18.1 文档 (python-requests.org)\n\n简明教程：\n\nAPI Reference:\n\nrequests.get(url, params=None, **kwargs)\n\n\n\nParameters:\nurl – URL for the new Request object.params – (optional) Dictionary, list of tuples or bytes to send in the query string for the Request.**kwargs – Optional arguments that request takes.\n\n\n\nReturns:\nResponse object\n\n\n\n\n\n\n\n\n\n\n\nrequests.post(url, data=None, json=None, **kwargs)\nSends a POST request.\n\n\n\nParameters:\nurl – URL for the new Request object.data – (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request.json – (optional) json data to send in the body of the Request.**kwargs – Optional arguments that request takes.\n\n\n\nReturns:\nResponse object\n\n\n\n\n\n\n\n\n\n\n\n**kwargs参数列表:\n\nparams – (optional) Dictionary, list of tuples or bytes to send in the query string for the Request.\ndata – (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request.\njson – (optional) A JSON serializable Python object to send in the body of the Request.\nheaders – (optional) Dictionary of HTTP Headers to send with the Request.\ncookies – (optional) Dict or CookieJar object to send with the Request.\nfiles – (optional) Dictionary of &#39;name&#39;: file-like-objects (or &#123;&#39;name&#39;: file-tuple&#125;) for multipart encoding upload. file-tuple can be a 2-tuple (&#39;filename&#39;, fileobj), 3-tuple (&#39;filename&#39;, fileobj, &#39;content_type&#39;) or a 4-tuple (&#39;filename&#39;, fileobj, &#39;content_type&#39;, custom_headers), where &#39;content-type&#39; is a string defining the content type of the given file and custom_headers a dict-like object containing additional headers to add for the file.\nauth – (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\ntimeout (float or tuple) – (optional) How many seconds to wait for the server to send data before giving up, as a float, or a (connect timeout, read timeout) tuple.\nallow_redirects (bool) – (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to True.\nproxies – (optional) Dictionary mapping protocol to the URL of the proxy.\nverify – (optional) Either a boolean, in which case it controls whether we verify the server’s TLS certificate, or a string, in which case it must be a path to a CA bundle to use. Defaults to True.\nstream – (optional) if False, the response content will be immediately downloaded.\ncert – (optional) if String, path to ssl client cert file (.pem). If Tuple, (‘cert’, ‘key’) pair.\n\n\n\n\n\n&gt; *class* **&#96;requests&#96;.&#96;Response&#96;**\n&gt;\n&gt; The [&#96;Response&#96;](https:&#x2F;&#x2F;docs.python-requests.org&#x2F;en&#x2F;latest&#x2F;api&#x2F;#requests.Response) object, which contains a server’s response to an HTTP request.\n&gt;\n&gt; 1. **content**\n&gt;\n&gt; ​\t\tContent of the response, in bytes.\n&gt;\n&gt; 2. **text**\n&gt;\n&gt;    Content of the response, in unicode.\n&gt;\n&gt;    If Response.encoding is None, encoding will be guessed using &#96;charset_normalizer&#96; or &#96;chardet&#96;.\n&gt;\n&gt;    The encoding of the response content is determined based solely on HTTP headers, following RFC 2616 to the letter. If you can take advantage of non-HTTP knowledge to make a better guess at the encoding, you should set &#96;r.encoding&#96; appropriately before accessing this property.\n&gt;    \n&gt; 3. **&#96;url&#96; *&#x3D; None***\n&gt;\n&gt;    Final URL location of Response.\n&gt;\n&gt; 4. **&#96;status_code&#96; *&#x3D; None***\n&gt;\n&gt;    Integer Code of responded HTTP Status, e.g. 404 or 200.\n&gt;\n&gt; 5. **&#96;request&#96; *&#x3D; None***\n&gt;\n&gt;    The [&#96;PreparedRequest&#96;](https:&#x2F;&#x2F;docs.python-requests.org&#x2F;en&#x2F;latest&#x2F;api&#x2F;#requests.PreparedRequest) object to which this is a response.\n&gt;\n&gt;    You can **check the response** header through this method! \n&gt;\n&gt; &gt; When you make a request, Requests makes educated guesses about the encoding of the response based on the HTTP headers. The text encoding guessed by Requests is used when you access **&#96;r.text&#96;**. You can find out what encoding Requests is using, and change it, using the **&#96;r.encoding&#96;** property:\n&gt; &gt;\n&gt; &gt; &#96;&#96;&#96;python\n&gt; &gt; &gt;&gt;&gt; r.encoding\n&gt; &gt; &#39;utf-8&#39;\n&gt; &gt; &gt;&gt;&gt; r.encoding &#x3D; &#39;ISO-8859-1&#39;\n\n2. ## Make a Request\n\n&gt; &#96;&#96;&#96;python \n&gt; &gt;&gt;&gt; import requests # first import the module\n&gt; \n &gt; &gt;&gt;&gt; r &#x3D; requests.get(&#39;https:&#x2F;&#x2F;api.github.com&#x2F;events&#39;) # get a webpage. In GET requests mode\n\n\n\n\n\n\n\n\n\nNow, we have a Response object called r. We can get all the information we need from this object.\nmeanwhile, requests’ simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request:\n&gt;&gt;&gt; r &#x3D; requests.post(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;, data &#x3D; &#123;&#39;key&#39;:&#39;value&#39;&#125;)\n# 我们当热可以在之前就将要发送的数据包data封装好，在post中就可以直接调用了\nNice, rights? What about the other HTTP request types: PUT, DELETE, HEAD and OPTIONS? These are all just as simple:\n&gt;&gt;&gt; r &#x3D; requests.put(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;put&#39;, data &#x3D; &#123;&#39;key&#39;:&#39;value&#39;&#125;)\n&gt;&gt;&gt; r &#x3D; requests.delete(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;delete&#39;)\n&gt;&gt;&gt; r &#x3D; requests.head(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;)\n&gt;&gt;&gt; r &#x3D; requests.options(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;)\n\nPassing Parameters In URLs\n\n\n\n\n\n\n\n\n\n\nYou often want to send some sort of data in the URL’s query string. If you were constructing the URL by hand, this data would be given as key/value pairs in the URL after a question mark, e.g. httpbin.org/get?key=val. Requests allows you to provide these arguments as a dictionary of strings, using the params keyword argument. As an example, if you wanted to pass key1=value1 and key2=value2 to httpbin.org/get, you would use the following code:\n&gt;&gt;&gt; payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;\n&gt;&gt;&gt; r &#x3D; requests.get(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;, params&#x3D;payload)\n\nYou can see that the URL has been correctly encoded by printing the URL:\n&gt;&gt;&gt; print(r.url)\nhttps:&#x2F;&#x2F;httpbin.org&#x2F;get?key2&#x3D;value2&amp;key1&#x3D;value1\n\nNote that any dictionary key whose value is None will not be added to the URL’s query string.\n\n第三步：利用bs和re来对爬取内容做处理bs4：一级处理（可跳过）\n使用手册：\n​    Beautiful Soup 4.4.0 文档 — Beautiful Soup 4.2.0 中文 文档\n\n简明教程：\n\n\n\n\n\n\n\n\n\n\n创建BeautifulSoup对象：\n​    将一段文档传入BeautifulSoup 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄.\nsoup &#x3D; BeautifulSoup(open(&quot;index.html&quot;)) # 方法一：读取文件\n\nsoup &#x3D; BeautifulSoup(&quot;&lt;html&gt;data&lt;&#x2F;html&gt;&quot;) # 方法二：读取现成、字符串形式的html代码片段\n\n​        首先,文档被转换成Unicode,并且HTML的实例都被转换成Unicode编码\n BeautifulSoup(&quot;Sacr&amp;eacute; bleu!&quot;)\n&lt;html&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;Sacré bleu!&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n​        然后,Beautiful Soup选择最合适的解析器来解析这段文档,如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档.(参考 解析成XML ).\n\n对文档进行处理：\n​    Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment .\n​    Tag：即原文档中的标签，可以通过name和attrs来直接调用对应的名称和属性，请务必注意属性的返回值！我们还可以通过string来调用内容，但是内容不能被直接修改\n​                如果只想得到tag中包含的文本内容,那么可以嗲用 get_text() 方法,这个方法获取到tag中包含的所有文版内容包括子孙tag中的内容,并将结果作为Unicode字符串返回\n​    **NavigableString**：字符串常被包含在tag内.Beautiful Soup用 NavigableString 类来包装tag中的字符串，tag中包含的字符串不能编辑,但是可以被替换成其它的字符串,用 replace_with() 方法:\n\n进行文档遍历：低效\n\n文档搜索（√）：\n\nselect()css选择器，支持id(#)，class(.)，tag，父子选择等css匹配规则\n​    example: bs.select(a[class = ‘hello!’ ])\n\nfind_all()几乎同select，但是支持了正则表达式\n​    example: bs.find_all(‘div’, class_=’item’) / bs.find_all(re.compile(“a”))\n\n\n\n\n\n\n\n\nre：二级处理（从根本解决问题）\n正则表达式使用手册：\n​    正则表达式 (Web 视图)\n\nre模块使用手册：\n​    re模块 (Web 视图)\n\n\n# 全部html代码已经在前面的url处理中完全取得\ndef get_information(html):\n\tglobal num\n\tbs &#x3D; BeautifulSoup(html, &#39;lxml&#39;) # 推荐使用lxml作为解析器,因为效率更高.\n\n\tfind_movie_address &#x3D; re.compile(r&#39;&lt;a href&#x3D;&quot;(.*?)&quot;&gt;&#39;, re.S)\n\tfind_title &#x3D; re.compile(r&#39;&lt;span class&#x3D;&quot;title&quot;&gt;(.*?)&lt;&#x2F;span&gt;&#39;, re.S)\n\tfind_more_title &#x3D; re.compile(r&#39;&lt;span class&#x3D;&quot;other&quot;&gt;(.*?)&lt;&#x2F;span&gt;&#39;, re.S)\n\n\tfor item in bs.find_all(&#39;div&#39;, class_&#x3D;&#39;item&#39;):\n\t\tprint(&#39;-&#39;*30)\n\t\tprint(num + 1)\n\t\titem &#x3D; str(item)\n\t\tmovie_address_data.append(re.findall(find_movie_address, item)[0])\n\n\t\tif len(re.findall(find_title, item)) &#x3D;&#x3D; 2:   # 不是所有影片都有“两个title”的class\n\t\t\tmovie_title_data.append(re.findall(find_title, item)[0])\n\t\t\tmovie_traditional_title_data.append(re.findall(find_title, item)[1])\n\t\telse:\n\t\t\tmovie_title_data.append(re.findall(find_title, item)[0])\n\t\t\tmovie_traditional_title_data.append(&#39; &#39;)  # 用空格&#39; &#39;来代表该电影是中文电影，没有外文“原名”\n\n\t\tmovie_more_title_data.append(re.findall(find_more_title, item)[0])\n\n\t\ttemp &#x3D; movie_title_data[num] + movie_traditional_title_data[num] + movie_more_title_data[num]\n\t\tmovie_title_collection.append(temp)\n\n\t\tprint(movie_address_data[num])\n\t\tprint(movie_title_collection[num])\n\t\tnum &#x3D; num + 1\n\t# 模拟正常浏览网页的停留时间\n\ttime.sleep(random.random() * 100)\n\n第四步：保存数据\nexcel表：Python Resources for working with Excel - Working with Excel Files in Python (python-excel.org)\n​    xlwings：Automate Excel with Python (Open Source and Free) (xlwings.org)\n# xlwings示例代码：\n\nimport xlwings as xw\n\n#连接到excel\nworkbook &#x3D; xw.Book(r&#39;path&#x2F;myexcel.xlsx&#39;)#连接excel文件\n#连接到指定单元格\ndata_range &#x3D; workbook.sheets(&#39;Sheet1&#39;).range(&#39;A1&#39;)\n#写入数据\ndata_range.value &#x3D; [1,2,3]\n#保存\nworkbook.save()\n\n以上步骤综合即是一个完整的python爬虫程序\n","slug":"Language Learning/Python/python爬虫","date":"2023-03-08T00:26:02.002Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"requirements.txt in Python project写python程序的时候，我们经常的会下载很多外部模块，当我们编写完成后，准备在其他设备上部署的时候，那么新设备上需要安装我当前环境下的所有包——非常麻烦\n我们可以利用pip来生成一个requirements.txt的文件，在新环境中通过读取这个文件中的模块名称进行环境的安装\n生成requirements.txt在项目根目录打开cmd/powershell\n执行\npip freeze &gt; requirements.txt\n\n例如：\n\n这时候项目根目录就会多一个requirements.txt文件，里面会记录我们项目需要的所以模块信息。具体说明可见：pip freeze - pip documentation v22.0.3 (pypa.io)\n\n请注意区分当前terminal中的pip是否和项目所使用的pip所一致，terminal生成的txt是根据系统变量中pip的所有依赖包来生成txt的，可能跟项目实际所使用的有所不同\n如果在创建项目都是包全局继承就比较悲剧，但鉴于requirements.txt的格式较为简单，在了解后可以尝试手动创建\n\n使用requirements.txt新环境中通过此文件可以直接安装模块（注:需要先切换到 requirements.txt的上级目录，也就是项目根目录）\n在项目根目录下执行\npip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple -r requirements.txt\n安装至虚拟环境中命令\n进入到了虚拟环境中：切到虚拟环境目录的Script文件下\npip install -r D:\\odoo13\\odoo\\requirements.txt\n\n\n\n两个备用镜像源：\n阿里 https://mirrors.aliyun.com/pypi/simple\n清华 https://pypi.tuna.tsinghua.edu.cn/simple\n","slug":"Language Learning/Python/Requirements.txt","date":"2023-03-08T00:26:01.997Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"目标：使用selenium来解决网页中的大量同质化人工操作内容零：想好该怎么做：关于指定网站：网站是网盘网站，其文件有密码保护，即每个文件都有不同且无规律的受保护地址；同时，这些网页的操作完全重复。\n我们可以使用selenium来完成自动化代替重复劳动。\n关于selenium\n需要使用浏览器的自动化driver\n需要使用键盘输入模拟模块\n需要使用鼠标输入模拟模块\n需要事先了解需要操作的网页元素对象的路径\n\n一、准备工作：将所有需要爬取的地址整合到一个列表里：import os\n\npath &#x3D; r&quot;D:\\Project\\Code Trainning\\Learning\\PythonDemo&quot;\nfilename &#x3D; r&quot;addresslist.txt&quot; # 存储所有网址的文件\ncode &#x3D; &quot;849227&quot; # 网站文件的密码\n\nos.chdir(path)\nos.getcwd()\n\nf &#x3D; open(file&#x3D;filename, mode&#x3D;&#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)\nFileContent &#x3D; f.readlines()\nf.close()\n\nAddressList &#x3D; []\nt &#x3D; 1\nfor i in FileContent:\n    if t % 2 &#x3D;&#x3D; 0 and t % 4 !&#x3D; 0:\n        AddressList.append(i)\n    t &#x3D; t + 1\n\n# for i in AddressList:\n#     print(i)\n\n二、用selenium来打开这些网页并模拟操作：打开网页：from selenium import webdriver # selenium.webdriver模块提供了所有WebDriver的实现\nfrom selenium.webdriver.common.keys import Keys # Keys类提供了键盘的代码，用来输入特殊的键盘符（如：回车,ALT,F1等等）\n\t# 比如，在上条语句输入之后，可以使用Keys.ENTER来模拟输入回车符\nimport time\n\nwd &#x3D; webdriver.Edge(r&quot;D:\\language\\EdgeDriver\\msedgedriver.exe&quot;) # 创建一个Edge浏览器的实例\n\ntry:\n    for i in AddressList:\n        wd.get(i)\n        \n        …… # 接第二步\n\n        time.sleep(60)\nexcept Exception as e:\n    print(e)\n\n    # driver.get方法会导向给定的URL的页面，WebDriver会等待页面完全加载完(就是onload函数被触发了)，才把程序的控制权交给你的测试或者脚本。 \n    # 但是！如果 你的页面用了太多的AJAX，那么这个机制将会失效，因为原本完整的页面只占用很小一部分时间，而ajax是“页面完成之后的操作”，selenium根本不知道页面到底是什么时候加载完。就像是requests面对众多ajax存在的网页一样\n\n对网页进行操作time.sleep(5) # 最差的实现方式，最好使用隐式等待\n\n\ninput_box1 &#x3D; wd.find_element_by_id(&#39;passcode&#39;) # 找到输入box\ninput_box1.send_keys(code) # 输入验证码，send_keys函数能模拟大部分的键盘输入，其他的需要Keys类来实现\nconfirm_button1 &#x3D; wd.find_element_by_xpath(r&quot;&#x2F;html&#x2F;body&#x2F;main&#x2F;div&#x2F;div[1]&#x2F;div&#x2F;div&#x2F;div&#x2F;div[2]&#x2F;div[2]&#x2F;button&quot;)\nconfirm_button1.click() # 模拟鼠标电机\n\ntime.sleep(5) # 如上\n\nconfirm_button2 &#x3D; wd.find_element_by_xpath(r&quot;&#x2F;html&#x2F;body&#x2F;main&#x2F;div&#x2F;div&#x2F;div[4]&#x2F;div[1]&#x2F;div[2]&#x2F;button&quot;)\nconfirm_button2.click()\n\ntime.sleep(180)\nwd.find_element_by_tag_name(&#39;body&#39;).send_keys(Keys.Control + &#39;t&#39;) # 模拟组合键\n\n&quot;&quot;&quot;\n显式Waits\n\t+ 用WebDriverWait结合ExpectedCondition来实现：\n\t\telement &#x3D; selenium.webdriver.support.ui.WebDriverWait(wd, 10).unitl(\n\t\t\tselenium.webdriver.support.expected_conditions.presence_of_located(By.ID, &quot;anyIDisOK&quot;)\n\t\t) \n\t\t# 这段代码将会等待10秒，并在等待过程中，每0.5s就调用一下ExpectedCondition，如果成功则立即返回，否则持续重试直到超时报错，报出错误TimeoutException\n\t+ 显示Wait中有许多预期条件，这样子就无需自己编写expected_condition（见文档\n\t\n隐式Waits\nplease forget that，but when I understand，I will c\n&quot;&quot;&quot;\n\n\n\n结束wd.close() # 或者 wb.quit()\n\n","slug":"Language Learning/Python/selenium自动化","date":"2023-03-08T00:26:01.994Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"使用Python解决文件自动化改名和命名原因：获取压缩文件的实际名称：压缩文件名称使用了随机字符，而原文件夹作为压缩文件的根目录来保存，为了避免打开压缩文件才能知道打开的到底是哪个文件，需要将压缩文件内的文件夹名复制出来为外部压缩文件改名\n采用方案：解压缩模块：zipfileofficial site zipfile — Work with ZIP archives — Python 3.9.6 documentation\n\n提取所有压缩文件的实际名称\n\n文件处理模块：os\n确定实际工作目录\n找到所有需要改名的文件并存储\n在压缩文件中提取完实际名称后对源文件进行改名\n\n文字提取模块（正则表达式）：re\n对路径使用正则表达式来处理文件\n\n程序实例：\nimport os\nimport zipfile\nimport re\n\nos.getcwd()\t\t\t# 等待结果\npath &#x3D; r&quot;&quot;\t\t\t# 输入要处理文件的路径\nos.chdir(path)\t\t# 进入目标目录\n\nA &#x3D; []\nfor i in os.walk(path):\n    A.append(i)\n    \nB &#x3D; A[0][2] # B按顺序存储了需要修改的所有文件，注意A[0][2]的真正含义！\n\n# 注意，B可能包含已经修改了的文件，这时有两个方案\n\t# 1. （通过操作）规避这些文件，单独处理（费时费力，但是可以在一个文件夹下完成所有操作，也符合我个人直觉，毕竟是存在某些文件没有\n\t# 2. 将这些文件全部复制到新文件夹下保持文件纯净\n# 采用方案2\n\nC &#x3D; [] # 存储真实名称\n\nfor i in B:\n    with zipfile.ZipFile(i, &#39;r&#39;) as z:\n        for i in z.namelist():\n            C.append(i)\n        z.close() # 可能会有几百行？_(:з」∠)_，总之，拿下了就行\n\nget_name_rule &#x3D; re.compile(r&quot; &quot;, re.S) # 正则表达式的筛选规则\nD &#x3D; []\nfor i in C:\n\tif re.findall(get_name_rule, i) !&#x3D; []:\n        D.append(re.findall(get_name_rule, i)[0])\n\n&#39;&#39;&#39;\nE &#x3D; []\nrule_extended &#x3D; re.compile(r&quot; &quot;, re.S)\nfor i in D:\n    if re.findall(rule_extended, i) !&#x3D; []:\n    \tE.append(re.findall(rule_extended, i)[0])\n    else:\n    \tE.append(i)\n补充提取，将所有违规字符如&#39;&#x2F;&#39;，&#39;*&#39;等全部剔除\n&#39;&#39;&#39;\n\ncount &#x3D; 0\nfor i in B:\n    temp &#x3D; E[count] + &quot;.zip&quot; \t# 注意后缀！\n    os.rename(i, temp)\n    count &#x3D; count + 1\n\n    \n    \n    \n    \n以上全部！\n\n\n\n","slug":"Language Learning/Python/使用python解决文件自动化处理的方案","date":"2023-03-08T00:26:01.980Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"使用Python解决文件自动化改名和命名原因：获取压缩文件的实际名称：压缩文件名称使用了随机字符，而原文件夹作为压缩文件的根目录来保存，为了避免打开压缩文件才能知道打开的到底是哪个文件，需要将压缩文件内的文件夹名复制出来为外部压缩文件改名\n采用方案：解压缩模块：zipfileofficial site zipfile — Work with ZIP archives — Python 3.9.6 documentation\n\n提取所有压缩文件的实际名称\n\n文件处理模块：os\n确定实际工作目录\n找到所有需要改名的文件并存储\n在压缩文件中提取完实际名称后对源文件进行改名\n\n文字提取模块（正则表达式）：re\n对路径使用正则表达式来处理文件\n\n程序实例：\nimport os\nimport zipfile\nimport re\n\nos.getcwd()\t\t\t# 等待结果\npath &#x3D; r&quot;&quot;\t\t\t# 输入要处理文件的路径\nos.chdir(path)\t\t# 进入目标目录\n\nA &#x3D; []\nfor i in os.walk(path):\n    A.append(i)\n    \nB &#x3D; A[0][2] # B按顺序存储了需要修改的所有文件，注意A[0][2]的真正含义！\n\n# 注意，B可能包含已经修改了的文件，这时有两个方案\n\t# 1. （通过操作）规避这些文件，单独处理（费时费力，但是可以在一个文件夹下完成所有操作，也符合我个人直觉，毕竟是存在某些文件没有\n\t# 2. 将这些文件全部复制到新文件夹下保持文件纯净\n# 采用方案2\n\nC &#x3D; [] # 存储真实名称\n\nfor i in B:\n    with zipfile.ZipFile(i, &#39;r&#39;) as z:\n        for i in z.namelist():\n            C.append(i)\n        z.close() # 可能会有几百行？_(:з」∠)_，总之，拿下了就行\n\nget_name_rule &#x3D; re.compile(r&quot; &quot;, re.S) # 正则表达式的筛选规则\nD &#x3D; []\nfor i in C:\n\tif re.findall(get_name_rule, i) !&#x3D; []:\n        D.append(re.findall(get_name_rule, i)[0])\n\n&#39;&#39;&#39;\nE &#x3D; []\nrule_extended &#x3D; re.compile(r&quot; &quot;, re.S)\nfor i in D:\n    if re.findall(rule_extended, i) !&#x3D; []:\n    \tE.append(re.findall(rule_extended, i)[0])\n    else:\n    \tE.append(i)\n补充提取，将所有违规字符如&#39;&#x2F;&#39;，&#39;*&#39;等全部剔除\n&#39;&#39;&#39;\n\ncount &#x3D; 0\nfor i in B:\n    temp &#x3D; E[count] + &quot;.zip&quot; \t# 注意后缀！\n    os.rename(i, temp)\n    count &#x3D; count + 1\n\n    \n    \n    \n    \n以上全部！\n\n\n\n\n\n有关zipfile的常用方法：\n一看就懂：\nimport zipfile\nf &#x3D; zipfile.ZipFile(&#39;filename.zip&#39;, &#39;w&#39; ,zipfile.ZIP_DEFLATED)\nf.write(&#39;file1.txt&#39;)\nf.write(&#39;file2.doc&#39;)\nf.write(&#39;file3.rar&#39;)\nf.close()\nf &#x3D; zipfile.ZipFile(&#39;filename&#39;)\nf.extractall()\nf.close()\n\n1.1 zipfile.ZipFile(file, mode=’r’, compression=ZIP_STORED, allowZip64=True, compresslevel=None, ***, strict_timestamps=True)\nOpen a ZIP file, where file can be a path to a file (a string), a file-like object or a path-like object.\n\n\n\n\n\n\n\n\n\nfileName是没有什么疑问的了。\nmode和一般的文件操作一样,’r’表示打开一个存在的只读ZIP文件；’w’表示清空并打开一个只写的ZIP文件，或创建一个只写的ZIP文件；’a’表示打开一个ZIP文件，并添加内容。\n\n\n\n\n\n\n\n\n\n\n\n\nThe mode parameter should be &#39;r&#39; to read an existing file, \n&#39;w&#39; to truncate and write a new file, \n&#39;x&#39; to exclusively create and write a new file. \n\nIf mode is &#39;x&#39; and file refers to an existing file, a FileExistsError will be raised. \n&#39;a&#39; to append to an existing file, \n\n\n\n\n\n\n\n\n\nIf mode is &#39;a&#39; and file refers to an existing ZIP file, then additional files are added to it. \nIf file does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file (such as python.exe).\n#比如：我有一个new.txt文件\na &#x3D; zipfile.ZipFile(&#39;new.txt&#39;, &#39;a&#39;) # 此时new.txt文件会被归档，new.txt会被改写为zip文件\na.write(&#39;new.txt&#39;)\na.close()\n# 并在外侧改写new.txt的后缀为.zip，发现存在是一个正式的.zip文件且存在一个new.txt\n\nIf mode is &#39;a&#39; and the file does not exist at all, it is created. \nIf mode is &#39;r&#39; or &#39;a&#39;, the file should be seekable.\n\n\n\n\n\n\n\n\n\n\n\ncompression表示压缩格式，可选的压缩格式只有2个：ZIP_STORE;ZIP_DEFLATED。ZIP_STORE是默认的，表示不压缩；ZIP_DEFLATED表示压缩。\nallowZip64为True时，表示支持64位的压缩，一般而言，在所压缩的文件大于2G时，会用到这个选项；默认情况下，该值为False，因为Unix系统不支持。\n1.2 zipfile.close()\n\n\n\n\n\n\n\n\n\n你写入的任何文件在关闭之前不会真正写入磁盘。\n1.3 zipfile.write(filename[, arcname[, compress_type]])\n\n\n\n\n\n\n\n\n\nacrname是压缩文件中该文件的名字，默认情况下和filename一样 \ncompress_type的存在是因为zip文件允许被压缩的文件可以有不同的压缩类型。\n1.4 zipfile.extractall([path[, member[, password]]])\n\n\n\n\n\n\n\n\n\npath解压缩目录\nmember需要解压缩的文件名儿列表\npassword当zip文件有密码时需要该选项\n\nExtract all members from the archive to the current working directory. \npath specifies a different directory to extract to. members is optional and must be a subset of the list returned by namelist(). pwd is the password used for encrypted files.\n\n\nZipFile.namelist()\n\n\n\n","slug":"Language Learning/Python/使用python解决文件自动化处理的方案及zipfile模块的介绍","date":"2023-03-08T00:26:01.978Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"依赖项管理：Requirements.txt, Setup.py及更多Write a setup.py\n\n\n\n\n\n\n\n\nremember what you use, or try to use some tools to control the dependenies efficiently and fine\nYes, we can write this file in multiple ways - python is a script language after all.\nHowever, what’s the most imporant part?\nI think we should follow the codes below:\nfrom setuptools import setup, find_packages()\nsetup(\n    # metadata with info\n    name&#x3D;&#39;SetupFileExample&#39;,\n    version&#x3D;&#39;0.1&#39;,\n    author&#x3D;&#39;JBR&#39;,\n    author_email&#x3D;&#39;jbr@example.com&#39;,\n    packages&#x3D;find_packages(),\n    description&#x3D;&#39;Useful towel-related stuff.&#39;,\n    # dependencies \n    install_requires&#x3D;[\n        &quot;Django &gt;&#x3D; 1.1.1&quot;,\n        &quot;caldav &#x3D;&#x3D; 0.1.4&quot;,\n    ],\n)\n\nAs for metadata, you can use this chart:\n\nand, the next one is a problem: how can we remember the packages we installed thousands of years ago?\nwell, thanks to the pip-tools we list at link4 - Link below, we can clearly see the main dependencies and decide which to list. With that, we can figure out what’s important\nWhy we need setup.py even if requirements.txt already exists?see link3 - it’s pretty nice!\nLinks：\nhighly recommend to read: A Practical Guide to Using Setup.py - GoDataDriven\nrecommend to read: Python 库打包分发(setup.py 编写)简易指南 | Huoty’s Blog (konghy.cn)\nrecommend to read: 12. setup.py vs requirements.txt — 一起写Python文章，一起看Python文章 (pyzh.readthedocs.io)\n别再用 requirements.txt 来管理依赖了 - 腾讯云开发者社区-腾讯云 (tencent.com)\njazzband/pip-tools: A set of tools to keep your pinned Python dependencies fresh. (github.com)\nPython 中的 requirements.txt 与 setup.py - 知乎 (zhihu.com)\n2. Writing the Setup Script — Python 3.10.7 documentation\nBuilding and Distributing Packages with Setuptools - setuptools 65.3.0.post20220826 documentation (pypa.io)\n\n","slug":"Language Learning/Python/依赖项管理","date":"2023-03-08T00:26:01.977Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"二维数组的定义创建一个二维数组？还是一个n*n的二维数组？\n1. 直接定义：a &#x3D; [[]]\n\n2.众多间接定义？a.直接地间接创建a&#x3D;[]\narrays&#x3D;[a*3]\n\n注意！这里的arrays并不是[[], [], []]，而是[[]]\nb.通过引用创建二维数组arrays&#x3D;[a]*N\n\n看上去是创建了二维数组，但是只是创建N个指向a的引用\n所以一旦a改变，arrays中N个list也会随之改变\neg:\na&#x3D;[]\nN&#x3D;3\narrays&#x3D;[a]*3\n# arrays &#x3D; [[], [], []]\n\narrays[0].append(1) # 注意：并不是只为第一个list添加整数1\nprint(arrays)\n# 输出[[1], [1], [1]]\n\narrays[1].append(1)\nprint(arrays)\n# 输出[[1, 1], [1, 1], [1, 1]]\n\nc.创建独立的二维数组arrays&#x3D;[[]for i in range(N)]\n\neg:\nN&#x3D;3\narrays&#x3D;[[]for i in range(N)]\nprint(arrays)\n\narrays[0].append(0)\nprint(arrays)\n# 输出[[0], [], []]\n\n输出[[], [], []]\n","slug":"Language Learning/Python/数组","date":"2023-03-08T00:26:01.974Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"python的is和==，java的==和equal（相等判断）Python判断对象是否相等（== 和 is）Python中的对象包含三个基本要素，分别是：\n\nid：用来唯一标识一个对象，可以理解为内存地址；\ntype：标识对象的类型；\nvalue：对象的值；\n\n== ：比较两个对象的内容是否 相等，即两个对象的 value 是否相等，无论 id 是否相等，默认会调用对象的 **__eq__()**方法\nis： 比较的是两个对象是不是完全 相同，即他们的 id 要相等。\n也就是说：如果 a is b 为 True，那么 a == b 也为True\n字符串比较a &#x3D; &#39;hello&#39;\nb &#x3D; &#39;hello&#39;\nprint(a is b)\nprint(id(a))\nprint(id(b))\n# 执行结果：\nTrue\n1830826496176\n1830826496176\n\n数字比较先看一个有趣的现象\nIn[43]: a &#x3D; 256\nIn[44]: b &#x3D; 256\nIn[45]: a is b\nOut[45]: True\nIn[46]: id(a)\nOut[46]: 140711685177712\nIn[47]: id(b)\nOut[47]: 140711685177712\nIn[48]: a &#x3D; 257\nIn[49]: b &#x3D; 257\nIn[50]: a is b\nOut[50]: False\nIn[51]: id(a)\nOut[51]: 2097451837488\nIn[52]: id(b)\nOut[52]: 2097451837648\n\n为什么当 a,b为257的时候 a is b 为False呢？\nPython 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。\n而Python 对小整数的定义是 [-5, 256)，只有数字在-5到256之间它们的id才会相等，超过了这个范围就不行了，同样的道理，字符串对象也有一个类似的缓冲池，超过区间范围内自然不会相等了。\n需要注意的是这仅仅是在命令行中执行时才会有小整数缓存，而在文件中执行时，结果是不一样的，这是因为解释器做了一部分优化，如下：\nx &#x3D; 257\ny &#x3D; 257\nprint(id(x))\nprint(id(y))\nprint(x is y)\n# 执行结果：\n2177330411024\n2177330411024\nTrue\n\n元组比较x &#x3D; (1, 2, 3)\ny &#x3D; (1, 2, 3)\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\n3014830376024\n3014830376024\n\n列表比较x &#x3D; [1, 2, 3]\ny &#x3D; [1, 2, 3]\nprint(x &#x3D;&#x3D; y)\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\nFalse\n2968991650248\n2968991650760\n\n列表赋值比较x &#x3D; [1, 2, 3]\ny &#x3D; x\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\n2294971781576\n2294971781576\n\n字典比较x &#x3D; &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;b&quot;: 3&#125;\ny &#x3D; &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;b&quot;: 3&#125;\nprint(x &#x3D;&#x3D; y)\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\nFalse\n2522908527576\n2522908269848\n\n集合比较x &#x3D; set([1, 2, 3])\ny &#x3D; set([1, 2, 3])\nprint(x &#x3D;&#x3D; y)\nprint(x is y)\nprint(id(x))\nprint(id(y))\n# 执行结果：\nTrue\nFalse\n2080395955784\n2080414590120\n\n小结：可以看到，当 x, y 为字符串、整数，元组（都是不可变类型）的时候，如果 x 和 y的值一样的话，x is y 则为True；\n然而为列表，字典，集合（都是可变类型）的时候，x is y 为False，列表赋值的时候为True；\n与 == 相比，is 的计算速度快——因为它不能重载，不用进行特殊的函数调用，少了函数调用的开销而直接比较两个整数 id。而 a == b 则是等同于**a.eq(b)**。继承自 object 的 **__**eq__ 方法比较两个对象的id，结果与 is 一样。但是多数Python的对象会覆盖object的 **__eq__**方法，而定义内容的相关比较，所以比较的是对象属性的值。\n在变量和单例值之间比较时，应该使用 is。目前，最常使用 is 的地方是判断对象是不是 None\n关于python的可变类型不可变类型可参考：https://www.runoob.com/python/python-variable-types.html\npython的赋值、浅拷贝和深拷贝可参考：https://blog.csdn.net/bufengzj/article/details/90486991\nJava判断对象是否相等（== 和equal）java中没有 is ,有 == 和 equal。。\n==：比较两个变量本身的值，即两个对象在内存中的首地址（类似也就是和python的 is ）；\nequals：比较变量所包含的内容是否相同（类似也就是和python的 == ）；\njava 具体参考：https://www.cnblogs.com/weibanggang/p/9457757.html\n","slug":"Language Learning/Python/相等判断","date":"2023-03-08T00:26:01.967Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"python 定时器在工作中，我们有时候会需要定时去做一些操作，比如凌晨更新远程代码，仓库每小时更新一次远程分支。这些操作，我们如果要人工进行，不仅要耗费精力，也更容易出错。\n如果一件事情，具有周期操作的特点，那么把这件事情设置为定时器操作，最合适不过。\n不借助第三方插件在不借助第三方插件的情况下，python内部可以有多种方式完成定时器操作，这里介绍一种简单易行的方法：\n利用threading.Timer方法创建一个定时器。\n一个简单的需求，程序启动5s后在屏幕上打印一个hello首先介绍一下threading.Timer的使用方法：\nclass threading.Timer(interval, function, args=[], kwargs={})\n创建一个timer，在interval秒过去之后，它将以参数args和关键字参数kwargs运行function 。\n调用该函数回返回一个定时器的句柄，同时也获得了一个定时器实例。\n但是这时，定时器只是被创建，被没有启动，需要调用实例里面的\nstart（）方法启动定时器。如果在定时过程中想要取消该定时器，需要使用cancel()函数。\n那么这个小需求，就很简单了，代码可以这么写：\n\n定义一个定时时间到了，需要调用的函数，方便Timer函数回调，创建定时器实例，并设置定时时间，或得实例后，启动定时器。\n\n但是我们发现，定时器只执行了一次，如何要定时器，能够不停的执行下去呢？\n一种方法是利用while（True），不停的创建定时器并启动，显然这种方法显得笨拙，而且会一直占用线程。\n另外一种方法，就是在回调函数中，创建定时器并启动，形成递归调用。这里着重说下这种方法。\n\n运行效果如下：\n\n程序看起来很简单，通过在回调函数里面，重新创建定时器，来使得定时器能够一直工作。\n但是值得注意的是，定时器的句柄需要定义成为一个全局变量，这样做的好处是，创建的定时器进程和实例不会堆积，而是覆盖，避免不必要的内存占用。\n另外利用threading创建的定时器还有一个好处是，每一个定时器的创建都是在一个新的进程里面，所以定时器是不阻塞式的，比如，我们创建两个定时器，让它们分别打印不同的字符串：\n\n我们运行程序可以看到：\n\n这样一个简单的定时器就完成了！\n但是这并不是一个十分健壮的定时器，还有很多问题需要考虑，比如，如何终止定时器？在何时使用cancel（）？如果创建定时器实例失败，应该如何处理？等等。\n不过一个定时器的基本雏形已经完成了，剩下的就是根据需要添加不同的功能。\nSchedule插件schedule · PyPI\n","slug":"Language Learning/Python/计时器","date":"2023-03-08T00:26:01.965Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"FormData 对象的使用 - Web API 接口参考 | MDN (mozilla.org)\n\n\n\n\n\n\n\n\n\nFormData对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。如果表单enctype属性设为multipart/form-data ，则会使用表单的submit()方法来发送数据，从而，发送数据具有同样形式。\n从零开始创建FormData对象你可以自己创建一个FormData对象，然后调用它的append()方法来添加字段，像这样：\nvar formData &#x3D; new FormData();\n\n&#x2F;&#x2F; 发送键值对\nformData.append(&quot;username&quot;, &quot;Groucho&quot;);\nformData.append(&quot;accountnum&quot;, 123456); &#x2F;&#x2F;数字123456会被立即转换成字符串 &quot;123456&quot;\n\n&#x2F;&#x2F; HTML 文件类型input，由用户选择\nformData.append(&quot;userfile&quot;, fileInputElement.files[0]); &#x2F;&#x2F; fileInputElement是 file类型的input标签\n\n&#x2F;&#x2F; JavaScript file-like 对象\nvar content &#x3D; &#39;&lt;a id&#x3D;&quot;a&quot;&gt;&lt;b id&#x3D;&quot;b&quot;&gt;hey!&lt;&#x2F;b&gt;&lt;&#x2F;a&gt;&#39;; &#x2F;&#x2F; 新文件的正文\nvar blob &#x3D; new Blob([content], &#123; type: &quot;text&#x2F;xml&quot;&#125;);\n\nformData.append(&quot;webmasterfile&quot;, blob);\n\n&#x2F;&#x2F; 发送\nvar request &#x3D; new XMLHttpRequest();\nrequest.open(&quot;POST&quot;, &quot;http:&#x2F;&#x2F;foo.com&#x2F;submitform.php&quot;);\nrequest.send(formData);\n\n上传文件思路：利用h5的input标签，将其type设置为file\n&lt;input type=”file”&gt; - HTML（超文本标记语言） | MDN (mozilla.org)\n此时，注意其一特殊的内置属性：files属性，它会以FileList对象的形式列出已选择的文件\nFileList - Web API 接口参考 | MDN (mozilla.org)\n值得注意的是，Filelist不是formdata，请不要尝试直接将Filelist对象发送给后端\n同时，如需发送formdata，请先行创建一个FormData对象\nFormData并非一定需要一个form来作为基础进行创建，但一定需要键值对\n也可以利用\nformdata.append(&#39;file&#39;, document.getElementById(&quot;fileInput&quot;).files[0])\n\n手动将传入的文件加入formdata对象中\n发送请求时，需要特别设置其请求头：\nheaders: &#123;\n      &#39;Content-Type&#39;: &quot;multipart&#x2F;form-data&quot;,\n&#125;\n\n防止所发送的文件被错误地转换了格式\n循环获取formdata内容javascript - How to inspect FormData? - Stack Overflow\nfor (var [a, b] of formData.entries()) &#123;\n  console.log(a, b, &#39;--------------&#39;);\n&#125;\n\n\n\nformdata.get(key)\n\n\n\n\n\n\n\n\n\n\n\n\n注意: 所有的输入元素都需要有name属性，否则无法访问到值。\n——FormData() - Web API 接口参考 | MDN (mozilla.org)\n上传文件完整攻略：&lt;body&gt;\n&lt;form id&#x3D;&quot;form&quot;&gt;\n    &lt;label&gt;Choose File to Send: &lt;&#x2F;label&gt;\n    &lt;input type&#x3D;&quot;file&quot; multiple name&#x3D;&quot;file&quot; required&#x2F;&gt; &lt;!-- 注意，用于输入的input一定要有name --&gt;\n    &lt;br &#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Send the file!&quot;&#x2F;&gt;\n&lt;&#x2F;form&gt;\n&lt;script&gt;\n    var form &#x3D; document.getElementById(&#39;form&#39;);\n    form.addEventListener(&#39;submit&#39;, function (ev) &#123;\n        var oData &#x3D; new FormData(form);\n\n        axios(&#123;\n            method: &quot;post&quot;,\n            url: &quot;upload&quot;,\n            headers: &#123;\n                &#39;Content-Type&#39;: &quot;multipart&#x2F;form-data&quot;,\n            &#125;,\n            data: oData,\n            timeout: 3000,\n        &#125;).then(res &#x3D;&gt; &#123;\n            console.log(res)\n        &#125;)\n        ev.preventDefault(); &#x2F;&#x2F; 阻止对应组件的默认行为,此处为防止页面刷新导致努力ba\n    &#125;, false);\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n# flask 后台\n@app.route(&#39;&#x2F;upload&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])\ndef upload_file():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        print(request.files)\n\n        print(request.files.getlist(&#39;file&#39;))\n\n        upload_files &#x3D; request.files.getlist(&#39;file&#39;)\n\n        for i in upload_files:\n            i.save(i.filename + &#39;.jpg&#39;)\n        return &quot;OK!&quot;\n    else:\n        return &quot;Wrong!&quot;\n\n","slug":"Language Learning/JavaScript/formdata使用攻略","date":"2023-03-08T00:26:01.963Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"DTD 简介 | 菜鸟教程 (runoob.com)\n","slug":"Language Learning/MARK LANGUAGE/DTD","date":"2023-03-08T00:26:01.961Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"XML 简介 – 什么是 XML？ | 菜鸟教程 (runoob.com)\n","slug":"Language Learning/MARK LANGUAGE/XML","date":"2023-03-08T00:25:59.891Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"箭头函数箭头函数 - JavaScript | MDN (mozilla.org)\n说明箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n注意箭头函数 != 匿名函数\n箭头函数是js对Anonymous function - Wikipedia的实现，它属于匿名函数的一种。\n一般而言匿名函数anonymous function == lambda表达式，但js比较特殊\nconst materials &#x3D; [\n  &#39;Hydrogen&#39;,\n  &#39;Helium&#39;,\n  &#39;Lithium&#39;,\n  &#39;Beryllium&#39;\n];\n\nconsole.log(materials.map(material &#x3D;&gt; material.length));\n&#x2F;&#x2F; expected output: Array [8, 6, 7, 9]\n\n语法(param1, param2, …, paramN) &#x3D;&gt; &#123; statements &#125;\n\n(param1, param2, …, paramN) &#x3D;&gt; expression\n&#x2F;&#x2F;相当于：(param1, param2, …, paramN) &#x3D;&gt;&#123; return expression; &#125;\n\n&#x2F;&#x2F; 当只有一个参数时，圆括号是可选的：\n(singleParam) &#x3D;&gt; &#123; statements &#125;\nsingleParam &#x3D;&gt; &#123; statements &#125;\n\n&#x2F;&#x2F; 没有参数的函数应该写成一对圆括号。\n() &#x3D;&gt; &#123; statements &#125;\n\n\n\n函数赋值变量就相当于给原函数换了个新名\n以函数形式返回function print(val) &#123;\n    console.log(&#96;姓名是：$&#123;val&#125;&#96;);\n&#125;\nvar fn &#x3D; print; &#x2F;&#x2F; 将函数赋值给fn\nfn(&#39;angus&#39;); &#x2F;&#x2F; 姓名是：angus\n\n以返回值形式将函数返回的值赋值给fn，如果函数没有返回值，但又接受了，此时会返回undefined\n有返回值：\nfunction print(val) &#123;\n   return &#96;姓名是：$&#123;val&#125;&#96;;\n&#125;\nvar fn &#x3D; print(&#39;angus&#39;);\nconsole.log(fn); &#x2F;&#x2F; 姓名是：angus\n\n无返回值：\nfunction print(val) &#123;\n    &#96;姓名是：$&#123;val&#125;&#96;;\n&#125;\nvar fn &#x3D; print(&#39;angus&#39;);\nconsole.log(fn); &#x2F;&#x2F; undefined\n\n返回值可为函数将我们定义的print函数返回给fn：\nfunction sum() &#123;\n    var num &#x3D; 0;\n    \n    function print() &#123;\n        num +&#x3D; 2;\n        return num;\n    &#125;\n    return print; &#x2F;&#x2F; return了print函数体，并非直接return num\n&#125;\nvar fn &#x3D; sum();\nconsole.log(fn()); &#x2F;&#x2F; 2\n\n&#x2F;&#x2F; var a &#x3D; function sum() &#123;...&#125;  &#x2F;&#x2F; &#x3D;&#x3D;&#x3D; var a &#x3D; sum\n&#x2F;&#x2F; a &#x3D;&gt; sum()&#123;...&#125;\n&#x2F;&#x2F; a() &#x3D;&gt; print()&#123;...&#125;\n&#x2F;&#x2F; a()() &#x3D;&gt; 2\n\n&#x2F;&#x2F; var b &#x3D; sum()\n&#x2F;&#x2F; b &#x3D;&gt; print()&#123;...&#125;\n&#x2F;&#x2F; b() &#x3D;&gt; 2\n\n直接执行print函数，没有返回：\nfunction sum() &#123;\n    var num &#x3D; 0;\n    function print() &#123;\n        num +&#x3D; 2;\n        return num;\n    &#125;\n    print();\n&#125;\nvar fn &#x3D; sum();\nconsole.log(fn); &#x2F;&#x2F; undefined\n\n函数参数中的括号以此为例：\nfunction computeLinkBreadths(&#123;nodes&#125;)&#123;...&#125;\n\nfunction computeLinkBreadths(nodes)&#123;...&#125;\n\n解释：带大括号是指传递一个参数，参数类型为对象，里面有一个属性nodes，而不带大括号就是传递一个参数这里的大括号不是块级作用域，就是单纯的表示一个对象\n但从使用上讲两种方式没有直接区别，但使用传递对象的方法会使今后的扩展变得很方便比如如果需要增加一个参数，在传递对象的方法中只需要直接向里面添加一个属性就行了，否则就需要在后面添加一个硬性的参数，而参数越来越多，调用的时候就越来越复杂——参数顺序不能乱。\n另外，上面的这种写法是es6的解构赋值，可以看下阮老师的http://es6.ruanyifeng.com/#do...，内容不多全书看下来要不了多久，但对你今后的帮助会非常大。\narguments对象&gt; var b &#x3D; function(a) &#123;\n    return arguments.length ? &#96;$&#123;a&#125;&#96; : &quot;none&quot;&#125;\n&lt; undefined\n\n&gt; b()\n&lt; &#39;none&#39;\n\n&gt; b(&quot;c&quot;)\n&lt; &#39;c&#39;\n\n\n\n\n\n\n\n\n\n\narguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。\nArguments 对象 - JavaScript | MDN (mozilla.org)\n","slug":"Language Learning/JavaScript/函数","date":"2023-03-08T00:25:59.867Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"条件运算符: ?条件运算符 - JavaScript | MDN (mozilla.org)\n说明条件（三元）运算符是 JavaScript 仅有的使用三个操作数的运算符。\n一个条件后面会跟一个问号（?），如果条件为 true，则问号后面的表达式A将会执行；\n表达式A后面跟着一个冒号（:），如果条件为 false，则冒号后面的表达式B将会执行。\n条件运算符经常作为 if 语句的简捷形式来使用。\n示例一：\nvar age &#x3D; 26;\nvar beverage &#x3D; (age &gt;&#x3D; 21) ? &quot;Beer&quot; : &quot;Juice&quot;;\nconsole.log(beverage); &#x2F;&#x2F; &quot;Beer&quot;\n\n条件链这个三元操作符是右结合的，也就是说你可以像这样把它链接起来， 和 if … else if … else if … else 链类似:\n示例二：\nfunction example(…) &#123;\n    return condition1 ? value1\n         : condition2 ? value2\n         : condition3 ? value3\n         : value4;\n&#125;\n\n&#x2F;&#x2F; Equivalent to:\n\nfunction example(…) &#123;\n    if (condition1) &#123; return value1; &#125;\n    else if (condition2) &#123; return value2; &#125;\n    else if (condition3) &#123; return value3; &#125;\n    else &#123; return value4; &#125;\n&#125;\n\n\n\n","slug":"Language Learning/JavaScript/特殊运算符","date":"2023-03-08T00:25:59.857Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Java语言：教程网站：Oracle Official Site：The Java™ Tutorials (oracle.com)\nRunoob：Java 教程 | 菜鸟教程 (runoob.com)\nw3school：Java Tutorial (w3schools.com)\n搜索引擎：\n集合，并发，JVM\nLinux：具备相当程度的Linux基础。包括基础命令和设计模式\n数据库：MySql，Redis，HBase，MangoDB，ES\n框架：Spring，SpringMVC，SpringBoot，MyBatis，Tomcat，Dubbo\nMQ：RocketMQ，RabbitMQ，Kafka，ActiveMQ\n分布式：ZooKeeper，分布式协议，如何保持一致性？RPC\n计算机：计算机网络，OS，算法\n系统：系统设计：DDD（领域设计），系统分层（横向纵向）\n其他：缓存，网络安全\n","slug":"Language Learning/Java/Java后端学习路径","date":"2023-03-08T00:25:59.836Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"在线工具\nJava 在线工具 | 菜鸟工具 (runoob.com)\n\n\n","slug":"Language Learning/Java/Java学习","date":"2023-03-08T00:25:59.831Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"what the import statements can doHow to use Java import statement\nIn Java, the import statement is used to bring certain classes or the entire packages, into visibility. As soon as imported, a class can be referred to directly by using only its name.\nThe import statement is a convenience to the programmer and is not technically needed to write complete Java program. If you are going to refer to some few dozen classes into your application, the import statement will save a lot of time and typing also.\nIn a Java source file, the import statements occur immediately following the package statement (if exists) and before any class definitions.\nBelow is the general form of the import statement :\nimport pkg1[.pkg2].(classname|*);\n\nwhen is the","slug":"Language Learning/Java/What happen when you use import statement","date":"2023-03-08T00:25:59.825Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"POST 请求 | Axios 中文文档 (axios-http.cn)\n","slug":"Web Dev/前后端交互","date":"2023-03-07T17:01:52.548Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"CR细则必须打回的情形\n违反代码规约\n\n直接违反阿里巴巴代码规约的要求，开发时可通过插件自动检测。\n\n明显的逻辑漏洞\n\n如前面声明了一个对象，并赋值为null，中间未做赋值，后面直接调用对象的方法等明显代码漏洞。\n\n代码晦涩且缺少必要的注释，CR同学无法理解代码意图\n\n如提供了一个方法，代码中全部用abcd等作为变量名，夹杂各种数学运算，且没有必要的文档和注释表达这段代码的算法逻辑。\n\n新加逻辑缺少开关或灰度等可以控制代码执行的手段\n\n对父类进行修改，但无法保证对其它场景无影响\n\n必要的防NPE判定缺失\n\n未对参数进行判空和必要的合法校验\n\n对外提供的HSF服务，未做异常捕获\n\n违反工程结构和依赖规范，引入不合理的依赖\n\n发布的对外提供的二方库版本为SNAPSHOT\n\n违反日志规范，缺失关键日志\n\n项目中存在无意义的文件等无关内容\n\n\n可以通过，但后续需要优化的情形\n当前功能可以满足，但性能有提升的空间。\n\n复杂业务流程中，单个方法的较为冗长。\n\n分支较多的情形，代码中存在过多的if判断。\n\n超过三层的嵌套循环。\n\n代码可读性较弱，注释较少。\n\n代码中的日志记录较多且有冗余。\n\n存在单元测试代码、用于测试时手动编写的main方法等无关代码。\n\n\n","slug":"WhatWeNeedToLearnLater/CR细则","date":"2023-03-07T17:01:52.546Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\nfatal: Not a valid object name: ‘master’.\nfatal: refusing to merge unrelated histories\ngit init时指定分支名\nfatal: couldn’t find remote ref\ngit 克隆指定分支代码_wudinaniya的博客-CSDN博客_克隆指定分支代码\nGitalk评论插件使用教程 - SegmentFault 思否\n插件 | Hexo Aurora (tridiamond.tech)\nwindows vpn (pptp) couldn’t establish the connection \n\n新式数据序列化技术：Protocol buffers\nOverview  | Protocol Buffers  | Google Developers\n","slug":"WhatWeNeedToLearnLater/fast note","date":"2023-03-07T17:01:51.937Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n序列化及其逆过程要解决的核心问题是 实现相同的数据在不同格式间的转化；\n\n持久化要解决的则是内存中数据结构到硬盘上数据的转化 ，比如比特流或者xml格式的文件；分布式系统数据层都需要做持久化的工作，要么存到数据库中、要么直接以文件形式保存到硬盘上；\n\nmarshalling要解决的问题和serialization类似，但它更加关注网络间数据传输、另有种说法认为marshalling包括跟数据转化有关的codebase;\n\n\nFirst，What is Serialization引用C#文档中对serialization的定义：\n\n\n\n\n\n\n\n\n\nSerialization is the process of converting an object into a stream of bytes to store the object or transmit it to memory, a database, or a file. Its main purpose is to save the state of an object in order to be able to recreate it when needed. The reverse process is called deserialization.\nHow serialization worksThis illustration shows the overall process of serialization:\n\nThe object is serialized to a stream that carries the data. The stream may also have information about the object’s type, such as its version, culture, and assembly name. From that stream, the object can be stored in a database, a file, or memory.\nUses for serializationSerialization allows the developer to save the state of an object and re-create it as needed, providing storage of objects as well as data exchange. Through serialization, a developer can perform actions such as:\n\nSending the object to a remote application by using a web service\nPassing an object from one domain to another\nPassing an object through a firewall as a JSON or XML string\nMaintaining security or user-specific information across applications\n\nSerialization (C#) | Microsoft Docs\n序列化(serialization)过程就是复杂数据在空间上的降维，最终结果是将一个数据结构或者包含对象状态的数据转换为一种可以在计算机文件系统或者内存缓存中被存储或者在计算机网络上被传输的数据格式，当它根据序列化格式被解析时，计算机就能生成一个语义上与原始数据相同的克隆。\n数据序列化不是数据持久化！数据序列化只是 “可以作为数据持久化的中间过程” 而已\n数据复杂度的降维\n几个数据序列化标准介绍与比较【Netty入门】几种序列化协议的介绍_白夜行-CSDN博客_netty序列化协议\nMarshallingThe difference between Serialization and Marshallingterminology - What is the difference between Serialization and Marshaling? - Stack Overflow\n补充材料https://en.wikipedia.org/wiki/Marshalling_(computer_science)\nhttps://zh.wikipedia.org/wiki/Marshalling_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\nrfc2713 (ietf.org)\n序列化理解起来很简单 - 知乎 (zhihu.com)\n","slug":"WhatWeNeedToLearnLater/Serialization、Persistence and Marshalling","date":"2023-03-07T17:01:51.935Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Python 运行效率为何低当我们提到一门编程语言的效率时：通常有两层意思，第一是开发效率，这是对程序员而言，完成编码所需要的时间；另一个是运行效率，这是对计算机而言，完成计算任务所需要的时间。编码效率和运行效率往往是鱼与熊掌的关系，是很难同时兼顾的。不同的语言会有不同的侧重，python语言毫无疑问更在乎编码效率，life is short，we use python。\n虽然使用python的编程人员都应该接受其运行效率低的事实，但python在越多越来的领域都有广泛应用，比如科学计算 、web服务器等。程序员当然也希望python能够运算得更快，希望python可以更强大。\n首先，python相比其他语言具体有多慢，这个不同场景和测试用例，结果肯定是不一样的。这个网址给出了不同语言在各种case下的性能对比，这一页是python3和C++的对比，下面是两个case：\n\n从上图可以看出，不同的case，python比C++慢了几倍到几十倍。\npython运算效率低，具体是什么原因呢，下列罗列一些：\n第一：python是动态语言\n一个变量所指向对象的类型在运行时才确定，编译器做不了任何预测，也就无从优化。举一个简单的例子：　r = a + b。　a和b相加，但a和b的类型在运行时才知道，对于加法操作，不同的类型有不同的处理，所以每次运行的时候都会去判断a和b的类型，然后执行对应的操作。而在静态语言如C++中，编译的时候就确定了运行时的代码。\n另外一个例子是属性查找，关于具体的查找顺序在《python属性查找》中有详细介绍。简而言之，访问对象的某个属性是一个非常复杂的过程，而且通过同一个变量访问到的python对象还都可能不一样（参见Lazy property的例子）。而在C语言中，访问属性用对象的地址加上属性的偏移就可以了。\n第二：python是解释执行，但是不支持JIT（just in time compiler）。虽然大名鼎鼎的google曾经尝试Unladen Swallow 这个项目，但最终也折了。\n第三：python中一切都是对象，每个对象都需要维护引用计数，增加了额外的工作。\n第四：python GIL，GIL是Python最为诟病的一点，因为GIL，python中的多线程并不能真正的并发。如果是在IO bound的业务场景，这个问题并不大，但是在CPU BOUND的场景，这就很致命了。所以笔者在工作中使用python多线程的情况并不多，一般都是使用多进程（pre fork），或者在加上协程。即使在单线程，GIL也会带来很大的性能影响，因为python每执行100个opcode（默认，可以通过sys.setcheckinterval()设置）就会尝试线程的切换，具体的源代码在ceval.c::PyEval_EvalFrameEx。\n第五：垃圾回收，这个可能是所有具有垃圾回收的编程语言的通病。python采用标记和分代的垃圾回收策略，每次垃圾回收的时候都会中断正在执行的程序，造成所谓的顿卡。infoq上有一篇文章，提到禁用Python的GC机制后，Instagram性能提升了10%。感兴趣的读者可以去细读。\n","slug":"WhatWeNeedToLearnLater/为什么Python的运行效率低","date":"2023-03-07T17:01:51.932Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"代码工程结构规范工程模块xxx为工程名称\n\nxxx-api\n\n此模块最终打包jar，仅提供模型定义和接口定义等需要对二方提供的定义内容，不包含任何实现。二方系统依赖本模块，不应当对其造成任何影响。\n\nxxx-client/fatclient\n\n此模块最终打包jar，是对二方提供的富客户端，包含了特定功能的具体实现。富客户端可以依赖稳定的中间件，对特殊业务场景需要引入特殊中间件或二方库的，需要单独打包。\n\nxxx-dal\n\n提供数据访问的实现，如TDDL、LIndorm或其它存储。\n\nxxx-base\n\n工程内公共逻辑的实现，如通用的Utils和服务等。\n\nxxx-service\n\n各个业务场景的具体实现。\n\nxxx-task\n\n异步链路的实现，如MQ和DTS等。\n\nxxx-start\n\n工程启动代码。\n模块依赖\nxxx-api\n\n对外发布，除common等公共的依赖外，api包不能引入任何依赖。\n\nxxx-client/fatclient\n\n对外发布，仅依赖api和稳定的中间件。\n\nxxx-dal\n\n严禁对外发布，依赖数据层的相关中间件，如tddl等\n\nxxx-base\n\n严禁对外发布，依赖api和dal，同时可以引入必要的二方和三方依赖\n\nxxx-service\n\n严禁对外发布，依赖basei，同时可以引入必要的二方和三方依赖\n\nxxx-task\n\n严禁对外发布，依赖base，依赖相关中间件如MQ和DTS等，同时可以引入必要的二方和三方依赖。\n\nxxx-start\n\n严禁对外发布，工程启动代码。\n代码包命名和组织规范\napi\n\n公共部分统一放在common下；\n以具体功能作为划分依据，同一个功能需要在同一个包下，每个包下，按需设置model、param、enums等子包，分别用于定义DTO等模型、参数和枚举常量等\n例如：\nxxx-api\n - common\n​    - model\n​    - param\n​    - enums\n​    - errorcodes\n​    - constants\n - &lt;xx功能&gt;\n​    - model\n​    - param\n​    - enums\n​    xxxxService\n\nservice\n\n与api对应，提供对应的实现\n\ntask\n\n异步链路的具体处理逻辑，统一放到handler或process包，按功能区分不同子包。\nMQ消费者统一定义在mq包，DTS的处理器，统一定义在dts下。\n框架层代码，统一放在除上述包外的独立包中。\n例如：\nxxx-task\n - process\n​    - &lt;xx功能&gt;\n​       XXXMqHandler\n​       XXXDtsHandler\n - mq\n​    XXXConsumer\n​    XXXConsumer\n - dts\n​    XXXProcessor\n","slug":"WhatWeNeedToLearnLater/代码工程结构规范","date":"2023-03-07T17:01:51.930Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"WhatWeNeedToLearnLater/出现问题收录","date":"2023-03-07T17:01:51.927Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"切片：SpringAOP\n请不要使用小写加下划线来命名你的变量，使用驼峰规则来命名\n将判断用的等式改为调用.equals()，并且在采用.equals()前使用常量，括号里装填变量即：\n&quot;abc&quot;.equals(var) ;\n&#x2F;&#x2F; 或者使用 .equals(&quot;abc&quot;, var);\n\n的调用方式，来避免当var.equals(“const”)如var == null时可能会出现的error\n防御性编程\n尽量减少代码块的嵌套，把你的代码改简洁，把它们拉平直\n注意代码的简洁度，一个function尽力做到在30行内实现你的需求或者完成一个特定的任务\n将Mapper的操作从循环写入改为批量写入，以此来\n","slug":"WhatWeNeedToLearnLater/如何合理地构建你的Java项目","date":"2023-03-07T17:01:51.914Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"日志规范日志格式通用前缀 class.method LEVEL | KEY | SUB_KEY | param1=x;param2=x;… | rs=JSON | traceId=xxx[ | 其它自定义日志]\nKEY：标示业务领域，如“领券”\nSUBKEY：标示业务领域中具体的逻辑，如“策略决策”、“权益决策”、“调用UMP”等\nLEVEL：DEBUG/TRACE/MONITOR/WARN\n要求：\n查找日志时，再一次查询中可以顺利通过一个或多个关键字的组合，找到一条完整的业务处理链路。\n如通过一个userId和KEY，可以完整的找到这个用户的领券全过程。\n调试日志仅在调试阶段需要输出，线上一般不输出。\n日志可以包括每次请求的详细出入参等信息。\n线上必须有开关可以控制这类日志的打印。\nlevel=DEBUG\n普通日志用户追踪必要的代码执行记录，线上一般打印出来，大促时可以降级。\n日志可以包括每次外部请求的详细出入参，以及内部请求的关键参数。\n请求出入参较长时，可考虑只打印关键参数。\nlevel=TRACE\n业务指标项日志记录必要的业务活动，通过sls或sunfire产出业务大盘\nlevel=MONITOR\n监控报警项日志通过sunfire产出报警\nlevel=WARN\n自定义日志不做格式要求，自行打印，注意避免过量日志造成线上磁盘资源紧张\n","slug":"WhatWeNeedToLearnLater/日志规范","date":"2023-03-07T17:01:51.911Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"OriginB站首发！草履虫都能看懂的【傅里叶变换】讲解，清华大学李永乐老师教你如何理解傅里叶变换，辨清美颜和变声原理，！！_哔哩哔哩_bilibili\n\n时域、频域：06:44\n傅里叶级数公式表达：10:46\n关于欧拉公式：虚数与复数与欧拉公式 - 知乎 (zhihu.com)\n\n快速傅里叶：快速傅里叶变换(FFT)是什么？FFT深入理解_哔哩哔哩_bilibili\n傅里叶变换/连续傅里叶变换利用傅里叶进行图像处理傅里叶级数\n\n\n\n\n\n\n\n\n任何一个周期性的函数f(t)，都可以进行变换为一系列正余弦函数的和\n\n\n\n\n\n\n\n\n\n同思路：用标准正交基表示坐标系内的任意坐标\n","slug":"Technical Artist/FourierTransform","date":"2023-03-07T17:01:51.905Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"(11 封私信 / 80 条消息) 当面试被问到详述一下OpenGL的渲染管线时，什么答案是面试官想听到的？ - 知乎 (zhihu.com)\n「黑丝」的材质如何用 shader 实现？数学模型是怎样的？ - 知乎 (zhihu.com)\nAll-frequency rendering of dynamic, spatially-varying reflectance (jiapingwang.com)\n","slug":"Technical Artist/Untitled","date":"2023-03-07T17:01:51.902Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"网页监管工具——uptimebotLink：\n\nUptimeRobot: Free Website Monitoring Service\n\n","slug":"Softwares/uptimerobot","date":"2023-03-07T17:01:51.896Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"GENERALStandard Naming Conventions - JAVA:Details:The below list outlines the standard Java naming conventions for each identifier type:\n\nPackages: \nNames should be in lowercase. With small projects that only have a few packages it’s okay to just give them simple (but meaningful!) names:\npackage pokeranalyzer package mycalculator \n\nIn software companies and large projects where the packages might be imported into other classes, the names will normally be subdivided. Typically this will start with the company domain before being split into layers or features:\npackage com.mycompany.utilities package org.bobscompany.application.userinterface \nClasses:\nNames should be in CamelCase. Try to use nouns because a class is normally representing something in the real world:\nclass Customer class Account \nInterfaces:\nNames should be in CamelCase. They tend to have a name that describes an operation that a class can do:\ninterface Comparable interface Enumerable \n\nNote that some programmers like to distinguish interfaces by beginning the name with an “I”:\ninterface IComparable interface IEnumerable \nMethods: \nNames should be in mixed case. Use verbs to describe what the method does:\nvoid calculateTax() string getSurname() \nVariables: \nNames should be in mixed case. The names should represent what the value of the variable represents:\nstring firstName int orderNumber \n\nOnly use very short names when the variables are short-lived, such as in for loops:\nfor (int i&#x3D;0; i&lt;20;i++) &#123;   &#x2F;&#x2F;i only lives in here &#125; \nConstants: \nNames should be in uppercase.\nstatic final int DEFAULT_WIDTH static final int MAX_HEIGHT \n\nReference in this part:\nUsing Java Naming Conventions (thoughtco.com)\n\n\nStandard Naming Conventions - PYTHON","slug":"Language Learning/NAMING CONVENTIONS","date":"2023-03-07T17:01:51.882Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"关键词：yeild关键字，yeild return，生成器函数，协程\nYeild in JSyield - JavaScript | MDN (mozilla.org)\nfunction* - JavaScript | MDN (mozilla.org)\n简单地说，Yeild可以在JS中暂停一个生成器函数，当我们再次呼叫这个生成器函数示例时，我们就可以该示例相关的一次结果\nfunction* foo(index) &#123;\n  while (index &lt; 5) &#123;\n    yield index;\n    index++;\n  &#125;\n&#125;\n\nconst iterator &#x3D; foo(0);\n\nconsole.log(iterator.next().value);\n&#x2F;&#x2F; Expected output: 0\n\nconsole.log(iterator.next().value);\n&#x2F;&#x2F; Expected output: 1\n\nconsole.log(iterator.next().value); &#x2F;&#x2F; 2\nconsole.log(iterator.next().value); &#x2F;&#x2F; 3\nconsole.log(iterator.next().value); &#x2F;&#x2F; 4\nconsole.log(iterator.next().value); &#x2F;&#x2F; undefined\n\nYeild in Python如何理解Python中的yield用法? - 知乎 (zhihu.com)\n事实上，Python中的yield与JS中的yield十分相近：同样是对规则的定义、会暂停执行函数，返回generator对象等等。\n不同的是，Python不需要使用类似function*这样的单独的定义字符。\n不过，在Python中我们可以直接使用for等方法来直接遍历整个生成器对象来快速获得全部的结果。\ndef fab(max): \n    n, a, b &#x3D; 0, 0, 1 \n    while n &lt; max: \n        yield b      # 使用 yield\n        # print b \n        a, b &#x3D; b, a + b \n        n &#x3D; n + 1\n \nfor n in fab(5): \n    print n\n\n\n\n\n\n\n\n\n\n\n生成器就是一个使用了yield关键字的函数，此函数可返回生成器对象\n对了，我们在Python中还可以使用send方法来在实时调用中给生成器函数传入我们需要的值：\nimport time\n\ndef fib(n):\n    index &#x3D; 0\n    a &#x3D; 0\n    b &#x3D; 1\n\n    while index &lt; n:\n        sleep &#x3D; yield b\n        print(&#39;等待%s秒&#39; %sleep)\n        time.sleep(sleep)\n        a,b &#x3D; b, a+b\n        index +&#x3D; 1\n\nfib &#x3D; fib(20)\nprint(fib.send(None))   # 效果等同于print(next(fib))\nprint(fib.send(2))\nprint(fib.send(3))\nprint(fib.send(4))\n\n# -----output:-----\n# \n\n\n\n~更多示例：Python 中 yield 的用法理解 与 send() 函数对生成器赋值_怎样才能回到过去的博客-CSDN博客 ~\ndef test():\n    print(&quot;--------Test starting------&quot;)\n    while True:\n        print(&quot;Stop here, position NO.0&quot;)\n        a &#x3D; &quot;a is unassigned!!!&quot;\n        print(a)\n        print(&quot;Stop here, position NO.1&quot;)\n        a &#x3D; yield &quot;--------Test over----------\\n&quot;\n        print(a)\n        print(&quot;Stop here, position NO.2&quot;)\n\n\nt &#x3D; test()\nprint(&quot;*&quot; * 20 + &quot;Next 1 Start&quot; + &quot;*&quot; * 20 + &quot;\\n&quot;)\nprint(next(t))\nprint(&quot;*&quot; * 20 + &quot;Next 2 Start&quot; + &quot;*&quot; * 20 + &quot;\\n&quot;)\nprint(next(t))\nprint(&quot;*&quot; * 20 + &quot;Next 3 Start&quot; + &quot;*&quot; * 20 + &quot;\\n&quot;)\nprint(t.send(&quot;a is assigned!&quot;))\n\n# ********************Next 1 Start********************\n# \n# --------Test starting------\n# Stop here, position NO.0\n# a is unassigned!!!\n# Stop here, position NO.1\n# --------Test over----------\n# \n# ********************Next 2 Start********************\n# \n# None\n# Stop here, position NO.2\n# Stop here, position NO.0\n# a is unassigned!!!\n# Stop here, position NO.1\n# --------Test over----------\n# \n# ********************Next 3 Start********************\n#\n# a is assigned!\n# Stop here, position NO.2\n# Stop here, position NO.0\n# a is unassigned!!!\n# Stop here, position NO.1\n# --------Test over----------\n#\n\n\n# 规律总结：\n# 1. 生成器函数实例化时，是不会执行的\n# 2. 当调用next函数时，我们的函数才会开始执行，每次执行时只会执行到yeild处一次\n# \t2.1. 初次执行时，函数是从头开始执行，执行到第一个yeild的地方放回yeild后面的值，如果没有外部传值，则yeild本身返回None\n#\t2.2. 后续执行时，函数从上一次yeild中断的地方重新开始执行直到下一个yeild出现（然后在那个地方再次中断）\n# 3. 我们可以通过send向生成器传值，这是JS所没有的\n\n\n\n小拓展深入理解Python 中的 yield from语法 - 知乎 (zhihu.com)\n就Python而言，它还有更多的语法糖：yeild from:\n\n\n\n\n\n\n\n\n\n&gt;使用yield\n\n&gt;# 字符串\n&gt;astr&#x3D;&#39;ABC&#39;\n&gt;# 列表\n&gt;alist&#x3D;[1,2,3]\n&gt;# 字典\n&gt;adict&#x3D;&#123;&quot;name&quot;:&quot;wangbm&quot;,&quot;age&quot;:18&#125;\n&gt;# 生成器\n&gt;agen&#x3D;(i for i in range(4,8))\n\n&gt;def gen(*args, **kw):\n   for item in args:\n       for i in item:\n           yield i\n\n&gt;new_list&#x3D;gen(astr, alist, adict, agen)\n&gt;print(list(new_list))\n&gt;# [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, &#39;name&#39;, &#39;age&#39;, 4, 5, 6, 7]\n&gt;使用yield from\n\n&gt;# 字符串\n&gt;astr&#x3D;&#39;ABC&#39;\n&gt;# 列表\n&gt;alist&#x3D;[1,2,3]\n&gt;# 字典\n&gt;adict&#x3D;&#123;&quot;name&quot;:&quot;wangbm&quot;,&quot;age&quot;:18&#125;\n&gt;# 生成器\n&gt;agen&#x3D;(i for i in range(4,8))\n\n&gt;def gen(*args, **kw):\n   for item in args:\n       yield from item\n\n&gt;new_list&#x3D;gen(astr, alist, adict, agen)\n&gt;print(list(new_list))\n&gt;# [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, &#39;name&#39;, &#39;age&#39;, 4, 5, 6, 7]\nYeild in C# and Unity","slug":"Language Learning/yeild","date":"2023-03-07T17:01:51.878Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"浅谈玄学算法——模拟退火 - M_sea 的博客 - 洛谷博客 (luogu.org)\n","slug":"Algorithm/Simulate Anneal","date":"2023-03-07T17:01:48.164Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Binaries和Source的区别\n二进制（Binaries）文件：即Binary文件/二进制文件：二进制包里面包括了已经经过编译，可以马上运行的程序。你只需要下载和解包（安装）它们以后，就马上可以使用\n源（Source）文件：一般是开源程序，这是程序的源代码文件，需要在你的计算机上进行编译以后才可以产生可以运行程序\n简单区分：\n源代码包里的文件往往会含有种种源代码文件，头文件*.h、c代码源文件*.c、C++代码源文件*.cc/*.cpp等；\n而二进制包里的文件则会有可执行文件（与软件同名的往往是主执行文件），标志是其所在路径含有名为bin的目录（仅有少数例外）。\n\n","slug":"Binaries与Source","date":"2023-03-07T16:55:26.475Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Original Post: Complexity Has to Live Somewhere (ferd.ca)\nChinese Version: \nComplexity Has to Live Somewhere - Google 文档\n架构设计-复杂度是不灭的 - 知乎 (zhihu.com)\nSome Related Posts: 复杂度是不灭的，只会转移，难道一切都是徒劳的吗？ - 知乎 (zhihu.com)\n\n\n\n\n\n\n\n\n\nComplexity has to live somewhere. If you embrace it, give it the place it deserves, design your system and organisation knowing it exists, and focus on adapting, it might just become a strength.\n\n\n\n\n\n\n\n\n\n很多架构/系统一开始是简单的，这一点都没错，因为他们开始只处理简单问题，只处理几个点，这是正确的。随着系统的不断升级迭代，他们开始把复杂的事情往简单里入侵，于是系统边界开始变得模糊不清，最后崩塌。\n千里之堤毁于蚁穴。\n\n\n\n\n\n\n\n\n\n\nif you make the build tool simple, it won’t handle all the weird edge cases that exist out there\nif you want to handle the weird edge cases, you need to deviate from whatever norm you wanted to establish\nif you want ease of use for common defaults, the rules for common defaults must be shared between the tool and the users, who shape their systems to fit the tool’s expectations\nif you allow configuration or scripting, you give the users a way to specify the rules that must be shared, so the tool fits their systems\nif you want to keep the tool simple, you have to force your users to only play within the parameters that fit this simplicity\nif your users’ use cases don’t map well to your simplicity, they will build shims around your tool to attain their objectives\n\n所以怎么解决复杂？要把复杂交给谁？\n是希望用户自定义？还是一站式打包，全部总揽？是只针对小问题破局？还是囊括一切？\n层层交叉，复杂自然分散。但是这些分散的复杂是否都经过了稳妥的处理？它们是不是被随意地丢弃在各个角落？\n最后：复杂度不会解决，但你所能做的一切都可以促成一个更完善的垃圾堆放处的实现\n","slug":"Complexity Has to Live Somewhere","date":"2023-03-07T16:55:26.468Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Remote Procedure Call (RPC)What is Remote Procedure Call (RPC)?Remote Procedure Call is a software communication protocol that one program can use to request a service from a program located in another computer on a network without having to understand the network’s details. RPC is used to call other processes on the remote systems like a local system. A procedure call is also sometimes known as a function call or a subroutine call.\nRPC uses the client-server model. The requesting program is a client, and the service-providing program is the server. Like a local procedure call, an RPC is a synchronous operation requiring the requesting program to be suspended until the results of the remote procedure are returned. However, the use of lightweight processes or threads that share the same address space enables multiple RPCs to be performed concurrently.\nThe interface definition language (IDL) – the specification language used to describe a software component’s application programming interface (API) – is commonly used in Remote Procedure Call software. In this case, IDL provides a bridge between the machines at either end of the link that may be using different operating systems (OSes) and computer languages.\nWhat does RPC do?When program statements that use the RPC framework are compiled into an executable program, a stub is included in the compiled code that acts as the representative of the remote procedure code. When the program is run and the procedure call is issued, the stub receives the request and forwards it to a client runtime program in the local computer. The first time the client stub is invoked, it contacts a name server to determine the transport address where the server resides.\nThe client runtime program has the knowledge of how to address the remote computer and server application and sends the message across the network that requests the remote procedure. Similarly, the server includes a runtime program and stub that interface with the remote procedure itself. Response-request protocols are returned the same way.\nHow does RPC work?When a remote procedure call is invoked, the calling environment is suspended, the procedure parameters are transferred across the network to the environment where the procedure is to execute, and the procedure is then executed in that environment.\nWhen the procedure finishes, the results are transferred back to the calling environment, where execution resumes as if returning from a regular procedure call.\nDuring an RPC, the following steps take place:\n\nThe client calls the client stub. The call is a local procedure call with parameters pushed onto the stack in the normal way.\nThe client stub packs the procedure parameters into a message and makes a system call to send the message. The packing of the procedure parameters is called marshalling.\nThe client’s local OS sends the message from the client machine to the remote server machine.\nThe server OS passes the incoming packets to the server stub.\nThe server stub unpacks the parameters – called unmarshalling – from the message.\nWhen the server procedure is finished, it returns to the server stub, which marshals the return values into a message. The server stub then hands the message to the transport layer.\nThe transport layer sends the resulting message back to the client transport layer, which hands the message back to the client stub.\nThe client stub unmarshalls the return parameters, and execution returns to the caller.\n\nTypes of RPCThere are several RPC models and distributed computing implementations. A popular model and implementation is the Open Software Foundation’s (OSF) Distributed Computing Environment (DCE). The Institute of Electrical and Electronics Engineers (IEEE) defines RPC in its ISO Remote Procedure Call Specification, ISO/IEC CD 11578 N6561, ISO/IEC, November 1991.\nExamples of RPC configurations include the following:\n\nThe normal method of operation where the client makes a call and doesn’t continue until the server returns the reply.\nThe client makes a call and continues with its own processing. The server doesn’t reply.\nA facility for sending several client nonblocking calls in one batch.\nRPC clients have a broadcast facility, i.e., they can send messages to many servers and then receive all the resulting replies.\nThe client makes a nonblocking client/server call; the server signals the call is completed by calling a procedure associated with the client.\n\nRPC spans the transport layer and the application layer in the Open Systems Interconnection (OSI) model of network communication. RPC makes it easier to develop an application that includes multiple programs distributed in a network. Alternative methods for client-server communication include message queueing and IBM’s Advanced Program-to-Program Communication (APPC).\nPros and cons of RPCThough it boasts a wide range of benefits, there are certainly a share of pitfalls that those who use RPC should be aware of.\nHere are some of the advantages RPC provides for developers and application managers:\n\nHelps clients communicate with servers via the traditional use of procedure calls in high-level languages.\nCan be used in a distributed environment, as well as the local environment.\nSupports process-oriented and thread-oriented models.\nHides the internal message-passing mechanism from the user.\nRequires only minimal effort to rewrite and redevelop the code.\nProvides abstraction, i.e., the message-passing nature of network communication is hidden from the user.\nOmits many of the protocol layers to improve performance.\n\nOn the other hand, some of the disadvantages of RPC include the following:\n\nThe client and server use different execution environments for their respective routines, and the use of resources (e.g., files) is also more complex. Consequently, RPC systems aren’t always suited for transferring large amounts of data.\nRPC is highly vulnerable to failure because it involves a communication system, another machine and another process.\nThere is no uniform standard for RPC; it can be implemented in a variety of ways.\nRPC is only interaction-based, and as such, it doesn’t offer any flexibility when it comes to hardware architecture.\n\nWhat Is Remote Procedure Call (RPC)? Definition from SearchAppArchitecture (techtarget.com)\nRPC是什么，看完你就知道了 - 知乎 (zhihu.com)\n","slug":"RPC framework","date":"2023-03-07T16:55:23.699Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"示例：\nxlwings - Make Excel Fly! — xlwings dev documentation\n用Github Page快速创建项目文档网站 - 知乎 (zhihu.com)\nYour awesome title · Write an awesome description for your new site here (rundocs.github.io)\n","slug":"为你的github项目新建一个doc页面","date":"2023-03-07T16:55:23.696Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"加密方法分类加密方法可以分为两大类。一类是单钥加密（private key cryptography），还有一类叫做双钥加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。\n历史上，人类传统的加密方法都是前一种，比如二战期间德军用的Enigma电报密码。莫尔斯电码也可以看作是一种私钥加密方法。\n单钥加密在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。\n双钥加密在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。\n双钥加密的原理如下：\na) 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。\nb) 所有的（公钥, 私钥）对都是不同的。\nc) 用公钥可以解开私钥加密的信息，反之亦成立。\nd) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。\n在双钥体系中，公钥用来加密信息，私钥用来数字签名。\n现状目前，通用的单钥加密算法为DES（Data Encryption Standard），通用的双钥加密算法为RSA（ Rivest-Shamir-Adleman），都产生于上个世纪70年代。\n因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。目前，世界上最主要的数字服务认证商是位于美国加州的Verisign公司，它的主要业务就是分发RSA数字证书。\n拓展\n数字签名？数字签名是什么？ - 阮一峰的网络日志 (ruanyifeng.com)\n\n\nReference\n密码学笔记 - 阮一峰的网络日志 (ruanyifeng.com)\n\n","slug":"密码学初步","date":"2023-03-07T16:55:23.695Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"线程、进程、协程、与CPU多核一、进程、线程、协程的概念进程：\n是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。\n线程：\n是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。\n协程：\n是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。\n二、进程和线程的区别地址空间：\n线程共享本进程的地址空间，而进程之间是独立的地址空间。\n资源：\n线程共享本进程的资源如内存、I/O、cpu等，不利于资源的管理和保护，而进程之间的资源是独立的，能很好的进行资源管理和保护。\n健壮性：\n多进程要比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。\n执行过程：\n每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口，执行开销大。\n但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，执行开销小。\n可并发性：\n两者均可并发执行。\n切换时：\n进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。\n其他：\n线程是处理器调度的基本单位，但是进程不是。\n三、协程和线程的区别协程避免了无意义的调度，由此可以提高性能，但程序员必须自己承担调度的责任。同时，协程也失去了标准线程使用多CPU的能力。\n线程\n相对独立\n有自己的上下文\n切换受系统控制；\n协程\n相对独立\n有自己的上下文\n切换由自己控制，由当前协程切换到其他协程由当前协程来控制。\n四、何时使用多进程，何时使用多线程？对资源的管理和保护要求高，不限制开销和效率时，使用多进程。\n要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。\n五、为什么会有线程？每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。\n六、*python多线程的问题（面试问题）存在问题：\npython由于历史遗留的问题，严格说多个线程并不会同时执行（没法有效利用多核处理器，python的并发只是在交替执行不同的代码）。\n多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。所以python的多线程并发并不能充分利用多核，并发没有java的并发严格。\n原因：\n原因就在于GIL ，在Cpython 解释器（Python语言的主流解释器）中，有一把全局解释锁（GIL, Global Interpreter Lock），在解释器解释执行Python 代码时，任何Python线程执行前，都先要得到这把GIL锁。\n这个GIL全局锁实际上把所有线程的执行代码都给上了锁。\n这意味着，python在任何时候，只可能有一个线程在执行代码。\n其它线程要想获得CPU执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。\n多个线程一起执行反而更加慢的原因：\n同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核CPU，也没办法让多个线程「并行」地同时执行代码，只能是交替执行，因为多线程涉及到上线文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。\n什么时候GIL 被释放？\n当一个线程遇到I/O 任务时，将释放GIL。\n计算密集型（CPU-bound）线程执行100次解释器的计步（ticks）时（计步可粗略看作Python 虚拟机的指令），也会释放GIL。\n即，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。\n不过，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。\n本条参考博客：\nhttp://www.sohu.com/a/230407177_99992472\n七、*进程通信方式（选读）管道：\n速度慢，容量有限，只有父子进程能通讯\nFIFO：\n任何进程间都能通讯，但速度慢\n消息队列：\n容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题\n信号量：\n不能传递复杂消息，只能用来同步\n共享内存区：\n能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存\n本条参考博客：\nhttps://blog.csdn.net/weixin_40283480/article/details/82155704\nCPU线程 和 Java线程​    \nCPU线程 和 Java线程 - webglcn - 博客园 (cnblogs.com)\n进程、线程和CPU 之间的关系（一）_nandao158的博客-CSDN博客_线程和cpu\n   进程是程序运行资源分配的最小单位 。进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、 磁盘 IO 等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程 之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次 运行活动,进程是系统进行资源分配和调度的一个独立单位。 进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一 个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进 程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就 是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。\n\n   线程是 CPU 调度的最小单位,必须依赖于进程而存在 线程是进程的一个实体,是 CPU 调度和分派的基本单位,它是比进程更小的、 能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中 必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其 他的线程共享进程所拥有的全部资源。 线程无处不在 任何一个程序都必须要创建线程,特别是 Java 不管任何程序都必须启动一个 main 函数的主线程; Java Web 开发里面的定时任务、定时器、JSP 和 Servlet、异 步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都 离不开线程和并发的知识。\n\n(2) Java多线程并不是由于cpu线程数为多个才称为多线程，当Java线程数大于cpu线程数，操作系统使用时间片机制，采用线程调度算法，频繁的进行线程切换。\n(10 封私信 / 81 条消息) CPU 的线程与操作系统的线程有何关系？ - 知乎 (zhihu.com)\n","slug":"线程进程协程与CPU","date":"2023-03-07T16:55:23.692Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"拒绝服务攻击拒绝服务（DoS）：DoS是 Denial of service的简称，即拒绝服务，任何对服务的干涉，使得其可用性降低或者失去可用性均称为拒绝服务。例如一个计算机系统崩溃或其带宽耗尽或其硬盘被填满，导致其\nDDoSCross—Site Request Forgery - 跨站点请求伪造 - CSRF什么是CSRF攻击？如何防御CRSF攻击？ - 知乎 (zhihu.com)\nCSRF攻击攻击原理及过程如下：\n\n用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\n网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。CSRF攻击实例\n\nCross Site Scripting - 跨站脚本攻击 - XSS跨站点请求伪造\nXSS可以插在哪里？\n用户输入作为script标签内容\n用户输入作为HTML注释内容\n用户输入作为HTML标签的属性名\n用户输入作为HTML标签的属性值\n用户输入作为HTML标签的名字\n直接插入到CSS里\n\n直接办法：不要引入任何不可信的第三方JavaScript到页面里！\nReference:\nXSS(跨站脚本攻击)详解 - 墨鱼菜鸡 - 博客园 (cnblogs.com)\n\n\n注入攻击","slug":"网络攻击","date":"2023-03-07T16:55:23.690Z","categories_index":"","tags_index":"","author_index":"JBR_Bunjie"},{"id":"d0f573d5ece004aa9f60d986d26310d5","title":"WSA Install third-party apps!","content":"# 第 0 步：确保已正确将 adb 命令加入到系统的环境变量\n# 执行下面的命令能看到 adb 版本号则表示 ok\n# 如有错误，请检查环境变量是否配置正确\nadb version\n\n# 第 1 步：连接 WSA\nadb connect 127.0.0.1:58526\n# 其中 127.0.0.1:58526 是刚才在 WSA 设置项中看到的 IP\n\n# 第 2 步：安装 APK\n# 连接成功之后，就能用下面命令来安装 APK 了\nadb install &#123;你的APK文件完整路径&#125;\n# 注意 .apk 的路径最好无中文且无空格，否则需要用英文双引号包裹。\n# 你可在资源管理器上右键点击 apk 文件选「复制文件地址」获取完整路径\nadb install d:\\download\\apk\\weixin.apk\n#下面是例子：\nadb install &quot;d:\\下载\\异次元 iPlaySoft.com\\qq.apk&quot;\n\n# 最后按下回车即可安装\n# 安装完成后，在 Windows 开始菜单的“所有应用”里就能找到你安装的 Android 应用\n\n","slug":"Softwares/Windows/WSA install third party apk","date":"2022-12-23T04:23:24.000Z","categories_index":"Delopy and Installation","tags_index":"Installation,Windows,WSA,Android","author_index":"JBR_Bunjie"},{"id":"2e7a3ae4090ee29ca9a2e76805bad9b3","title":"CRC Algorithm","content":"\n\n\n\n\n\n\n\n\n那简而言之就是 取首位 异或(首位为0 除数为0) 左移 上述三个步骤循环呗 当左移后余数长度小于被除数时则取余 也可以这么理解吧 当余数开头出现n个0的时候就可以全部消掉直到首位是1 商补上n-1个0和一个1就可以了 继续异或运算嘛 我是看到有好几题余数开头俩0的 分析看看\n模2除法(CRC校验码计算)鉴于网上的讲解自己好不容易才看懂…所以整理了一下, 也方便大家能够理解\n模2加减法模2除法需要用到模2加减法,关于模2加减法,其实就是异或操作,规则如下:\n&#x2F;&#x2F;不需要考虑进位和借位\n0 ± 0 &#x3D; 0\n1 ± 1 &#x3D; 0\n0 ± 1 &#x3D; 1\n1 ± 0 &#x3D; 1\n例: 1101 ± 1001 &#x3D; 0100\n计算如下:\n\t\t  1 1 0 1 \n\t\t± 1 0 0 1 \n\t\t-----------\n\t\t  0 1 0 0\n1234\n\n简记:同为0,异为1\n\n模2除法:规则:假设被除数X,和除数P,余数R\n\nX除以P(对X和P做模2加减法),当前X首位为1时,商1,为0时商0\n\n所得余数R去除首位(即左移一位):\n\n\n\n\n\n\n\n\n\n若R第一位为0,将其作为新的被除数,除以0,此时其首位为0,商即为0若R第一位为1,将其作为新的被除数,除以P,此时其首位为1,商即为1\n\n重复第2步直到R位数少于P位数\n\n\n\n例:1111000对除数1101做模2除法:先说结果: 商1011余111整体运算      1 0 1 1     &#x2F;&#x2F;商\n---------------\n1 1 1 1 0 0 0     &#x2F;&#x2F;被除数,注意首位为1\n1 1 0 1\t          &#x2F;&#x2F;被除数首位为1,除以除数\n---------------\n  0 1 0 0 0 0     &#x2F;&#x2F;余数去除首位,作为新的被除数\n  0 0 0 0         &#x2F;&#x2F;被除数首位为0,除以0\n---------------\n    1 0 0 0 0     &#x2F;&#x2F;余数去除首位,作为新的被除数\n    1 1 0 1       &#x2F;&#x2F;被除数首位为1,除以除数  \n---------------\n      1 0 1 0     &#x2F;&#x2F;余数去除首位,作为新的被除数\n      1 1 0 1     &#x2F;&#x2F;被除数首位为1,除以除数\n---------------\n        1 1 1     &#x2F;&#x2F;余数,此时余数位数少于除数,不能继续除了\n123456789101112131415\n\n分步分析第一步(每一步其实都是模2加减法运算):      1         &#x2F;&#x2F;商\n-------------\n1 1 1 1 0 0 0   &#x2F;&#x2F;被除数,注意首位为1\n1 1 0 1\t        &#x2F;&#x2F;除数\n-------------\n0 0 1 0 0 0 0   &#x2F;&#x2F;余数,模2运算后结果\n123456\n\n\n\n\n\n\n\n\n\n\n商的第一位:被除数首位为1,商为1(只要被除数首位非0,商就是1)\n第二步:余数去除首位(左移一位),当第一位为0时,除以0;为1时,除以除数。      1 0        &#x2F;&#x2F;商\n---------------\n  0 1 0 0 0 0    &#x2F;&#x2F;余数去除首位,作为新的被除数\n  0 0 0 0        &#x2F;&#x2F;被除数首位为0,除以0\n---------------\n  0 1 0 0 0 0    &#x2F;&#x2F;余数,模2运算后结果\n123456\n\n\n\n\n\n\n\n\n\n\n商的第二位:被除数首位为0,商为0(只要被除数首位是0商就是0)\n第三步      1 0 1      &#x2F;&#x2F;商\n----------------\n    1 0 0 0 0    &#x2F;&#x2F;余数去除首位,作为新的被除数\n    1 1 0 1      &#x2F;&#x2F;被除数首位为1,除以除数\n----------------\n    0 1 0 1 0    &#x2F;&#x2F;余数,模2运算后结果\n123456\n\n\n\n\n\n\n\n\n\n\n商的第三位:被除数首位为1,商为1\n第四步      1 0 1 1     &#x2F;&#x2F;商\n----------------\n      1 0 1 0     &#x2F;&#x2F;余数去除首位,作为新的被除数\n      1 1 0 1     &#x2F;&#x2F;被除数首位为1,除以除数\n----------------\n      0 1 1 1     &#x2F;&#x2F;余数,此时余数位数(这里的0要忽略掉,不参与下一轮,因为最上面的被除数后面\n      \t\t\t  &#x2F;&#x2F;没有数可以给这里往后补一位了)少于除数位数,不能继续除了\n1234567\n\n\n\n\n\n\n\n\n\n\n商的第四位:被除数首位为1,商为1此时不能继续做除法,计算结束\n得到最终结果: 商1011余111\n前言\nCRC算法简介\nCRC计算\nCRC校验\nCRC计算的C语言实现\nCRC计算工具\n总结\n\n前言最近的工作中，要实现对通信数据的CRC计算，所以花了两天的时间好好研究了一下，周末有时间整理了一下笔记。\n一个完整的数据帧通常由以下部分构成：\n\n校验位是为了保证数据在传输过程中的完整性，采用一种指定的算法对原始数据进行计算，得出的一个校验值。接收方接收到数据时，采用同样的校验算法对原始数据进行计算，如果计算结果和接收到的校验值一致，说明数据校验正确，这一帧数据可以使用，如果不一致，说明传输过程中出现了差错，这一帧数据丢弃，请求重发。\n常用的校验算法有奇偶校验、校验和、CRC，还有LRC、BCC等不常用的校验算法。\n以串口通讯中的奇校验为例，如果数据中1的个数为奇数，则奇校验位0，否则为1。\n例如原始数据为：0001 0011，数据中1的个数（或各位相加）为3，所以奇校验位为0。这种校验方法很简单，但这种校验方法有很大的误码率。假设由于传输过程中的干扰，接收端接收到的数据是0010 0011，通过奇校验运算，得到奇校验位的值为0，虽然校验通过，但是数据已经发生了错误。\n\n校验和同理也会有类似的错误：\n\n一个好的校验校验方法，配合数字信号编码方式，如(差分)曼彻斯特编码，(不)归零码等对数据进行编码，可大大提高通信的健壮性和稳定性。例如以太网中使用的是CRC-32校验，曼彻斯特编码方式。本篇文章介绍CRC校验的原理和实现方法。\nCRC算法简介\n\n\n\n\n\n\n\n\n循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。\nCRC校验计算速度快，检错能力强，易于用编码器等硬件电路实现。从检错的正确率与速度、成本等方面，都比奇偶校验等校验方式具有优势。因而，CRC 成为计算机信息通信领域最为普遍的校验方式。常见应用有以太网/USB通信，压缩解压，视频编码，图像存储，磁盘读写等。\nCRC参数模型不知道你是否遇到过这种情况，同样的CRC多项式，调用不同的CRC计算函数，得到的结果却不一样，而且和手算的结果也不一样，这就涉及到CRC的参数模型了。计算一个正确的CRC值，需要知道CRC的参数模型。\n一个完整的CRC参数模型应该包含以下信息：WIDTH，POLY，INIT，REFIN，REFOUT，XOROUT。\n\nNAME：参数模型名称。\nWIDTH：宽度，即生成的CRC数据位宽，如CRC-8，生成的CRC为8位\nPOLY：十六进制多项式，省略最高位1，如 x8 + x2 + x + 1，二进制为1 0000 0111，省略最高位1，转换为十六进制为0x07。\nINIT：CRC初始值，和WIDTH位宽一致。\nREFIN：true或false，在进行计算之前，原始数据是否翻转，如原始数据：0x34 = 0011 0100，如果REFIN为true，进行翻转之后为0010 1100 = 0x2c\nREFOUT：true或false，运算完成之后，得到的CRC值是否进行翻转，如计算得到的CRC值：0x97 = 1001 0111，如果REFOUT为true，进行翻转之后为11101001 = 0xE9。\nXOROUT：计算结果与此参数进行异或运算后得到最终的CRC值，和WIDTH位宽一致。\n\n通常如果只给了一个多项式，其他的没有说明则：INIT=0x00，REFIN=false，REFOUT=false，XOROUT=0x00。\n常用的21个标准CRC参数模型：\n\nCRC校验在电子通信领域非常常用，可以说有通信存在的地方，就有CRC校验：\n\n美信(MAXIM)的芯片DS2401/DS18B20，都是使用的CRC-8/MAXIM模型\nSD卡或MMC使用的是CRC-7/MMC模型\nModbus通信使用的是CRC-16/MODBUS参数模型\nUSB协议中使用的CRC-5/USB和CRC-16/USB模型\nSTM32自带的硬件CRC计算模块使用的是CRC-32模型\n\n至于多项式的选择，初始值和异或值的选择，输入输出是否翻转，这就涉及到一定的编码和数学知识了。感兴趣的朋友，可以了解一下每个CRC模型各个参数的来源。至于每种参数模型的检错能力、重复率，需要专业的数学计算了，不在本文讨论的范畴内。\nCRC计算好了，了解了CRC参数模型知识，下面手算一个CRC值，来了解CRC计算的原理。\n问：原始数据：0x34，使用CRC-8/MAXIN参数模型，求CRC值？\n答：根据CRC参数模型表，得到CRC-8/MAXIN的参数如下：\nPOLY &#x3D; 0x31 &#x3D; 0011 0001(最高位1已经省略)\nINIT &#x3D; 0x00\nXOROUT &#x3D; 0x00\nREFIN &#x3D; TRUE\nREFOUT &#x3D; TRUE\n\n有了上面的参数，这样计算条件才算完整，下面来实际计算：\n0.原始数据 &#x3D; 0x34 &#x3D; 0011 0100，多项式 &#x3D; 0x31 &#x3D; 1 0011 0001\n1.INIT &#x3D; 00，原始数据高8位和初始值进行异或运算保持不变。\n2.REFIN为TRUE，需要先对原始数据进行翻转：0011 0100 &gt; 0010 1100\n3.原始数据左移8位，即后面补8个0：0010 1100 0000 0000\n4.把处理之后的数据和多项式进行模2除法，求得余数：\n原始数据：0010 1100 0000 0000 &#x3D; 10 1100 0000 0000\n多项式：1 0011 0001\n模2除法取余数低8位：1111 1011\n5.与XOROUT进行异或，1111 1011 xor 0000 0000 &#x3D; 1111 1011 \n6.因为REFOUT为TRUE，对结果进行翻转得到最终的CRC-8值：1101 1111 &#x3D; 0xDF\n7.数据+CRC：0011 0100 1101 1111 &#x3D; 34DF，相当于原始数据左移8位+余数。\n\n模2除法求余数：\n\n验证手算结果：\n\n可以看出是一致的，当你手算的结果和工具计算结果不一致时，可以看看INIT，XOROUT，REFINT，REFOUT这些参数是否一致，有1个参数不对，计算出的CRC结果都不一样。\nCRC校验上面通过笔算的方式，讲解了CRC计算的原理，下面来介绍一下如何进行校验。\n按照上面CRC计算的结果，最终的数据帧：0011 0100 1101 1111 = 34DF，前8位0011 0100是原始数据，后8位1101 1111 是 CRC结果。\n接收端的校验有两种方式，一种是和CRC计算一样，在本地把接收到的数据和CRC分离，然后在本地对数据进行CRC运算，得到的CRC值和接收到的CRC进行比较，如果一致，说明数据接收正确，如果不一致，说明数据有错误。\n另一种方法是把整个数据帧进行CRC运算，因为是数据帧相当于把原始数据左移8位，然后加上余数，如果直接对整个数据帧进行CRC运算（除以多项式），那么余数应该为0，如果不为0说明数据出错。\n\n而且，不同位出错，余数也不同，可以证明，余数与出错位数的对应关系只与CRC参数模型有关，而与原始数据无关。\nCRC计算的C语言实现无论是用C还是其他语言，实现方法网上很多，这里我找了一个基于C语言的CRC计算库，里面包含了常用的21个CRC参数模型计算函数，可以直接使用，只有crcLib.c和crcLib.h两个文件。\nGitHub地址：https://github.com/whik/crc-lib-c\n使用方法非常简单：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &quot;crcLib.h&quot;\n\nint main()\n&#123;\n    uint8_t LENGTH &#x3D; 10;\n    uint8_t data[LENGTH];\n    uint8_t crc;\n\n    for(int i &#x3D; 0; i &lt; LENGTH; i++)\n    &#123;\n        data[i] &#x3D; i*5;\n        printf(&quot;%02x &quot;, data[i]);\n    &#125;\n    printf(&quot;\\n&quot;);\n\n    crc &#x3D; crc8_maxim(data, LENGTH);\n\n    printf(&quot;CRC-8&#x2F;MAXIM:%02x\\n&quot;, crc);\n    return 0;\n&#125;\n\n计算结果：\n\nCRC计算工具下面这几款工具都可以自定义CRC算法模型，而且都有标准CRC模型可供选择。如果自己用C语言或者Verilog实现校验算法时，非常适合作为标准答案进行验证。\n\n在线计算：http://www.ip33.com/crc.html\n离线计算工具：CRC_Calc v0.1.exe或者GCRC.exe\n\n格西CRC计算器：\n\n总结CRC校验并不能100%的检查出数据的错误，非常低的概率会出现CRC校验正确但数据中有错误位的情况。这和CRC的位数，多项式的选择等等有很大的关系，所以在实际使用中尽量选择标准CRC参数模型，这些多项式参数都是经过理论计算得出的，可以提高CRC的检错能力。CRC校验可以检错，也可以纠正单一比特的错误，你知道纠错的原理吗？\n参考资料\nhttps://www.cnblogs.com/liushui-sky/p/9962123.html\nhttps://segmentfault.com/a/1190000018094567!\n\n","slug":"Algorithm/CRC、LRC、BCC校验与模二运算","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"CRC","author_index":"JBR_Bunjie"},{"id":"413173748dc9f0bf852352ce35bf92b1","title":"Catalan Number","content":"wikipedia-en: Catalan number - Wikipedia\nwikipedia-cn:卡塔兰数 - 维基百科，自由的百科全书 (wikipedia.org)\n强烈推荐这篇博客：卡特兰(Catalan)数入门详解 - Morning_Glory - 博客园 (cnblogs.com)\n\n\nCatalan Number\n\n\n\n\n\n\n\n\nIn combinatorial mathematics, the Catalan numbers are a sequence of natural numbers that occur in various counting problems, often involving recursively defined objects. They are named after the French-Belgian mathematician Eugène Charles Catalan (1814–1894).\nThe first Catalan numbers for n = 0, 1, 2, 3, … are\n​    1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, … (sequence A000108 in the OEIS).\n意义？\n\n\n\n\n\n\n\n\n卡特兰数是一个在组合数学里经常出现的一个数列，它并没有一个具体的意义，却是一个十分常见的数学规律\n也就是说：只要我们能在实际解决问题的过程中，发现当前问题符合Catalan Number的定义(公式)，就可以直接利用Cantanlan的相关公式来解决\n定义：设h(n)为catalan数的第n项，令h(0)=1,h(1)=1，catalan数满足递推式：\nh(n) = h(0) * h(n-1) + h(1) * h(n-2) + … + h(n-1) * h(0) (n≥2)\n容易计算的推导公式：可以看英文维基的推导过程\nThe nth Catalan number can be expressed directly in terms of binomial coefficients by\n\n\n(公式中的括号表达式请勿用组合的方式来计算)\nAn alternative expression for Cn is\n\n\nusage例题1：题目：2N个人排队买电影票，N个人持5元买票，N个人持10元买票。售票处在售票前只有票没有钱，票价5元，问有多少种排队方式能让2N个人顺利买票，并且输出所有排队队列（不会因为找钱问题）\n题解：设x为当前已购票人群中持五元的人数，设y为当前已购票人群中持十元的人数\n则易知，任何时候都应有x &gt;= y\n将本题转换为坐标系上的问题\n则有：\n\n易知，所有在直线y = x之下的路径都是合法路径，而所有与y = x + 1有交集的路径都是非法路径\n我们所需要做的，只是从所有的可能路径——C(2n, n)中，取出非法路径即可\n将所有经过y = x + 1的非法路径(因为所有路径仍然都是要到达(n,n)的) 对直线y = x + 1进行对称\n此时所有路径都会到达点 (n - 1, n + 1)\n故易知，所有非法路径总数：C(2n, n-1)\n故最终结果为：C(2n, n) - C(2n, n-1)\n由此题我们可以看出Catalan Number类题目的相关特征——使用高度相关的两种数据进行先后排序\n例题2：题目：电影院卖电影票，但是没有零钱找，票价一张 5 元，买票的人为 n 个持有 5 元，m个持 有 10 元，求解出可能的买票序列的个数，使得电影院能够将票卖完。\n测试数据：\n\n\n\n\n\n\n\n\n\n\nn=3, m=3 \n\n  输出：180\n\nn=5, m=3\n\n  输出：20160 \n\nn=100, m=100\n输出：7808493736285054490617457563685000616783524531556170923710322111330291583796072702181230534772124989150269427118016226042154879111313238663979471534186434961519434230403597200370267217266558867539125388517366666256080507202260345081955685568391820824161596607976035333269564672318518060023284166918774048734879105185187102720000000000000000000000000000000000000000000000000\n\n\n解法：和例题一几乎一致，但是具体公式不再能直接套用\n我们仍有相同含义的x(x - n - 5元)与y(y - m - 10元)，但是具体公式开始不同\n其中，所有可能的顺序为：C(m+n, n)\n不合法的路径仍与y = x + 1有关，但是最终的非法内容有：C(m + n, m-1)\n故最终有：C(m + n, n) - C(m + n, m - 1)\n是不是有点疑惑？怎么算出来和结果不一样，好像多除以了(m! * n!)？\n若是将每个人视为相同的人，是无序的话，结果解释上述表达式，但是实际上每个人都不尽相同，为了保证顺序，还需要乘以(m! * n!) (组合方式已定，每组内自由排列)，最终可得到答案(m + n)! * (n - m + 1)/(n + 1)，事实上，上一题也应该作这样子的额外处理才对\n更多典例1. 出栈次序一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?\n2. 01序列给出一个n，要求一个长度为2n的01序列，使得序列的任意前缀中1的个数不少于0的个数， 有多少个不同的01序列?以下为长度为6的序列:111000 101100 101010 110010 110100\n3. ‘+1’ ‘-1’序列\nn个+1和n个-1构成的2n项 a1,a2,⋅⋅⋅,a2na1,a2,⋅⋅⋅,a2n，其部分和满足非负性质，即a1+a2+⋅⋅⋅+ak&gt;=0a1+a2+⋅⋅⋅+ak&gt;=0，(k=1,2,···,2n) ，有多少个不同的此序列?\n4. 括号序列\nn对括号有多少种匹配方式？\n5. 找零问题\n2n个人要买票价为五元的电影票，每人只买一张，但是售票员没有钱找零。其中，n个人持有五元，另外n个人持有十元，问在不发生找零困难的情况下，有多少种排队方法？\n6. 矩阵链乘\nP=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？\n7. 二叉树计数\n有n个节点构成的二叉树（非叶子节点都有2个儿子），共有多少种情形？有n+1个叶子的二叉树的个数？\n8. 凸多边形划分\n在一个n边形中，通过不相交于n边形内部的对角线，把n边形拆分为若干个三角形，问有多少种拆分方案？\n9. 圆上n条线段\n在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线段不相交的方法数？\n10. 单调路径\n一位大城市的律师在他住所以北n个街区和以东n个街区处工作，每天他走2n个街区去上班。如果他从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？\n11. 填充阶梯图形\n用n个长方形填充一个高度为n的阶梯状图形的方法个数？\n12. 摞碗问题\n饭后，姐姐洗碗，妹妹把姐姐洗过的碗一个一个放进碗橱摞成一摞。一共有n个不同的碗，洗前也是摞成一摞的，也许因为小妹贪玩而使碗拿进碗橱不及时，姐姐则把洗过的碗摞在旁边，问：小妹摞起的碗有多少种可能的方式？\n13. 汽车胡同加油问题\n一个汽车队在狭窄的路面上行驶，不得超车，但可以进入一个死胡同去加油，然后再插队行驶，共有n辆汽车，问共有多少种不同的方式使得车队开出城去？\n14. 还书借书问题\n在图书馆一共2n个人在排队，n个还《面试宝典》一书，n个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数\n15. 高矮排队问题\n2n个高矮不同的人,排成两排,每排必须是从矮到高排列,而且第二排比对应的第一排的人高,问排列方式有多少种?\n","slug":"Algorithm/Catalan number","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"String Processing","author_index":"JBR_Bunjie"},{"id":"4bbde60d3dafb255adad1c9293392efa","title":"全排列","content":"Permutations - 全排列顾名思义，就是找出当前元素所有可行的序列\n一个朴素的思想是递归，这种方式简单但并不高效快捷\n以两个示例来进行算法说明：\nExample1: \n\n\n\n\n\n\n\n\n\n实验五     数据输出\n实验准备理解数据输入、输出的技巧。\n实验目的理解算法设计的数学基本思想，理解算法程序化实现的技巧。\n实验过程输出1,2,3,4,5,6这六个元素的所有全排列。\ndef permutations(arr: list, position: int, end: int):\n    if position &#x3D;&#x3D; end:\n        # 完成一次排列，输出结果，返回上层\n        print(arr)\n    else:\n        # 采用递归解决问题\n        for index in range(position, end):\n            # 每进入一次函数，都会在当前位置山建立循环，这个循环会将所有的锁具都和当前数进行一次交换\n            # 由于每单次循环都会将数据列表重置还原，所以不会对下一次交换产生影响导致重复\n            # 故从当前的position开始，与end之前的所有数据交换次序，就可以得到所有内容\n            arr[index], arr[position] &#x3D; arr[position], arr[index]\n            permutations(arr, position + 1, end)\n            arr[index], arr[position] &#x3D; arr[position], arr[index]  # 还原到交换前的状态，为了进行下一次交换\n\npermutations(arr, 0, len(arr))\nprint(&quot;共720条数据&quot;)  # 6*5*4*3*2*1 &#x3D;&#x3D; 720\n\n\n\nExample2: 46. 全排列 - 力扣（LeetCode） (leetcode-cn.com)\nclass Solution:\n    def permute(self, nums: List[int]) -&gt; List[List[int]]:\n        self.result &#x3D; []\n        self.generatation(nums, 0, len(nums))\n        return self.result\n\n    def generatation(self,nums, start, end):\n        if start &#x3D;&#x3D; end:\n            # print(nums)\n            self.result.append([t for t in nums])\n            return\n        \n        for i in range(start, end):\n            nums[i], nums[start] &#x3D; nums[start], nums[i]\n            self.generatation(nums, start+1,end)\n            nums[start], nums[i] &#x3D; nums[i], nums[start]\n\n\n\n1.6 字符串的全排列 | 编程之法：面试和算法心得 (gitbooks.io)\n","slug":"Algorithm/Permutations","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"穷举","author_index":"JBR_Bunjie"},{"id":"d42b57b5bace0bb67392a01a7601ad24","title":"Dijkstra Algorithm","content":"Dijkstra 算法详解概述Dijkstra 算法是求一个图中一个点到其他所有点的最短路径的算法\nDijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 O(n2)\n$$\\begin{align}&amp;(n-1)+(n-2)+···+1\\= &amp;\\frac{n*(n - 1)}{2}\\= &amp;\\frac{n^2}{2} - \\frac{n}{2}\\≈ &amp;n^2\\end{align}$$\n主要行为每次从「未求出最短路径的点」中 取出 距离距离起点 最小路径的点，以这个点为桥梁 刷新「未求出最短路径的点」的距离\n图解案例分析题要以 A 点为顶点，求到其他点的最短路径。\n\n邻接矩阵图\nint[][] graph &#x3D; new int[][]&#123;\n&#123;0 , 2, ∞, 6&#125;\n&#123;2 , 0, 3, 2&#125;\n&#123;∞ , 3, 0, 2&#125;\n&#123;6 , 2, 2, 0&#125;&#125;;\n\n算法过程result：已求出 最小路径的顶点notFound：未求出 最小路径的顶点，里面的值是 到起点的距离每次从 「未求出最短路径的点」中 取出 距离距离起点 最近的点，以这个点为桥梁 刷新「未求出最短路径的点」的距离\n初始，result={A(0)} 中只有起点 A，notFound={B(2),C(∞),D(6)} 中是除了 A 点的其他点，里面的值是到起点的距离（例如 B(2) 代表 B点到起点的距离为 2）\n\n然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 B(2) ，然后通过 B(2) 为桥梁 刷新「未求出最短路径的点」的距离\n取出 最短路径的点：从「未求出最短路径的点」notFound 中取出 最短路径的点 B(2)，放入结果 result 中，结果如下：\n「未求出最短路径点」 notFound={C(∞),D(6)}，「已求出最短路径的点 」result={A(0),B(2)}\n刷新距离：通过 B(2) 为桥梁，刷新距离。\n例如 AD = 6 &lt; AB + BD = 4 以 B(2) 为桥梁的距离更短，就刷新「未求出最短路径点」D(6) 的距离为 D(4)\nnotFound={C(∞),D(4)}\n同理刷新 C(∞) 的距离为 C(5) ，最后结果如下：\n「未求出最短路径点」 notFound={C(5),D(4)} ，「已求出最短路径的点」result=&#123;A(0),B(2)&#125; \n\n然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 D(4) ，然后通过 D(4) 为桥梁 刷新「未求出最短路径的点」的距离\n同理，最后结果如下：\n「未求出最短路径点」 notFound={C(5)} ，「已求出最短路径的点」result={A(0),B(2),D(4)}\n\n然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 C(5) ，算法结束\nresult={A(0),B(2),D(4),C(5)} 就是最终所求的 最短距离\n\n\n代码\n\n这里使用 -1 表无穷大，下面是 Java 代码和测试案例\npublic class Dijkstra &#123;\n    public static int[] dijkstra(int[][] graph,int startVertex)&#123;\n        &#x2F;&#x2F;初始化 以求出最短路径的点 result[]\n        int length &#x3D; graph.length;\n        int[] result &#x3D; new int[length];\n        for (int i &#x3D; 0; i &lt; length; i++) &#123;\n            result[i] &#x3D; -1;\n        &#125;\n        result[startVertex] &#x3D; 0 ;\n        \n        &#x2F;&#x2F; 初始化 未求出最短路径的点 notFound[]\n        int[] notFound &#x3D; new int[length];\n        for (int i &#x3D; 0; i &lt; length; i++) &#123;\n            notFound[i] &#x3D; graph[startVertex][i];\n        &#125;\n        notFound[startVertex] &#x3D; -1;\n        \n        &#x2F;&#x2F; 开始 Dijkstra 算法\n        for (int i &#x3D; 1; i &lt; length; i++) &#123;\n            &#x2F;&#x2F;1. 从「未求出最短路径的点」notFound 中取出 最短路径的点\n            &#x2F;&#x2F;1.1 找到最短距离的点\n            int min &#x3D; Integer.MAX_VALUE;\n            int minIndex &#x3D; 0;\n            for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                if (notFound[j] &gt; 0 &amp;&amp; notFound[j] &lt; min)&#123;\n                    min &#x3D; notFound[j];\n                    minIndex &#x3D; j;\n                &#125;\n            &#125;\n            &#x2F;&#x2F;1.2 将最短距离的点 取出 放入结果中\n            result[minIndex] &#x3D; min;\n            notFound[minIndex] &#x3D; -1;\n            \n            &#x2F;&#x2F;2. 刷新 「未求出最短距离的点」 notFound[] 中的距离\n            &#x2F;&#x2F;2.1 遍历刚刚找到最短距离的点 (B) 的出度 (BA、BB、BC、BD)\n            for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                &#x2F;&#x2F; 出度可通行(例如 BD:graph[1][3]  &gt; 0)\n                &#x2F;&#x2F; 出度点不能已经在结果集 result中(例如 D: result[3] &#x3D;&#x3D; -1)\n                if (graph[minIndex][j] &gt; 0\n                &amp;&amp; result[j] &#x3D;&#x3D; -1)&#123;\n                    int newDistance &#x3D; result[minIndex] + graph[minIndex][j];\n                    &#x2F;&#x2F;通过 B 为桥梁，刷新距离\n                    &#x2F;&#x2F;（比如&#96;AD &#x3D; 6 &lt; AB + BD &#x3D; 4&#96; 就刷新距离）（ -1 代表无限大）\n                    if (newDistance &lt; notFound[j] || notFound[j]&#x3D;&#x3D;-1)&#123;\n                        notFound[j] &#x3D; newDistance;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n    &#x2F;** 测试案例 *&#x2F;\n    public static void main(String[] args) &#123;\n        char[] vertices &#x3D; new char[]&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;&#125;;\n        int[][] graph &#x3D; new int[][]&#123;\n            &#123;0, 2, -1, 6&#125;, \n            &#123;2, 0, 3, 2&#125;, \n            &#123;-1, 3, 0, 2&#125;, \n            &#123;6, 2, 2, 0&#125;\n        &#125;;\n        int[] dijkstra &#x3D; dijkstra(graph, 0);\n        for (int i : dijkstra) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\n测试结果\n0\n2\n5\n4\nDijkstra算法详解 通俗易懂 - 知乎 (zhihu.com)\n另题：\n\n","slug":"Algorithm/Dijkstra","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Shortest Path Algorithm","author_index":"JBR_Bunjie"},{"id":"08152463b75b8ab3478d28a28a35a8b9","title":"中国邮递员问题","content":"The Route of the PostmanReference\nThe Chinese-Postman-Method (tum.de)\n邮递员问题 - 维基百科，自由的百科全书 (wikipedia.org)\n中国邮递员问题 | Junnor.G (cfonheart.github.io)\n\nDetails\n\n\n\n\n\n\n\n\n邮递员问题（也称邮路问题，Route Inspection Problem，或中国邮路问题,China Route Inspection Problem，或中国邮递员问题Chinese Postman Problem）是一个图论问题。此问题为在一个连通的无向图中找到一最短的封闭路径，且此路径需通过所有边至少一次。\n简单来说，邮递员问题就是在一个已知的地区，邮差要设法找到一条最短路径，可以走过此地区所有的街道，且最后要回到出发点。\n一笔画问题 - 维基百科，自由的百科全书 (wikipedia.org)\n问题解决\n\n\n\n\n\n\n\n\n\n图本身就是一个欧拉回路图，那么直接走一个欧拉回路就访问了所有路径并回到了起点\n\n  （欧拉回路图的前提条件是每个点的度数都是偶数）\n\n图不是一个欧拉回路图，需要对某些边重复走多次回到起点，等价于添加了一些已经存在的重边，构建了欧拉回路。\n\n  不是欧拉回路需要通过增加一些边使得图变成一个欧拉回路，并能保证问题的最优解，添加的边权值和一定是尽可能短的。\n\n计算度数为奇数的点\n算出所有点之间的最短路径\n奇度数的点一定为偶数，点与点之间构建二分图，权值为两点之间的最短路，找到一个最小权值匹配集\n对于匹配集，找到每一个匹配集两点之间形成的最短路径，那么这条最短路径就需要加入到额外的边中，且一定能保证这条路径上除了这两个匹配的奇度数点度数加了1变成了偶数，其他所有中间点都是加了2，不影奇偶性。\n所有边都添加好后，就是一个欧拉回路了，计算从起点开始的欧拉回路路径\n\n","slug":"Algorithm/The Chinese Postman Problem","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Shortest Route","author_index":"JBR_Bunjie"},{"id":"9fd0e4d3dba46b1add7af94a3f9b782a","title":"Sugiyama Algorithm","content":"划时代的自动布局算法：sugiyama算法sugiyama algorithm stepsof the framework is to divide the task of drawing a graph into several subproblems, most of which closely resemble other well known problems within computer science. That way one can use algorithms for the similar problems to solve the Sugiyama subproblems and thereby simplify the graph layout process. The different steps of the method are illustrated in figure 2. They are the following: \n\nCycle removal \n\nFirst the possibly cyclic graph must be made acyclic by removing cycles, done by reversing some edges. \n\nLayer assignment \n\nSecond, the vertices are assigned to layers and dummy vertices and dummy edges are introduced for every edge that spans over more than two layers so as to create a proper layering [2], i.e. one where every edge has its endpoints in adjacent layers. \n\nVertex ordering \n\nThird, the vertices are ordered within their layers to minimise edge crossings.\n\nCoordinate assignment \n\nFourth and last, the vertices are assigned coordinates to create a balanced graph.\nsugiyama barycenter算法内容两层间的情况：\nn层间的情况：\n纯python实现：\n\n\n\n\n\n\n\n原论文地址：\nMethods for Visual Understanding of Hierarchical System Structures | IEEE Journals &amp; Magazine | IEEE Xplore\n所实现算法的仓库：\n视频教程：\n(40) Hierarchical Drawings: Sugiyama Framework | Visualization of Graphs - Lecture 8 - YouTube\nMore Resource:\n161388.pdf (chalmers.se)\n","slug":"Algorithm/Sugiyama","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Auto Layout","author_index":"JBR_Bunjie"},{"id":"7dbcf1e35df66bdccacdaed2ecd943d3","title":"利用递归、无循环地打印数组","content":"ReverseOutputWithoutCycle描述：不用循环，不逐一赋值地把一个数组逆序输出\n循环 -&gt; 递归；即用递归去承担原本循环的工作\n即：\nvoid Print(int[] arr, int len) &#123;\n    if (len &gt; 0) &#123;\n        Console.printline(arr[len-1] + &quot;\\n&quot;);\n        Print(arr, len - 1);\n    &#125;\n&#125;\n\n\n\n","slug":"Algorithm/ReverseOutputWithoutCycle","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Recursion","author_index":"JBR_Bunjie"},{"id":"c7cd6315021c2b49c9efb80c79e420a8","title":"大数运算","content":"前言：\n在计算机中数字表示的范围是有限制的，比如我们熟知的 int、float、double 等数据类型所能表示的范围都是有限的，如果我们要对位数达到几十位、几百位、上千位的大整数进行计算，这些数据类型显然不能满足我们的要求，因此我们需要通过算法来实现这些功能。\n1、大数加法\n两个大数我们可以用数组来保存，然后在数组中逐位进行相加，再判断该位相加后是否需要进位，为了方便计算，我们将数字的低位放在数组的前面，高位放在后面。\n下面是两个正的大整数相加算法的C语言参考代码：\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\n#define MAX 1000    &#x2F;&#x2F; 大数的最大位数\n\n\n&#x2F;*\n  大数加法\n  参数：\n  num1为第一个大数，用字符数组保存\n  num2为第二个大数\n  sum数组保存相加的结果  即：num1+num2&#x3D;sum\n  返回值：返回数组sum的有效长度，即计算结果的位数\n *&#x2F;\nint Addition(char num1[], char num2[], int sum[])\n&#123;\n    int i, j, len;\n    int n2[MAX] &#x3D; &#123;0&#125;;\n    int len1 &#x3D; strlen (num1); &#x2F;&#x2F; 计算数组num1的长度，即大数的位数\n    int len2 &#x3D; strlen (num2); &#x2F;&#x2F; 计算数组num2的长度，即大数的位数\n\n    len &#x3D; len1&gt;len2 ? len1 : len2; &#x2F;&#x2F; 获取较大的位数\n    &#x2F;&#x2F;将num1字符数组的数字字符转换为整型数字，且逆向保存在整型数组sum中，即低位在前，高位在后\n    for (i &#x3D; len1-1, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)\n        sum[j] &#x3D; num1[i] - &#39;0&#39;;\n    &#x2F;&#x2F; 转换第二个数\n    for (i &#x3D; len2-1, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)\n        n2[j] &#x3D; num2[i] - &#39;0&#39;;\n    &#x2F;&#x2F; 将两个大数相加\n    for (i &#x3D; 0; i &lt;&#x3D; len; i++)\n    &#123;\n        sum[i] +&#x3D; n2[i];  &#x2F;&#x2F; 两个数从低位开始相加\n        if (sum[i] &gt; 9)   &#x2F;&#x2F; 判断是否有进位\n        &#123;   &#x2F;&#x2F; 进位\n            sum[i] -&#x3D; 10;\n            sum[i+1]++;\n        &#125;\n    &#125;\n    if(sum[len] !&#x3D; 0)  &#x2F;&#x2F; 判断最高位是否有进位\n        len++;\n    return len;   &#x2F;&#x2F; 返回和的位数\n&#125;\n\nint main()\n&#123;\n    int i, len;\n    int sum[MAX] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 存放计算的结果，低位在前，高位在后，即sum[0]是低位\n    char num1[] &#x3D; &quot;1234567891234567891234&quot;; &#x2F;&#x2F; 第一个大数\n    char num2[] &#x3D; &quot;2345678912345678913345&quot;; &#x2F;&#x2F; 第二个大数\n    len &#x3D; Addition(num1, num2, sum);    &#x2F;&#x2F; 两数相加\n    printf(&quot;%s\\n  +\\n%s\\n  &#x3D;\\n&quot;, num1, num2);\n    &#x2F;&#x2F; 反向输出求和结果\n    for (i &#x3D; len-1; i &gt;&#x3D; 0; i--)\n        printf(&quot;%d&quot;, sum[i]);\n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;\n\n\n2、大数减法\n相减算法也是从低位开始减的。先要判断被减数和减数哪一个位数长，若被减数位数长是正常的减法；若减数位数长，则用被减数减去减数，最后还要加上负号；当两数位数长度相等时，最好比较哪一个数字大，否则负号处理会很繁琐；处理每一项时要，如果前一位相减有借位，就先减去上一位的借位，无则不减，再去判断是否能够减开被减数，如果减不开，就要借位后再去减，同时置借位为1，否则置借位为0。\n下面是C语言参考代码：\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\n#define MAX 1000    &#x2F;&#x2F; 大数的最大位数\n\n&#x2F;*\n  大数减法\n  参数：\n  num1为被减数，用字符数组保存\n  num2为减数\n  sum数组保存相减的结果   即：num1-num2&#x3D;sum\n  返回值：返回数组sum的有效长度，即计算结果的位数\n *&#x2F;\nint Subtraction(char num1[], char num2[], int sum[])\n&#123;\n    int i, j, len, blag;\n    char *temp;\n    int n2[MAX] &#x3D; &#123;0&#125;;\n    int len1 &#x3D; strlen(num1); &#x2F;&#x2F; 计算数组num1的长度，即大数的位数\n    int len2 &#x3D; strlen(num2); &#x2F;&#x2F; 计算数组num2的长度，即大数的位数\n\n    &#x2F;&#x2F; 在进行减法之前要进行一些预处理\n    blag &#x3D; 0; &#x2F;&#x2F; 为0表示结果是正整数，为1表示结果是负整数\n    if(len1 &lt; len2) &#x2F;&#x2F; 如果被减数位数小于减数\n    &#123;\n        blag &#x3D; 1; &#x2F;&#x2F; 标记结果为负数\n        &#x2F;&#x2F; 交换两个数，便于计算\n        temp &#x3D; num1;\n        num1 &#x3D; num2;\n        num2 &#x3D; temp;\n        len &#x3D; len1;\n        len1 &#x3D; len2;\n        len2 &#x3D; len;\n    &#125;\n    else if(len1 &#x3D;&#x3D;len2) &#x2F;&#x2F; 如果被减数的位数等于减数的位数\n    &#123;\n        &#x2F;&#x2F; 判断哪个数大\n        for(i &#x3D; 0; i &lt; len1; i++)\n        &#123;\n            if(num1[i] &#x3D;&#x3D; num2[i])\n                continue;\n            if(num1[i] &gt; num2[i])\n            &#123;\n                blag &#x3D; 0; &#x2F;&#x2F; 标记结果为正数\n                break;\n            &#125;\n            else\n            &#123;\n                blag &#x3D; 1; &#x2F;&#x2F; 标记结果为负数\n                &#x2F;&#x2F; 交换两个数，便于计算\n                temp &#x3D; num1;\n                num1 &#x3D; num2;\n                num2 &#x3D; temp;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    len &#x3D; len1&gt;len2 ? len1 : len2; &#x2F;&#x2F; 获取较大的位数\n    &#x2F;&#x2F;将num1字符数组的数字转换为整型数且逆向保存在整型数组sum中，即低位在前，高位在后\n    for (i &#x3D; len1-1, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)\n        sum[j] &#x3D; num1[i] - &#39;0&#39;;\n    &#x2F;&#x2F; 转换第二个数\n    for (i &#x3D; len2-1, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)\n        n2[j] &#x3D; num2[i] - &#39;0&#39;;\n    &#x2F;&#x2F; 将两个大数相减\n    for (i &#x3D; 0; i &lt;&#x3D; len; i++)\n    &#123;\n        sum[i] &#x3D; sum[i] - n2[i]; &#x2F;&#x2F; 两个数从低位开始相减\n        if (sum[i] &lt; 0)   &#x2F;&#x2F; 判断是否有借位\n        &#123;    &#x2F;&#x2F; 借位\n            sum[i] +&#x3D; 10;\n            sum[i+1]--;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 计算结果长度\n    for (i &#x3D; len1-1; i&gt;&#x3D;0 &amp;&amp; sum[i] &#x3D;&#x3D; 0; i--)\n        ;\n    len &#x3D; i+1;\n    if(blag&#x3D;&#x3D;1)\n    &#123;\n        sum[len] &#x3D; -1;  &#x2F;&#x2F; 在高位添加一个-1表示负数\n        len++;\n    &#125;\n    return len;   &#x2F;&#x2F; 返回结果的位数\n&#125;\n\nint main()\n&#123;\n    int i, len;\n    int sum[MAX] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 存放计算的结果，低位在前，高位在后，即sum[0]是低位\n    char num1[] &#x3D; &quot;987654321987654321&quot;; &#x2F;&#x2F; 第一个大数\n    char num2[] &#x3D; &quot;123456789123456789&quot;; &#x2F;&#x2F; 第二个大数\n    len &#x3D; Subtraction(num1, num2, sum);    &#x2F;&#x2F; 两数相减\n    &#x2F;&#x2F; 输出结果\n    printf(&quot;%s\\n  -\\n%s\\n  &#x3D;\\n&quot;, num1, num2);\n    if(sum[i&#x3D;len-1] &lt; 0) &#x2F;&#x2F; 根据高位是否是-1判断是否是负数\n    &#123;\n        printf(&quot;-&quot;); &#x2F;&#x2F; 输出负号\n        i--;\n    &#125;\n    for (; i &gt;&#x3D; 0; i--)\n        printf(&quot;%d&quot;, sum[i]);\n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;\n\n3、大数乘法\n首先说一下乘法计算的算法，从低位向高位乘，在竖式计算中，我们是将乘数第一位与被乘数的每一位相乘，记录结果，之后，用第二位相乘，记录结果并且左移一位，以此类推，直到计算完最后一位，再将各项结果相加，得出最后结果。\n计算的过程基本上和小学生列竖式做乘法相同。为了编程方便，并不急于处理进位，而是将进位问题留待最后统一处理。\n总结一个规律: 即一个数的第i 位和另一个数的第j 位相乘所得的数，一定是要累加到结果的第i+j 位上。这里i, j 都是从右往左，从0 开始数。ans[i+j] = a[i]*b[j];\n另外注意进位时要处理，当前的值加上进位的值再看本位数字是否又有进位；前导清零。\n下面是C语言的两个正大数相乘的参考代码：\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\n#define MAX 1000    &#x2F;&#x2F; 大数的最大位数\n\n\n&#x2F;*\n  大数乘法\n  参数：\n  num1为第一个因数，用字符数组保存\n  num2为第二个因数\n  sum数组保存相乘的结果  即：num1*num2&#x3D;sum\n  返回值：返回数组sum的有效长度，即计算结果的位数\n *&#x2F;\nint Multiplication(char num1[],char num2[], int sum[])\n&#123;\n    int i, j, len, len1, len2;\n    int a[MAX+10] &#x3D; &#123;0&#125;;\n    int b[MAX+10] &#x3D; &#123;0&#125;;\n    int c[MAX*2+10] &#x3D; &#123;0&#125;;\n\n    len1 &#x3D; strlen(num1);\n    for(j &#x3D; 0, i &#x3D; len1-1; i &gt;&#x3D; 0; i--) &#x2F;&#x2F;把数字字符转换为整型数\n        a[j++] &#x3D; num1[i]-&#39;0&#39;;\n    len2 &#x3D; strlen(num2);\n    for(j &#x3D; 0, i &#x3D; len2-1; i &gt;&#x3D; 0; i--)\n        b[j++] &#x3D; num2[i]-&#39;0&#39;;\n\n    for(i &#x3D; 0; i &lt; len2; i++)&#x2F;&#x2F;用第二个数乘以第一个数,每次一位\n    &#123;\n        for(j &#x3D; 0; j &lt; len1; j++)\n        &#123;\n            c[i+j] +&#x3D; b[i] * a[j]; &#x2F;&#x2F;先乘起来,后面统一进位\n        &#125;\n    &#125;\n\n    for(i&#x3D;0; i&lt;MAX*2; i++) &#x2F;&#x2F;循环统一处理进位问题\n    &#123;\n        if(c[i]&gt;&#x3D;10)\n        &#123;\n            c[i+1]+&#x3D;c[i]&#x2F;10;\n            c[i]%&#x3D;10;\n        &#125;\n    &#125;\n\n    for(i &#x3D; MAX*2; c[i]&#x3D;&#x3D;0 &amp;&amp; i&gt;&#x3D;0; i--); &#x2F;&#x2F;跳过高位的0\n    len &#x3D; i+1; &#x2F;&#x2F; 记录结果的长度\n    for(; i&gt;&#x3D;0; i--)\n        sum[i]&#x3D;c[i];\n    return len;\n&#125;\n\nint main()\n&#123;\n    int i, len;\n    int sum[MAX*2+10] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 存放计算的结果，低位在前，高位在后，即sum[0]是低位\n    char num1[] &#x3D; &quot;123456789123456789&quot;; &#x2F;&#x2F; 第一个大数\n    char num2[] &#x3D; &quot;123456789123456789&quot;; &#x2F;&#x2F; 第二个大数\n    len &#x3D; Multiplication(num1, num2, sum);\n    &#x2F;&#x2F; 输出结果\n    printf(&quot;%s\\n  *\\n%s\\n  &#x3D;\\n&quot;, num1, num2);\n    for(i &#x3D; len-1; i&gt;&#x3D;0; i--)\n        printf(&quot;%d&quot;, sum[i]);\n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;\n\n4、大数除法\n大数除法是四则运算里面最难的一种。不同于一般的模拟，除法操作不是模仿手工除法，而是利用减法操作来实现的。其基本思想是反复做除法，看从被除数里面最多能减去多少个除数，商就是多少。逐个减显然太慢，要判断一次最多能减少多少个整数(除数)的10的n次方。\n以7546除以23为例：\n先用7546减去23的100倍，即减去2300，可以减3次，余下646，此时商就是300 (300=100*3)；然后646减去23的10倍，即减去230，可以减2次，余下186，此时商就是320 (320=300+10*2)；\n然后186减去23，可以减8次，余下2，此时商就是328 (328=320+1*8)；\n因为2除以23的结果小于1，而我们又不用计算小数点位，所以不必再继续算下去了。\n下面是C语言的两个正大数相除的参考代码，计算结果中没有小数：\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#define MAX 1000    &#x2F;&#x2F; 大数的最大位数\n\n&#x2F;&#x2F; 注：\n&#x2F;&#x2F; 本代码在以下博客代码中进行修改：\n&#x2F;&#x2F; http:&#x2F;&#x2F;www.cnblogs.com&#x2F;javawebsoa&#x2F;archive&#x2F;2013&#x2F;08&#x2F;01&#x2F;3231078.html\n&#x2F;&#x2F;\n\n\n&#x2F;*\n  函数SubStract功能：\n  用长度为len1的大整数p1减去长度为len2的大整数p2\n  结果存在p1中，返回值代表结果的长度\n  不够减：返回-1 ， 正好够：返回0\n*&#x2F;\nint SubStract(int *p1, int len1, int *p2, int len2)\n&#123;\n    int i;\n    if(len1 &lt; len2)\n        return -1;\n    if(len1 &#x3D;&#x3D; len2 )\n    &#123;                        &#x2F;&#x2F; 判断p1 &gt; p2\n        for(i &#x3D; len1-1; i &gt;&#x3D; 0; i--)\n        &#123;\n            if(p1[i] &gt; p2[i])   &#x2F;&#x2F; 若大，则满足条件，可做减法\n                break;\n            else if(p1[i] &lt; p2[i]) &#x2F;&#x2F; 否则返回-1\n                return -1;\n        &#125;\n    &#125;\n    for(i &#x3D; 0; i &lt;&#x3D; len1-1; i++)  &#x2F;&#x2F; 从低位开始做减法\n    &#123;\n        p1[i] -&#x3D; p2[i];         &#x2F;&#x2F; 相减\n        if(p1[i] &lt; 0)           &#x2F;&#x2F; 若是否需要借位\n        &#123;   &#x2F;&#x2F; 借位\n            p1[i] +&#x3D; 10;\n            p1[i+1]--;\n        &#125;\n    &#125;\n    for(i &#x3D; len1-1; i &gt;&#x3D; 0; i--)  &#x2F;&#x2F; 查找结果的最高位\n    &#123;\n        if( p1[i] )             &#x2F;&#x2F;最高位第一个不为0\n            return (i+1);       &#x2F;&#x2F;得到位数并返回\n    &#125;\n    return 0;                   &#x2F;&#x2F;两数相等的时候返回0\n&#125;\n\n\n&#x2F;*\n  大数除法---结果不包括小数点\n  num1 被除数\n  num2 除数\n  sum  商，存放计算的结果，即：num1&#x2F;num2&#x3D;sum\n  返回数组sum的有效长度，即商的位数\n*&#x2F;\nint Division(char num1[], char num2[], char sum[])\n&#123;\n    int k, i, j;\n    int len1, len2, len&#x3D;0;     &#x2F;&#x2F;大数位数\n    int dValue;                &#x2F;&#x2F;两大数相差位数\n    int nTemp;                 &#x2F;&#x2F;Subtract函数返回值\n    int num_a[MAX] &#x3D; &#123;0&#125;;      &#x2F;&#x2F;被除数\n    int num_b[MAX] &#x3D; &#123;0&#125;;      &#x2F;&#x2F;除数\n    int num_c[MAX] &#x3D; &#123;0&#125;;      &#x2F;&#x2F;商\n\n    len1 &#x3D; strlen(num1);       &#x2F;&#x2F;获得大数的位数\n    len2 &#x3D; strlen(num2);\n\n    &#x2F;&#x2F;将数字字符转换成整型数，且翻转保存在整型数组中\n    for( j &#x3D; 0, i &#x3D; len1-1; i &gt;&#x3D; 0; j++, i-- )\n        num_a[j] &#x3D; num1[i] - &#39;0&#39;;\n    for( j &#x3D; 0, i &#x3D; len2-1; i &gt;&#x3D; 0; j++, i-- )\n        num_b[j] &#x3D; num2[i] - &#39;0&#39;;\n\n    if( len1 &lt; len2 )          &#x2F;&#x2F;如果被除数小于除数，直接返回-1，表示结果为0\n    &#123;\n        return -1;\n    &#125;\n    dValue &#x3D; len1 - len2;      &#x2F;&#x2F;相差位数\n    for (i &#x3D; len1-1; i &gt;&#x3D; 0; i--)    &#x2F;&#x2F;将除数扩大，使得除数和被除数位数相等\n    &#123;\n        if (i &gt;&#x3D; dValue)\n            num_b[i] &#x3D; num_b[i-dValue];\n        else                         &#x2F;&#x2F;低位置0\n            num_b[i] &#x3D; 0;\n    &#125;\n    len2 &#x3D; len1;\n    for(j &#x3D; 0; j &lt;&#x3D; dValue; j++ )    &#x2F;&#x2F;重复调用，同时记录减成功的次数，即为商\n    &#123;\n        while((nTemp &#x3D; SubStract(num_a, len1, num_b+j, len2-j)) &gt;&#x3D; 0)\n        &#123;\n            len1 &#x3D; nTemp;            &#x2F;&#x2F;结果长度\n            num_c[dValue-j]++;       &#x2F;&#x2F;每成功减一次，将商的相应位加1\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 计算商的位数，并将商放在sum字符数组中\n    for(i &#x3D; MAX-1; num_c[i] &#x3D;&#x3D; 0 &amp;&amp; i &gt;&#x3D; 0; i-- );  &#x2F;&#x2F;跳过高位0，获取商的位数\n    if(i &gt;&#x3D; 0)\n        len &#x3D; i + 1; &#x2F;&#x2F; 保存位数\n    for(j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)     &#x2F;&#x2F; 将结果复制到sum数组中\n        sum[j] &#x3D; num_c[i] + &#39;0&#39;;\n    sum[j] &#x3D; &#39;\\0&#39;;   &#x2F;&#x2F; sum字符数组结尾置0\n    return len;      &#x2F;&#x2F; 返回商的位数\n&#125;\n\n\nint main()\n&#123;\n    int i;\n    int len;                &#x2F;&#x2F; 商的位数\n    char num1[MAX] &#x3D; &quot;1234567899876543210&quot;;   &#x2F;&#x2F; 第一个大数\n    char num2[MAX] &#x3D; &quot;20160415123025&quot;;              &#x2F;&#x2F; 第二个大数\n    char sum[MAX] &#x3D; &#123;0&#125;;    &#x2F;&#x2F; 计算结果\n\n    &#x2F;&#x2F;scanf(&quot;%s&quot;, num1);      &#x2F;&#x2F;以字符串形式读入大数\n    &#x2F;&#x2F;scanf(&quot;%s&quot;, num2);\n\n    len &#x3D; Division(num1, num2, sum);\n\n    &#x2F;&#x2F;输出结果\n    printf(&quot;%s\\n  ÷\\n%s\\n  &#x3D;\\n&quot;, num1, num2);\n    if( len&gt;&#x3D;0 )\n    &#123;\n        for(i &#x3D; 0; i &lt; len; i++ )\n            printf(&quot;%c&quot;, sum[i]);\n    &#125;\n    else\n    &#123;\n        printf(&quot;0&quot;);\n    &#125;\n    printf(&quot;\\n&quot;);\n\n    return 0;\n&#125;\n","slug":"Algorithm/大数四则运算","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"calculate","author_index":"JBR_Bunjie"},{"id":"e7ccb6064d60a08f73c48322b41c41c6","title":"三角形","content":"求面积1.底高求面积已知三角形底a，高h，则$$S = \\frac{a·h}{2}$$\n2.海伦公式已知三角形三边a,b,c，则$$\\begin{aligned}p &amp;= \\frac{a+b+c}{2}\\S &amp;= \\sqrt{[p(p - a)(p - b)(p - c)]}\\&amp;=\\sqrt{[(1/16)(a+b+c)(a+b-c)(a+c-b)(b+c-a)]}\\&amp;=1/4\\sqrt{[(a+b+c)(a+b-c)(a+c-b)(b+c-a)]}\\end{aligned}$$\n3.边角公式已知三角形两边a,b,这两边夹角$\\alpha$，则有：$$\\begin{aligned}S = \\frac{a·b·\\sin\\alpha}{2}\\end{aligned}$$即两夹边之积乘夹角正弦值的一半。\n4.内切圆面积公式设三角形三边分别为a、b、c，内切圆半径为r\n则三角形面积$$S = \\frac{(a+b+c)·r}{2}$$\n5.外接圆面积公式设三角形三边分别为a、b、c，外接圆半径为R\n则三角形面积$$\\begin{aligned}S &amp;= \\frac{a · b · c}{4R}\\&amp;= 2R^2 · \\sin{A} · \\sin{B} · \\sin{C}\\end{aligned}$$\n6.行列式形式$$S = \\frac{1}{2}\\left|\\begin{array}{cccc}a&amp;b&amp;1\\c&amp;d&amp;1\\e&amp;f&amp;1\\end{array}\\right|$$\n为三阶行列式，此三角形$ABC$在平面直角坐标系内$A(a,b), B(c,d), C(e,f)$，这里$ABC$选取最好按逆时针顺序从右上角开始取，因为这样取得出的结果一般都为正值，如果不按这个规则取，可能会得到负值，但不要紧，只要取绝对值就可以了，不会影响三角形面积的大小。\n7.中线面积公式Ma,Mb,Mc为三角形的中线长.$$S=\\sqrt{[(Ma+Mb+Mc)(Mb+Mc-Ma)(Mc+Ma-Mb)*(Ma+Mb-Mc)]/3}$$\n单色三角形Description在空间中给出了n个点。这些点任三点不共线，并且每两个点之间都有一条线相连，每一条线不是红的就是黑的。在这些点和线组成的三角形中，如果一个三角形的三条边的颜色都相同，那么我们就称这个三角形为单色三角形。现给出所有涂红色的线，试求出单色三角形的数目。\nmathematics sideQuestion:给定空间里n(n&lt;=1000)个点，假设任意三个点都不共线。\n将任意两点之间的连线涂上红色或者黑色。\n问3条边同色的三角形个数。\n\nAnswer:由于三角形总数C(n,3)，所以求出异色三角形个数就求出了同色三角形个数。\n值得注意的是，当我们比较一个三角形是否是单色三角形时，我们实际比较的是三角形中的任意两条边，而不是比较一个“三角形”\n利用这样的比较关系，我们比较的对象是单个顶点而不是每个三角形，易知：一个异色三角形存在两个顶点，该三角形中与它们相邻的两边是不同色的；而对从一个顶点出发的两条异色边都属于一个异色三角形。这是个一对二的关系。\n已知第i个点会连接总共n-1条边。设第i个点连接了a条红边、n-1-a条黑边，由于边之间的组合关系，这些边一定属于a(n-1-a)个不同的异色三角形。由于异色三角形都会被考虑两次，所以最终的答案为C(n, 3) - sigmaΣ(i from 1 to n)a(n-1-a)/2\n请注意，每个i下的a都是不同的，为了彰显这之中的关联，可以改设为ai，故得答案：\nC(n, 3) - Σ(i from 1 to n) ai * (n - 1 - ai) / 2\n\nprogramming sideQuestion:任务：\n请写一个程序：\n从文本文件中读入点数和对红色连线的描述；\n找出该图中红色三角形的数目；\n把结果输出到文件TRO.OUT中。\n输入格式：\n在文本文件TRO.IN的第一行包括一个整数n，3 &lt;= n &lt;= 1000，为空间中的点数。\n该文件的第二行为一个整数m，0 &lt;= m &lt;= 250000，为红色连线的数目。\n以下的m行中每行为两个用空格分开的整数p和k，1 &lt;= p &lt; k &lt;= n，表示第p点和第k号点之间的连线为红色。\n输出格式：\n你应该在文本文件TRO.OUT输出唯一的一个整数——同色三角形的数目。\n样例：\n输入\n\n\n\n\n\n\n\n\n\n691 22 32 51 41 63 44 55 63 6\n输出\n\n\n\n\n\n\n\n\n\n2\nAnswer:按照在mathematics side中的思路，我们可以发现，单个点的比较中，是不存在“方向”的，或者说，所比较的每条线都是双向的。而同时也不在意当前点对点的具体内容，我们只在意当前点下，具体 有 多少“红线”与“黑线”\n故我们用一个字典来记录各个顶点下的线数即可\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n \nusing namespace std;\n \nconst int maxn &#x3D; 200010;\ntypedef long long LL;\n \nint a[maxn];\nint cnt[maxn];\nint n,num;\nint ele[100];\n \nvoid fen(int x)&#x2F;&#x2F;素因子分解\n&#123;\n    num&#x3D;0;\n    for(int i&#x3D;2;i*i&lt;&#x3D;x;i++)&#123;\n        if(x%i&#x3D;&#x3D;0)&#123;\n            ele[num++]&#x3D;i;\n            while(x%i&#x3D;&#x3D;0)\n                x&#x2F;&#x3D;i;\n        &#125;\n    &#125;\n    if(x&gt;1) ele[num++]&#x3D;x;\n&#125;\n \nvoid init()&#x2F;&#x2F;预处理与a[i]不互质的数的个数\n&#123;\n    memset(cnt,0,sizeof(cnt));\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        scanf(&quot;%d&quot;,&amp;a[i]);\n        fen(a[i]);\n        for(int j&#x3D;1;j&lt;(1&lt;&lt;num);j++)&#123;\n            int tmp&#x3D;1;\n            for(int k&#x3D;0;k&lt;num;k++)\n                if((1&lt;&lt;k)&amp;j) tmp*&#x3D;ele[k];\n            cnt[tmp]++;\n        &#125;\n    &#125;\n&#125;\n \nLL solve()\n&#123;\n    LL ans&#x3D;n;\n    ans&#x3D;ans*(n-1)*(n-2)&#x2F;6;&#x2F;&#x2F;防止爆int\n    LL sum&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;&#x2F;&#x2F;容斥原理求与a[i]不互质的数的个数\n        fen(a[i]);\n        LL tmp&#x3D;0;\n        for(int j&#x3D;1;j&lt;(1&lt;&lt;num);j++)&#123;\n            LL ret &#x3D; 1;\n            int t&#x3D;0;\n            for(int k&#x3D;0;k&lt;num;k++)&#123;\n                if((1&lt;&lt;k)&amp;j)&#123;\n                    ret*&#x3D;ele[k];\n                    t++;\n                &#125;\n            &#125;\n            if(t&amp;1) tmp+&#x3D;cnt[ret];\n            else tmp-&#x3D;cnt[ret];\n        &#125;\n        if(tmp&#x3D;&#x3D;0) continue;\n        else sum+&#x3D;(n-tmp)*(tmp-1);\n        &#x2F;&#x2F;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;&quot; &quot;&lt;&lt;(n-tmp)*(tmp-1)&#x2F;2&lt;&lt;endl;\n    &#125;\n    return ans-sum&#x2F;2;\n&#125;\nint main()\n&#123;\n    int t;\n    scanf(&quot;%d&quot;,&amp;t);\n    while(t--)&#123;\n        init();\n        LL ans&#x3D;solve();\n        printf(&quot;%I64d\\n&quot;,ans);\n    &#125;\n    return 0;\n&#125;\n\n","slug":"Algorithm/三角形面积计算","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"triangle area","author_index":"JBR_Bunjie"},{"id":"88fe004551a3de4348d535f91c34c293","title":"字符画","content":"字符画另类应用当你需要在shell里查看图片时\n现有框架ascii-image-converter TheZoraiz/ascii-image-converter: A cross-platform command-line tool to convert images into ascii art and print them on the console. Now supports braille art! (github.com)\n原理字符画是一系列字符的组合，我们可以把字符看作是比较大块的像素，一个字符能表现一种颜色，字符的种类越多，可以表现的颜色也越多，图片也会更有层次感。\n最终显示的是黑白色的字符画，那么彩色的图 片怎么转换成黑白的呢？这里就需要了解灰度值的概念了。\n灰度值：指黑白图像中点的颜色深度，范围一般从0到255，白色为255，黑色为0，故黑白图片也称灰度图像。我们利用下面的公式将像素的RGB值转换成灰度值：\ngray ＝ 0.2126 * r + 0.7152 * g + 0.0722 * b\n用不同的字符代表不同的灰度值，字符的种类和数量可以根据自己需要的效果进行调整，最好从前往后可以看到明显的变化，最后一个字符为空格符最佳：\nascii_char &#x3D; list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft&#x2F;\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\\&quot;^&#96;&#39;. &quot;)\n\n图片转字符画的关键思想是将图片的灰度值与你自己设定的字符集之间建立映射关系，不同区间的灰度值对应不同的字符，之后将图片每一个像素对应的字符打印出来就是我们要的字符画啦~ 这里提供两种方法：\n\n获取图片的RGB值，利用公式： Gray = R0.299 + G0.587 + B*0.114 计算可得每个像素点的灰度值，之后再建立映射即可。\n先将彩色图片转换为黑白图片，然后直接将每个像素点的灰度值与字符集建立映射。\n\n实现思路？思路也很简单，通过像素的灰度来映射出ASCII字符。灰度值越大，所映射的ASCII字符占的单位面积越大，也就是看起来越黑。\n（例如某点的灰度是0，那么对应的字符就是空格；类似的，灰度为255时，对应的字符就是“$”）\n实际操作起来会遇到的问题就是：\n图片太大，输出后的文本即使使用最小字体也看不全\nASCII字符不是方形像素（长宽比不是1:1）\n处理方法就是对图片的大小数据进行处理（而不是原图修改）然后映射。\n总体上来说制作字符画还是比较简单的，需要处理的情况没有那么多。\n黑白字符画黑白字符画应该是难度最低的了。大致思路是这样的：\n\n设计一个从深到浅（0~255，黑~白）的字符列表；\n将原图转为黑白，并量化（quantization，如从 0255 量化为 016）从而匹配字符列表的长度；\n将图片缩放为一个很小的图（如宽度 100）；\n将每一个像素点的亮度转为对应字符；\n输出为 .txt 文件。\n\n彩色字符画\n将原图缩放为一个很小的缩略图（如宽度 100）；\n新建一个大的白色或黑色画布；\n计算好每个字符在画布上的位置，将缩略图中每一个像素点转为颜色相同的字符，并打印在画布指定位置上；\n将画布输出为图像（如 .png）文件。\n\nReference：字符画——从入门到不屑 - 知乎 (zhihu.com)\n","slug":"Algorithm/字符画","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"String Processing","author_index":"JBR_Bunjie"},{"id":"920b0f28d25f5984040e129525c64cc1","title":"Floor method","content":"以python为例：\n\nint()进行强制类型转化\nround()函数\nformat()函数\n两个精巧的数学计算\n\na &#x3D; 60.89564\n\na&#x2F;&#x2F;1\na-(a+1)%1\n(a+B-1)&#x2F;&#x2F;B # 向上取整\n\n","slug":"Algorithm/小数取整","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Number Processing","author_index":"JBR_Bunjie"},{"id":"61e7c8da8f21c01a5499770adb3ae992","title":"平面分割问题","content":"直线切割平面问题Reference：\n平面分割_xzx9的博客-CSDN博客_平面分割空间\n平面分割类问题总结 - Yeader - 博客园 (cnblogs.com)\n\nDetail：【题型一】直线分割平面\n\n\n\n\n\n\n\n\n在一个平面上有一个圆和n条直线，这些直线中每一条在圆内同其他直线相交，假设没有3条直线相交于一点，试问这些直线将圆分成多少区域。 \n分析： 当添加第N条，为了使平面最多， 则第N条直线要与前面的N-1条直线都相交，且没有任何三条直线相交一个点。则添加第N条直线会多N-1个交点。同时：由于每增加N个交点，就增加N+1个平面，所以添加的第N条直线来会在之前的基础上增加N个平面。\n若用F[i]表示i条直线能把平面切分成的个数。$$\\begin{aligned}F(1)&amp;=2;\\F(n)&amp;=F[n-1]+n;\\end{aligned}$$\n可得递推结果：$$F(n)=1+n*(n+1)/2$$\n【题型二】平面分割空间（HDU 1290）$$F(n)=(n^3+5n)/6+1$$\n全面考虑，注意平面是可以倾斜的！\n还有更多？【题型三】折线分割平面（HDU 2050）\n【题型四】圆形划分区域\n","slug":"Algorithm/平面切割","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Geometry,plane","author_index":"JBR_Bunjie"},{"id":"018a847738d23737cfe4d3b9bbf1a909","title":"面经贴002","content":"2作为Unity程序员需要掌握的技能_海洋_的博客-CSDN博客_unity 在职技能\n","slug":"ExperiencesForJob/2","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"面经","author_index":"JBR_Bunjie"},{"id":"0cac3f987485de1d75a5a244c4c39f42","title":"面经贴001","content":"1Unity 工作经历+近期面试经历_weixin_33912246的博客-CSDN博客\n\n\n\n\n\n\n\n\n\n1.不要过多去问关于加班的问题，如果有熟人在里面直接问熟人好了。或者等拿到offer的时候再问。游戏公司情况比较特殊，加班普遍严重。（当然，技巧归技巧，我个人观点并不认为问清楚加班情况和愿意不愿意加班有什么必然联系。这是双方选择的过程，本来我们就应该有知情权。你给我的钱只够买我一斤的体力脑力，我凭什么卖3斤给你？嗯？）\n*2.技术老大问技术和职业困惑，主管boss问公司发展和职业发展，HR*问生活。**（这是我和大学同学交流面试疑惑时，他的原话。挺有道理）\n3.平常做项目，学习，多问个为什么。不要只顾埋头写逻辑，多想多学一些底层的东西。知其然，且知其所以然。（虽然作为一个搬砖级的程序员来说，平常更多的只是写逻辑就行了，但如果想要进阶的话，还是多深究一下。想当将军的士兵会让面试者更喜欢吧）\n4.关于知识点：几次面试比较常规的知识点是：C#（GC，装拆箱，ref/out，容器，迭代器），Lua（元表，面向对象），算法，数据结构，渲染（流程），性能优化。（这个肯定不全面，只是我基于最近面试的总结）\n想法：\n看情况，看资本\n了解你自己的能力，去了解你自己的公司\n\n知识点简明内容：C# GCC# 装拆箱","slug":"ExperiencesForJob/1","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"面经","author_index":"JBR_Bunjie"},{"id":"7c38d39e738512a528b01881f848d2e4","title":"Game Dev Recordings","content":"STAGE 1: Project Setup\nCreate a 2D URP Project\n\nSet Preset for Textures\n\n16px * 16px grid\n\n\nApply preset manually to all existing pixel art\n\n\nSTAGE 2: Install Art Packs\nAnimated Pixel Adventurer by rvros (itch.io)\nFantasy Knight - Free Pixelart Animated Character by aamatniekss (itch.io)\nhttps://managore.itch.io/m5x7 Typeface / Font\nhttps://aamatniekss.itch.io/free-pixelart-tileset-cute-forest\nhttps://henrysoftware.itch.io/pixel-food\nKyrise’s Free 16x16 RPG Icon Pack by Kyrise (itch.io)\nMonsters Creatures Fantasy by LuizMelo (itch.io)\nLegendary JRPG Battle Music Pack FREE by YouFulca (itch.io)\nRPG Essentials SFX - Free! by Leohpaz (itch.io)\n\nSTAGE 3: Install Necessary Unity Packages\nIntsall “Cinemachine” \nInstall “Input System”\nChange Project Setting: Turn off Reload Domain(faster loading of scenes in editor)(may cause some potential errors)\n\nSTAGE 4: Create Background\n创建背景: sprite renderer\n设定sorting layer\n\nLayer、Sorting Layer and Order in Layer\nSTAGE 5: Setup player(basic move: left and right)\nSpriteRenderer\nRigidbody2D: diff with “rigidbody”\nprefabs: make and change\nPlayer Input Component: with assert needed\nPlayerController script movement: start to write the control script\n\n\n\n\n\n\n\n\n\n\nBroadcastmessage sends a message to an object AND all of its children\nSendMessageUpwards sends a message to all parent game objects.\nReference:TUTORIAL LINKS:Learn How to Make a 2D Platformer in Unity 2022 - FULL GAMEDEV COURSE! - YouTube\nDOWNLOAD LINKS:- \n","slug":"GAME_DEV/2DGAME","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Experience Recordings","author_index":"JBR_Bunjie"},{"id":"86f05433afcd220f1d55c4667ed9f60c","title":"Http Explanations","content":"\n\n\n\n\n\n\n\n\nHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML. It was designed for communication between web browsers and web servers, but it can also be used for other purposes. HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response. HTTP is a stateless protocol, meaning that the server does not keep any data (state) between two requests.\nOverview:\nComponents of HTTP-based systemsHTTP is a client-server protocol: requests are sent by one entity, the user-agent (or a proxy on behalf of it). Most of the time the user-agent is a Web browser, but it can be anything, for example, a robot that crawls the Web to populate and maintain a search engine index.\nEach individual request is sent to a server, which handles it and provides an answer called the response. Between the client and the server there are numerous entities, collectively called proxies, which perform different operations and act as gateways or caches, for example\nIn reality, there are more computers between a browser and the server handling the request: there are routers, modems, and more. Thanks to the layered design of the Web, these are hidden in the network and transport layers. HTTP is on top, at the application layer. Although important for diagnosing network problems, the underlying layers are mostly irrelevant to the description of HTTP.\nClient: the user-agentThe user-agent is any tool that acts on behalf of the user. This role is primarily performed by the Web browser, but it may also be performed by programs used by engineers and Web developers to debug their applications.\nThe browser is always the entity initiating the request. It is never the server (though some mechanisms have been added over the years to simulate server-initiated messages).\nTo display a Web page, the browser sends an original request to fetch the HTML document that represents the page. It then parses this file, making additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then combines these resources to present the complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.\nThe Web serverOn the opposite side of the communication channel is the server, which serves the document as requested by the client. A server appears as only a single machine virtually; but it may actually be a collection of servers sharing the load (load balancing), or a complex piece of software interrogating other computers (like cache, a DB server, or e-commerce servers), totally or partially generating the document on demand.\nA server is not necessarily a single machine, but several server software instances can be hosted on the same machine. With HTTP/1.1 and the Host header, they may even share the same IP address.\nProxiesBetween the Web browser and the server, numerous computers and machines relay the HTTP messages. Due to the layered structure of the Web stack, most of these operate at the transport, network or physical levels, becoming transparent at the HTTP layer and potentially having a significant impact on performance. Those operating at the application layers are generally called proxies. These can be transparent, forwarding on the requests they receive without altering them in any way, or non-transparent, in which case they will change the request in some way before passing it along to the server. Proxies may perform numerous functions:\n\ncaching (the cache can be public or private, like the browser cache)\nfiltering (like an antivirus scan or parental controls)\nload balancing (to allow multiple servers to serve different requests)\nauthentication (to control access to different resources)\nlogging (allowing the storage of historical information)\n\nBasic aspects of HTTPHTTP is simpleHTTP is generally designed to be simple and human readable, even with the added complexity introduced in HTTP/2 by encapsulating HTTP messages into frames. HTTP messages can be read and understood by humans, providing easier testing for developers, and reduced complexity for newcomers.\nHTTP is extensibleIntroduced in HTTP/1.0, HTTP headers make this protocol easy to extend and experiment with. New functionality can even be introduced by a simple agreement between a client and a server about a new header’s semantics.\nHTTP is stateless, but not sessionlessHTTP is stateless: there is no link between two requests being successively carried out on the same connection. This immediately has the prospect of being problematic for users attempting to interact with certain pages coherently, for example, using e-commerce shopping baskets. But while the core of HTTP itself is stateless, HTTP cookies allow the use of stateful sessions. Using header extensibility, HTTP Cookies are added to the workflow, allowing session creation on each HTTP request to share the same context, or the same state.\nHTTP and connectionsA connection is controlled at the transport layer, and therefore fundamentally out of scope for HTTP. HTTP doesn’t require the underlying transport protocol to be connection-based; it only requires it to be reliable, or not lose messages (at minimum, presenting an error in such cases). Among the two most common transport protocols on the Internet, TCP is reliable and UDP isn’t. HTTP therefore relies on the TCP standard, which is connection-based.\nBefore a client and server can exchange an HTTP request/response pair, they must establish a TCP connection, a process which requires several round-trips. The default behavior of HTTP/1.0 is to open a separate TCP connection for each HTTP request/response pair. This is less efficient than sharing a single TCP connection when multiple requests are sent in close succession.\nIn order to mitigate this flaw, HTTP/1.1 introduced pipelining (which proved difficult to implement) and persistent connections: the underlying TCP connection can be partially controlled using the Connection header. HTTP/2 went a step further by multiplexing messages over a single connection, helping keep the connection warm and more efficient.\nExperiments are in progress to design a better transport protocol more suited to HTTP. For example, Google is experimenting with QUIC which builds on UDP to provide a more reliable and efficient transport protocol.\nAn overview of HTTP - HTTP | MDN (mozilla.org)\n","slug":"Internet Protocol/Http","date":"2022-12-23T04:23:23.000Z","categories_index":"Protocol Theory","tags_index":"Computer Network","author_index":"JBR_Bunjie"},{"id":"aa8ff1f4cd866ae3e0deaae5a8bc6249","title":"OSI Model Explanations","content":"The OSI Model DefinedThe OSI Model (Open Systems Interconnection Model) is a conceptual framework used to describe the functions of a networking system. The OSI model characterizes computing functions into a universal set of rules and requirements in order to support interoperability between different products and software. In the OSI reference model, the communications between a computing system are split into seven different abstraction layers: Physical, Data Link, Network, Transport, Session, Presentation, and Application.\nCreated at a time when network computing was in its infancy, the OSI was published in 1984 by the International Organization for Standardization (ISO). Though it does not always map directly to specific systems, the OSI Model is still used today as a means to describe Network Architecture.\nThe 7 Layers of the OSI ModelPhysical LayerThe lowest layer of the OSI Model is concerned with electrically or optically transmitting raw unstructured data bits across the network from the physical layer of the sending device to the physical layer of the receiving device. It can include specifications such as voltages, pin layout, cabling, and radio frequencies. At the physical layer, one might find “physical” resources such as network hubs, cabling, repeaters, network adapters or modems.\nData Link LayerAt the data link layer, directly connected nodes are used to perform node-to-node data transfer where data is packaged into frames. The data link layer also corrects errors that may have occurred at the physical layer.\nThe data link layer encompasses two sub-layers of its own. The first, media access control (MAC), provides flow control and multiplexing for device transmissions over a network. The second, the logical link control (LLC), provides flow and error control over the physical medium as well as identifies line protocols.\nNetwork LayerThe network layer is responsible for receiving frames from the data link layer, and delivering them to their intended destinations among based on the addresses contained inside the frame. The network layer finds the destination by using logical addresses, such as IP (internet protocol). At this layer, routers are a crucial component used to quite literally route information where it needs to go between networks.\nTransport LayerThe transport layer manages the delivery and error checking of data packets. It regulates the size, sequencing, and ultimately the transfer of data between systems and hosts. One of the most common examples of the transport layer is TCP or the Transmission Control Protocol.\nSession LayerThe session layer controls the conversations between different computers. A session or connection between machines is set up, managed, and termined at layer 5. Session layer services also include authentication and reconnections.\nPresentation LayerThe presentation layer formats or translates data for the application layer based on the syntax or semantics that the application accepts. Because of this, it at times also called the syntax layer. This layer can also handle the encryption and decryption required by the application layer.\nApplication LayerAt this layer, both the end user and the application layer interact directly with the software application. This layer sees network services provided to end-user applications such as a web browser or Office 365. The application layer identifies communication partners, resource availability, and synchronizes communication.\nWhat is the OSI Model? The 7 Layers Explained | Forcepoint\n一文看懂网络七层协议/OSI七层模型 - 知乎 (zhihu.com)\n图解OSI七层模型 - 简书 (jianshu.com)\n","slug":"Internet Protocol/OSI","date":"2022-12-23T04:23:23.000Z","categories_index":"Protocol Theory","tags_index":"Computer Network","author_index":"JBR_Bunjie"},{"id":"d5ce47e1ac59ed5b28424dda2538d8ad","title":"URL Explanations","content":"General: What is URI? and URL?http - What is the difference between a URI, a URL and a URN? - Stack Overflow\n\n\n\n\n\n\n\n\n\n最简单易懂的：\nURL - http://example.com/some/page.html\nURI - /some/page.html\nHTTP 协议中 URI 和 URL 有什么区别？ - 知乎 (zhihu.com)\nURL：(Uniform Resource Locator 的缩写，统一资源定位符)\nURI：(Uniform Resource Identifier 的缩写，统一资源标识符)\nURN：(Uniform Resource Name 的缩写，统一资源标识符)\n其实名字就已经非常明显了：\nIdentifier: 重点是表示特定的资源。\nLocator: 通过位置来表示资源。\nName: 通过名字来表示资源。\nURI 在于I(Identifier)，是统一资源标示符，可以唯一标识一个资源。\nURL在于L(Locater)，一般来说（URL）统一资源定位符，可以提供找到该资源的路径，比如\nhttps://github.com/JBR-Bunjie/JBR-Bunjie/blob/main/back.jpg\n但URL又是URI，因为它可以标识一个资源，所以URL又是URI的子集—&gt;URI 属于 URL 更高层次的抽象，一种字符串文本标准。\nencoding and decoding in URLURL编码通常也被称为百分号编码（percent-encoding），是因为它的编码方式非常简单：\n使用%加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。\n\n\n\n\n\n\n\n\n\nencodeURI() - JavaScript | MDN (mozilla.org)\ndecodeURI() - JavaScript | MDN (mozilla.org)\nURL编码要做的，就是将每一个非安全的ASCII字符都被替换为“%xx”格式，而对于非ASCII字符，RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。\n如 中文 使用 UTF-8 字符集得到的字节为 0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到 %E4%B8%AD%E6%96%87。\n一些常见的特殊字符换成相应的十六进制的值：\n+   %20   \n&#x2F;   %2F   \n?   %3F   \n%   %25   \n#   %23   \n&amp;   %26  \n\n用python测试编码：\n&gt; &quot;中文&quot;.encode(encoding&#x3D;&quot;utf8&quot;)\nb&#39;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#39;\n\n&gt; b&quot;\\x2f&quot;.decode()\n&#39;&#x2F;&#39;\n\nURL的编码和解码 - 何必等明天 - 博客园 (cnblogs.com)\nEvery char in the address bar will be encoded in ansi or utf8.\nencodeURI(&#39;https:&#x2F;&#x2F;mzh.moegirl.org.cn&#x2F;乐正绫&#39;)\ndecodeURI(&quot;https:&#x2F;&#x2F;mzh.moegirl.org.cn&#x2F;%E4%B9%90%E6%AD%A3%E7%BB%AB&quot;)\n\nimp\nurllib.parse.unquote(a)\n\n","slug":"Internet Protocol/URL,URI,URN","date":"2022-12-23T04:23:23.000Z","categories_index":"Protocol Theory","tags_index":"Computer Network","author_index":"JBR_Bunjie"},{"id":"23e47bb6f32c19be2d53fa043d58a084","title":"E-mail格式记录","content":"e-mail的格式主要包括4项：\nTo：即这个e-mail发给谁，通常是接受者的电子邮件信箱。\nFrom：即这个e-mail是谁发的，通常是发送者的电子邮件信箱。 \nCC: carbon copy 的缩写，愿意是用复写纸预写副本，在e-mail 中为“抄送”之意，即可同时把此邮件发给其他的人，有时也可写成copy to\nSubject：即主题，也就是这封e-mail的主要内容是什么。\n","slug":"Softwares/E-Mail Format and Explanation","date":"2022-12-23T04:23:23.000Z","categories_index":"Coding Software","tags_index":"E-mail","author_index":"JBR_Bunjie"},{"id":"b0298187d3b43e42af9c0e2b93f65724","title":"Birthday Paradox","content":"生日悖论-birthday paradox一个很简单的概率关系，由于其反直觉而称为“悖论”：\n一个房间要多少人，则两个人的生日相同的概率\n\n\n\n对应情况\n所需人数\n\n\n\n大于50%？\n23人\n\n\n大于70%？\n30人\n\n\n大于97%？\n50人\n\n\n大于99%？\n57人\n\n\n可以发现，概率大于99%所需的人数 只是总数的1 / 6不到而已！\n每个人生日 都不同 的 阶乘 形式为：\n![img](birthday paradox equation01.svg)\n故至少有两个人生日相同的概率就是上述结果的补，即：![img](birthday paradox equation02.svg)\n生日悖论 - 知乎 (zhihu.com)\n鸽笼理论-pigeonhole principle又叫抽屉原理\n如果有n种n+1个物品，那么至少有一种有两个物品\n这种基本概念也没什么太多好阐释的，主要是鸽笼定理在思维上可能会造成一些奇怪的突破口\n有几个衍生的阐述形式：\n形式一：如果把n+1(n是正整数)个对象放入n个盒子里，那么至少有一个盒子中放入两个或者两个以上的对象。证明：假设每个盒子中都少于两个对象，那么总数不可能为n+1个对象，与前提矛盾。\n形式二：如果把m个对象放到n个盒子里（m,n都是正整数），那么至少有一个盒子中放入[m-1/n]+1个的对象。注：[m-1/n]中的[]代表着m-1/n的整数部分。证明：假设每个盒子中都少于或者等于[m-1/n]对象，那么对象的总数将不会多于n*[m-1/n]个，从而少于或者等于m-1个，与前提矛盾。\n应用——生日攻击生日悖论与鸽笼理论组合的可被应用于设计密码学攻击方法——生日攻击。\n即 N 位长度的哈希表可能发生碰撞测试次数不是 2^N 次而是只有 2^(N/2) + 1 次\n\n\n\n\n\n\n\n\n\n如果输出是256位，我们随机地选择输入，并计算哈希值，在检验第2^256 + 1个输入之前便很可能找到碰撞。\n实际上，如果我们随机选择2^128 + 1个输入，找到至少两个相同哈希值的概率为99%，而2 ^ 130 + 1 则高达 99.8%。\n具体场景可以看：密码学：生日攻击_Linuxest-CSDN博客_生日攻击\n算法题鸽笼原理&amp;容斥原理_LazyCrazyCat的博客-CSDN博客_鸽笼定理\n","slug":"Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"String Processing","author_index":"JBR_Bunjie"},{"id":"26cdbb886310bf39cb3aaad08f67e70b","title":"售货员问题！","content":"一、题目\n一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。\n（等价于求图的最短哈密尔顿回路问题）令G=(V, E)是一个带权重的有向图，顶点集V=(v0, v1, …, vn-1)。从图中任一顶点vi出发，经图中所有其他顶点一次且只有一次，最后回到同一顶点vi的最短路径。\n\n二、测试用例\n其中1,2,3,4,5代表五个城市。此模型可抽象为图，可用邻接矩阵c表示，如下图所示：\n\n三、动态规划方程 假设从顶点s出发，令d(i, V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。\n​    推导：(分情况来讨论)\n​    ①当V为空集，那么d()，表示直接从i回到s了，此时 且 \n​    ②如果V不为空，那么就是对子问题的最优求解。你必须在V这个城市集合中，尝试每一个，并求出最优解。\n​     \n​      注：表示选择的城市和城市i的距离，是一个子问题。\n​    综上所述，TSP问题的动态规划方程就出来了：\n\n四、用例分析现在对问题定义中的例子来说明TSP的求解过程。(假设出发城市是 0城市)\n\n\n这里只画出了d(1,{2,3,4}),由于篇幅有限这里就不画了。\n①我们要求的最终结果是d(0,{1,2,3,4}),它表示，从城市0开始，经过{1,2,3,4}之中的城市并且只有一次，求出最短路径.。②d(0,{1,2,3,4})是不能一下子求出来的，那么他的值是怎么得出的呢？看上图的第二层，第二层表明了d(0,{1,2,3,4})所需依赖的值。那么得出：      ③d(1,{2,3,4})，d(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样也不是一步就能求出来的，它们的解一样需要有依赖，就比如说d(1,{2,3,4})   d(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样需要这么求。\n  ④按照上面的思路，只有最后一层的，当V为空集时，就可以满足 且 该条件，直接求出dp数组部分的值。\n五、数据结构由上述动态规划公式d(i,V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。根据上述给的测试用例有5个城市编号0,1,2,3,4。那么访问n个城市，恰好访问每个城市一次，并最终回到出发城市的嘴短距离可表示为d(0,{1,2,3,4}),那么问题来了我们用什么数据结构表示d(i,V)，这里我们就可二维数据dp[N][M]来表示，N表示城市的个数，M表示集合的数量，即,之所以这么表示因为集合V有个子集。根据测试用例可得出如下dp数组表格：\n\n那么你们可能就有疑问了，为什么这么表示？这里说明一下比如集合{1,2,3,4}为什么用15表示，我们可以把集合中元素看成二进制1的位置（二进制从右开始看），1表示从右开始第一位为1,2表示从又开始第二位为1，所以集合{1,2,3,4}可表示二进制（1111）转化为十进制为15。再举个例子比如集合{1,3}表示为二进制为0101，十进制为5。所以我们求出dp[0][15]（通用表示dp[0][]）就是本题的最终解。\n注意：\n\n对于第y个城市，他的二进制表达为，1&lt;&lt;(y-1)。\n对于数字x，要看它的第i位是不是1，那么可以通过判断布尔表达式 (((x &gt;&gt; (i - 1) ) &amp; 1) == 1或者（x  &amp; (1&lt;&lt;(i-1))）!= 0的真值来实现。\n由动态规划公式可知，需要从集合中剔除元素。假如集合用索引x表示，要剔除元素标号为i,我们异或运算实现减法，其运算表示为： x = x ^ (1&lt;&lt;(i - 1))。\n\n六、最短路径顶点的计算我们先计算dp[N][M]数组之后，我可以用dp数组来反向推出其路径。其算法思想如下：\n比如在第一步时，我们就知道那个值最小，如下图所示：\n\n因为dp[][]数组我们已经计算出来了，由计算可知C01+d(1,{2,3,4})最小，所以一开始从起始点0出发，经过1。接下来同样计算d(1,{2,3,4})\n\n由计算可知C14+d(4,{2,3})所以0—&gt;1—-&gt;4，接下来同理求d(4,{2,3})，这里就省略，读者可以自行计算。最终计算出来的路径为：0—&gt;1—&gt;4—&gt;2—&gt;3—&gt;0\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n \nusing namespace std;\n \n#define N 5\n#define INF 10e7\n#define min(a,b) ((a&gt;b)?b:a)\n \nstatic const int M &#x3D; 1 &lt;&lt; (N-1);\n&#x2F;&#x2F;存储城市之间的距离\nint g[N][N] &#x3D; &#123;&#123;0,3,INF,8,9&#125;,\n               &#123;3,0,3,10,5&#125;,\n               &#123;INF,3,0,4,3&#125;,\n               &#123;8,10,4,0,20&#125;,\n               &#123;9,5,3,20,0&#125;&#125;;\n\n&#x2F;&#x2F;保存顶点i到状态s最后回到起始点的最小距离\nint dp[N][M];\n\n&#x2F;&#x2F;保存路径\nvector&lt;int&gt; path;\n \n&#x2F;&#x2F;核心函数，求出动态规划dp数组\nvoid TSP()&#123;\n    &#x2F;&#x2F;初始化dp[i][0]\n    for(int i &#x3D; 0; i &lt; N; i++)\n        dp[i][0] &#x3D; g[i][0];\n    \n    &#x2F;&#x2F;求解dp[i][j]\n    for(int j &#x3D; 1; j &lt; M; j++ ) &#123;\n        for(int i &#x3D; 0; i &lt; N; i++ ) &#123;\n            dp[i][j] &#x3D; INF;\n            &#x2F;&#x2F;如果集和j(或状态j)中包含结点i,则不符合条件退出\n            if( ((j &gt;&gt; (i-1)) &amp; 1) &#x3D;&#x3D; 1)\n                continue;\n            \n            for(int k &#x3D; 1; k &lt; N; k++) &#123;\n                if( ((j &gt;&gt; (k-1)) &amp; 1) &#x3D;&#x3D; 0)\n                    continue;\n                \n                if( dp[i][j] &gt; g[i][k] + dp[k][j^(1&lt;&lt;(k-1))] )\n                    dp[i][j] &#x3D; g[i][k] + dp[k][j^(1&lt;&lt;(k-1))] ;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;判断结点是否都以访问,不包括0号结点\nbool isVisited(bool visited[])&#123;\n    for(int i &#x3D; 1 ; i&lt;N ;i++)\n        if(visited[i] &#x3D;&#x3D; false)\n            return false;\n    return true;\n&#125;\n\n&#x2F;&#x2F;获取最优路径，保存在path中,根据动态规划公式反向找出最短路径结点\nvoid getPath()&#123;\n    &#x2F;&#x2F;标记访问数组\n    bool visited[N] &#x3D; &#123;false&#125;;\n    &#x2F;&#x2F;前驱节点编号\n    int pioneer &#x3D; 0 ,min &#x3D; INF, S &#x3D; M - 1,temp ;\n    &#x2F;&#x2F;把起点结点编号加入容器\n    path.push_back(0);\n \n    while(!isVisited(visited))&#123;\n        for(int i&#x3D;1; i&lt;N;i++)\n            if(visited[i] &#x3D;&#x3D; false &amp;&amp; (S&amp;(1&lt;&lt;(i-1))) !&#x3D; 0)\n                if(min &gt; g[i][pioneer] + dp[i][(S^(1&lt;&lt;(i-1)))])\n                    min &#x3D; g[i][pioneer] + dp[i][(S^(1&lt;&lt;(i-1)))] ;\n                    temp &#x3D; i;\n            \n        pioneer &#x3D; temp;\n        path.push_back(pioneer);\n        visited[pioneer] &#x3D; true;\n        S &#x3D; S ^ (1&lt;&lt;(pioneer - 1));\n        min &#x3D; INF;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;输出路径\nvoid printPath()&#123;\n    cout&lt;&lt;&quot;最小路径为：&quot;;\n    vector&lt;int&gt;::iterator  it &#x3D; path.begin();\n    for(it ; it !&#x3D; path.end();it++)\n        cout&lt;&lt;*it&lt;&lt;&quot;---&gt;&quot;;\n    &#x2F;&#x2F;单独输出起点编号\n    cout&lt;&lt;0;\n&#125;\n \nint main()\n&#123;\n    TSP();\n    cout&lt;&lt;&quot;最小值为：&quot;&lt;&lt;dp[0][M-1]&lt;&lt;endl;\n    getPath();\n    printPath();\n    return 0;\n&#125;\n\n八、测试结果及性能分析\n时间复杂度：\n空间复杂度：\n旅行商问题（动态规划方法，超级详细的）_仁者乐山智者乐水的博客-CSDN博客_旅行商问题\n","slug":"Algorithm/DP/Traveling Salesman Problem","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"DP","author_index":"JBR_Bunjie"},{"id":"991c84bc86acdc32c9243fba302e2655","title":"Hash Function","content":"简明Hash function教程\n\n\n\n\n\n\nWARNING\n请注意！这篇文档是关于散列函数Hash function的，如果需要了解Hash table相关内容请查阅“简明Hash table教程”等相关文章\n\n\n引子在各种下载站的资源页面下方，经常会有如下以SHA开头的特殊字段\n\n\n\n\n\n\n\n\n\nSHA1：9B71AD5604B3816BCC7E9AFA3052AE7D823163E8\n或者是或MD5开头的特殊字段\n\n\n\n\n\n\n\n\n\nMD5：124756ef340daf80196b4124686d651c\n这些特殊字段既非下载链接，也特定网址。那么这些特殊的字段都有什么用？\n想要解决这个问题，我们需要先了解一下什么是Hash算法\nHash算法什么是Hash？先简单介绍一下Hash算法\n\n\n\n\n\n\n\n\n\n散列函数（Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建数字“指纹”的方法。\n\n\n\n\n\n\nTIP\n请注意！Hash算法并非特指某一种算法，而是所有满足Hash算法的一整类算法的统称\n\n\nHash算法的实际效果为：对任意一组输入数据进行计算处理，并最终得到一个固定长度的输出摘要。\n经典的比如经MD5算法运算后的结果只有16位或者32位16进制字符，而SHA-1的结果为40位16进制字符\n试着去生成一串Hash Code吧现在打开你的任何一款ide，通过MD5方法来对你好啊这串字符进行处理，如下是Python对之进行处理的例子\nimport hashlib\nstr1 &#x3D; &quot;你好呀&quot; # 准备Hash算法需要处理的数据块\nm &#x3D; hashlib.md5() # 确定特定的Hash算法\nm.update(str1.encode(&quot;utf8&quot;)) # 执行该算法\nprint(m.hexdigest(), type(m.hexdigest())) # 查验输出结果\n\n# python提供了一个build-in function：hash，但是它有点特殊，具体了解可以参照下文：\n# https:&#x2F;&#x2F;blog.csdn.net&#x2F;cunchi4221&#x2F;article&#x2F;details&#x2F;107474126\n\n检查一下结果：4f65fdb33e0f2bd0de6bd1b41fdea968 &lt;class &#39;str&#39;&gt;——一个32个字符，32Byte，128bit大小的字符串，和MD5算法规定的长度完全一致。同时，当我们重复执行这个程序时，我们发现程序最终得到的结果和第一次的结果不变！\n是的！更进一步地，当我们的数据和Hash算法确定以后，不管是在本地，还是在别的任何设备上再次执行这串代码，它的结果是不会发生变化的。也就是说，一个既定的输入在既定的Hash算法中只会对应一个特定的输出\n根据这个特点，我们可以用某种特定的Hash算法来检验资源的完整性：当用户完成资源的下载后，如果本地资源使用对应的Hash算法得到的Hash code与下载网站上给出的Hash code不相符的话，就意味着你的本地资源有问题，需要进行修复或者重新下载\nHash算法还能干什么？事实上，Hash Code被大量使用于网站的密码加密中：当用户注册的时候，用户的密码通过某种Hash算法加密后得到一串Hash Code，服务器就将Hash Code代替明文密码存储到服务器的数据库中，用户登陆时输入的密码经过加密会再次得到相同的结果，这当然与数据库中存储的内容一致，这样子就完成了用户的验证。\n由于Hash算法是一种有损的压缩运算，即在实时的运算中损失了大部分原始数据，这并不是加密而是摘要，同时也导致得到原数据最直接的方式只有再次输入，想要破解一般只能够依靠穷举。故一般认为Hash算法是不可逆运算，所以即便是服务器数据库泄露也不必担心账号被别人盗取\n尝试使用Hash算法，并研究它的输出规律为了研究Hash算法的输出结果的规律，我们需要几个实例\npublic class HelloWorld &#123;\n    public static void main(String []args) &#123;\n\t\tSystem.out.println(&quot;hello, java&quot;.hashCode());\n\t\tSystem.out.println(&quot;hello, java&quot;.hashCode()); &#x2F;&#x2F;相同数据输入，查看结果\n        \n        System.out.println(&quot;---------------------------&quot;);\n\t\t\n\t\tSystem.out.println(&quot;hello, jav&quot;.hashCode());\n\t\tSystem.out.println(&quot;hello, java&quot;.hashCode());\n\t\tSystem.out.println(&quot;hello, javav&quot;.hashCode());\n\t\tSystem.out.println(&quot;AaAaA&quot;.hashCode());  \n\t\tSystem.out.println(&quot;AaAaAa&quot;.hashCode());\n\t\tSystem.out.println(&quot;AaAaAaA&quot;.hashCode()); &#x2F;&#x2F; 不同数据输入，查看结果\n\t\t\n        System.out.println(&quot;---------------------------&quot;);\n\t\t\n\t\tSystem.out.println(&quot;AaAaAa&quot;.hashCode());\n\t\tSystem.out.println(&quot;BBAaBB&quot;.hashCode()); &#x2F;&#x2F; 仍然是不同数据输入，再次查看结果\n    &#125;\n&#125;\n\n&#x2F;* outputs：\n2057144552\n2057144552 &#x2F;&#x2F; 相同的输入经过散列表算法运算后得到了相同的输出\n---------------------------\n-1596208487\n2057144552\n-653028210\n62984129\n1952508096\n398208897 &#x2F;&#x2F; 不同的输入“理所当然”地得到了完全不同的输出\n---------------------------\n1952508096\n1952508096 &#x2F;&#x2F; 不同的输入居然得到了相同的输出！\n*&#x2F;\n\n从以上实例中我们可以发现虽然一般的不同字符经过运算后输出的结果是不同的，但是也存在不同字符串在经过运算后得到了相同的输出\n特别地，我们将这种两个不同的输入值经过运算后得到了相同的输入值的情况称作是“Hash collision”\n需要指出的是，发生collision并不可怕，当一个更大的数据集被映射到一个更小的数据集或容器时，一定会出现多对一的情况，这是一件不可避免的事，而算法的优劣只取决于出现collision的频率如何。如果collision出现频次过高，那么就意味着这个Hash算法生成的Hash Code可以在较短时间内被别人使用穷举等办法来破解其内容——也就是说，它不安全，所以用户需要设置更长更复杂组合的密码，而服务器则需要使用更不容易被破解的Hash算法。\n一般来讲输出大小越长的算法，安全性也就越高。只有安全度足够高的Hash算法，即没有任何人能够成功实现碰撞的哈希，才有资格被考虑用在加密场合\n\n在极限情况下，传统的MD5算法可以保证最多340282366920938463463374607431768211456个数据与结果的一一对应，而SHA-1算法甚至可以保证最多1461501637330902918203684832716283019655932542976个数据，但是由于计算机算力的进步，算法自身的缺陷，现呈的彩虹表等的诸多原因存在，它们已经可以在短时间内被破解，为了保证数据的安全，我们需要使用更安全的Hash算法如SHA-2系列的Hash算法来做数据加密\n小结\n什么是Hash算法？\n\nHash算法，一般译为哈希算法，摘要算法或者散列算法，它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。\n\n\n哈希算法的特点？\n\n相同的输入一定得到相同的输出；\n不同的输入大概率得到不同的输出。\n\n\n哈希加密的作用：\n\n完整性校验：MD5，SHA-1\n数据加密：SHA-2系列等\n\n\n\nHash算法是怎么实现的？——以MD5为例Hash算法原理大同小异，大体上的流程包括对原数据块进行切片，再对切片进行细分，并利用每一细分小组的内容按预设算法进行破坏式压缩处理来得到最终的结果，下面以MD5算法为例介绍Hash算法流程\n原理概述：MD5算法先对数据块填充，将不合规的数据标准化。然后进行分组，标准是每512bit为大小分一组。在每一个分组中又进一步划分出16个32位的子分组。设立四个标准幻数，定义四个非线性函数，一个大小为64的常数数组，一个大小为64的位移常量数组。\n在计算过程中，根据512位分组的数据进行外循环，在这之中利用每个细分小组进行一轮16次循环一共4轮合64次的内循环。\n在单次内部循环中，根据正在进行的轮次运用四个非线性函数中的一个对子分组进行的数据进行处理，将处理的结果与标准幻数相加，并进行下一次循环。当主循环完成时，原标准幻数就与数据紧密联系起来，把所有标准幻数组合到一起，这就是一个基于MD5算法的Hash Code\n\n\n\n\n\n\n\n\n\n什么是幻数？\n不同领域对于幻数这一名称有不同的定义，而MD5中的幻数其实就是在算法中被预设的4个32位的整数，对于一个128位的MD5 Hash Code来说，由4个32位的整数结果彼此组和来得到最终结果貌似是一个不错的选择，而这4个结果就是由这4个标准幻数A,B,C,D根据数据块的内容按照预定算法经过不断演变得到的\n实际使用的标准幻数：\nA &#x3D; 0x67452301\nB &#x3D; 0xEFCDAB89\nC &#x3D; 0x98BADCFE\nD &#x3D; 0x10325476 \n\n注意，其实这四个标准幻数和ABCD四个字母全无关系，实际生效的只是他们后面的变量值，而这四个值只是被算法规定如此而已也许这也算是一种另类的私货？\n详细流程介绍：填充首先将原数据进行补长（长度的度量是bits）到一个对512取模的结果为448的数在补长的过程中，我们先在原数据末尾append “1” bit to message，然后再append “0” bits until message length in bits ≡ 448 (mod 512)\n完成了补长之后，利用最后的64位（512-448=64）来记录填充前的长度(append original length in bits mod 2^64^ to message)\n当上述两个操作都完成以后，数据的总长度就是512的倍数了\n一定要补长(64+1~512)，内容为100…0（如若消息长448，则填充512+64）\n计算首先把结果分割为N个512位的块：Y0，Y1，…（每一个512位块再细分为16个32比特子组） \n每个块都进行一次循环，在当前循环中，我们将整个块再次细分为16个32位的子块\n在正式开始循环之前，我们还需要这些东西：\n\n设立四个标准幻数\n\n\n我们无需考究这四个数字的16进制内容有什么含义，但是规律明显得让人不禁发笑\n我们分别以ABCD为名设立四个32位的整数变量，A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476，这就是实际使用到的标准幻数\n\n定义四个非线性函数：\n ![image-20210917103252897](MD5’s function.png)\n\n定义常量数组(正弦函数表)：\nfor i in range(0, 64)\n    k[i] &#x3D; math.floor(math.fabs(math.sin(i + 1)) * (2 ** 32))\n# 或者直接赋值：\nk &#x3D; [\n     0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n      0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,\n      0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n      0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,\n      0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n      0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n      0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n      0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391\n]\n\n\n\n\n\n\n\n\n\n\n和为什么标准幻数被定义成那样子一样，解释为什么常量数组是这些东西的理由也只有“它是被定义成这样子的”。不过常量数组有一个优势：我们可以了解这些数字具体是怎么来的：\n你应该已经看见了定义常量数组的第一种（即利用正弦函数实时生成的）办法，这就是这些数据产生的来源。\n\n定义位移常量:\n# md5转换用到的常量，数据都是算法本身规定的\nr &#x3D; [\n    7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n\t5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n\t4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n\t6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21\n]\n\n\n\n\n\n\n\n\n\n\n事实上：所有常量都是经由算法规定的，毕竟只有经过被“规定”的步骤才能保证结果的一致性\n循环计算\n循环分为内层和外层，外层是对512块进行循环，内层则对32位子块进行循环\n每次外层循环中，我们共会进行四轮内层循环，每次内层循环我们都会按顺序对单个32位子块进行处理\nfor i in outside: # 外层循环\n    for t in range(0, 64): # 内层总循环\n        if 0 ≤ i ≤ 15:\n            f &#x3D; (b &amp; c) | (~b &amp; d) # 临时变量f，实际上是存储了当前轮次的非线性函数的结果\n            g &#x3D; i # 存储当前轮次下的第几次\n        else if 16 ≤ i ≤ 31:\n            f &#x3D; (d &amp; b) | ((~d) &amp; c)\n            g &#x3D; (5×i + 1) % 16\n        else if 32 ≤ i ≤ 47:\n            f &#x3D; b ^ c ^ d\n            g &#x3D; (3×i + 5) % 16\n        else if 48 ≤ i ≤ 63:\n            f &#x3D; c ^ (b | (~ d))\n            g &#x3D; (7×i) % 16\n        temp &#x3D; d\n        d &#x3D; c\n        c &#x3D; b\n        b &#x3D; ((a + f + k[i] + w[g]) &lt;&lt; r[i]) + b\n        # w[g]是当前顺序下的32位数据子块,k[i]是我们已经生成好的常量数组,r[i]则是当前轮次所使用到的左移量\n        a &#x3D; temp\n    A &#x3D; A + a\n    B &#x3D; B + b \n    C &#x3D; C + c\n    D &#x3D; D + d\n\n每次：一个输入128位，另一个输入512位，结果输出128位，用于下一轮输入 \n\n结果\n\ndigest &#x3D; str(A) + str(B) + str(C) + str(D)\n\n //最后一步的输出即为散列结果，共128位。\n又如SHA-1等算法原理与MD5大同小异，主要的变化之处在于：增加初始的标准幻数个数，增加循环轮数与参与范围，改变变换的非线性函数等\n怎么改进Hash算法？虽然我们认为哈希算法是一种“有损的压缩运算”，但是其攻击手段并不少，而当今Hash解密网站更是不胜枚举\nmd5在线解密破解,md5解密加密 (cmd5.com)\n彩虹表Rainbow table - Wikipedia\n（总结）密码破解之王：Ophcrack彩虹表(Rainbow Tables)原理详解（附：120G彩虹表下载） (ha97.com)\n什么是彩虹表？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/19790488/answer/19290308\n“加盐”(salting)\n\n\n\n\n\n\n\n\n给密码加一个随即的前缀或者后缀，然后再进行hash。这个随即的后缀或者前缀成为“盐”。通过加盐，相同的密码经过hash后就可以得到不一样的字符串了。检查用户输入的密码是否正确的时候，我们也还需要这个盐，所以盐一般都是跟hash一起保存在数据库里，或者作为hash字符串的一部分。\n盐不需要保密，只要盐是随机的话，查表，彩虹表都会失效。因为攻击者无法事先知道盐是什么，也就没有办法预先计算出查询表和彩虹表。如果每个用户都是使用了不同的盐，那么反向查表攻击也没法成功。\n因为能取得的“最好的结果”，也就是取得加盐后的密码，那究竟哪部分是我们添加的“盐”呢，黑客不知道\n下面是另一角度的思考：\n\n\n\n\n\n\n\n\n\n为什么加盐哈希可以抵御彩虹表\n彩虹表在生成的过程中，针对的是特定的函数H，H如果发生了改变，则已有的彩虹表数据就完全无法使用。\n生成彩虹表需要先预先选定一些口令，再一步步生成。然而如果加盐的话，会导致之前生成的那些口令都没有用了。（正确的口令需要有加了盐的格式），因此可以抵御彩虹表攻击。\n详见：\n加盐hash保存密码的正确方式 - D＆G (wooyun.js.org)\n彩虹表攻击 - 莫须有- - 博客园 (cnblogs.com)\n","slug":"Algorithm/HashFunction/HashFunction","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Hash","author_index":"JBR_Bunjie"},{"id":"120c49bf67650504f15740668777cd42","title":"Heap Sort - 堆排序","content":"Heap Sort - 堆排序Reference：\nRecommend：堆排序之JAVA实现月光下一只赏月的猪的博客-CSDN博客java 堆排序\n（高效率排序算法三）堆排序_送人玫瑰手留余香的博客-CSDN博客_堆排序效率\n1.7 堆排序 | 菜鸟教程 (runoob.com)\n\nDetail：\n两个定义：\n\n\n\n\n\n\n\n\n\n\n大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；\n小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；\n\n步骤描述：\n\n\n\n\n\n\n\n\n\n\n\n创建一个堆 H[0……n-1]；\n把堆首（最大值）和堆尾互换；\n把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n重复步骤 2，直到堆的尺寸为 1。\n\n\n分析：\n\n堆排序的平均时间复杂度为 Ο(nlogn)。\nCode：Code - JavaScriptvar len;    &#x2F;&#x2F; 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量\n\nfunction buildMaxHeap(arr) &#123;   &#x2F;&#x2F; 建立大顶堆\n    len &#x3D; arr.length;\n    for (var i &#x3D; Math.floor(len&#x2F;2); i &gt;&#x3D; 0; i--) &#123;\n        heapify(arr, i);\n    &#125;\n&#125;\n\nfunction heapify(arr, i) &#123;     &#x2F;&#x2F; 堆调整\n    var left &#x3D; 2 * i + 1,\n        right &#x3D; 2 * i + 2,\n        largest &#x3D; i;\n\n    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;\n        largest &#x3D; left;\n    &#125;\n\n    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;\n        largest &#x3D; right;\n    &#125;\n\n    if (largest !&#x3D; i) &#123;\n        swap(arr, i, largest);\n        heapify(arr, largest);\n    &#125;\n&#125;\n\nfunction swap(arr, i, j) &#123;\n    var temp &#x3D; arr[i];\n    arr[i] &#x3D; arr[j];\n    arr[j] &#x3D; temp;\n&#125;\n\nfunction heapSort(arr) &#123;\n    buildMaxHeap(arr);\n\n    for (var i &#x3D; arr.length-1; i &gt; 0; i--) &#123;\n        swap(arr, 0, i);\n        len--;\n        heapify(arr, 0);\n    &#125;\n    return arr;\n&#125;\n\nCode - Pythondef buildMaxHeap(arr):\n    import math\n    for i in range(math.floor(len(arr)&#x2F;2),-1,-1):\n        heapify(arr,i)\n\ndef heapify(arr, i):\n    left &#x3D; 2*i+1\n    right &#x3D; 2*i+2\n    largest &#x3D; i\n    if left &lt; arrLen and arr[left] &gt; arr[largest]:\n        largest &#x3D; left\n    if right &lt; arrLen and arr[right] &gt; arr[largest]:\n        largest &#x3D; right\n\n    if largest !&#x3D; i:\n        swap(arr, i, largest)\n        heapify(arr, largest)\n\ndef swap(arr, i, j):\n    arr[i], arr[j] &#x3D; arr[j], arr[i]\n\ndef heapSort(arr):\n    global arrLen\n    arrLen &#x3D; len(arr)\n    buildMaxHeap(arr)\n    for i in range(len(arr)-1,0,-1):\n        swap(arr,0,i)\n        arrLen -&#x3D;1\n        heapify(arr, 0)\n    return arr\n\n","slug":"Algorithm/SORT/Heap Sort","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Sort","author_index":"JBR_Bunjie"},{"id":"01d132f13ac67dff21350f57c338a855","title":"拓扑排序","content":"拓扑排序Reference：拓扑排序（Topological Sorting） | 神奕的博客 (songlee24.github.io)\nDetail：\n\n\n\n\n\n\n\n\n在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：\n\n每个顶点出现且只出现一次。\n若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。\n\n有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。\n在sugiyama算法的“分层”步骤中，我们相当于直接用到了这种思路\n唯一的不同是：\n拓扑排序根据顺序剔除边后入度为零的全部节点生成了一个序列\n而sugiyama将当前所有为零的节点并入独立的一整层\n用途？\n\n\n\n\n\n\n\n\n拓扑排序通常用来“排序”具有依赖关系的任务。\n比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边 表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。\n","slug":"Algorithm/SORT/Topological Sort","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Sort","author_index":"JBR_Bunjie"},{"id":"0d08c32366a524bf34b2dc2c2fb0333a","title":"Boyer Moore Algorithm","content":"Boyer Moore AlgorithmGeneral高效，可靠，应用广泛：各种文本编辑器的”查找”功能（Ctrl+F），大多采用Boyer-Moore算法\n1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了这种算法。\nDetail“坏字符规则”\n\n\n\n\n\n\n\n\n后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置\n如果”坏字符”不包含在搜索词之中，则上一次出现位置为 -1。\n“好后缀规则”\n\n\n\n\n\n\n\n\n后移位数 = 好后缀的(最后)位置 - 后缀(在搜索词中)的上一次出现位置\n注意点：\n\n“好后缀”的位置以最后一个字符为准。假定”ABCDEF”的”EF”是好后缀，则它的位置以”F”为准，即5（从0开始计算）\n如果”好后缀”在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，”EF”在”ABCDEF”之中只出现一次，则它的上一次出现位置为-1（即未出现）\n如果”好后缀”有多个，则除了最长的那个”好后缀”，其他”好后缀”的上一次出现位置必须在头部。比如，假定”BABCDAB”的”好后缀”是”DAB”、”AB”、”B”，请问这时”好后缀”的上一次出现位置是什么？回答是，此时采用的好后缀是”B”，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个”好后缀”只出现一次，则可以把搜索词改写成如下形式进行位置计算”(DA)BABCDAB”，即虚拟加入最前面的”DA”\n\nCodepublic static int pattern(String pattern, String target) &#123;\n    int tLen &#x3D; target.length();&#x2F;&#x2F;主串的长度\n    int pLen &#x3D; pattern.length();&#x2F;&#x2F;模式串的长度\n\n\t&#x2F;&#x2F;如果模式串比主串长，没有可比性，直接返回-1\n    if (pLen &gt; tLen) &#123;\n        return -1;\n    &#125;\n\n    int[] bad_table &#x3D; build_bad_table(pattern);&#x2F;&#x2F; 获得坏字符数值的数组，实现看下面\n    int[] good_table &#x3D; build_good_table(pattern);&#x2F;&#x2F; 获得好后缀数值的数组，实现看下面\n\n    for (int i &#x3D; pLen - 1, j; i &lt; tLen;) &#123;\n        System.out.println(&quot;跳跃位置：&quot; + i);\n        &#x2F;&#x2F;这里和上面实现坏字符的时候不一样的地方，我们之前提前求出坏字符以及好后缀\n        &#x2F;&#x2F;对应的数值数组，所以，我们只要在一边循环中进行比较。还要说明的一点是，这里\n        &#x2F;&#x2F;没有使用skip记录跳过的位置，直接针对主串中移动的指针i进行移动\n        for (j &#x3D; pLen - 1; target.charAt(i) &#x3D;&#x3D; pattern.charAt(j); i--, j--) &#123;\n            if (j &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;指向模式串的首字符，说明匹配成功，直接返回就可以了\n                System.out.println(&quot;匹配成功，位置：&quot; + i);\n                &#x2F;&#x2F;如果你还要匹配不止一个模式串，那么这里直接跳出这个循环，并且让i++\n                &#x2F;&#x2F;因为不能直接跳过整个已经匹配的字符串，这样的话可能会丢失匹配。\n&#x2F;&#x2F;\t\t\t\t\ti++;   &#x2F;&#x2F; 多次匹配\n&#x2F;&#x2F;\t\t\t\t\tbreak;\n                return i;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;如果出现坏字符，那么这个时候比较坏字符以及好后缀的数组，哪个大用哪个\n        i +&#x3D; Math.max(good_table[pLen - j - 1], bad_table[target.charAt(i)]);\n    &#125;\n    return -1;\n&#125;\n\n&#x2F;&#x2F;字符信息表\npublic static int[] build_bad_table(String pattern) &#123;\n    final int table_size &#x3D; 256;&#x2F;&#x2F;上面已经解释过了，字符的种类\n    int[] bad_table &#x3D; new int[table_size];&#x2F;&#x2F;创建一个数组，用来记录坏字符出现时，应该跳过的字符数\n    int pLen &#x3D; pattern.length();&#x2F;&#x2F;模式串的长度\n\n    for (int i &#x3D; 0; i &lt; bad_table.length; i++) &#123;\n        bad_table[i] &#x3D; pLen;  \n        &#x2F;&#x2F;默认初始化全部为匹配字符串长度,因为当主串中的坏字符在模式串中没有出\n        &#x2F;&#x2F;现时，直接跳过整个模式串的长度就可以了\n    &#125;\n    for (int i &#x3D; 0; i &lt; pLen - 1; i++) &#123;\n        int k &#x3D; pattern.charAt(i);&#x2F;&#x2F;记录下当前的字符ASCII码值\n        &#x2F;&#x2F;这里其实很值得思考一下，bad_table就不多说了，是根据字符的ASCII值存储\n        &#x2F;&#x2F;坏字符出现最右的位置，这在上面实现坏字符的时候也说过了。不过你仔细思考\n        &#x2F;&#x2F;一下，为什么这里存的坏字符数值，是最右的那个坏字符相对于模式串最后一个\n        &#x2F;&#x2F;字符的位置？为什么？首先你要理解i的含义，这个i不是在这里的i，而是在上面\n        &#x2F;&#x2F;那个pattern函数的循环的那个i，为了方便我们称呼为I，这个I很神奇，虽然I是\n        &#x2F;&#x2F;在主串上的指针，但是由于在循环中没有使用skip来记录，直接使用I随着j匹配\n        &#x2F;&#x2F;进行移动，也就意味着，在某种意义上，I也可以直接定位到模式串的相对位置，\n        &#x2F;&#x2F;理解了这一点，就好理解在本循环中，i的行为了。\n\n\t\t&#x2F;&#x2F;其实仔细去想一想，我们分情况来思考，如果模式串的最\n        &#x2F;&#x2F;后一个字符，也就是匹配开始的第一个字符，出现了坏字符，那么这个时候，直\n        &#x2F;&#x2F;接移动这个数值，那么正好能让最右的那个字符正对坏字符。那么如果不是第一个\n        &#x2F;&#x2F;字符出现坏字符呢？这种情况你仔细想一想，这种情况也就意味着出现了好后缀的\n        &#x2F;&#x2F;情况，假设我们将最右的字符正对坏字符\n        bad_table[k] &#x3D; pLen - 1 - i;\n    &#125;\n    return bad_table;\n&#125;\n\n&#x2F;&#x2F;匹配偏移表\npublic static int[] build_good_table(String pattern) &#123;\n    int pLen &#x3D; pattern.length();&#x2F;&#x2F;模式串长度\n    int[] good_table &#x3D; new int[pLen];&#x2F;&#x2F;创建一个数组，存好后缀数值\n    &#x2F;&#x2F;用于记录最新前缀的相对位置，初始化为模式串长度，因为意思就是当前后缀字符串为空\n    &#x2F;&#x2F;要明白lastPrefixPosition 的含义\n    int lastPrefixPosition &#x3D; pLen;\n\n    for (int i &#x3D; pLen - 1; i &gt;&#x3D; 0; --i) &#123;\n        if (isPrefix(pattern, i + 1)) &#123;\n        &#x2F;&#x2F;如果当前的位置存在前缀匹配，那么记录当前位置\n            lastPrefixPosition &#x3D; i + 1;\n        &#125;\n        good_table[pLen - 1 - i] &#x3D; lastPrefixPosition - i + pLen - 1;\n    &#125;\n\n    for (int i &#x3D; 0; i &lt; pLen - 1; ++i) &#123;\n    &#x2F;&#x2F;计算出指定位置匹配的后缀的字符串长度\n        int slen &#x3D; suffixLength(pattern, i);\n        good_table[slen] &#x3D; pLen - 1 - i + slen;\n    &#125;\n    return good_table;\n&#125;\n\n&#x2F;&#x2F;前缀匹配\nprivate static boolean isPrefix(String pattern, int p) &#123;\n    int patternLength &#x3D; pattern.length();&#x2F;&#x2F;模式串长度\n    &#x2F;&#x2F;这里j从模式串第一个字符开始，i从指定的字符位置开始，通过循环判断当前指定的位置p\n    &#x2F;&#x2F;之后的字符串是否匹配模式串前缀\n    for (int i &#x3D; p, j &#x3D; 0; i &lt; patternLength; ++i, ++j) &#123;\n        if (pattern.charAt(i) !&#x3D; pattern.charAt(j)) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\n\n&#x2F;&#x2F;后缀匹配\nprivate static int suffixLength(String pattern, int p) &#123;\n    int pLen &#x3D; pattern.length();\n    int len &#x3D; 0;\n    for (int i &#x3D; p, j &#x3D; pLen - 1; i &gt;&#x3D; 0 &amp;&amp; pattern.charAt(i) &#x3D;&#x3D; pattern.charAt(j); i--, j--) &#123;\n        len +&#x3D; 1;\n    &#125;\n    return len;\n&#125;\n\nReference\n字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志 (ruanyifeng.com)\n不用找了，学习BM算法，这篇就够了（思路+详注代码）_BoCong-Deng的博客-CSDN博客_bm算法\n\n","slug":"Algorithm/String Processing/Boyer Moore Algorithm","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"String Processing","author_index":"JBR_Bunjie"},{"id":"3300e6e8edea21eb33ad89b2150bf9cc","title":"R&K Algorithm","content":"Rabin–Karp algorithm - 拉宾-卡普算法拉宾-卡普算法（英語：Rabin–Karp algorithm）或卡普-拉宾算法（Karp–Rabin algorithm）\nGeneralRabin-Karp 算法是由 Richard M. Karp和 Michael O. Rabin创建的字符串搜索算法\nKR Algorithm使用散列来查找文本中的一组模式字符串中的任何一个。\nDetail假设我们有一个文本： yeminsajid ，我们想知道文本中是否存在模式 nsa 。要计算散列和滚动散列，我们需要使用素数。这可以是任何素数。让我们在这个例子中使用 prime = 11 。我们将使用以下公式确定哈希值：\n(1st letter) X (prime) + (2nd letter) X (prime)¹ + (3rd letter) X (prime)² X + ......\n\n我们将表示：\na -&gt; 1    g -&gt; 7    m -&gt; 13   s -&gt; 19   y -&gt; 25\nb -&gt; 2    h -&gt; 8    n -&gt; 14   t -&gt; 20   z -&gt; 26\nc -&gt; 3    i -&gt; 9    o -&gt; 15   u -&gt; 21\nd -&gt; 4    j -&gt; 10   p -&gt; 16   v -&gt; 22\ne -&gt; 5    k -&gt; 11   q -&gt; 17   w -&gt; 23\nf -&gt; 6    l -&gt; 12   r -&gt; 18   x -&gt; 24\n\nnsa 的哈希值为 ：$$HASH(nsa) = 14 * 11^0 + 19 * 11^1 + 1 * 11^2 = 344$$\n现在我们找到文本的滚动哈希值。如果滚动哈希与模式的哈希值匹配，我们将检查字符串是否匹配。因为我们的模式有 3 个字母，我们将采取 1 日 3 封 YEM 从我们的文本，并计算哈希值。我们得到：$$HASH(yem) = 25 * 11^0 + 5 * 11^1 + 13 * 11^2 = 1653$$此值与我们的模式的哈希值不匹配。所以字符串在这里不存在。现在我们需要考虑下一步。计算下一个字符串 emi 的哈希值。我们当然可以直接重新从。但这将是相当微不足道的，并且会花费更多。相反，我们使用另一种技术。\n\n我们从当前哈希值中减去 Previous String 中的 第一个字母的 即 y 的值。即：1653 - 25 = 1628。\n再次除以设定的素数 prime——11，可得：1628 / 11 = 148`。\n最后加上新的字母 *（素数）^ m - 1，可得：148 + 9 X 11² = 1237。\n\n新的哈希值不等于我们的模式哈希值。继续前进直到 a (nsa)，有：\nPrevious String: ins\nFirst Letter of Previous String: i(9)\nNew Letter: a(1)\nNew String: &quot;nsa&quot;\n------------------------------\n2462 - 9 &#x3D; 2453\n2453 &#x2F; 11 &#x3D; 223\n223 + 1 X 11² &#x3D; 344\n\n这是一个匹配！ 现由于两个字符串都匹配，因此匹配字符串存在于目标字符串中，现在我们只需要返回目标字符串匹配字段的起始位置即可。\nCodeKR - JS&#x2F;**\n * @param &#123;string&#125; haystack\n * @param &#123;string&#125; needle\n * @return &#123;number&#125;\n *&#x2F;\n&#x2F;*\n\n*&#x2F;\n&#x2F;**\n * @param &#123;string&#125; haystack\n * @param &#123;string&#125; needle\n * @return &#123;number&#125;\n *&#x2F;\nvar strStr &#x3D; function(haystack, needle)&#123;\n    if(needle.length &#x3D;&#x3D; 0) return 0;\n    let n &#x3D; haystack.length;\n    let m &#x3D; needle.length;\n    let s &#x3D; &#39; &#39;+haystack;\n    let t &#x3D; &#39; &#39;+needle;\n    \n    &#x2F;&#x2F;String添加一个重新确定字符值得方法\n    String.prototype.newCode &#x3D; function()&#123;\n        return this.charCodeAt()-97+1;\n    &#125;\n    &#x2F;&#x2F;确定模数 尽量避免冲突\n    let p &#x3D; 999991, d &#x3D; 131;\n    &#x2F;&#x2F;计算thash\n    let tHash &#x3D; 0;\n    for(let i&#x3D;1; i&lt;&#x3D;m; i++)&#123;\n        tHash &#x3D; (tHash*d + t[i].newCode()) % p;\n    &#125;\n    &#x2F;&#x2F;计算sHash子串的值\n    let sHash &#x3D; new Array(n+1);\n    sHash[0] &#x3D; 0;\n    for(let i&#x3D;1; i&lt;&#x3D;n; i++)&#123;\n        sHash[i] &#x3D; (sHash[i-1]*d + s[i].newCode()) % p;\n    &#125;\n   \n\n    &#x2F;&#x2F;hello ll\n    for(let i&#x3D;m; i&lt;&#x3D;n; i++)&#123;\n        if(calcHash(i-m, i, m) &#x3D;&#x3D; tHash)&#123;\n            return i-m;\n        &#125;\n    &#125;\n    return -1;\n    function calcHash(l, r, len)&#123;\n        &#x2F;&#x2F;_hello  求ll的hash\n        &#x2F;&#x2F;先求_hell的hash, 再求_he的hash进行补位\n        &#x2F;&#x2F;_hell - _he00 就是ll\n        &#x2F;&#x2F;注意相减的时候为避免负数，可以先加上模数。再取模\n        return (sHash[r] - (sHash[l]*myPow(d, len, p))%p + p) % p;\n    &#125;\n&#125;\nfunction myPow(x,n, m)&#123;\n    function helper(x,n)&#123;\n        if(n&#x3D;&#x3D;0) return 1.0;\n        let y &#x3D; helper(x, n&#x2F;2 | 0);\n        return n%2 &#x3D;&#x3D;0 ? (y*y)%m: (y*y*x)%m;\n    &#125;\n    return n&gt;&#x3D;0? helper(x, n) : 1.0&#x2F;helper(x, n);\n&#125;\n\n\n\nReference\nRabin-Karp 算法简介 | 他山教程，只选择最优质的自学材料 (tastones.com)\n28. 实现 strStr() 题解 - 力扣（LeetCode） (leetcode-cn.com)\n\n","slug":"Algorithm/String Processing/KR&RK","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"String Processing","author_index":"JBR_Bunjie"},{"id":"53896b079468d4c41963b2300dea196e","title":"KMP","content":"KMP算法KMP算法作用简介：在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。\nKMP算法原理：1.前缀与后缀\n\n\n\n\n\n\n\n\n几个必须明确的概念：前缀、后缀、相同前缀后缀的最大长度（为表述方便，下文均用公共最大长指代）\n\nabcdef的前缀：a、ab、abc、abcd、abcde（注意：abcdef不是前缀）\nabcdef的后缀：f、ef、def、cdef、bcdef（注意：abcdef不是后缀）\nabcdef的公共最大长：0（因为其前缀与后缀没有相同的）\nababa的前缀：a、ab、aba、abab\nababa的后缀：a、ba、aba、baba\nababa的公共最大长：3（因为他们的公共前缀后缀中最长的为aba，长度3）\n\n2.确定PMT (Partial Match Table)\n\n\n\n\n\n\n\n\n“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，\n\n“A”的前缀和后缀都为空集，共有元素的长度为0；其value为\n“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；　　\n“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；　　\n“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；　　\n“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；　　\n“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；　　\n“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。\n\n得表：\n\nKMP算法的Python实现：class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n        def KMP(s, p):\n            &quot;&quot;&quot;\n            s 为主串\n            p 为模式串\n            如果 t 里有 p，返回打头下标\n            &quot;&quot;&quot;\n            nex &#x3D; getNext(p)\n            i &#x3D; 0\n            j &#x3D; 0   # 分别是 s 和 p 的指针\n            while i &lt; len(s) and j &lt; len(p):\n                if j &#x3D;&#x3D; -1 or s[i] &#x3D;&#x3D; p[j]: # j &#x3D;&#x3D; -1 是由于 j &#x3D; next[j]产生\n                    i +&#x3D; 1\n                    j +&#x3D; 1\n                else:\n                    j &#x3D; nex[j]\n\n            if j &#x3D;&#x3D; len(p): # j 走到了末尾，说明匹配到了\n                return i - j\n            else:\n                return -1\n\n        def getNext(p):\n            &quot;&quot;&quot;\n            p 为模式串\n            返回 next 数组，即部分匹配表\n            &quot;&quot;&quot;\n            nex &#x3D; [0] * (len(p) + 1)\n            nex[0] &#x3D; -1\n            i &#x3D; 0\n            j &#x3D; -1\n            while i &lt; len(p):\n                if j &#x3D;&#x3D; -1 or p[i] &#x3D;&#x3D; p[j]:\n                    i +&#x3D; 1\n                    j +&#x3D; 1\n                    nex[i] &#x3D; j     # 这是最大的不同：记录next[i]\n                else:\n                    j &#x3D; nex[j]\n\n            return nex\n        \n        return KMP(haystack, needle)\n\n\n\nReference\n字符串匹配的KMP算法 - 阮一峰的网络日志 (ruanyifeng.com)\n如何更好地理解和掌握 KMP 算法? - 白鱼咸蛋笨大的回答 - 知乎 https://www.zhihu.com/question/21923021/answer/642165149\n如何更好地理解和掌握 KMP 算法? - 海纳的回答 - 知乎 https://www.zhihu.com/question/21923021/answer/281346746 (第一个示例比较特殊)\n\n","slug":"Algorithm/String Processing/KMP","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"String Processing","author_index":"JBR_Bunjie"},{"id":"9804ef7a4cf22f333e494cd94f29c482","title":"Cpp `#pragma Once` and `#ifndef`","content":"Source\n在 C++ 中防止头文件被重复包含时为什么同时使用 #ifndef 和 #pragma once？ - 望山的回答 - 知乎 https://www.zhihu.com/question/40990594/answer/1675549910\n\n#pragma once - 维基百科，自由的百科全书 (wikipedia.org)\n\n\n结论：请同时使用#ifdef与#pragma once\n解释：如果所用的编译器支持#pragma once，则可以加快我们的编译速度；如果不支持，也会有#ifdef语句来兜底\n\n\n\n\n\n\n\n\n\n使用#pragma once代替include防范将加快编译速度，因为这是一种高阶的机制；编译器会自动比对档案名称或inode而不需要在标头档去判断#ifndef和#endif。\n\n\n\n\n\n\n\n\n\n使用#ifndef的话，缺点不单单是需要多写两行代码和想出一个合适的#define名字，更大的缺点是它要求编译器一直扫描到文件尾，找到对应的#endif，才能确定你的意图是整个头文件都要略过。然而这时候已经花费了许多CPU时间（和电能），前面做的那么多都是白忙。\n","slug":"Language Learning/CPP/[F]PragmaOnce","date":"2022-12-23T04:23:23.000Z","categories_index":"Coding Language","tags_index":"CPP","author_index":"JBR_Bunjie"},{"id":"b7afcba22e06e2e680735e918e5fcad8","title":"Encoding Methods","content":"计算机编码梳理ASCII码描述这是计算机编码发展历程里的第一阶段：ASCII码，即：American Standard Code for Information Interchange，美国信息交换标准代码\n设计思路：在计算机内部存储单元的最小单位时Byte。不过Byte仍然可以细分：每一个二进制位是一个bit，有0和1两种状态。8个bit构成一个byte——所有的信息最终都表示为一个二进制的字符串。\n在这个基础上，如果利用0和1各代表一个状态，由于一个byte有8个bit，故总共可以表示2的8次方＝256个状态。若是每个状态对应一个符号，一个byte可以表示256个符号，也就是从0000000到11111111。\n根据这个思路，美国在上个世纪60年代制定了一套字符编码，用于安排控制字符、英语字符、数字等符号与二进制位之间对应的关系，形成了大名鼎鼎的ASCII码。\n但ASCII码一共只规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，而由于使用了8位二进制，故规定最前面的第一位二进制数则为0。\n\n\n\n\n\n\n\n\n\n 可以访问：ASCII Code - The extended ASCII table (ascii-code.com)了解\n现状：时至今日，仍然有很多语言采用这一编码作为默认编码，比如Python2等语言\n\n\n\n\n\n\n\n\n\nPython2的 默认编码是ASCII，不能识别中文字符，需要显式指定字符编码；而Python3的默认编码改为了Unicode，可以识别中文字符\n采用ASCII编码主要的字符集：Windows-1252字符集、ISO8859-1字符集\nASCII实现思路\n所有的控制字符(比如CR回车、DEL删除等)编码在0-31范围以及127中。\n把所有的标点符号，英文大小写全部放在32-126范围中。\n\nASCII实现形式\n0xxxx xxxx\n\n示例String str &#x3D; new String(&quot;华侨永亨银行&quot;);\n&#x2F;&#x2F; 采用UTF-8编码得到字节数组\nbyte[] bytes &#x3D; str.getBytes(&quot;UTF-8&quot;);\n&#x2F;&#x2F; bytes: &#123;e5 8d 8e e4 be a8 e6 b0 b8 e4 ba a8 e9 93 b6 e8 a1 8c&#125;\n&#x2F;&#x2F; 注意第二个字节0x8d，在下面的编解码中被自动转换成了3f\n\n&#x2F;&#x2F; 采用Windows-1252解码得到字符串\nstr &#x3D; new String(bytes, &quot;Windows-1252&quot;);\n&#x2F;&#x2F; 采用windows-1252编码，还原字节数组\nbytes &#x3D; str.getBytes(&quot;Windows-1252&quot;);\n&#x2F;&#x2F; bytes: &#123;e5 3f 8e e4 be a8 e6 b0 b8 e4 ba a8 e9 93 b6 e8 a1 8c&#125;\n\n&#x2F;&#x2F; 采用UTF-8解码，预期得到原字符串\nstr &#x3D; new String(bytes, &quot;UTF-8&quot;);\n&#x2F;&#x2F; str: ???侨永亨银行,第一个字被永久性破坏\n&#x2F;&#x2F; 引自：https:&#x2F;&#x2F;blog.csdn.net&#x2F;zou8944&#x2F;article&#x2F;details&#x2F;79859112\n\n\n\n\n\n\n\n\n\n\n不过，这个例子对Python不生效，因为python取了个巧:\n![image-20210910211848379](image-20210910211848379 - copy.png)\n![restsdafa](image-20210910211923507 - Copy.png)\nGB2312&amp;GBK说明英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。\n以中文为例，汉字有10万左右，即使是常用字也有六七千，必须得用多个字节来表示。\n最先诞生的是GB2312编码。对于该编码，我们只需要明白以下两点：\n\n该编码可以表示大概7000左右个字符。其中有中文及一些常见的拉丁字母等。基本可以覆盖我们日常打字使用。\n\n该编码完全兼容ASCII码，计算机去读的时候首先判断最高位，如果是0，那么这个字符只占用一个字节，表示的内容跟ASCII码表示的一样。如果该字符最高位是1，那么该字节连同下一个字节表示一个中文汉字。所以平常咱们常说的英文一个字节，中文两个字节其实是从这里来的。\n\n\nGB2312实现形式\n0xxxxxxx：表示为ASCII字符\n1xxxxxxx 1xxxxxxx：表示为汉字\n\n后来？两个字节最多可以表示的字符数是 2^16＝65536，如果要求首位必须是1，那么最多可以表示 32768 个字符，但是GB2312 只用了其中的7000左右的字符。这显然是没有做到物尽其用，而且如果有些特殊的中文，GB2312根本表示不了。所以GBK就应运而生了。\nGBK 就尽量将能用到的状态都表示成中文字符了，当然最终还是有些状态没办法用（具体可以自行查找文档），最终可以表示23940个字符，其中有21003是汉字。\nGBK是完全兼容GB2312的，所以GBK的应用是很广泛的，而且从Windows95开始，Windows的中文版默认中文支持就是GBK编码。你可以通过在cmd下输入chcp命令来查看你当前系统的默认编码\n\n\n\n\n\n\n\n\n\n在GBK后还有GB18030等，不再解释\nGBK实现形式：\n0xxxxxxx：表示为ASCII字符\n1xxxxxxx xxxxxxxx：表示为汉字\n\nUnicodeGBK基本解决了中文编码问题，但另外一个大问题随之而来，那就是国际化。\n从我们的视角看，我们按照这种方式来表示简体中文和英文，成了是成了，可是繁体中文怎么表示？日文又怎么表示？\n而又从他们的视角看，当然他们也利用最高位来做文章，发明了big5（台湾繁体），JIS（日文）等兼容ASCII码的编码格式，但是这几种编码之间是并不兼容的。一段GBK编码的文件在台湾友人的电脑里打开就是乱码了。\n这时候，Unicode就诞生了。\nUnicode – The World Standard for Text and Emoji\n完全弄明白Unicode的细节是非常困难的，我们也是明白以下几点就够了：\n\nUnicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n\nUnicode 编码是给世界上所有的符号都分配了一个码。GBK最多也只能表示3万多的汉字，康熙字典里面的大部分汉字都没法用GBK表示，但是Unicode就能，它(大概)可以表示这个星球上所有的符号。\n\nUnicode有UCS-2和UCS-4两种编码，2和4都是代表字节的意思，也就是说前者用两个字节表示，后者用4个字节表示。所以，UCS-2的表示范围是65536个字符，而UCS-4则可以表示超过22亿个字符，我想这真的是可以表示所有的字符了。其实日常使用我们用的只是UCS-2，一般说的Unicode编码也是只它。它包含了所有的简体中文，现用的繁体中文，火星文，以及其他国家的现用文字。古籍中的文字就得去UCS-4中去找了。\n\n\n值得注意的是：Unicode中，中文的编码范围为4E00-9FCF，其中9FC4-9FCF之间的区间没有使用。\n一个比较突出的问题就是这个区间全部都是文字，而中文标点没有包含在其中，反而散落在各个位置。同时，一些特殊的文字和中文部首以及一些特殊符号也不在此范围内，需要特别注意。\nUTF-8说明很遗憾，Unicode并不是完美的。不完美的地方主要有两点：\n1）不兼容ASCII码。因为Unicode是用两个字节表示，ASCII码范围内的字符都被扩充成了两个字节，前面又补了8个0。所以，如果你的电脑只支持Unicode编码的话，所有的英文资料全都没法阅读了。\n2）占用的存储变大，如果涉及到传输，所耗费的流量也会变大。中文文本还好，英文就相当明显。纯英文文本所消耗的存储比以前增大了一倍。\n这个时候就出现了诸如UTF-8等实现方式。这里我们只讨论UTF-8，因为它是使用最广泛的。它弥补了Unicode的缺陷，同时主要有以下几个优点。\n\nUTF-8与Unicode是一一对应的。所以UTF-8是国际化的编码方式。\n\nUTF-8是针对Unicode的可变长度字符编码，最短一个字节，最长3个字节，1个字节表示的就是ASCII码，所以UTF-8是完全兼容ASCII码的。\n\n正是因为UTF-8的变长实现，解决了Unicode的存储多的问题。可能有朋友要问了，UTF-8最多需要用3个字节表示，而Unicode只需要两个，怎么能说UFT-8会省存储呢？因为目前英文是最通用的语言，大部分字符都是ASCII码。\n\n\n但UTF-8并不是一点缺点也没有，因为变长表示，所以一段UTF-8编码没法一下子算出有多少个字符。而这一点能力对于以上几种编码格式来说是轻而易举的。所以当今世界上没有最完美的字符编码，只有最合适某个场景的编码。\nUTF-8具体实现\n\n\n范围\n字节数\n存储格式\n\n\n\n0x0000~0x007F (0 ~ 127)\n1字节\n0xxxxxxx\n\n\n0x0080~0x07FF(128 ~ 2047)\n2字节\n110xxxxx 10xxxxxx\n\n\n0x0800~FFFF(2048 ~ 65535)\n3字节\n1110xxxx 10xxxxxx 10xxxxxx\n\n\n0x10000~1FFFFFF(65536 ~ 2097152)\n4字节\n11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\n0x2000000~0x3FFFFFF\n5字节\n111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\n0x4000000~0x7FFFFFFF)\n6字节\n1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\n番外：多字节编码的一些概念大尾(big endian)和小尾(little endian)大尾和小尾是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。\nBOMUTF-8以字节为编码单元，故没有字节序的问题。而UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？\nUnicode规范中推荐的标记字节顺序的方法是BOM，即Byte Order Mark。BOM是一个有点小聪明的想法：\n在UCS编码中有一个叫做&quot;ZERO WIDTH NO-BREAK SPACE&quot;的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符&quot;ZERO WIDTH NO-BREAK SPACE&quot;。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符&quot;ZERO WIDTH NO-BREAK SPACE&quot;又被称作BOM。\nUTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符&quot;ZERO WIDTH NO-BREAK SPACE&quot;的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。\n不过话又说回来：理论上说，UTF-8并没有大小尾的困扰，所以并不需要BOM。但是一些Windows应用会指定大小尾，比如Notepad，而且Excel在没有指定BOM的UTF-8文件进行读取时会使用Windows的codepage，从而出现错误。 \n","slug":"Language Learning/Encoding/Endcoding","date":"2022-12-23T04:23:23.000Z","categories_index":"Coding Language","tags_index":"ASCII,U","author_index":"JBR_Bunjie"},{"id":"c501575a20c82b47e7d6e471fd5a77bc","title":"LUA急速入门","content":"安装# for ubuntu\napt install lua5.4\n\n# for windows\n# Go to github to install lua_for_windows\n\n代码执行交互式编程lua5.4已经支持了交互式编程，这样我们可以直接在命令行中输入程序语句并立即查看执行结果\n~#: lua\nLua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio\n&gt; print(&quot;Hello World&quot;)\nHello World\n&gt; \n-- 退出交互式编程状态：Ctrl+D(发送退出信号)、Ctrl+C(强制中断)、os.exit()\n\n脚本式编程传统的lua编写过程，和别的语言并无二致\n#!&#x2F;someDir&#x2F;bin&#x2F;lua --我们指定了 Lua 的解释器 &#x2F;someDir&#x2F;bin directory，加上 # 号标记后，解释器会忽略它。当我们为脚本添加可执行权限后，就可以通过输入 .&#x2F;hello.lua 来快速执行该脚本了\n\nprint(&quot;Hello World！&quot;)\nprint(&quot;www.runoob.com&quot;)\n\n-- 完成编写后，我们通过 lua hello.lua 的方式来执行该脚本\n\n变量：作用域Lua中，所有创建的变量，默认为全局变量而对于删除一个全局变量，我们只需将变量赋为nil\n当然，你也可以用 local 来设置局部变量\n\n\n\n\n\n\n\n\n\n应尽可能多地使用局部变量：\n\n避免命名冲突与逻辑错误\n访问局部变量的速度比全局变量更快\n\n数据类型Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\n你总是可以通过 type(x) 来检查数据类型\ntype(nil) &#x3D;&#x3D; nil; -- false\ntype(nil) &#x3D;&#x3D; &quot;nil&quot; -- true\n\n\n\n\n\n\n数据类型\n描述\n\n\n\nnil\n只有值nil属于该类，代表被删除、不存在等，是表示一个无效值（在条件表达式中相当于false）\n\n\nboolean\n包含两个值：false和true。\n\n\nnumber\n表示双精度类型的实浮点数\n\n\nstring\n字符串由一对双引号或单引号来表示\n\n\nfunction\n由 **C **或 Lua 编写的函数\n\n\nuserdata\n表示任意存储在变量中的C数据结构**\n\n\nthread\n表示执行的独立线路，用于执行协同程序\n\n\ntable\n字典或者”关联数组”。其索引可以是数字、字符串或表类型。我们用”构造表达式”来创建表\n\n\ntable实例：-- table_test.lua 脚本文件\na &#x3D; &#123;&#125; -- 创建空表\na[&quot;key&quot;] &#x3D; &quot;value&quot; -- 添加键值对\nkey &#x3D; 10\na[key] &#x3D; 22\na[key] &#x3D; a[key] + 11\nfor k, v in pairs(a) do\n    print(k .. &quot; : &quot; .. v)\nend\n-- 结果：\n-- key : value\n-- 10 : 33\n\n索引：不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。\n-- table_test2.lua 脚本文件\nlocal tbl &#x3D; &#123;&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;&#125;\nfor key, val in pairs(tbl) do\n    print(&quot;Key&quot;, key)\nend\n\n-- Key    1\n-- Key    2\n-- ..\n\n无序：tab &#x3D; &#123;&quot;Hello&quot;,&quot;World&quot;,a&#x3D;1,b&#x3D;2,z&#x3D;3,x&#x3D;10,y&#x3D;20,&quot;Good&quot;,&quot;Bye&quot;&#125;\nfor k,v in pairs(tab) do\n    print(k..&quot;  &quot;..v)\nend\n\n如上代码输出结果存在一定规律，”Hello”、”World”、”Good”、”Bye”是表中的值，在存储时是按照顺序存储的，并且不同于其他脚本语言，Lua是从1开始排序的，因此，使用pairs遍历打印输出时，会先按照顺序输出表的值，然后再按照键值对的键的哈希值打印。\n1  Hello\n2  World\n3  Good\n4  Bye\ny  20\nx  10\nz  3\nb  2\na  1 \n\n构建数组我们可以使用整数索引来访问数组元素，如果指定的索引没有值则返回 nil\narray &#x3D; &#123;&quot;Lua&quot;, &quot;Tutorial&quot;&#125;\n\nfor i&#x3D; 0, 2 do\n   print(array[i])\nend\n\n-- nil\n-- Lua\n-- Tutorial\n\n“指针”当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都会指向同一个内存。而当 a 设置为 nil 时，Lua只会回收变量 a 本身，而 b 仍然能访问原 table 的元素。这种规则同样适用于传参数的情况\nmytable[&quot;wow&quot;] &#x3D; &quot;修改前&quot;\nprint(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])\n\n-- alternatetable和mytable的是指同一个 table\nalternatetable &#x3D; mytable\n\nprint(&quot;mytable 索引为 wow 的元素是 &quot;, alternatetable[&quot;wow&quot;])\nalternatetable[&quot;wow&quot;] &#x3D; &quot;修改后&quot;\nprint(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])\n\n-- 释放变量\nalternatetable &#x3D; nil\nprint(&quot;alternatetable 是 &quot;, alternatetable)\n\n-- mytable 仍然可以访问\nprint(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])\n\n-- mytable 索引为 wow 的元素是     修改前\n-- mytable 索引为 wow 的元素是     修改前\n-- mytable 索引为 wow 的元素是     修改后\n-- alternatetable 是     nil\n-- mytable 索引为 wow 的元素是     修改后\n\n插入删除\n\n\n方法\n用途\n\n\n\ntable.insert (table, [pos,] value):\n在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.\n\n\ntable.remove (table [, pos])\n返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n\n\nSort\n\n\n\n\n\n\n\n\ntable.sort (list [, comp])\nSorts the list elements in a given order, in-place, from list[1] to list[#list]. If comp is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order, so that, after the sort, i &lt;= j implies not comp(list[j],list[i]). If comp is not given, then the standard Lua operator &lt; is used instead.\nfunction在 Lua 中，函数是被看作是”第一类值（First-Class Value）”\n值得注意的是，我们可以临时创建一个匿名函数来进行参数传递：\ntestFun(tab,\n    function(key, val)\n        return key - val;\n    end\n);\n\nthread\n\n\n\n\n\n\n\n\n在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\n线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n字符串定义Lua 语言中字符串可以使用以下三种方式来表示：\n\n单引号间的一串字符。\n双引号间的一串字符。\n[[ 与 ]] 间的一串字符。\n\n特别的，我们可以通过嵌套来给字符串中加入引号：\na &#x3D; &quot;&#39;test&#39;&quot;\nprint(a) -- &#39;a&#39;\n\n字符串格式化Lua 提供了 string.format() 函数来生成具有特定格式的字符串，这个函数的格式很像 C 语言中的 printf()。同时由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。\n格式字符串可能包含以下的转义码:\n\n%c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\n%d, %i - 接受一个数字并将其转化为有符号的整数格式\n%o - 接受一个数字并将其转化为八进制数格式\n%u - 接受一个数字并将其转化为无符号整数格式\n%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\n%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\n%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\n%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\n%f - 接受一个数字并将其转化为浮点数格式\n%g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式\n%q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\n%s - 接受一个字符串并按照给定的参数格式化该字符串\n\n为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\n\n(1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.\n(2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.\n(3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.\n(4) 宽度数值\n(5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.\n\n匹配Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。\n字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类 %d 匹配任意数字。所以你可以使用模式串 %d%d/%d%d/%d%d%d%d 搜索 dd/mm/yyyy 格式的日期：\ns &#x3D; &quot;Deadline is 30&#x2F;05&#x2F;1999, firm&quot;\ndate &#x3D; &quot;%d%d&#x2F;%d%d&#x2F;%d%d%d%d&quot;\nprint(string.sub(s, string.find(s, date)))    --&gt; 30&#x2F;05&#x2F;1999\n\n\n\n\n\n赋值语句：-- Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量\na, b &#x3D; 10, 2*x           -- a&#x3D;10; b&#x3D;2*x\n\n-- 遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：\nx, y &#x3D; y, x              -- swap &#39;x&#39; for &#39;y&#39;\n\n-- 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略：\na. 变量个数 &gt; 值的个数      -- 按变量个数补足nil\nb. 变量个数 &lt; 值的个数      -- 多余的值会被忽略\n--&gt; 常见的错误情况:\na, b, c &#x3D; 0\nprint(a,b,c)             --&gt; 0   nil   nil\n\n循环相对于其它语言来说，Lua的循环结构是特殊而合理的：\n\n\n\n方法名称\n描述\n\n\n\nwhile 循环\n在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\n\n\nfor 循环\n重复执行指定语句，重复次数可在 for 语句中控制。\n\n\nrepeat…until\n重复执行循环，直到 指定的条件为真时为止\n\n\n\n\n\n控制语句\n描述\n\n\n\nbreak 语句\n退出当前循环或语句，并开始脚本执行紧接着的语句。\n\n\ngoto 语句\n将程序的控制点转移到一个标签处。\n\n\n值得注意的是，lua中并不包含 continue 控制语句，要想实现 continue 的功能，我们可以利用 goto 语句：\nfor i&#x3D;1, 10 do\n\tif i % 2 &#x3D;&#x3D; 0 then goto continue end\n    print(i)\n    ::continue::\nend\n\n\n\n\n\n\n\n\n\n\nloops - Why does Lua have no “continue” statement? - Stack Overflow\n流程控制我们利用 if...elseif...else 语句来完成流程控制\nif( 布尔表达式 1) then\n   --[ 在布尔表达式 1 为 true 时执行该语句块 --]\nelseif( 布尔表达式 2) then\n   --[ 在布尔表达式 2 为 true 时执行该语句块 --]\nelse \n   --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]\nend\n\n函数\n\n\n\n\n\n\n\n\n在Lua中，函数是对语句和表达式进行抽象的主要方法。\nLua 函数主要有两种用途：\n\n1.完成指定的任务，这种情况下函数作为调用语句使用；\n2.计算并返回值，这种情况下函数作为赋值语句的表达式使用。\n\n函数定义Lua 编程语言函数定义格式如下：\noptional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n    function_body\n    return result_params_comma_separated\nend\n\n\noptional_function_scope: 该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\nfunction_name: 指定函数名称。\nargument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\nfunction_body: 函数体，函数中需要执行的代码语句块。\nresult_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\n\n“重载”关于函数的”重载”能力：Lua能自动去适应传入的参数，如果传入的参数个数多于定义的个数，则会自动忽略后面多于的参数，如果传入的参数个数少于定义的个数，则会将不足的参数用nil补齐。如：\nfunction Add(a,b,c)\n     if c &#x3D;&#x3D; nil then\n         return a + b\n     else\n         return a + b + c\n     end\nend\n\n可变参数：\n\n\n\n\n\n\n\n\nLua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 … 表示函数有可变的参数。\nfunction average(...)\n   result &#x3D; 0\n   local arg&#x3D;&#123;...&#125;    --&gt; arg 为一个表，局部变量\n   for i,v in ipairs(arg) do\n      result &#x3D; result + v\n   end\n   print(&quot;总共传入 &quot; .. #arg .. &quot; 个数&quot;)\n   return result&#x2F;#arg\nend\n\nprint(&quot;平均值为&quot;,average(10,5,3,4,5,6))\n\n我们常将可变参数通过 &#123;...&#125; 来组合为table，此时，我们可以通过select方法来访问可变参数的信息：\n\nselect(‘#’, …) 返回可变参数的长度。\nselect(n, …) 用于返回从起点 n 开始到结束位置的所有参数列表。\n\n请注意，select方法中的参数并非是table，这当然意味着select只适用于可变参数，不适合table\n\n\n\n\n\n\n\n\n\nselect (index, ···)\nIf index is a number, returns all arguments after argument number index;a negative number indexes from the end (-1 is the last argument).Otherwise, index must be the string “#”, and select returns the total number of extra arguments it received.\n运算符\n\n\n操作符\n描述\n实例\n\n\n\n^\n乘幂\n10^2 输出结果 100\n\n\n//\n整除(&gt;=lua5.3)\n5//2 输出结果 2\n\n\n~=\n不等于\n(1 ~= 2) 为 true。\n\n\nand\n逻辑与\n(true and false) 为 false。\n\n\nor\n逻辑或\n(false or false) 为 true。\n\n\nnot\n逻辑非\nnot(true and false) 为 true。\n\n\n.\n连接两个字符串\na..b，若a为 “Hello “ ，b为 “World”, 输出结果为 “Hello World”\n\n\n#\n一元运算符，返回字符串或表的长度。\n#”Hello” 返回 5\n\n\n特别的，当对 table 使用 # 运算时会遇到的问题&gt; a &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, nil, &quot;3&quot;&#125;\n&gt; #a\n4\n&gt; b &#x3D; &#123;&quot;1&quot;, &quot;2&quot;,&quot;3&quot;, nil&#125;\n&gt; #b\n3\n\n其获取长度时，依靠的其实是最大索引值：\n在获取表的长度时，根据的是表的最大索引的值:\ntab1 &#x3D; &#123;&quot;1&quot;,&quot;2&quot;&#125;\nprint(&quot;tab1长度&quot;..#tab1)\n\ntab2 &#x3D; &#123;key1&#x3D;&quot;1&quot;,&quot;2&quot;&#125;\nprint(&quot;tab2长度&quot;..#tab2)\n\ntab3 &#x3D; &#123;&#125;\ntab3[1]&#x3D;&quot;1&quot;\ntab3[2]&#x3D;&quot;2&quot;\ntab3[4]&#x3D;&quot;4&quot;\nprint(&quot;tab3长度&quot;..#tab3)\n\n-- tab1长度2\n-- tab2长度1\n-- tab3长度4\n\n而当下标越位超过 1 时：\n下标越过 1 位以上，长度还是为 2：\ntab3&#x3D;&#123;&#125;\ntab3[1]&#x3D;&quot;1&quot;\ntab3[2]&#x3D;&quot;2&quot;\ntab3[5]&#x3D;&quot;5&quot;\nprint(&quot;tab3的长度&quot;,#tab3)\n\n-- tab3的长度    2\n\n\n\n\n\n\n\n\n\n\n当我们获取 table 的长度的时候无论是使用 # 还是 table.getn 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。\n可以使用以下方法来代替：\n&gt;function table_leng(t)\n local leng&#x3D;0\n for k, v in pairs(t) do\n   leng&#x3D;leng+1\n end\n return leng;\n&gt;end\n实现三目运算使用 Lua 的逻辑运算符实现就需要一些小技巧，写法如下（具体可查看Lua 中的三目运算符）\n(condition and &#123;result1&#125; or &#123;result2&#125;)[1]\n\n例：\nlocal isAppel &#x3D; false\nprint(isAppel and &quot;苹果&quot; or &quot;梨&quot;)\n\n原理：\n\n\n\n\n\n\n\n\n\n\n(A and B), 若 A 为 false 返回 A(返回false) ;\n\n(A or B), 若 A 为 false 返回 B ;\n\n除 nil 外其他数据类型被当做 true\n\n\n元表Lua中我们使用元表来增强Table的表现：通过为table赋予元表，我们可以改变对table进行操作时的默认行为，以达到更多的效果。\n当我们为一个 table 指定好对应的 metatable 后，我们就可以为元表增添即时字段来修改上层 table 行为了\n为指定的表设定元表两个主要方法：\n\nsetmetatable(table, metatable): 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。\ngetmetatable(table): 返回对象的元表(metatable)。\n\n为元表增添元方法仅列出部分主要方法\n__index 元方法生效情况：当你通过键来访问 table 的时候，如果这个键没有值，那么 Lua 就会寻找该 table 的 metatable 中的__index 键。当 __index生效时：\n__index包含表格若__index包含一个表格，Lua 会在表格中查找相应的键。\nother &#x3D; &#123; foo &#x3D; 3 &#125;\nt &#x3D; setmetatable(&#123;&#125;, &#123; __index &#x3D; other &#125;)\nprint(t.foo) -- 3\nprint(t.bar) -- nil\n\n若__index包含函数若__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。\nmytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123;\n  __index &#x3D; function(mytable, key)\n    print(mytable, key)\n  end\n&#125;)\nprint(mytable.key1, mytable.key2)\n\n\n\n\n\n\n\n\n\n\n总结Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:\n\n1.在表中查找，如果找到，返回该元素，找不到则继续\n2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。\n3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。\n\n该部分内容来自作者寰子：https://blog.csdn.net/xocoder/article/details/9028347\n__newindex 元方法生效情况：当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法。如果存在则调用该方法而不进行赋值操作。\n\n\n\n\n\n\n\n\n\n__newindex 元方法用来对表更新，__index则用来对表访问 。\n\nmymetatable &#x3D; &#123;&#125;\nmytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123; __newindex &#x3D; mymetatable &#125;)\n\nprint(mytable.key1)\n\nmytable.newkey &#x3D; &quot;新值2&quot;\nprint(mytable.newkey,mymetatable.newkey)\n\nmytable.key1 &#x3D; &quot;新值1&quot;\nprint(mytable.key1,mymetatable.key1)\n\n重载操作符：__add、__sub等元方法：\n\n\n\n\n\n\n\n\n以下实例演示了两表相加操作：\n实例&gt;-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数\n&gt;function table_maxn(t)\n   local mn &#x3D; 0\n   for k, v in pairs(t) do\n       if mn &lt; k then\n           mn &#x3D; k\n       end\n   end\n   return mn\n&gt;end\n\n&gt;-- 两表相加操作\n&gt;mytable &#x3D; setmetatable(&#123; 1, 2, 3 &#125;, &#123;\n __add &#x3D; function(mytable, newtable)\n   for i &#x3D; 1, table_maxn(newtable) do\n     table.insert(mytable, table_maxn(mytable)+1,newtable[i])\n   end\n   return mytable\n end\n&gt;&#125;)\n\n&gt;secondtable &#x3D; &#123;4,5,6&#125;\n\n&gt;mytable &#x3D; mytable + secondtable\n&gt;for k,v in ipairs(mytable) do\nprint(k,v)\n&gt;end\n\n&gt;-- 以上实例执行输出结果为：\n&gt;-- 1    1\n&gt;-- 2    2\n&gt;-- 3    3\n&gt;-- 4    4\n&gt;-- 5    5\n&gt;-- 6    6\n全部的操作符元方法如下：\n\n\n\n模式\n描述\n\n\n\n__add\n对应的运算符 ‘+’.\n\n\n__sub\n对应的运算符 ‘-‘.\n\n\n__mul\n对应的运算符 ‘*’.\n\n\n__div\n对应的运算符 ‘/‘.\n\n\n__mod\n对应的运算符 ‘%’.\n\n\n__unm\n对应的运算符 ‘-‘.\n\n\n__concat\n对应的运算符 ‘..’.\n\n\n__eq\n对应的运算符 ‘==’.\n\n\n__lt\n对应的运算符 ‘&lt;’.\n\n\n__le\n对应的运算符 ‘&lt;=’.\n\n\n__call 元方法\n\n\n\n\n\n\n\n\n__call: The call operation func(args). \nThis event happens when Lua tries to call a non-function value (that is, func is not a function). The metamethod is looked up in func. If present, the metamethod is called with func as its first argument, followed by the arguments of the original call (args). All results of the call are the results of the operation. This is the only metamethod that allows multiple results.\n-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数\nfunction table_maxn(t)\n    local mn &#x3D; 0\n    for k, v in pairs(t) do\n        if mn &lt; k then\n            mn &#x3D; k\n        end\n    end\n    return mn\nend\n\n-- 定义元方法__call\nmytable &#x3D; setmetatable(&#123;10&#125;, &#123;\n  __call &#x3D; function(mytable, newtable)\n        sum &#x3D; 0\n        for i &#x3D; 1, table_maxn(mytable) do\n                sum &#x3D; sum + mytable[i]\n        end\n    for i &#x3D; 1, table_maxn(newtable) do\n                sum &#x3D; sum + newtable[i]\n        end\n        return sum\n  end\n&#125;)\nnewtable &#x3D; &#123;10,20,30&#125;\nprint(mytable(newtable)) -- 70\n\n__tostring 元方法__tostring 元方法用于修改表的输出行为。\nmytable &#x3D; setmetatable(&#123; 10, 20, 30 &#125;, &#123;\n    __tostring &#x3D; function(mytable)\n        sum &#x3D; 0\n        for k, v in pairs(mytable) do\n            \tsum &#x3D; sum + v\n            end\n        return &quot;表所有元素的和为 &quot; .. sum\n    end\n&#125;)\nprint(mytable) -- 表所有元素的和为 60\n\n绕开元方法以__newindex为例：设置了元方法 __newindex 后，在对新索引键(newkey)赋值时，会调用元方法，而自身不再主动进行赋值。而对于已存在的索引键(oldkey)，则会进行赋值，而不调用元方法 newindex。为了保证我们仍然能实现赋值语句本身的功能，我们在__newindex调用的方法中，会需要绕开该元方法本身直接进行赋值，这时我们需要用到 rawser、rawget 两个函数，它们能在完成本身功能时避免激活元方法\n\n\n\n\n\n\n\n\n\nrawset (table, index, value)\nSets the real value of table[index] to value, without using the __newindex metavalue. table must be a table, index any value different from nil and NaN, and value any Lua value.\n\n\n\n\n\n\n\n\n\nrawget (table, index)\nGets the real value of table[index], without using the __index metavalue. table must be a table; index may be any value.\nmytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123;\n    __newindex &#x3D; function(mytable, key, value)\n        rawset(mytable, key, &quot;\\&quot;&quot;..value..&quot;\\&quot;&quot;)\n    end\n&#125;)\n\nmytable.key1 &#x3D; &quot;new value&quot;\nmytable.key2 &#x3D; 4\n\nprint(mytable.key1, mytable.key2) -- new value    &quot;4&quot;\n\n协程 - coroutine：Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。\n线程和协同程序区别线程与协同程序的主要区别在于：一个具有多个线程的程序可以同时运行几个线程，而在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。\n基本语法\n\n\n方法\n描述\n\n\n\ncoroutine.create()\n创建 coroutine，返回 coroutine (thread)， 参数是一个函数当和 resume 配合使用的时候就唤醒函数调用\n\n\ncoroutine.resume()\n重启 coroutine，和 create 配合使用\n\n\ncoroutine.yield()\n挂起 coroutine，将 coroutine 设置为挂起状态这个和 resume 配合使用能有很多有用的效果\n\n\ncoroutine.status()\n查看 coroutine 的状态※: coroutine 的状态共三种：dead，suspended，running\n\n\ncoroutine.wrap（）\n创建 coroutine 并返回一个函数，如调用该函数就进入 coroutine和 create 功能重复\n\n\ncoroutine.running()\n返回正在跑的 coroutine，一个 coroutine 就是一个线程当使用running的时候，就是返回一个 corouting 的线程号\n\n\n-- coroutine_test.lua 文件\nco &#x3D; coroutine.create(\n    function(i)\n        print(i);\n    end) \n-- 刚创建时并未执行\n\ncoroutine.resume(co, 1)   -- 1\nprint(coroutine.status(co))  -- dead -- 执行完毕\n\nprint(&quot;----------&quot;)  -- ----------\n \nco &#x3D; coroutine.wrap(\n    function(i)\n        print(i);\n    end\n)\n \nco(10)  -- 10 -- warp创建和create创建的调用方式是不一样的，因为create返回的是thread对象，而wrap返回的是function\nprint(&quot;----------&quot;)  -- ----------\n \nco2 &#x3D; coroutine.create(function()\n    for i&#x3D;1,10 do\n        print(i)\n        if i &#x3D;&#x3D; 3 then\n            print(coroutine.status(co2))  -- running\n            print(coroutine.running())  -- thread:XXXXXX\n        end\n        coroutine.yield()\n    end\nend)\n\ncoroutine.resume(co2) --1\ncoroutine.resume(co2) --2\ncoroutine.resume(co2) --3\n \nprint(coroutine.status(co2))   -- suspended\nprint(coroutine.running())  -- thread: 0x7fb801c04c88    true\n\n\n\n\n\n\n\n\n\n\n\ncoroutine.creat方法只要建立了一个协程 ，那么这个协程的状态默认就是suspend。使用resume方法启动后，会变成running状态；遇到yield时将状态设为suspend；如果遇到return，那么将协程的状态改为dead。\n\ncoroutine.resume方法需要特别注意的一点是，这个方法只要调用就会返回一个boolean值。\n\ncoroutine.resume方法如果调用成功，那么返回true；如果有yield方法，同时返回yield括号里的参数；如果没有yield，那么继续运行直到协程结束；直到遇到return，将协程的状态改为dead，并同时返回return的值。\n\ncoroutine.resume方法如果调用失败(调用状态为dead的协程会导致失败)，那么返回false，并且带上一句”cannot resume dead coroutine”\n\nwrap不会返回boolean值，但是当coroutine执行完dead后，如继续执行该coroutine则会导致程序报错。\n\ncoroutine.yield 除了挂起协程外，还可以同时返回数据给 resume ,并且还可以同时定义下一次唤醒时需要传递的参数。\n\n\n cor &#x3D; coroutine.create(function(a)\n    print(&quot;参数 a 值为：&quot;, a);\n    local b, c &#x3D; coroutine.yield(a + 1); --这里表示挂起协程，并且将a+1的值进行返回，并且指定下一次唤醒需要 b,c 两个参数。\n    print(&quot;参数 b, c 值分别为：&quot;, b, c);\n    return b * c; --协程结束，并且返回 b*c 的值。\nend);\n\nprint(&quot;第一次调用：&quot;, coroutine.resume(cor, 1));\nprint(&quot;第二次调用：&quot;, coroutine.resume(cor, 2, 2));\nprint(&quot;第三次调用：&quot;, coroutine.resume(cor));\n\n--[[\n参数 a 值为：    1\n第一次调用：    true    2\n参数 b, c 值分别为：    2    2\n第二次调用：    true    4\n第三次调用：    false    cannot resume dead coroutine ]]\n\n cor &#x3D; coroutine.wrap(function(a)\n    print(&quot;参数 a 值为：&quot;, a);\n    local b, c &#x3D; coroutine.yield(a + 1); --这里表示挂起协程，并且将a+1的值进行返回，并且指定下一次唤醒需要 b,c 两个参数。\n    print(&quot;参数 b, c 值分别为：&quot;, b, c);\n    return b * c; --协程结束，并且返回 b*c 的值。\nend);\n\nprint(&quot;第一次调用：&quot;, cor(1));\nprint(&quot;第二次调用：&quot;, cor(2, 2));\nprint(&quot;第三次调用：&quot;, cor());\n\n--[[\n参数 a 值为：   1\n第一次调用：    2\n参数 b, c 值分别为：    2       2\n第二次调用：    4\nlua: test.lua:18: cannot resume dead coroutine\nstack traceback:\n        [C]: in function &#39;cor&#39;\n        test.lua:18: in main chunk\n        [C]: in ?  ]]\n\n迭代器迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。\nLua 的迭代器（迭代函数）包含以下两种类型：\n\n无状态的迭代器\n多状态的迭代器\n\n泛型 for 调用迭代器泛型 for 的执行过程：\n\n首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。\n第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。\n第三，将迭代函数返回的值赋给变量列表。\n第四，如果返回的第一个值为nil循环结束，否则执行循环体。\n第五，回到第二步再次调用迭代函数\n\n如：\narray &#x3D; &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;\n\nfor key,value in ipairs(array)\ndo\n   print(key, value)\nend\n\n无状态的迭代器类似pairs, ipairs的，没有更多信息(状态)的迭代器\nfunction square(iteratorMaxCount, currentNumber)\n   if currentNumber &lt; iteratorMaxCount\n   then\n      currentNumber &#x3D; currentNumber+1\n   return currentNumber, currentNumber*currentNumber\n   end\nend\n\nfor i,n in square(3,0) do\n   print(i,n)\nend\n\n多状态的迭代器为了保存更多信息，使用闭包来构造迭代器\narray &#x3D; &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;\n\nfunction elementIterator (collection)\n   local index &#x3D; 0\n   local count &#x3D; #collection\n   -- 闭包函数\n   return function ()\n      index &#x3D; index + 1\n      if index &lt;&#x3D; count\n      then\n         --  返回迭代器的当前元素\n         return collection[index]\n      end\n   end\nend\n\nfor element in elementIterator(array)\ndo\n   print(element)\nend\n\n\n\n\n\n\n\n模块化从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\n-- 文件名为 Test1.lua\n-- 定义一个名为 module 的模块(Table)\nmodule &#x3D; &#123;&#125;\n \n-- 定义一个常量\nmodule.constant &#x3D; &quot;这是一个常量&quot;\n \n-- 定义一个函数\nfunction module.func1()\n    io.write(&quot;这是一个公有函数！\\n&quot;)\nend\n \nlocal function func2()\n    print(&quot;这是一个私有函数！&quot;)\nend\n \nfunction module.func3()\n    func2()\nend\n \nreturn module\n\n由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。其中：\n\nfunc1 声明为程序块的全局变量，我们以这样的方式实现了 public 属性，可以在引入后随意调用.\nfunc2 则声明为程序块的局部变量，即表示一个 private 函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的函数来调用.\n\n面向对象利用function实现面向对象闭包一句话说就是，在函数中引用外部函数来进行嵌套的函数。\ndef outer(x):\n    def inner(y):\n        return x + y\n    return inner\n\nprint(outer(6)(5))\n\n&gt;&gt;&gt; 11\n\n如代码所示，在outer函数内，又定义了一个inner函数，并且inner函数又引用了外部函数outer的变量x，这就是一个闭包了。在输出时，outer(6)(5),第一个括号传进去的值返回inner函数，其实就是返回6 + y，所以再传第二个参数进去，就可以得到返回值，6 + 5。\n实现-- 元类\nRectangle &#x3D; &#123;area &#x3D; 0, length &#x3D; 0, breadth &#x3D; 0&#125;\n\n-- 派生类的方法 new\nfunction Rectangle:new (o,length,breadth)\n  o &#x3D; o or &#123;&#125;\n  setmetatable(o, self)\n  self.__index &#x3D; self  -- 子类没设置area这三个属性时，会导回Rectangle\n  self.length &#x3D; length or 0\n  self.breadth &#x3D; breadth or 0\n  self.area &#x3D; length*breadth;\n  return o\nend\n\n-- 派生类的方法 printArea\nfunction Rectangle:printArea ()\n  print(&quot;矩形面积为 &quot;,self.area)\nend\n\n\n\n\n\n\n\n\n\n\nLua中的self - 知乎 (zhihu.com)\n利用table实现\n封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性\ntable已经完备\n\n\n继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。\n我们需要自己实现clone/copy函数\n\n\n多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。\nLua function已完备\n\n\n\n-- clone function\nfunction clone(tb)\n    local ins &#x3D; &#123;&#125;\n    for key, var in pairs(tb) do\n        ins[key] &#x3D; var\n    end\n    return ins\nend\n-- copy function\nfunction copy(dist, tb)\n    for key, var in pairs(tb) do\n        dist[key] &#x3D; var\n    end\nend\n\n-- define original table\ntable &#x3D; &#123;&#125;\ntable.funHello &#x3D; function(tb)\n    print(&quot;Hello &quot;..tb.name)\nend\ntable.new &#x3D; function(name)\n    local self &#x3D; clone(table);\n    self.name &#x3D; name\n    return self\nend\n\n-- 实例化\nlocal tb1 &#x3D; table.new(&quot;World&quot;)\ntb1:funHello(tb1)  -- 事实上，常规地使用 . 或者 : 来引用funHello是几乎完全一样的，但是为了提升可读性，我们需要做出区分\n\n-- 继承\ntb2 &#x3D; &#123;&#125;\ntb2.new &#x3D; function(name)\n    local self &#x3D; table.new(name)\n    copy(self, tb2)\n    return self\nend\n\ntb2.tb2Hello &#x3D; function()\n    print(&quot;tb2 Hello&quot;)\nend\ntb2.funHello &#x3D; function()\n    print(&quot;tb2 fun Hello&quot;)\nend\n\nlocal m &#x3D; tb2.new(&quot;Lili&quot;)\nm:funHello()\nm:tb2Hello()\n\n\n\n错误处理程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。\n这里我们主要着眼运行时错误。\nRaise ErrorLua主要使用两个函数：assert 和 error 来错误。\n\n\n\n\n\n\n\n\n\nassert (v [, message])\n\nRaises an error if the value of its argument v is false (i.e., nil or false); \nIn case of error, message is the error object; when absent, it defaults to “assertion failed!“\n\n\notherwise, returns all its arguments. \n\n\nassert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。\n\n\n\n\n\n\n\n\n\n\nerror (message [, level])\nRaises an error (see §2.3) with message as the error object. This function never returns.\nUsually, error adds some information about the error position at the beginning of the message, if the message is a string. The level argument specifies how to get the error position. With level 1 (the default), the error position is where the error function was called. Level 2 points the error to where the function that called error was called; and so on. Passing a level 0 avoids the addition of error position information to the message.\n\n功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\n通常情况下，error会附加一些错误位置的信息到message头部。\nLevel参数指示获得错误的位置:\n\nLevel=1[默认]：为调用error位置(文件+行号)\nLevel=2：指出哪个调用error的函数的函数\nLevel=0:不添加错误位置信息\n\n\nlocal function add(a,b)\n   assert(type(a) &#x3D;&#x3D; &quot;number&quot;, &quot;a 不是一个数字&quot;)\n   assert(type(b) &#x3D;&#x3D; &quot;number&quot;, &quot;b 不是一个数字&quot;)\n   return a+b\nend\nadd(10)\n\nProcess Errorpcallpcall接收一个函数和要传递给后者的参数，并执行。最后根据执行结果是否有错误返回true或者或false及errorinfo\n&gt; if pcall(function_name, ….) then\n-- 没有错误\nelse\n-- 存在错误\nend\n\n&gt; pcall(function(i) print(i) end, 33)\n33\ntrue\n\n&gt; pcall(function(i) print(i) error(&#39;error..&#39;) end, 33)\n33\nfalse   stdin:1: error..\n\npcall会以一种”保护模式”来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\n不过，通常在错误发生时，我们往往希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。为了获取更多信息，我们可以直接使用的办法：xpcall\nxpcall\n\n\n\n\n\n\n\n\nxpcall (f, msgh [, arg1, ···])\nThis function is similar to pcall, except that it sets a new message handler msgh.\nxpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用 debug 库来获取关于错误的额外信息了。\ndebug库提供了两个通用的错误处理函数:\n\ndebug.debug：提供一个Lua提示符，让用户来检查错误的原因\ndebug.traceback：根据调用桟来构建一个扩展的错误消息\n\nfunction myfunction ()\n   n &#x3D; n&#x2F;nil\nend\n\nfunction myerrorhandler( err )\n   print( &quot;ERROR:&quot;, err )\nend\n\nstatus &#x3D; xpcall( myfunction, myerrorhandler )\nprint( status )\n\n-- ERROR:  test.lua:10: attempt to perform arithmetic on a nil value (global &#39;n&#39;)     \t\t -- from xpcall(..)\n-- false \t\t-- from print( status )\n\ndebug\n\n\n方法\n用途\n\n\n\ntraceback ([thread,] [message [, level]])\n如果 message 存在且不是字符串或 nil，那么函数不做任何处理直接返回 message。 否则，traceback将返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。\n\n\ngetinfo ([thread,] f [, what]):\n返回关于一个函数信息的表。 你可以直接提供该函数，也可以用一个数字 f 表示该函数——它表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。\n\n\ngetupvalue (f, up)\n此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。以 ‘(‘ （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）\n\n\nsetupvalue (f, up, value):\n这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。\n\n\nfunction newCounter ()\n    local n &#x3D; 0\n    local k &#x3D; 0\n    return function ()\n        k &#x3D; n\n        n &#x3D; n + 1\n        return n\n    end\nend\n  \ncounter &#x3D; newCounter()\nprint(counter())\nprint(counter())\n\nlocal i &#x3D; 1\nrepeat\n    name, val &#x3D; debug.getupvalue(counter, i)\n    if name then\n        print (&quot;index&quot;, i, name, &quot;&#x3D;&quot;, val)\n        \n        if(name &#x3D;&#x3D; &quot;n&quot;) then\n            debug.setupvalue (counter,2,10)\n        end\n        i &#x3D; i + 1\n    end -- if\nuntil not name\n\nprint(counter())\n\n垃圾回收概述Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。\nLua 运行了一个垃圾收集器来收集所有死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。\nLua 实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： 垃圾收集器间歇率和垃圾收集器步进倍率。 这两个数字都使用百分数为单位(例如：值 100 在内部表示 1)：\n\n垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到之前的两倍时才开始新的循环。\n垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100，那样的话收集器就工作的太慢了以至于永远都干不完一个循环。默认值是 200，这表示收集器以内存分配的”两倍”速工作。如果你把步进倍率设为一个非常大的数字(比你的程序可能用到的字节数还大 10%)，收集器的行为就像一个 stop-the-world 收集器。接着你若把间歇率设为 200，收集器的行为就和过去的 Lua 版本一样了：每次 Lua 使用的内存翻倍时，就做一次完整的收集。\n\n运用我们可以通过函数**collectgarbage ([opt [, arg]])**来控制垃圾收集器：\n\n**collectgarbage(“setpause”, 200)**： 内存增大 2 倍（200/100）时自动释放一次内存 （200 是默认值）。\n**collectgarbage(“setstepmul”, 200)**：收集器单步收集的速度相对于内存分配速度的倍率，设置 200 的倍率等于 2 倍（200/100）。（200 是默认值）\n\ncollectgarbage(“collect”): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：\n\ncollectgarbage(“count”): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。\n\ncollectgarbage(“restart”): 重启垃圾收集器的自动运行。\n\ncollectgarbage(“setpause”): 将 arg 设为收集器的 间歇率。 返回 间歇率 的前一个值。\n\ncollectgarbage(“setstepmul”): 返回 步进倍率 的前一个值。\n\ncollectgarbage(“step”): 单步运行垃圾收集器。 步长”大小”由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。\n\ncollectgarbage(“stop”): 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。\n\n\n实例mytable &#x3D; &#123;&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;&#125;\nprint(collectgarbage(&quot;count&quot;))\n\nmytable &#x3D; nil\n\nprint(collectgarbage(&quot;count&quot;))\nprint(collectgarbage(&quot;collect&quot;))\nprint(collectgarbage(&quot;count&quot;))\n\n执行以上程序，输出结果如下(注意内存使用的变化)：\n20.9560546875\n20.9853515625\n0\n19.4111328125\n\nMain Origin\nLua Official Site：The Programming Language Lua\nLua 教程 | 菜鸟教程 (runoob.com)\n\n","slug":"Language Learning/LUA/急速入门","date":"2022-12-23T04:23:23.000Z","categories_index":"Coding Language","tags_index":"LUA,Coding Language","author_index":"JBR_Bunjie"},{"id":"761a62d925d7b04621f13a2ac3196dda","title":"Markdown type","content":"我展示的是一级标题我展示的是二级标题一、二级标题上不能有东西\n\n一级标题二级标题三级标题四级标题五级标题六级标题斜体文本 斜体文本粗体文本 粗体文本粗斜体文本 粗斜体文本\n分隔线:\n\n\n\n\n\n删除线:BAIDU.COM\n下划线:带下划线文本\n上标：\n2^3^\n下标：\nH2O\n高亮：\n==22==\n内联公式：\n$\\LaTeX$\n无序列表：\n\n第一项\n第二项\n第三项\n\n\n第一项\n第二项\n第三项\n\n\n第一项\n第二项\n第三项\n\n有序列表:\n\n第一项\n第二项\n第三项\n\n允许列表嵌套\n区块\n\n\n\n\n\n\n\n\n\n区块引用1区块引用2区块引用3最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n区块中使用列表:\n\n\n\n\n\n\n\n\n\n区块中使用列表\n\n第一项\n第二项\n\n\n第一项\n第二项\n第三项\n\n列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。\n区块中使用列表实例如下：\n\n第一项\n\n\n\n\n\n\n\n\n区块引用1区块引用2\n\n第二项\n\n代码printf() 函数\n可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n$(document).ready(function () &#123;\n    alert(&#39;RUNOOB&#39;);\n&#125;);\n\n链接\n这是一个链接：google\n或者直接放上地址：https://google.com\n\n\n\n\n\n\n\n\n\n还可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n这个链接用 1 作为网址变量 Google\n这个链接用 runoob 作为网址变量 Runoob\n然后在文档的结尾为变量赋值（网址）\n图片\n![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n\nMarkdown 还没有办法指定图片的高度与宽度如果你需要的话，你可以使用普通的  标签。\n表格\n\n\n\n左对齐\n右对齐\n居中对齐\n\n\n\n单元格\n单元格\n单元格\n\n\n单元格\n单元格\n单元格\n\n\n支持的 HTML 元素不在 Markdown 涵盖范围之内的标签都可以直接在文档里面用 HTML 撰写\n目前支持的 HTML 元素有：      等，可自行尝试\n转义md使用了很多特殊符号来表示特定的意义如果需要显示特定的符号则需要使用转义字符md使用反斜杠转义特殊字符：\n文本加粗 \n** 正常显示星号 **\nmd支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\\   反斜线`   反引号\n\n  星号_   下划线{}  花括号[]  方括号()  小括号井字号\n\n\n  加号\n\n\n  减号.   英文句点!   感叹号\n\n数学公式：LaTeX数学符号大全_LCCFlccf的博客-CSDN博客_latex 数学符号\n【Markdown笔记】数学公式 三角函数_dadalaohua的博客-CSDN博客_markdown 三角函数\nmarkdown最全数学公式速查_博客-CSDN博客_markdown数学公式\nMarkdown中的行列式和矩阵(LaTex) - 简书 (jianshu.com)\n输入公式：最速解决：在线LaTeX公式编辑器-编辑器 (latexlive.com)\n公式标签：在行内输入：$ $符号，在这两个符号之间输入LaTex语法，即可实现在行内插入公式。\n在行间输入：$$ $$符号，在这两对符号之间输入LaTex语法，即可实现在行间插入公式。\n示例：\n $\\alpha$、$\\beta$、$\\chi$、$\\Delta$、$\\Gamma$、$\\Theta$$$\\alpha$$\n公式语法：换行：\\\\\n对齐：&amp;对齐\n一般对齐：\n\n$$\\begin{aligned}&amp;y=kx+b\\&amp;y=kx^2+b\\\\end{aligned}$$\n\n等号对齐\n\n$$\\begin{aligned}y=&amp;kx+b\\kx^2+b=&amp;y\\\\end{aligned}$$\n\n灵活对齐\n\n$$\\begin{aligned}&amp;y&amp;&amp;=kx+b\\&amp;kx^2+b&amp;&amp;=y\\\\end{aligned}$$\n中心对齐：default\n分数：\\frac{分子}{分母}\n求和：\n\n参数位于右方：\\sum_{i=1}^{n}\n参数位于上下方：\\sum\\limits_{i=1}^{n}\n\n求导：\n\nd - 求导：\\frac{\\mathrm{d} y }{\\mathrm{d} x}\n∂ - 偏导：\\frac{\\partial f}{\\partial x}\n∇ - 梯度：\\nabla f\n\n附录：1.字母的LaTex语法希腊字母\n\n\n希腊字母小写、大写\nLaTeX形式\n希腊字母小写、大写\nLaTeX形式\n\n\n\nα A\n\\alpha A\nμ N\n\\mu N\n\n\nβ B\n\\beta B\nξ Ξ\n\\xi \\Xi\n\n\nγ Γ\n\\gamma \\Gamma\no O\no O\n\n\nδ Δ\n\\delta \\Delta\nπ Π\n\\pi \\Pi\n\n\nϵ ε E\n\\epsilon \\varepsilon E\nρ ϱ P\n\\rho \\varrho P\n\n\nζ Z\n\\zeta Z\nσ Σ\n\\sigma \\Sigma\n\n\nη H\n\\eta H\nτ T\n\\tau T\n\n\nθ ϑ Θ\n\\theta \\vartheta \\Theta\nυ Υ\n\\upsilon \\Upsilon\n\n\nι I\n\\iota I\nϕ φ Φ\n\\phi \\varphi \\Phi\n\n\nκ K\n\\kappa K\nχ X\n\\chi X\n\n\nλ Λ\n\\lambda \\Lambda\nψ Ψ\n\\psi \\Psi\n\n\nμ M\n\\mu M\nω Ω\n\\omega \\Omega\n\n\n2.常用运算符\n\n\n运算符\nlatex\n\n\n\n$\\le$\n\\le\n\n\n$\\ge$\n\\ge\n\n\n$\\neq$\n\\neq 或 \\ne\n\n\n$\\equiv$\n\\equiv\n\n\n$\\triangleq$\n\\triangleq\n\n\n$\\rightarrow$\n\\rightarrow\n\n\n$\\infty$\n\\infty\n\n\n$\\in$\n\\in\n\n\n$\\subset$\n\\subset\n\n\n$\\subseteq$\n\\subseteq\n\n\n$\\supset$\n\\supset\n\n\n$\\supseteq$\n\\supseteq\n\n\n$\\times$\n\\times\n\n\n$\\cdot$\n\\cdot\n\n\n\\sqrt\n\\sqrt\n\n\n","slug":"Language Learning/MARK LANGUAGE/Markdown","date":"2022-12-23T04:23:23.000Z","categories_index":"Coding Language","tags_index":"Markdown","author_index":"JBR_Bunjie"},{"id":"f8c8a85b34fcac6d0fefec2d2d2d9cd5","title":"Merge Sort - 归并排序","content":"Merge Sort 归并排序Reference：1.5 归并排序 | 菜鸟教程 (runoob.com)\n算法步骤：\n概述：\n\n\n\n\n\n\n\n\n\n\n\n申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n重复步骤 3 直到某一指针达到序列尾；\n将另一序列剩下的所有元素直接复制到合并序列尾。\n\n\n图示：\n\n\n\n\n\n\n\n\n\n1:\n\n\n\n\n\n\n\n\n\n\n2:\n\n\n\n实现-迭代法：function mergeSort(arr) &#123;  &#x2F;&#x2F; 采用自上而下的递归方法\n    var len &#x3D; arr.length;\n    if(len &lt; 2) &#123;\n        return arr;\n    &#125;\n    var middle &#x3D; Math.floor(len &#x2F; 2),\n        left &#x3D; arr.slice(0, middle),\n        right &#x3D; arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n&#125;\n\nfunction merge(left, right)\n&#123;\n    var result &#x3D; [];\n\n    while (left.length &amp;&amp; right.length) &#123;\n        if (left[0] &lt;&#x3D; right[0]) &#123;\n            result.push(left.shift());\n        &#125; else &#123;\n            result.push(right.shift());\n        &#125;\n    &#125;\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n&#125;\n\n实现-递归法：import java.util.Arrays;\n\n&#x2F;**\n * Created by chengxiao on 2016&#x2F;12&#x2F;8.\n *&#x2F;\npublic class MergeSort &#123;\n    public static void main(String []args)&#123;\n        int []arr &#x3D; &#123;9,8,7,6,5,4,3,2,1&#125;;\n        sort(arr);\n        System.out.println(Arrays.toString(arr));\n    &#125;\n    public static void sort(int []arr)&#123;\n        int []temp &#x3D; new int[arr.length];&#x2F;&#x2F;在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间\n        sort(arr,0,arr.length-1,temp);\n    &#125;\n    private static void sort(int[] arr,int left,int right,int []temp)&#123;\n        if(left&lt;right)&#123;\n            int mid &#x3D; (left+right)&#x2F;2;\n            sort(arr,left,mid,temp);&#x2F;&#x2F;左边归并排序，使得左子序列有序\n            sort(arr,mid+1,right,temp);&#x2F;&#x2F;右边归并排序，使得右子序列有序\n            merge(arr,left,mid,right,temp);&#x2F;&#x2F;将两个有序子数组合并操作\n        &#125;\n    &#125;\n    private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123;\n        int i &#x3D; left;&#x2F;&#x2F;左序列指针\n        int j &#x3D; mid+1;&#x2F;&#x2F;右序列指针\n        int t &#x3D; 0;&#x2F;&#x2F;临时数组指针\n        while (i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;\n            if(arr[i]&lt;&#x3D;arr[j])&#123;\n                temp[t++] &#x3D; arr[i++];\n            &#125;else &#123;\n                temp[t++] &#x3D; arr[j++];\n            &#125;\n        &#125;\n        while(i&lt;&#x3D;mid)&#123;&#x2F;&#x2F;将左边剩余元素填充进temp中\n            temp[t++] &#x3D; arr[i++];\n        &#125;\n        while(j&lt;&#x3D;right)&#123;&#x2F;&#x2F;将右序列剩余元素填充进temp中\n            temp[t++] &#x3D; arr[j++];\n        &#125;\n        t &#x3D; 0;\n        &#x2F;&#x2F;将temp中的元素全部拷贝到原数组中\n        while(left &lt;&#x3D; right)&#123;\n            arr[left++] &#x3D; temp[t++];\n        &#125;\n    &#125;\n&#125;\n\n\n\n用例1：计算二分图（bipartite graph）交叉点（crossing）的数量_imred的博客-CSDN博客_bipartite graph\n","slug":"Algorithm/SORT/MergeSort/Merge Sort","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Sort","author_index":"JBR_Bunjie"},{"id":"1223d7521828be4194e268189685670f","title":"创建Django项目","content":"Step 0. figure out the environment of your computer\neditor: vs code\nOS: windows 11\nShell: powershell\n\nStep1. create the virtual environment\nwe create a new folder named “django_test”\nwe run this command\n\npython -m venv .&#x2F;venv\n\nso that we will see a folder in “django_test” named “venv” has been created, what happened?\n\nwhat is python -m ?\n\n\nwhat is venv?\n\nwe can have a pure new environment of python which help us a lot.\nfor example, we can use pip freeze &gt; requirement.txt\n\nactive the virtual environment\n\nafter creating the venv folder, you can see there folders inside, and we enter the “Script” folder and exec activate.ps1 in powershell, then you should see the new command line like:\n(venv) PS C:\\Project\\django_test&gt;\n\nit means we have activated the virtual environment successfully.\nNow, you can use where command and you will see that the python.exe of venv folder was placed at the first place.\n(venv) PS C:\\Project\\django_test&gt; where.exe python\nC:\\Project\\django_test\\venv\\Scripts\\python.exe\nC:\\Users\\m1518\\AppData\\Local\\Programs\\Python\\Python310\\python.exe\nC:\\Users\\m1518\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe\n\n\n\n特别的，当你在powershell下使用脚本时，可能会遇到如下问题：\n&lt;YouProjectPath&gt;\\venv\\Scripts&gt; .\\activate.ps1\n.\\activate.ps1 : 无法加载文件 &lt;YouProjectPath&gt;\\venv\\Scripts\\Activate.ps1，\n因为在此系统上禁止运行脚本。有关\n详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 \n中的 about_Execution_Policies。\n所在位置 行:1 字符: 1\n+ .\\activate.ps1\n+ ~~~~~~~~~~~~~~\n    + CategoryInfo          : SecurityError: (:) []，PSSecurityException\n    + FullyQualifiedErrorId : UnauthorizedAccess\n\n这是因为在默认情况下，PowerShell对脚本的管理策略时是 Restricted。\nRestricted 执行策略不允许任何脚本运行。AllSigned 和 RemoteSigned 执行策略可防止 Windows PowerShell 运行没有数字签名的脚本。本主题说明如何运行所选未签名脚本（即使在执行策略为 RemoteSigned 的情况下），还说明如何对 脚本进行签名以便您自己使用。有关 Windows PowerShell 执行策略的详细信息，请参阅 about_Execution_Policy。\n\n想了解 计算机上的现用执行策略，在 PowerShell 然后输入 get-executionpolicy\n默认情况下返回的是 Restricted\n以管理员身份打开PowerShell 输入 **set-executionpolicy remotesigned**\n就可以正常在 PowerShell 中运行 ps1 文件了\n\n\n\n\n\n\n\n\n\npowershell - Set-ExecutionPolicy unrestricted permission denied - Stack Overflow\n\n退出\n\n退出虚拟环境很简单，只需要执行 deactivate 命令就行，这个命令也在虚拟环境的脚本目录下，因为激活时，将脚本目录设置到 PATH 中了，所以可以直接使用\n当然也可以直接输入powershell或bash等来重启你的terminal\nStep 2. install Djangojust use these commands below:\npip install django\n\npip install django-fliter\n\n# pip install markdown\n\ncd ..\ndjango-admin startproject &lt;YourProjectName&gt;\ncd &lt;YourProjectName&gt;\n\nYou can see your project have been created well here.\nYou can start the server directly by using python manage.py runserver, you will see something.\nLinks\nwindows - Equivalent of cmd’s “where” in powershell - Super User\nhttps://www.youtube.com/watch?v=F5mRW0jo-U4&amp;t=2866s\nvenv — Creation of virtual environments — Python 3.10.7 documentation\n\nCreate a Superuser(venv) PS C:\\Project\\django_test\\helloworld&gt; python manage.py createsuperuser\nUsername (leave blank to use &#39;m1518&#39;): \nEmail address: jbr_bunjie@outlook.com\nPassword: \nPassword (again): \nSuperuser created successfully.\n\n\n\n","slug":"Web Dev/Back End/django/CreateYourProject","date":"2022-12-23T04:23:23.000Z","categories_index":"Backend","tags_index":"Python,Django,Windows Powershell","author_index":"JBR_Bunjie"},{"id":"b14408b92d0c8809e1d3bbbaabf2879c","title":"Prim’s Minimum Spanning Tree","content":"\n\nPrim算法(Python实现)_JohnJim的博客-CSDN博客_prim算法python\n","slug":"Algorithm/Prim/Prim","date":"2022-12-22T04:23:23.000Z","categories_index":"Algorithm","tags_index":"MST","author_index":"JBR_Bunjie"},{"id":"a4d745e71ea13e3d21a3232d9b139847","title":"Chapter 1 of Computer Network","content":"1. BeginningQuestions\n\n\n\n\n\n\n\n\n\n什么是计算机网络？它是怎样发展起来的？\n计算机网络有那些功能？=&gt; 具体见\n网络上不同的计算机系统如何进行数据交换的？=&gt; 具体见\n什么是网络协议?=&gt; 具体见\n如何进行差错控制，流量控制? =&gt; 具体见\n如何进行路由选择?=&gt; 具体见\n如何保证网络安全？=&gt; 具体见\n\nAnswers\n\n\n\n\n\n\n\n\n主要回答了问题1，其他内容略有涉及，但主要集中在接下来的其他章节\n\n\n\n\n\n\n\n\n\n计算机网络是计算机技术与通信技术的产物\n定义笼统定义: 将若干台具有独立功能的计算机系统，用某种或多种通信介质连接起来，通过完善的网络协议，在数据交换的基础上，实现网络资源共享的系统称为计算机网络。 \n\n\n\n\n\n\n\n\n\n\n一个网络中包含了多个独立的计算机系统。 “独立”的含义是指每台计算机都可运行各自独立的操作系统，各计算机系统之间的地位平等，无主从之分，任何一台计算机不能干预或强行控制其他计算机的正常运行。\n数据交换是网络的最基本功能，各种资源共享都是建立在数据交换的基础上的。\n资源共享是网络最终目的。\n\n发展阶段初期；五十年代中期－六十年代中期；远程联机系统：世界上最早的计算机网络ARPANET（Internet的前身），由美国国防部高级计划研究署研制。ARPANET于1969年开通。最初仅连接美国本土的四个主机系统（加州大学洛杉矶分校，加州大学伯克利分校，斯坦福研究所，犹他大学），随后网络规模不断扩大，连接的主机数目越来越多，并由最初的纯军事网络演变成为面向教育，科研，商业的全球性网络。\n![image-20230302193235598](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_001)\n![image-20230302195015269](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_002)\n中期；六十年代末 - 七十年代末；计算机—计算机网络：\n![image-20230302195429892](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_003)\n![image-20230302195820874](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_004)\n\n\n\n\n\n\n\n\n\n计算机—计算机网络与远程联机系统的本质区别：\n计—计网络以资源共享为目标，在网络协议的支持下，用户使用远方计算机系统的资源就好像使用本地计算机系统一样方便。几乎觉察不到地理位置的差别。\n后期；八十年代 - 至今；开放式标准化网络\n具有统一的网络体系结构，遵守国际标准化协议，便于网络互连，大规模生产，降低成本 。如：\n\nOSI参考模型  \nCCITT建议\nTCP/IP协议族\n\n2. Homework什么是计算机网络的拓扑结构？按照拓扑结构，计算机网络可以分为哪几种？各有什么特点？\n\n\n\n\n\n\n\n\n还可以按地理范围分类：\n\n局域网LAN\n城域网MAN\n广域网WAN\n\n\n计算机网络的拓扑结构是指：计算机网络拓扑是指通信子网节点间连接结构的拓扑形式，通过结点与线段间的几何关系表示网络结构，反映网络中各实体的结构关系。\n\n按照拓扑结构，计算机网络可以分为：\n\n 星型网\n转输介质从一个中央结点向外辐射连接其他节点。\n任何两个结点之间的信息交换必须经过中央结点转发。\n中央结点的可靠性十分重要，一旦中央结点发生故障，会引起整个网络瘫痪\n\n![image-20230302201845313](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_005)\n\n环形网\n网络上所有的结点通过传输介质连接成一个闭环，任何两个结点的数据交换必须沿环进行。\n一旦结点或链路发生故障，则环路断开，导致网络瘫痪\n\n\n\n![image-20230302201909929](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_006)\n\n总线网络\n一条总线连接所有的结点，任何一个结点发送数据，其他节点都能收到。\n共享信道。\n任何结点故障都不会影响整个网络正常运行。\n\n\n\n![image-20230302201931552](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_007)\n\n不规则型网\n每个结点至少要和其他两个结点连接。\n可靠性好：任何一个结点或一条链路发生故障都不会影响网络的连通性。\n布线灵活，几乎不受任何拓扑结构的约束。\n\n\n\n\n\n![image-20230302201943498](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_008)\n\n\n\n\n\n\n\n\n\n小结:\n局域网: 总线型，星型，环型广域网: 不规则型\n点—点通信: 星型、不规则型 独占信道多点通信: 总线型、环型 共享信道\n网络中任意两台计算机系统之间可以采取哪些方式进行通信？分别有哪些特点？\n\n\n\n\n\n\n\n\n两个计算机系统进行通信实际上是指两个分别位于不同计算机系统中的程序之间进行通信。\n存在两种方式：客户服务器方式和对等方式\n\n客户服务器方式：通常称为C/S方式\n\n 客户端软件特点：\n被用户调用后运行，在打算通信时主动向远地服务器发起通信（服务请求）。因此，客户程序必须知道服务器程序的地址。\n不需要特殊的硬件和很复杂的操作系统。 \n服务端软件特点：\n一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。\n系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。\n一般需要强大的硬件和高级的操作系统支持。\n\n\n\n\n对等方式：通常称为P2P模式\n\n两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又同时是服务器。\n\n\n\n数据交换交换的作用是什么？按照数据交换形式，计算机网络可以分为哪几种？各有什么特点？\n\n\n\n\n\n\n\n\n![image-20230302203719178](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_009)\n数据交换是在多个数据终端设备之间，为任意两个终端设备建立数据通信临时互连通路的过程。其作用为接收来自源主机系统的数据，并向目的主机系统转发。\n数据交换有三种方式——电路交换、报文交换、分组交换\n\n电路交换：\n电路交换必定是面向连接的。 \n电路交换三阶段：Ⅰ.建立连接 Ⅱ.通信 Ⅲ.释放连接\n信道资源独占，通信线路的利用率很低\n实时性好\n\n\n\n![image-20230302204332122](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_010)![image-20230302204405984](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_011)\n\n分组交换：\n\n优点：\n高效：动态分配传输带宽，对通信链路是逐段占用。 \n灵活：以分组为传送单位和查找路由。\n迅速：不必先建立连接就能向其他主机发送分组。\n可靠：保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。  \n\n\n缺点：\n分组在各结点存储转发时需要排队，这就会造成一定的时延。 \n分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 \n\n\n\n\n报文交换：\n\n时延较长\n基于存储转发原理\n\n\n\n![image-20230302205659820](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_012)\n阐述分组交换的工作过程，说明其特点。\n工作过程：\n\n首先，在发送端，我们先把较长的报文划分成较短的、固定长度的数据段。\n完成划分后，我们对每一个数据段的段首加入“首部”构成不同的“分组”。\n之后分组交换网以“分组”作为数据传输单元，依次把各组发送到接收端。\n在接收端，收到分组后会剥去其首部以还原成报文。\n最后，在接收端把收到的数据恢复成为原来的报文。\n\n\n特点：\n\n高效：动态分配传输带宽，对通信链路是逐段占用。 \n灵活：以分组为传送单位和查找路由。\n迅速：不必先建立连接就能向其他主机发送分组。\n可靠：保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。  \n分组在各结点存储转发时需要排队，这就会造成一定的时延。 \n分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。\n\n\n\n请分别阐述你对“带宽”、“速率”、“吞吐量”、“时延”和“信道利用率”的认识，并说明信道利用率并非越高越好的原因。\n速率：“速率”即数据率或比特率，是计算机网络中最重要的一个性能指标。速率的单位是b/s, 或kb/s, Mb/s等。“速率”往往是指额定速率或标称速率。\n\n带宽：“带宽”本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫等），但现在，“带宽”体现了传输管道中可以传递数据的能力，它通常是数组信道所能传送的“最高数据率”的同义语，单位是“比特每秒”(bps, b/s, bit/s)，它还有多个不同大小的单位。\n\n吞吐量：“吞吐量”表示在单位时间内通过某个网络（或信道、接口）的数据量，它经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络，不过通常也受网络的带宽或网络的额定速率限制。\n\n时延：“时延”可分为处理时延、排队时延、传输时延和传播时延。\n\n传输时延（发送时延）是发送数据时，数据块从结点到进入传输介质所需的时间。\n\n![image-20230302211622698](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_013)\n\n传播时延是电磁波在信道中需要传播一定的距离而花费的时间。\n\n![image-20230302211635670](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_014)\n\n处理时延是交换结点为存储转发而进行一些必要的处理所花费的时间。\n排队时延是结点缓存队列中分组排队所经历的时延。\n数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和: 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延\n\n\n\n![image-20230302211812281](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_015)\n\n\n\n\n\n\n\n\n\n注意：对于高速网络链路，我们提高的仅仅是数据的发送速率，不是比特在链路上的传播速率。 提高链路带宽减小了数据的发送时延。 \n\n信道利用率：信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。\n网络利用率：则是全网络的信道利用率的加权平均值。\n\n\n\n\n\n\n\n\n\n\n\n信道利用率并非越高越好，理由如下：\n\n根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。\n若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用以公式：$$D=D_0/(1-U)$$来表示 D 和 D0之间的关系，其中 U 是信道利用率，数值在 0 到 1 之间。\n由该公式可简单推知，信道利用率过高会导致时延增大，所以信道利用率并非越高越好\n\n![image-20230302212551910](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_016)\nQuiz什么是计算机网络？从结构、分类等方面说说你对计算机网络的认识说说你对C/S模式和P2P模式的认识路由器的主要功能是什么？说说你对数据交换方式的认识![image-20230302203719178](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\1_009)\n为什么说带宽增大速率就会提高？说说你对时延的认识信道利用率是不是越高越好？为什么？说说你对因特网的三级ISP的认识","slug":"Internet Protocol/ComputerNetwork/Chapter1_General","date":"2022-11-23T04:23:23.000Z","categories_index":"Protocol Theory","tags_index":"Computer Network","author_index":"JBR_Bunjie"},{"id":"5ebead784411a9c38007c0b8eb5465fb","title":"Chapter 3 of Computer Network","content":"0. 课前思考1. 如何在模拟介质中传输数字信号？2. 如何保证通信双方协调通信？3. 如何让物理媒介传输更多的信息？1. 课堂提问1.谈谈你对数据、信号、信息以及信息量的认识\n数据：事件的某些属性规范化后的表现形式，它能被识别，也可以被描述。\n\n信号：数据的具体表现形式，具有确定的物理描述。\n\n信息：事件中包含的有意义的内容。\n\n\n\n\n\n\n\n\n\n信息是用来消除随机不确定性的东西。——《通讯的数学理论》，1948，香农\n\n信息量：信息的度量。信息量与事件出现的概率有关：$$I = I[P(x)]$$\n\n信息量是事件出现概率的函数：概率愈小，信息量愈大；反之，也成立:$$P = 1; I = 0;\\P = 0; I = ∞;$$\n\n若干个互相独立事件构成的信息量等于各独立事件信息量的和:$$I[P_1(x), P_2(x),…,P_n(x)] = I[P_1(x)] + I[P_2(x)] + … + I[P_n(x)];$$\n\n信息量运算公式：$$I(M) = -\\log_m \\frac{1}{M}$$\n\n\n\n\n2.说说你对通信系统模型的认识，数字通信有什么优点？3.说说你对码元、信号传输速率和信息传输速率的认识![image-20230303190142849](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\3_001)\n![image-20230303190414163](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\3_002)\n![image-20230303190703464](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\3_003)\n![image-20230303190735154](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\3_004)\n4.有哪几种数据传输方式？各有什么特点？5.什么是信源编码？为什么要进行信源编码？\n信源编码目的：将模拟信号转变为适合在数字信道上传输的数字信号\n\n信源编码作用：\n\n数据压缩\n模拟信号数字化\n\n\n\n6.信源编码包括哪几个过程？o  抽样：对模拟信号进行时间上的离散化处理，即每隔一段时间（通常时间间隔是一个固定值）对模拟信号抽取一个样值。\no  量化：为将连续的无限多种可能的样值变为有限的取值，并使用相应的数字序列表示，用有限位数的0、1数字序列表示被抽取的样值。\no  编码：将量化的结果按一定的码型转换成相应的二进制码组，获得能够在数字信道上传输的数字信号。\n7.为什么说根据奈奎斯特定理，数字化后对带宽频率的需求大大提高了？奎：如果媒体传输的最大频率为f，那么接受方只要以2f次的频率进行采样，就能完整地重现原信号。\n8.说说你非归零编码、曼彻斯特编码和差分曼彻斯特编码的认识。9.说说你对频分复用、时分复用、码分复用的认识。核心：一路信号独占一个信道对于充分发挥信道利用率、扩大通信的普及范围是极为不利的，也是不可想象。\n10.说说你对宽带接入技术的认识11.说说你对物理层协议的认识2. 课后作业1.阐述通信系统模型结构、指出各部分的主要作用和功能通信系统模型一般具有六个结构，包括：\n\n信源：把各种信息转换成原始物理信号，如计算机，FAX，电话机等。\n\n变换器：将原始物理信号转换成适合在信道上传输的信号，如MODEM,TA,光电转换器等。\n\n信道：传输信号的一条通路。通常一条物理线路可构成一个或多个信道。\n\n反变换器：具有与发送设备具有反向功能，目的是从受到减损的接收信号中正确恢复出原始物理信号\n\n信宿：将原始物理信号还原成原始信息，如扬声器\n\n噪声源：信道自身的噪声以及周围环境对信道的干扰。如热噪声，闪电，强电磁场干扰等。\n\n\n通过这些结构，我们就能将消息转换为物理信号（原始物理信号），原始物理信号经过各种发送设备的加工修饰后变得强壮，它能够较为顺利地通过信道到达接收设备处。\n2.数据通信方式有哪几种？各有什么特点？3.阐述信源编码的目的、作用和主要过程。4.阐述数字数据编码的目的和作用，并对二进制字符串“01101001”分别给出非归零、曼彻斯特和差分曼彻斯特编码。5.阐述多路复用的目的和作用，分别说明频分、时分和码分复用的原理和特点。","slug":"Internet Protocol/ComputerNetwork/Chapter3_PhysicsLayer","date":"2022-11-23T04:23:23.000Z","categories_index":"Protocol Theory","tags_index":"Computer Network","author_index":"JBR_Bunjie"},{"id":"d778590aa45aa75bc76fcb4037112854","title":"Chapter 4 of Computer Network","content":"0. 课前思考1. 如何才能做到向高层屏蔽物理通信的细节？构建对等层级，在走向上层之前进行装箱拆箱\n2. 如何发现和纠正传输过程中发生的数据错误？确认、校验、重发\n3. 如何加快或减缓数据传输的速率？1. 课堂提问1. 从提供的主要服务、具有的主要功能和不同的传输方式等方面，说说你对数据链路层的认识2. 说说你对数据链路层需要解决的基本问题的理解\n\n\n\n\n\n\n\n\n为实现可靠数据传输，数据链路层有许多问题需要解决，其中以下三个是最基本的共性问题：\n封装成帧：发送结点的数据链路层将网络层的数据报文添加首部和尾部后封装成帧。透明传输：数据报文中的任意数据都可以得到传输，高层应用无需担心特殊字符的传输问题。差错控制：接收方只接收无差错的数据帧。\n3. 从应用场景、协议组成、帧格式和运行过程等方面，说说你对PPP协议的理解。4. 从配置、格式和工作原理等方面,说说你对HDLC协议的理解。5. 从应用场景、协议组成、帧格式和运行过程等方面，说说你对PPP协议的理解。6. 说说你所认识的纯ALOHA和时隙ALOHA7. 在CSMA/CD中，可能会发生哪几种碰撞？发生碰撞后如何处理？8. 根据原理，说说CSMA/CA是如何解决隐蔽节点和暴露节点的。","slug":"Internet Protocol/ComputerNetwork/Chapter4","date":"2022-11-23T04:23:23.000Z","categories_index":"Protocol Theory","tags_index":"Computer Network","author_index":"JBR_Bunjie"},{"id":"1e6dfc30a649b3e508384cf6137376d2","title":"Chapter 2 of Computer Network","content":"\n\n\n\n\n\n\n\n\n课前思考如何在各自独立、相互平等的计算机系统之间有条不紊的通信？                ——建立秩序如何在结构相异、标准不同的计算机系统之间进行数据交换和资源共享？                ——建立共识\n1.课后习题1.阐述计算机网络体系结构的基本思想和主要特点。\n基本思想：将一个庞大、复杂的问题进行分解，产生若干个功能相对单一、结构比较简单、处理更为方便的局部问题，并基于此建立对应多个层级来解决问题。每层在自己下层所提供服务的支持下，通过自身内部功能实现一种或几种特定的服务。\n主要特点：\n耦合度低(独立性强)：每层只需调用下层接口即可获得下层的服务，无需关心下层的具体实现。即在上层看来，下层是具有特定功能的黑箱。　\n适应性强：只要每层提供的服务和接口不变，其内部实现细节可以任意改变。　\n易于实现和维护：把复杂的系统分解成若干个涉及范围小且功能简单的子系统，使得系统结构更加清晰，系统实现、调试和维护都变得简单和容易。\n\n\n\n2.结合定义，谈谈你对计算机网络体系结构的认识。首先，计算机网络体系结构的定义为：层、层间接口及协议的集合被称为计算机网络体系结构。\n这个定义与基于分层思想所需要解决的三个问题深度绑定的\n而分层思想有三个主要问题：\n\n确定分层与功能，即确定网络体系结构应该具哪些层次，以及每层应该具有哪些功能。\n\n确定服务与接口，即确定每个层次为上层提供哪些服务，以及上层调用这些服务的接口规格。\n\n确定协议，即确定每层的必须遵守的规则，以便确保通信的两方可以达成高度默契。\n\n\n因此，计算机网络体系结构的设计与划分就必须解决这三方面的内容。即通过对分层结构、每层的功能及服务与层间接口和协议的设计，解决我们的主要问题。基于这些内容，我们自然得出了我们的定义。\n3.阐述你对OSI/RM、Internet模型和五层结构模型的认识。\nOSI/RM模型\n\nOSI/RM体系结构具有概念清楚、理论完整的特点，是一个理论上的国际标准，但却不是事实上的国际标准；\nOSI/RM模型具体架构：\n最高层为应用层，这是计算机用户以及各种应用程序和网络之间的接口，能 直接向用户提供服务 并完成用户希望在网络上完成的各种工作，本层为用户的 应用进程 提供网络通信服务。\n第二层是表示层，会对上层数据或命令进行解释，以保证一个主机应用层信息可以被另一个主机的应用程序理解，使应用程序能够理解数据报文的真实含义。\n第三层是会话层，这是应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信向两个实体的表示层提供建立和使用连接的方法。\n第四层是传输层，这是通信子网与资源子网的分界层，同时也是通信子网和资源子网的接口和桥梁。本层向高层屏蔽数据通信的所有细节，为用户提供透明的报文传输，保证报文可靠的、正确的传输。提供端到端的可靠的透明数据传输，使上层服务用户不必关心通信子网的实现细节。\n第五层是网络层，这是通信子网中的最高层，在下两层的基础上向资源子网提供服务。在选择路由时，网络层将综合考虑优先权、网络拥塞程度、服务质量以及路由代价等决定从一个节点 到另一个节点的最佳路径。将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。\n第六层是数据链路层，本层负责建立和管理节点间的链路，控制网络层与物理层之间的通信。通过差错控制、流量控制方法，在不可靠的物理介质上提供可靠的数据传输。\n物理层是OSI的最底层，也是真正将数据在传输媒介上进行传输的层次。该层会为上层实现在物理介质上正确、透明的传送比特流。规定激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性，为上层协议提供一个传输数据的物理媒体。在物理介质上正确地、透明地传送比特流。即在源结点将1、0转化为强弱不同的电信号并进行传输,在目的结点，将强弱不同的电信号转化为1、0，也就是数模转换与模数转换。\n\n\n\n\nInternet模型\n\n因为模型中两个核心协议为TCP和IP协议，Internet模型也称为TCP/IP模型。\n\nTCP/IP协议簇是一个四层体系结构，具有简单易用特点，是事实上的国际标准。\n\nTCP/IP协议标准完全开放，可免费使用，且独立于特定计算机硬件及操作系统。\n\n独立于网络硬件系统，可以运行在广域网，更适合于互联网。\n\n网络地址统一分配，网络中每一设备和终端都具有一个唯一地址。\n\n高层协议标准化，可以提供多种多样可靠网络服务。\n\nTCP/IP协议具体架构：（以OSI/RM七层模型为标准）\n\n应用层：大体对应OSI参考模型的应用层、表示层和会话层。该层协议主要包括: \n\n\n\n\n\n\n\n\n\n\nFTP（文件传输协议）\nSMTP(简单报文传输协议)\nTELNET(远程网络登陆协议)\nDNS(域名服务)  \nHTTP（超文本传输协议）\n\n\n传输层：大体上对应OSI的传输层。该层协议包括：\n\n\n\n\n\n\n\n\n\n\nTCP(传输控制协议Transmission control protocol)：可靠的，面向连接的协议。将报文以字节流形式从源主机进程发到目的主机进程。\nUDP(用户数据报协议User Datagram protocol )：不可靠的，无连接的协议。\n\n\n网际层：大体上对应OSI的网络层。该层的协议是\n\n\n\n\n\n\n\n\n\nIP(INTERNET PROTOCOL)Internet 体系结构的核心协议。把IP分组以数据报方式从源主机发送到目的主机。\n\n网络接口层：大体上对应OSI的物理层和链路层。\n\n\n\n\n\n\n\n\n\nInternet体系结构的网络接口层也称为子网层，具有开放的特点。子网协议有：\n\n以太网协议\nFDDI\nPPP\nSLIP\nToken Bus (802.4)\n百兆，千兆，万兆以太网\n\n\n\n\n\n\n五层结构模型\n\n五层体系结构是结合了OSI/RM和TCP/IP协议簇的优点而提出来的一个五层结构的模型，但其存在意义只是为了学术学习研究，没有具体的实际意义。\n五层模型结构从上到下依次为：应用层、传输层、网络层、数据链路层、物理层\n\n\n\n2.课堂提问1.说说你对计算机网络体系结构的理解基于1.1及1.2中的认识，我们划分出计算机网络的体系结构\n补充部分\n\n\n\n\n\n\n\n\n从定义到实现：\n计算机网络体系结构是关于计算机网络及其部件所应完成功能的精确定义。\n实现(implementation)是在遵循这种体系结构的前提下用合适的硬件或软件完成这些功能的过程。\n体系结构是抽象的，实现则是具体的，是真正在运行的计算机硬件和软件。\n![image-20230303142731465](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\2_001)\n\n实体：任何可发送或接收信息的硬件或软件进程。\n接口：同系统内相邻层之间的交互通道，也称为服务访问点SAP（Service Access Point）。\n协议：控制对等层实体间进行数据交换的规则、约定和标准。\n服务：为保证上层对等实体间的通信，由下层向上层提供的功能。\n\n协议的影响范围是对应的那一层(系统间的对等层)，有“协议是水平的”之说\n服务的影响范围上下相邻层，有“服务是垂直的”之说\n![image-20230303143700028](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\2_002)\n2.说说你对网络协议的理解\n\n\n\n\n\n\n\n\n网络协议(network protocol，简称协议)，是为进行网络数据交换而建立的规则、标准或约定。 也就是说，对等实体间的共识就是协议。\n协议：网络对等实体间为完成数据交换所必须遵循的规则、约定和标准。\n在构建通信协议时，存在三要素：语法、语义和时序（同步）。\n\n语法是指协议元素与数据的组合结构，也就是 报文格式。\n语义是指对协议中各协议元素的含义的解释。\n时序（也称为同步）是指在通信过程中，通信两方操作的执行顺序与规则。\n\n语法规定了报文格式，语义赋予了报文特定内涵；时序则通过控制具有特定语义的报文的交换，从而实现了计算机间的通信。\n\n\n\n\n\n\n\n\n\n语法是语义的载体，时序又是对语义的有序组织。正是基于这样的关系，计算机在通信时才得以保持高度默契。\n在定义好协议后，便可以依据协议内容进行数据(信息报文)的传输：\n![image-20230303145337491](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\2_003)\n\n\n\n\n\n\n\n\n\n两个端系统之间的数据通信过程本质上就是PDU的不断封装和解封过程:\n\n在源系统，数据在自上而下逐层递交的过程就是PDU不断封装的过程；\n在目的系统，当数据到达后自下而上递交的过程就是PDU不断拆封的过程。\n\nPDU具体变化可参考3.1\n3.说说你对OSI/RM与TCP/IP两个模型的理解1.3\n4.说说你对应用层的认识，举例说说你所知道的应用层协议1.3\n3.重点内容补充3.1 两主机间互传数据过程\n\n\n\n\n\n\n\n\n计算机间通信的本质在于信息报文的交换。\n\n\n\n\n\n\n\n\n\n基于五层体系结构模型，注意数据链路层同时加装了首部与尾部，而其他层只有首部；最下层的物理层不会加装任何首、尾部，但会将数据正式转化为比特流\n![image-20230303150649221](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\2_004)\n3.2 基于OSI/RM模型的层次解析图![image-20230303151058783](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\2_005)\n3.3 三种主要模型比较![image-20230303152536659](C:\\Users\\m1518\\OneDrive\\DOCUMENTS\\MARKDOWN DOCUMENTS\\Internet Protocol\\ComputerNetwork\\ImageResources\\2_006)\n特别的，我们以OSI/RM模型为基准，对照地看待TCP/IP时，有如1.3的内容\n","slug":"Internet Protocol/ComputerNetwork/Chapter2_Structure","date":"2022-11-23T04:23:23.000Z","categories_index":"Protocol Theory","tags_index":"Computer Network","author_index":"JBR_Bunjie"},{"id":"13957a375b1f4d8dbb85454bdce75343","title":"Chapter 5 of Computer Network","content":"1. 课堂提问1. 说说你对网桥的认识2. 网络中形成环后会有什么后果？如何处理？3. 说说你对VLAN的认识4. 说说你对虚电路和数据报的理解","slug":"Internet Protocol/ComputerNetwork/Chapter5","date":"2022-11-23T04:23:23.000Z","categories_index":"Protocol Theory","tags_index":"Computer Network","author_index":"JBR_Bunjie"},{"id":"57d5800b0ce1e7689f82868780b3f764","title":"Chapter 6 of Computer Network","content":"1. 课堂提问1. 说说你对静态路由和动态路由的认识2. 说说你对D-V算法与L-S路由算法的理解3. 超网IP地址与子网划分的IP地址有什么显著区别？4. 除了具体的功能不同外，ICMP与ARP还有什么显著的区别？5. 说说你对ARP及免费ARP的认识","slug":"Internet Protocol/ComputerNetwork/Chapter6","date":"2022-11-23T04:23:23.000Z","categories_index":"Protocol Theory","tags_index":"Computer Network","author_index":"JBR_Bunjie"},{"id":"2679faecf929a89d04089c85f6582773","title":"从Json杀到Yaml","content":"从Json杀到YamlJson介绍什么是Json？\n\n\n\n\n\n\n\n\nJSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.\n\nJson是一种轻量级数据交换格式。它有着可读性高，易于机器解析和生成的优点，它是编程语言Js 第三版ECMA-262规范的一个子集。JSON 是一种完全独立于语言的文本格式，但是却使用了C系程序员熟悉的相关约定如C, C++, C#, Java, JavaScript, Perl, Python, and many others。这些特性使 JSON 成为一种理想的数据交换语言。\n\nJson语法Json is built on two structures:\n\nA collection of name/value pairs. In various languages, this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array.\nAn ordered list of values. In most languages, this is realized as an array, vector, list, or sequence.\n\nThese are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages also be based on these structures.\n这些是通用的数据结构。几乎所有的现代编程语言都以这样或那样的形式支持它们。所以一个可以融入编程语言的数据格式自然也应当基于这些结构来设计。\n&#123;\n    &quot;object1&quot;: [\n    &#123; &quot;key1.1&quot;:&quot;value1.1&quot; , &quot;key1.2&quot;:&quot;value1.2&quot; &#125;, \n    &#123; &quot;key2.1&quot;:&quot;value2.1&quot; , &quot;key2.2&quot;:&quot;value2.2&quot; &#125;, \n    ...\n    ],\n    &quot;object2&quot;:&quot;valueForObject2&quot;,\n    &quot;object3&quot;: ...\n&#125;\n\nJson整体是一个对象Object，其中内容是无序的name/value键值对集合，name以string构建，value可以以array, string, number, object, true, false和null中的任意一种来构建。array中的元素一般为Object的对象，value又可以直接调用Object，如此便形成嵌套。name与value以 :分隔。\n当我们引用Json数据时，我们对Object中的键值使用点计法取名引用，对数组数据用一般引用数组的办法Array[ n ]来引用\n\n\n\n\n\n\n\nWARNING\n原生Json并不支持注释，如果一定需要使用注释，可以查阅Json schema或者换用JSON5，虽然JSON5是第三方库，但仍然严格符合JS标准，并且JSON5.parse与JSON.parse的解析结果一致。当然，你也可以直接换用换用下面的Yaml\n\n\nYaml介绍\n\n\n\n\n\n\n\n\nYAML Ain’t Markup Language, YAML is a human friendly data serialization language for all programming languages.\n有意思的是，虽然YAML是YAML Ain’t Markup Language的缩写，但是这个缩写中的YAML其实是Yet Another Markup Language的缩写，即：这是一个标记语言。正式名称改为了“不是标记语言”，这一点颇为有趣，也耐人寻味——强调其以数据作为重心，而非标记语言。\n截止2021.9.27，Yaml的最新版本为1.2.1(发布于2009.10.1)\n到2021.10.1，Yaml发布了最新版：1.2.2\n\n\n\n\n\n\n\n\n\nWe are excited to announce the release of Revision 1.2.2 of the YAML 1.2 Specification. This revision comes 12 years to the day after the previous revision.\n如果你没有耐心啃最新的文档的话，你只需要看一句话：No normative changes from the 1.2.1 revision. YAML 1.2 has not been changed. 就行\nyaml优点\n\n\n\n\n\n\n\n\nThe design goals for YAML are, in decreasing priority:\n\nYAML is easily readable by humans.（易读\nYAML data is portable between programming languages.（跨语言\nYAML matches the native data structures of agile languages.（与当前语言的数据结构兼容\nYAML has a consistent model to support generic tools.（支持通用工具\nYAML supports one-pass processing.\nYAML is expressive and extensible.\nYAML is easy to implement and use.\n\n\nYAML中没有额外的定界符，所以相比JSON更轻量级。\n没有额外定界符，所以更易读（不过这一点颇为激进，时至今日仍有很多开发者无法接受这种以缩进来界定结构的做法，因为经常出现“一个空格引发的悲剧”）\nYAML使数据更易于理解，因此常用于配置文件中（很经常看见别人将.properties改为.yaml）\nYAML是JSON 的超集，对于合法的JSON代码，同样可以被YAML解析，这样对于使用JSON和YAML的应用来说，可以使用一个解析器完成两种解析。然而其并没有如期望中那样受欢迎，具体而言，因为不同的序列化语言都有其特定的适宜语言或者场景（下文可以提到），并且相较于其他广泛使用的序列化语言，YAML有一些不足。\n\nYAML使用场景对于序列化语言来说，使用场景如下：\n\n与服务器之间传输数据\n使用一个配置文件来配置应用，这些文件声明对应参数和相应取值\n在同一个应用不同组件之间转换数据\n中间数据存储：针对此类场景，YAML有一些明确的优势相比于其他同类语言。也是为什么现在越来越多的开发者使用其的地方。\n\nYAML语法：Yaml与Json一样同时支持对象和数组，但是Yaml将其余的所有值全部归为“纯量”\n# yaml代码示例：\nlanguages:\n  - Ruby\n  - Perl\n  - Python \n  # 以 - 开头的行表示构成一个数组\nwebsites:\n  YAML: yaml.org \n  Ruby: ruby-lang.org \n  Python: python.org \n  Perl: use.perl.org\n  # 对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200W\n    -\n        id: 2\n        name: company2\n        price: 500W\n        # 意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n转换为 json 为：\n&#123; \n  languages: [&#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39;],\n  websites: &#123;\n    YAML: &#39;yaml.org&#39;,\n    Ruby: &#39;ruby-lang.org&#39;,\n    Python: &#39;python.org&#39;,\n    Perl: &#39;use.perl.org&#39; \n  companies: [&#123;\n      \tid: 1,\n      \tname: company1,\n      \tprice: 200W\n  \t  &#125;, &#123;\n    \tid: 2,\n    \tname: company2,\n    \tprice: 500W\n\t&#125;]\n  &#125; \n&#125;\n\nyaml相比json？\n\n\n\n\n\n\n\n\nofficial document:\nBoth JSON and YAML aim to be human readable data interchange formats. However, JSON and YAML have different priorities. JSON’s foremost design goal is simplicity and universality. Thus, JSON is trivial to generate and parse, at the cost of reduced human readability. It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment.\n\nJson和Yaml的目标都是人类可读的数据交换格式。但是，Json和Yaml对于目标有不同的优先级。Json格式设计的首要目标是simplicity和universality。因此Json容易生成和解析，代价就是减少可读性。\nIn contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary [native data structures](https://yaml.org/spec/1.2.1/#native data structure//). Thus, YAML allows for extremely readable files, but is more complex to generate and parse. In addition, YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments.\nYAML中有很多方式来体系化数据层级，因此处理时会相对复杂些。性能上相对于XML和JSON会有差别。\n\nyaml与yml区别?.yaml与.yml都是yaml格式的拓展名，虽然.yaml才是官方推荐的拓展格式，但是到目前为止，yml仍然被广泛使用：GitHub上 .yml相关总提交次数为1千3百万次，而.yaml总次数仅为5百万次\n贴一个比较古早的stackoverflow的问题链接：configuration files - Is it .yaml or .yml? - Stack Overflow\n如果你不太想看的话，以下由简略版本：\n\n\n\n\n\n\n\n\n\n正方：I like .yml, it’s 25% faster to write. ☝😆. Personally, I’m fine with whichever is the “standard” \n反方：Some people like to stick to 3 letter extensions as it was back in the old days when file systems were still limited to short names\n但是我仍然推荐使用yaml，作为官方推荐的拓展格式，它也许可以帮你避免很多意料之外的error。\n关于配置文件：是.yaml还是.yml？ | 码农家园 (codenong.com)\n本来找到了原文，但是链接丢了(((φ(◎ロ◎;)φ)))，坏欸\n\n参考资料：\nJSON\nJSON Schema | The home of JSON Schema (json-schema.org) \nJSON5 | JSON for Humans\nThe JSON5 Data Interchange Format\nThe Official YAML Web Site\nYAML File Format\nYAML Documentation · YAML\nYAMLlint - The YAML Validator\nyaml/yaml: YAML language and community information (github.com)\n\n \n","slug":"Language Learning/从json杀到yaml","date":"2021-11-16T08:15:04.000Z","categories_index":"Programming Language Learning","tags_index":"Json","author_index":"JBR_Bunjie"},{"id":"2679faecf929a89d04089c85f6582773","title":"从Json杀到Yaml","content":"从Json杀到YamlJson介绍什么是Json？\n\n\n\n\n\n\n\n\nJSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.\n\nJson是一种轻量级数据交换格式。它有着可读性高，易于机器解析和生成的优点，它是编程语言Js 第三版ECMA-262规范的一个子集。JSON 是一种完全独立于语言的文本格式，但是却使用了C系程序员熟悉的相关约定如C, C++, C#, Java, JavaScript, Perl, Python, and many others。这些特性使 JSON 成为一种理想的数据交换语言。\n\nJson语法Json is built on two structures:\n\nA collection of name/value pairs. In various languages, this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array.\nAn ordered list of values. In most languages, this is realized as an array, vector, list, or sequence.\n\nThese are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages also be based on these structures.\n这些是通用的数据结构。几乎所有的现代编程语言都以这样或那样的形式支持它们。所以一个可以融入编程语言的数据格式自然也应当基于这些结构来设计。\n&#123;\n    &quot;object1&quot;: [\n    &#123; &quot;key1.1&quot;:&quot;value1.1&quot; , &quot;key1.2&quot;:&quot;value1.2&quot; &#125;, \n    &#123; &quot;key2.1&quot;:&quot;value2.1&quot; , &quot;key2.2&quot;:&quot;value2.2&quot; &#125;, \n    ...\n    ],\n    &quot;object2&quot;:&quot;valueForObject2&quot;,\n    &quot;object3&quot;: ...\n&#125;\n\nJson整体是一个对象Object，其中内容是无序的name/value键值对集合，name以string构建，value可以以array, string, number, object, true, false和null中的任意一种来构建。array中的元素一般为Object的对象，value又可以直接调用Object，如此便形成嵌套。name与value以 :分隔。\n当我们引用Json数据时，我们对Object中的键值使用点计法取名引用，对数组数据用一般引用数组的办法Array[ n ]来引用\n\n\n\n\n\n\n\nWARNING\n原生Json并不支持注释，如果一定需要使用注释，可以查阅Json schema或者换用JSON5，虽然JSON5是第三方库，但仍然严格符合JS标准，并且JSON5.parse与JSON.parse的解析结果一致。当然，你也可以直接换用换用下面的Yaml\n\n\nYaml介绍\n\n\n\n\n\n\n\n\nYAML Ain’t Markup Language, YAML is a human friendly data serialization language for all programming languages.\n有意思的是，虽然YAML是YAML Ain’t Markup Language的缩写，但是这个缩写中的YAML其实是Yet Another Markup Language的缩写，即：这是一个标记语言。正式名称改为了“不是标记语言”，这一点颇为有趣，也耐人寻味——强调其以数据作为重心，而非标记语言。\n截止2021.9.27，Yaml的最新版本为1.2.1(发布于2009.10.1)\n到2021.10.1，Yaml发布了最新版：1.2.2\n\n\n\n\n\n\n\n\n\nWe are excited to announce the release of Revision 1.2.2 of the YAML 1.2 Specification. This revision comes 12 years to the day after the previous revision.\n如果你没有耐心啃最新的文档的话，你只需要看一句话：No normative changes from the 1.2.1 revision. YAML 1.2 has not been changed. 就行\nyaml优点\n\n\n\n\n\n\n\n\nThe design goals for YAML are, in decreasing priority:\n\nYAML is easily readable by humans.（易读\nYAML data is portable between programming languages.（跨语言\nYAML matches the native data structures of agile languages.（与当前语言的数据结构兼容\nYAML has a consistent model to support generic tools.（支持通用工具\nYAML supports one-pass processing.\nYAML is expressive and extensible.\nYAML is easy to implement and use.\n\n\nYAML中没有额外的定界符，所以相比JSON更轻量级。\n没有额外定界符，所以更易读（不过这一点颇为激进，时至今日仍有很多开发者无法接受这种以缩进来界定结构的做法，因为经常出现“一个空格引发的悲剧”）\nYAML使数据更易于理解，因此常用于配置文件中（很经常看见别人将.properties改为.yaml）\nYAML是JSON 的超集，对于合法的JSON代码，同样可以被YAML解析，这样对于使用JSON和YAML的应用来说，可以使用一个解析器完成两种解析。然而其并没有如期望中那样受欢迎，具体而言，因为不同的序列化语言都有其特定的适宜语言或者场景（下文可以提到），并且相较于其他广泛使用的序列化语言，YAML有一些不足。\n\nYAML使用场景对于序列化语言来说，使用场景如下：\n\n与服务器之间传输数据\n使用一个配置文件来配置应用，这些文件声明对应参数和相应取值\n在同一个应用不同组件之间转换数据\n中间数据存储：针对此类场景，YAML有一些明确的优势相比于其他同类语言。也是为什么现在越来越多的开发者使用其的地方。\n\nYAML语法：Yaml与Json一样同时支持对象和数组，但是Yaml将其余的所有值全部归为“纯量”\n# yaml代码示例：\nlanguages:\n  - Ruby\n  - Perl\n  - Python \n  # 以 - 开头的行表示构成一个数组\nwebsites:\n  YAML: yaml.org \n  Ruby: ruby-lang.org \n  Python: python.org \n  Perl: use.perl.org\n  # 对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200W\n    -\n        id: 2\n        name: company2\n        price: 500W\n        # 意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n转换为 json 为：\n&#123; \n  languages: [&#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39;],\n  websites: &#123;\n    YAML: &#39;yaml.org&#39;,\n    Ruby: &#39;ruby-lang.org&#39;,\n    Python: &#39;python.org&#39;,\n    Perl: &#39;use.perl.org&#39; \n  companies: [&#123;\n      \tid: 1,\n      \tname: company1,\n      \tprice: 200W\n  \t  &#125;, &#123;\n    \tid: 2,\n    \tname: company2,\n    \tprice: 500W\n\t&#125;]\n  &#125; \n&#125;\n\nyaml相比json？\n\n\n\n\n\n\n\n\nofficial document:\nBoth JSON and YAML aim to be human readable data interchange formats. However, JSON and YAML have different priorities. JSON’s foremost design goal is simplicity and universality. Thus, JSON is trivial to generate and parse, at the cost of reduced human readability. It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment.\n\nJson和Yaml的目标都是人类可读的数据交换格式。但是，Json和Yaml对于目标有不同的优先级。Json格式设计的首要目标是simplicity和universality。因此Json容易生成和解析，代价就是减少可读性。\nIn contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary [native data structures](https://yaml.org/spec/1.2.1/#native data structure//). Thus, YAML allows for extremely readable files, but is more complex to generate and parse. In addition, YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments.\nYAML中有很多方式来体系化数据层级，因此处理时会相对复杂些。性能上相对于XML和JSON会有差别。\n\nyaml与yml区别?.yaml与.yml都是yaml格式的拓展名，虽然.yaml才是官方推荐的拓展格式，但是到目前为止，yml仍然被广泛使用：GitHub上 .yml相关总提交次数为1千3百万次，而.yaml总次数仅为5百万次\n贴一个比较古早的stackoverflow的问题链接：configuration files - Is it .yaml or .yml? - Stack Overflow\n如果你不太想看的话，以下由简略版本：\n\n\n\n\n\n\n\n\n\n正方：I like .yml, it’s 25% faster to write. ☝😆. Personally, I’m fine with whichever is the “standard” \n反方：Some people like to stick to 3 letter extensions as it was back in the old days when file systems were still limited to short names\n但是我仍然推荐使用yaml，作为官方推荐的拓展格式，它也许可以帮你避免很多意料之外的error。\n关于配置文件：是.yaml还是.yml？ | 码农家园 (codenong.com)\n本来找到了原文，但是链接丢了(((φ(◎ロ◎;)φ)))，坏欸\n\n参考资料：\nJSON\nJSON Schema | The home of JSON Schema (json-schema.org) \nJSON5 | JSON for Humans\nThe JSON5 Data Interchange Format\nThe Official YAML Web Site\nYAML File Format\nYAML Documentation · YAML\nYAMLlint - The YAML Validator\nyaml/yaml: YAML language and community information (github.com)\n\n \n","slug":"Language Learning/MARK LANGUAGE/从json杀到yaml","date":"2021-11-16T08:15:04.000Z","categories_index":"Programming Language Learning","tags_index":"Json","author_index":"JBR_Bunjie"},{"id":"fc9433631750b4e2a27c5cd3c21a72be","title":"Python编程入门","content":"Python 3 Basic Grammar Training为什么是python？一个最重要的原因——简单，快速，容易上手：\n你也可以通过著名的开发语言排行榜TIOBE来直观感受Python有多么热门index | TIOBE - The Software Quality Company\npython官网：Welcome to Python.orgpython社区（PYPI）：PyPI · The Python Package Indexpython最大的优势：开发效率高python最大的劣势：运行效率低开发效率与运行效率间的取舍是动态语言不可能绕过的问题，Python选择了开发效率换运行效率。\n但是python支持嵌入c，c++等高效率的低级语言，可以在一定程度上缓解这个问题\n配置你的电脑环境：安装Python 3.8（Python会自带一个编辑器”IDLE”，不过只提供了基础的代码编写功能）\n你可以通过我\n关于IDE，我会推荐推荐使用Jet Brains公司出品的Pycharm。当然，宇宙第一IDE——Visual Studio也是不错的选择\n\n\n\n\n\n\n\n\n\n关于Python的版本：\nPython3中的更新与c/c++的新标准，Java的新版本等有相通之处；\n\n每次Python更新都会推出很多新的feature，3.7版本中更新了这些内容：https://docs.python.org/zh-cn/3.7/whatsnew/3.7.html，如果你需要了解当前版本更新了什么，最好的办法当然是去阅读Python的官方文档，当然，你也可以直接在Python自带的ide：idle来查阅Python的版本变化信息。在idle中，你可以按照Help &gt;&gt;&gt; Python Docs &gt;&gt; What’s New In Python 3.7的路径来查看\n简单来说，python的更新会添加新的语法，提升python的稳定性(一般)，少数情况下会删除旧的语法与功能（3.10的兼容性差大概就是这么来的）\n截止本文完成时，Python已经推出了发布3.11版本的计划，并且已经推出了Python3.11的文档：What’s New In Python 3.11 — Python 3.11.0a0 documentation\n\n正式开始！从命令行开始！\n这时，cmd就进入了python的编写模式，支持python 当前版本的所有语法，和python自带的编辑器\n\n\n\n\n\n\n\n\n\n当然，你也可以使用windows的powershell，不过相对于cmd而言，powershell更加复杂，而且有各种莫名其妙的限制\n\n\n\n\n\n\n\nWARNING\n注意，如果你在cmd中输入python后打开的是windows 商店，这是你操作系统的环境变量出了问题，请在edit the system environment variables下仔细检查Path中python条目下的环境变量指向的地址！\n\n\n现在尝试打印Hello World吧所有你需要做的只是输入\nprint(&quot;Hello World&quot;)\n\ncmd就会显示：\n\n简单吧！相信你一定会爱上python这门简单的语言的\n如果你要回到cmd的初始状态，只需要用 quit() 即可\n\n什么时候需要使用到命令行？比如我现在已经编写完成了一个基于python的脚本。在命令行中，我们甚至无需要进入python的编辑模式，只需输入python + 文件路径即可直接执行。一般来说，启动一个ide是很耗费时间的，而这就是我们节约时间的手段。\n\n在pycharm中继续：PyCharm介绍官网：PyCharm: the Python IDE for Professional Developers by JetBrains\n至于为什么选用它，建议逼乎一下😂\n新建项目\n对pycharm的一些初始设置：\n设置编码：（都改为utf-8）\n设置新建文件的默认代码和内容：\n\n你可以在PyCharm的官网上找到所有的File template variables：File template variables | PyCharm (jetbrains.com)\n在console里执行命令：前面已经提到过在命令行中执行Python代码，这当然是运行已经编写好的Python程序或脚本的好办法。但是命令行中执行程序后就立刻输出结果并结束程序，那要是程序结束后我还想继续执行更多操作怎么办？\n这时候你可能需要用到Python Console功能\npycharm中的console就是一个pychon的直接运行环境，这里允许你以解释性的形式逐句输入并运行python代码。值得一提的是，在PyCharm中运行你的Python文件时，默认输出到Python Console中，这意味着你可以在程序结束完成之后接着输入更多内容\n\n\n\n\n\n\nTIP\n当你有不确定的代码需要验证的时候，不妨先复制到console里试一试！\n\n\n数据类型：在学习语法之前，你需要了解构成程序的要素是什么\n如果你有过其它语言的编程经验的话，你可能会说“数据结构+算法”\n但是如果你纯新手的话，那这可能难以理解。那么我会说，程序是由符合当前编程语言语法的语句依次执行生成的，构建程序的基本内容是数据的运算与处理\n很显然，就数据的处理而言，直接使用 1 + 2 等既定的数据常量是远远不够的——我们需要应付更多变的情况——这就要用到变量\nPython变量命名规则和其它语言一样，Python也有自己的变量命名规则\n\n第一个字符必须是字母表中字母或下划线 _ \n\n标识符的其他的部分由字母、数字和下划线组成\n\n标识符对大小写敏感\n\n注意避开python自己的保留字符\n你可以通过以下语句来查询Python保留的关键字符\nimport keyword \nkeyword.kwlist\n\n示例：\n关于变量的基本数据类型：在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。\nPython 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\n\n\n\n\n\n\n\n\n\n不过Python中的确存在这些“基本数据类型”如：int，float之类的，并且它们之间都存在着严格的限制\n你可以使用 type() 函数来检查当前变量的数据类型：\n标准数据类型：\n不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；\n可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。\n\n共六种\n关于可变与不可变数据：什么是不可变数据？\n在Python中，我们可以设立变量 a = 1，之后我们可以对 a 的值做出改变，比如又执行语句 a = 2，这时 a 当然就不再指向1，但是1这个“内容”本身并没有改变。\n而可变数据则是可以改变数据的具体内容：如语句 a = [1, 2]，我们可以将 a 中的[0], [1]等数据单独拎出来并做出改变而并不改变 a 本身的指向\n这些“指向”，“内容”都是基于内存地址来说的。\n不可变数据类型： 当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。\n可变数据类型  ：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。\n你可以用 id(变量名)来查验对应变量的内存地址是否发生变化\n数字：int float…\n列表：Python中功能最强大的数据类型用“[ ]”来定义列表！\n列表支持：\n\n列表间的拼接\n定义以列表为元素的列表\n将整个列表赋给新列表（也可以使用copy()函数：）\n通过append()，entend()，insert()，实现增\n通过pop()，remove()，实现删 \n支持通过截取来获取列表内容（截取参看字符串\n\n元组：”常量列表“不能改变元素个数的列表，列表中一切涉及改变元素个数改变的功能全部NG\n用 “( )” 来定义一个元组\n\n\n\n\n\n\n\nWARNING\n元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：\n\n\n\n字符串：特化列表\npython允许直接把字符/字符串存储到一个变量中\n\n&gt;&gt;&gt; a &#x3D; &quot;bunjie&quot;\n&gt;&gt;&gt; a[-1]\n&#39;e&#39;\n&gt;&gt;&gt; a[0]\n&#39;b&#39;\n&gt;&gt;&gt; a[1]\n&#39;u&#39;\n&gt;&gt;&gt; a[:]\n&#39;bunjie&#39;\n&gt;&gt;&gt; a[0:1]\n&#39;b&#39;\n&gt;&gt;&gt; a[0:5]\n&#39;bunji&#39;\n&gt;&gt;&gt; a[0:6]\n&#39;bunjie&#39;\n&gt;&gt;&gt; a[0:7]\n&#39;bunjie&#39; #没有报错\n&gt;&gt;&gt; a[-1:-2]\n&#39;&#39;\n&gt;&gt;&gt; a[:-1]\n&#39;bunji&#39;\n&gt;&gt;&gt; a[:-6]\n&#39;&#39;\n&gt;&gt;&gt; a[:-5]\n&#39;b&#39;\n\n\n字典：使用键值对进行匹配，类似c语言中的“枚举类型”，以键值对构建数据内容 &#123;key: value, ...&#125;\nd &#x3D; &#123;key1 : value1, key2 : value2, key3 : value3 &#125;\nprint(d[key1])\n# 输出：value1\n\nD &#x3D; &#123;&#125; # 我们可以使用大括号来创建空字典\n\n字典可能是所有数据类型中最高效的，因为取元素时直接采用key来定点查找而不是像是list等数据类型依次迭代查找\n集合：是的，就是集合论中的集合\n总体来说，集合这种数据类型我们使用得较少，做可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 **{ }**，因为 { } 是用来创建一个空字典。\n创建格式：\nparame1 &#x3D; &#123;value01, value02, ...&#125; # 注意格式\nparame2 &#x3D; set() # set只允许单个参数，我们一般使用set来创建空集合\n\n\n\n\n\n\n\n\n\n\n根据我们中学时所学到的知识，我们知道：集合具有确定性、互异性、无序性\n根据这些性质，我们获知：单个确定数据只会出现一次。所以如果出现重复的值，集合会把相同的合并。\n语法：关于注释：什么是注释？注释是你在程序中插入的解释性的文字，单纯的只是为了方便别人和自己理解当前程序。程序在运行时会忽略所有被注释的部分，所以你留下的注释并不会对程序功能造成任何实际上的影响\npython中的注释方式：\n以 # 作为单行注释，在pycharm中，你可以使用   ctrl + / 来快速注释一整行:\n# 这是一个单行注释\n以一对三个连续的单引号**&#39;&#39;&#39; &#39;&#39;&#39;，或一对三个连续的双引号&quot;&quot;&quot; &quot;&quot;&quot;**来作为多行注释\n&quot;&quot;&quot;\n这是一个多行注释\n&quot;&quot;&quot;\n\n&#39;&#39;&#39;\n这也是一个多行注释\n&#39;&#39;&#39;\n\n关于缩进：Python没有 &#123; &#125;，它采用精确的缩进来确定控制语句的执行范围！\n一个项目里最好只采用 tab 和 space 两种中的一种缩进，如果在一个控制体里使用了两种缩进格式是会报错的\n个人建议使用 tab 作为缩进\n\npython没有分号：“ ; ”， 语句间几乎没有大括号，代价是精确的缩进！\n条件控制语句为什么使用条件控制？当然是为了以一个程序去应对多种可能性\n例如：我们解决除法运算时，我们当然需要以除数不为零来分类，但是我们不可能因为这一点就开发两个程序，并且要求用户根据除数是什么来选择运行那个程序——这就要求我们在设计程序的时候为某些特定情况运行特定代码\nPython中的条件控制语句长什么样？Python中if语句的一般形式如下所示：\nif condition_1:    \n    statement_block_1 \nelif condition_2:    \n    statement_block_2\n# 更多情况使用elif condiition_3: ... 并以此类推\nelse:\n    statement_block_3\n\n\n如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句\n如果 “condition_1” 为False，将判断 “condition_2”\n如果”condition_2” 为 True 将执行 “statement_block_2” 块语句\n如果 “condition_1”与”condition_2”均为False，那么将执行”statement_block_3”块语句\n\n\n\n\n\n\n\n\nWARNING\n1、每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。\n2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。\n3、在Python中没有switch – case语句。\n\n\n循环语句：循环的意义有点类似于乘法之于加法，它提供了一种解出某一个条件下的最终结果的方式。借助循环，计算机能够非常高效的完成人很难或无法完成的事情，比如说，在大量文件中查找包含某个搜索词的文档，对几十万条销售数据进行统计汇总等。\nwhile循环：while 判断条件(condition)：    \n\t执行语句(statements)……\n# 每次循环之前都会进行一次condition是否为真的判断，如果结果为false，则立即停止循环\n\nfor循环：for &lt;variable&gt; in &lt;sequence&gt;:\n    &lt;statements&gt;\nelse:\n    &lt;statements&gt;\n\n例一：\n例二：\n基础语法到此结束！附录1：python包的获取和管理类似于Node的npm，Linux中的yum，apt等，python有自己的包管理工具——pip，这也是Python安装时自带的\n但是直接从pypi上获取包的速度太慢长城防火墙，所以我们要借用一些国内的镜像网站，比如清华大学的清华源镜像网站\n你可以从console(非python的编辑模式)里用python的pip语句指定国内的镜像源来直接安装包，如：\npip install numpy -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;\n# -i代表当前安装操作使用后面的临时源\n\n不过我们也可以通过 ctrl + shift + s 打开pycharm的 settings 进入 Project: (你当前的项目名) &gt;&gt; Python InterPreter 来直接安装包。记得在manage repository中添加国内的python源的地址\n\n\n\n\n\n\n\n\n\n国内Python源建议使用清华源：https://pypi.tuna.tsinghua.edu.cn/simple/\n附录2：Python运算符运算符：（python的语法糖很大一部分集中在多种多样的运算符，这也是让书写python代码速度起飞的重要原因！）\n（虽然刚接触的时候会因为大量的运算符而痛苦😀）\n运算符手册：算数运算符：（相比c语言多了幂运算于取整运算）\n\n\n运算符\n描述\n实例\n\n\n\n+\n加 - 两个对象相加\na + b 输出结果 31\n\n\n-\n减 - 得到负数或是一个数减去另一个数\na - b 输出结果 -11\n\n\n*\n乘 - 两个数相乘或是返回一个被重复若干次的字符串\na * b 输出结果 210\n\n\n/\n除 - x 除以 y\nb / a 输出结果 2.1\n\n\n%\n取模 - 返回除法的余数\nb % a 输出结果 1\n\n\n**\n幂 - 返回x的y次幂\na**b 为10的21次方\n\n\n//\n取整除 - 向下取接近商的整数\n&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5\n\n\n比较运算符：（和c语言相同）\n\n\n运算符\n描述\n实例\n\n\n\n==\n等于 - 比较对象是否相等\n(a == b) 返回 False。\n\n\n!=\n不等于 - 比较两个对象是否不相等\n(a != b) 返回 True。\n\n\n&gt;\n大于 - 返回x是否大于y\n(a &gt; b) 返回 False。\n\n\n&lt;\n小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。\n(a &lt; b) 返回 True。\n\n\n&gt;=\n大于等于 - 返回x是否大于等于y。\n(a &gt;= b) 返回 False。\n\n\n&lt;=\n小于等于 - 返回x是否小于等于y。\n(a &lt;= b) 返回 True。\n\n\n赋值运算：\n\n\n运算符\n描述\n实例\n\n\n\n=\n简单的赋值运算符\nc = a + b 将 a + b 的运算结果赋值为 c\n\n\n+=\n加法赋值运算符\nc += a 等效于 c = c + a\n\n\n-=\n减法赋值运算符\nc -= a 等效于 c = c - a\n\n\n*=\n乘法赋值运算符\nc *= a 等效于 c = c * a\n\n\n/=\n除法赋值运算符\nc /= a 等效于 c = c / a\n\n\n%=\n取模赋值运算符\nc %= a 等效于 c = c % a\n\n\n**=\n幂赋值运算符\nc **= a 等效于 c = c ** a\n\n\n//=\n取整除赋值运算符\nc //= a 等效于 c = c // a\n\n\n\n\n\n\n\n\n\nWARNING\n特别提醒！python中没有像c语言一样的自加运算！\n\n\n位运算符：（和c语言相同）\n\n\n运算符\n描述:(下表中变量 a 为 60，b 为 13二进制格式如下：)\n实例\n\n\n\n&amp;\n按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0\n(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100\n\n\n|\n按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。\n(a | b) 输出结果 61 ，二进制解释： 0011 1101\n\n\n^\n按位异或运算符：当两对应的二进位相异时，结果为1\n(a ^ b) 输出结果 49 ，二进制解释： 0011 0001\n\n\n~\n按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 -x-1\n(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。\n\n\n&lt;&lt;\n左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。\na &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000\n\n\n&gt;&gt;\n右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数\na &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111\n\n\n逻辑运算符：\n\n\n运算符\n逻辑表达式\n描述（令a=10， b=20）\n实例\n\n\n\nand\nx and y\n布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。\n(a and b) 返回 20。\n\n\nor\nx or y\n布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。(与“与运算恰好相反”)\n(a or b) 返回 10。\n\n\nnot\nnot x\n布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。\nnot(a and b) 返回 False\n\n\n\n\n\n\n\n\n\n\n\n补充说明：\n成员运算符：\n\n\n运算符\n描述\n实例\n\n\n\nin\n如果在指定的序列中找到值返回 True，否则返回 False。\nx 在 y 序列中 , 如果 x 在 y 序列中返回 True。\n\n\nnot in\n如果在指定的序列中没有找到值返回 True，否则返回 False。\nx 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。\n\n\n身份运算符：（有种 == 和 != 的感觉，但是确实不一样！）\nis 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。\n\n\n\n运算符\n描述（注：id () 函数用于获取对象内存地址。）\n实例\n\n\n\nis\nis 是判断两个标识符是不是引用自一个对象\nx is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False\n\n\nis not\nis not 是判断两个标识符是不是引用自不同对象\nx is not y ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。\n\n\n\nPython运算符优先级以下表格列出了从最高到最低优先级的所有运算符：\n\n\n\n运算符\n描述\n\n\n\n**\n指数 (最高优先级)\n\n\n~ + -\n按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)\n\n\n* / % //\n乘，除，求余数和取整除\n\n\n+ -\n加法减法\n\n\n&gt;&gt; &lt;&lt;\n右移，左移运算符\n\n\n&amp;\n位 ‘AND’\n\n\n^ |\n位运算符\n\n\n&lt;= &lt; &gt; &gt;=\n比较运算符\n\n\n== !=\n等于运算符\n\n\n= %= /= //= -= += *= **=\n赋值运算符\n\n\nis is not\n身份运算符\n\n\nin not in\n成员运算符\n\n\nnot and or\n逻辑运算符\n\n\n最后（传教）:我即使是死了，钉在棺材里了，也要在墓里，用这腐朽的声带喊出：“vocaloid forever！！！“\n最后的最后：都看到这里了，不听支歌吗?(❁’◡’❁)\n \n\n\n\n参考资料：\nPython3 教程 | 菜鸟教程 (runoob.com)\n\n","slug":"Language Learning/Python/PythonBasicGrammar/PythonBasicGrammar","date":"2021-09-26T09:22:04.000Z","categories_index":"Programming Language Learning","tags_index":"Python","author_index":"JBR_Bunjie"},{"id":"9ec39e11b1bab83a62560ea633cdc96a","title":"更新你的Git版本","content":"那么现在，如果我的就电脑上已经安装了一个version为2.31.1的git\n问题来了，如何将它更新至最新版本呢，\nHow to upgrade Git on Windows to the latest version - Stack Overflow\n如果你迫切想要知道解决方法的话，那么，你可以直接运行这个命令\n\n\n\n\n\n\n\n\n\nC:\\&gt; git update-git-for-windows\n这个命令对于当前版本&gt;2.16.1的Git有效\n对于Git版本在2.14到2.16.1之间的，请使用如下命令：\n\n\n\n\n\n\n\n\n\nC;\\&gt; git update\n\n至于更低的，就只能先卸载旧版本再重装了，它太古董了\n等待你的进程完成即可\n\n","slug":"Softwares/updateGit/updateGit","date":"2021-09-07T15:59:53.000Z","categories_index":"配置方法","tags_index":"Git","author_index":"JBR_Bunjie"},{"id":"cadb81dd6adf93defe9d2e5bccb01250","title":"美化你的GitHub主页！","content":"一般来说，GitHub主页是很简陋枯燥又单调的：\n\n但是也许你也见过别人的完全不同的主页：\n\n欸？他的主页怎么有一个markdown文件作为公示栏来展示？怎么做到的？\n答案是GitHub的官方彩蛋（后门）：\n当↗当↗当↗当↘\n\n\n\n\n\n\n\n\n\n\n请注意：你需要创建一个公共仓库，这样才会被GitHub所捕捉到，如果这是私密仓库的话是不会在主页上出现的\n然后你会在这个新创建的仓库的页面右侧看到\n\n此时，这个“彩蛋”会立即生效\n\n如果想要有一个不一样的GitHub主页，就需要使用这个小小的“彩蛋”来定制你的主页\n当然，你也可以引入很多组件来深度定制你的GitHub主页：比如：\ngithub-readme-stats/readme_cn.md at master · anuraghazra/github-readme-stats\n","slug":"Softwares/Git/beautifyGithubHome/beautifyGithubHome","date":"2021-09-07T15:58:53.000Z","categories_index":"工具美化","tags_index":"GitHub","author_index":"JBR_Bunjie"},{"id":"6adf345a8e80c4aa1ee89482b75933eb","title":"Hello World, Hello Hexo","content":"hexo website：Hexo\nHexo从开箱到弃用Hexo的基础配置安装hexo-clinpm install hexo-cli -g\n\n完成hexo的部署：npm install hexo-cli -g\nhexo init &lt;name&gt; # 注意：hexo必须要在空文件夹下完成初始化，如果没有&lt;name&gt;，则在当前目录下完成初始化，否则新建一个&lt;name&gt;文件夹初始化 \ncd &lt;name&gt; # 根据上个命令初始化的文件夹使用\nnpm install # 安装依赖\nhexo server # 启动hexo服务器，这时候便可以访问所有 source&#x2F; 下的所有文章页面了\n\n创建新的页面：hexo new [layout] &lt;name&gt; # 创建一个新的post页面，会出现在source文件夹下，内涵一个index.md\n# 我们可以直接对这个md文件进行编辑，hexo会自动将这个文件渲染为一个html页面\n\n\n\n\n\n\n\n\nWARNING\n创建新文件夹或者页面时请注意 \\_config.yml 中 # Directory 下项目的配置\n\n\n再次运行hexo：hexo clean # 清除之前hexo的缓存\nhexo g # g或generate 根据md文件生成html等文件\nhexo s # s或server 启动hexo服务器\n\n配置Hexo快速部署：One-Command Deployment | Hexo\n以git为例：\n安装hexo的git插件：npm install hexo-deployer-git --save\n\n修改Hexo中的\\_config.yml文件：deploy:\n  type: git\n  repo: &lt;repository url&gt; # https:&#x2F;&#x2F;bitbucket.org&#x2F;JohnSmith&#x2F;johnsmith.bitbucket.io\n  branch: [branch]\n  message: [message]\n \n# 例如，我自己的仓库配置如下：\ndeploy:\n  type: git\n  repo: git@github.com:JBR-Bunjie&#x2F;JBR-Bunjie.github.io.git\n  branch: master\n\n配置完成之后，我们便可以使用命令：\nhexo deploy\n\n来直接将我们编写的Hexo文档推送到所有远端托管地址上了\n\n\n\n\n\n\n\n\n\n在使用git来推送之前，你需要先完成本地git工具对远程仓库的权限等配置\n安装别的博客框架当然，你需要先选定一个博客框架才行\n比如如果想要安装aurora，我会选择直接去查阅aurora的官方文档来了解aurora的具体配置项\nHome | Hexo Aurora (tridiamond.tech)\n但是当我们想要更替当前Hexo框架时，我们需要同时修改Hexo项目的\\_config.yml和Hexo框架的的\\_config.xxx.yml，例如：Aurora的\\_config.aurora.yml\n# 修改项：\n\ntheme: &lt;yourThemeName&gt;  \n\n\n\n\n\n \n","slug":"Softwares/Hexo使用","date":"2021-09-07T14:09:05.000Z","categories_index":"配置方法","tags_index":"使用hexo来搭建你的博客！","author_index":"JBR_Bunjie"}]