[{"id":"83fc4bf0106b2e566bb88fa07ace1ff9","title":"Install certain python version in Linux","content":"Install certain python\r\nversion in Linux\r\n-1: for Ubuntu:\r\njust: apt install python3.8\r\nZero, try to\r\ndownload python3.8 through yum\r\n1yum list | grep python3\r\nfind no python38, so choose to setup python3.8 through make\r\ninstall\r\nFirst, download the python\r\nfile\r\ngo to website: https://www.python.org/ftp/python to choose correct\r\nfile\r\n\r\nexample:\r\nhttps://www.python.org/ftp/python/3.8.10/Python-3.8.10.tgz\r\n\r\n1wget https://www.python.org/ftp/python/3.8.10/Python-3.8.10.tgz\r\nunzip, make and install\r\n\r\n在编译前先在/usr/local 建一个文件夹 python3（作为 python\r\n的安装路径，以免覆盖老的版本）\r\n\r\n1mkdir /usr/local/python3\r\n\r\n解压：\r\n\r\n1tar -zxvf Python-3.8.10.tgz\r\n\r\n进行指定目录的编译安装\r\n\r\n12345./configure --prefix=/usr/local/python3 # 设置编译安装路径make # 编译make install # 安装\r\n\r\n创建软链接\r\n\r\n123ln -s /usr/local/python3/bin/python3  /usr/bin/python3.8# 修改旧版本软连接：ln -s /usr/local/python3/bin/python3  /usr/bin/pythonv\r\n检验安装\r\n12python3.8 -V# Python 3.8.10\r\ncentOS\r\n下升级 python 版本，详细步骤 - leon-zyl - 博客园 (cnblogs.com)\r\n","slug":"Deploy/Linux/install certain python version in Linux","date":"2023-10-25T17:22:23.000Z","categories_index":"Linux","tags_index":"Linux,Python","author_index":"JBR_Bunjie"},{"id":"c501575a20c82b47e7d6e471fd5a77bc","title":"LUA急速入门","content":"LUA急速入门\r\n安装\r\n12345# for ubuntuapt install lua5.4# for windows# Go to github to install lua_for_windows\r\n代码执行\r\n交互式编程\r\nlua5.4已经支持了交互式编程，这样我们可以直接在命令行中输入程序语句并立即查看执行结果\r\n123456~#: luaLua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio&gt; print(&quot;Hello World&quot;)Hello World&gt; -- 退出交互式编程状态：Ctrl+D(发送退出信号)、Ctrl+C(强制中断)、os.exit()\r\n脚本式编程\r\n传统的lua编写过程，和别的语言并无二致\r\n123456#!/someDir/bin/lua --我们指定了 Lua 的解释器 /someDir/bin directory，加上 # 号标记后，解释器会忽略它。当我们为脚本添加可执行权限后，就可以通过输入 ./hello.lua 来快速执行该脚本了print(&quot;Hello World！&quot;)print(&quot;www.runoob.com&quot;)-- 完成编写后，我们通过 lua hello.lua 的方式来执行该脚本\r\n变量：\r\n作用域\r\nLua中，所有创建的变量，默认为全局变量\r\n而对于删除一个全局变量，我们只需将变量赋为nil\r\n当然，你也可以用 local 来设置局部变量\r\n\r\n应尽可能多地使用局部变量：\r\n\r\n避免命名冲突与逻辑错误\r\n访问局部变量的速度比全局变量更快\r\n\r\n\r\n数据类型\r\nLua 是动态类型语言，变量不要类型定义,只需要为变量赋值。\r\n值可以存储在变量中，作为参数传递或结果返回。\r\n你总是可以通过 type(x) 来检查数据类型\r\n12type(nil) == nil; -- falsetype(nil) == &quot;nil&quot; -- true\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n数据类型\r\n描述\r\n\r\n\r\n\r\n\r\nnil\r\n只有值nil属于该类，代表被删除、不存在等，是表示一个无效值（在条件表达式中相当于false）\r\n\r\n\r\nboolean\r\n包含两个值：false和true。\r\n\r\n\r\nnumber\r\n表示双精度类型的实浮点数\r\n\r\n\r\nstring\r\n字符串由一对双引号或单引号来表示\r\n\r\n\r\nfunction\r\n由 C 或\r\nLua 编写的函数\r\n\r\n\r\nuserdata\r\n表示任意存储在变量中的C数据结构**\r\n\r\n\r\nthread\r\n表示执行的独立线路，用于执行协同程序\r\n\r\n\r\ntable\r\n字典或者\"关联数组\"。其索引可以是数字、字符串或表类型。我们用\"构造表达式\"来创建表\r\n\r\n\r\n\r\ntable\r\n实例：\r\n123456789101112-- table_test.lua 脚本文件a = &#123;&#125; -- 创建空表a[&quot;key&quot;] = &quot;value&quot; -- 添加键值对key = 10a[key] = 22a[key] = a[key] + 11for k, v in pairs(a) do    print(k .. &quot; : &quot; .. v)end-- 结果：-- key : value-- 10 : 33\r\n索引：\r\n不同于其他语言的数组把 0 作为数组的初始索引，在 Lua\r\n里表的默认初始索引一般以 1 开始。\r\n123456789-- table_test2.lua 脚本文件local tbl = &#123;&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;&#125;for key, val in pairs(tbl) do    print(&quot;Key&quot;, key)end-- Key    1-- Key    2-- ..\r\n无序：\r\n1234tab = &#123;&quot;Hello&quot;,&quot;World&quot;,a=1,b=2,z=3,x=10,y=20,&quot;Good&quot;,&quot;Bye&quot;&#125;for k,v in pairs(tab) do    print(k..&quot;  &quot;..v)end\r\n如上代码输出结果存在一定规律，\"Hello\"、\"World\"、\"Good\"、\"Bye\"是表中的值，在存储时是按照顺序存储的，并且不同于其他脚本语言，Lua是从1开始排序的，因此，使用pairs遍历打印输出时，会先按照顺序输出表的值，然后再按照键值对的键的哈希值打印。\r\n1234567891  Hello2  World3  Good4  Byey  20x  10z  3b  2a  1 \r\n构建数组\r\n我们可以使用整数索引来访问数组元素，如果指定的索引没有值则返回\r\nnil\r\n123456789array = &#123;&quot;Lua&quot;, &quot;Tutorial&quot;&#125;for i= 0, 2 do   print(array[i])end-- nil-- Lua-- Tutorial\r\n\"指针\"\r\n当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b\r\n都会指向同一个内存。而当 a 设置为 nil 时，Lua只会回收变量 a 本身，而 b\r\n仍然能访问原 table 的元素。这种规则同样适用于传参数的情况\r\n12345678910111213141516171819202122mytable[&quot;wow&quot;] = &quot;修改前&quot;print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])-- alternatetable和mytable的是指同一个 tablealternatetable = mytableprint(&quot;mytable 索引为 wow 的元素是 &quot;, alternatetable[&quot;wow&quot;])alternatetable[&quot;wow&quot;] = &quot;修改后&quot;print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])-- 释放变量alternatetable = nilprint(&quot;alternatetable 是 &quot;, alternatetable)-- mytable 仍然可以访问print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])-- mytable 索引为 wow 的元素是     修改前-- mytable 索引为 wow 的元素是     修改前-- mytable 索引为 wow 的元素是     修改后-- alternatetable 是     nil-- mytable 索引为 wow 的元素是     修改后\r\n插入删除\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n用途\r\n\r\n\r\n\r\n\r\ntable.insert (table, [pos,] value):\r\n在table的数组部分指定位置(pos)插入值为value的一个元素.\r\npos参数可选, 默认为数组部分末尾.\r\n\r\n\r\ntable.remove (table [, pos])\r\n返回table数组部分位于pos位置的元素. 其后的元素会被前移.\r\npos参数可选, 默认为table长度, 即从最后一个元素删起。\r\n\r\n\r\n\r\nSort\r\n\r\ntable.sort (list [, comp])\r\nSorts the list elements in a given order, in-place, from\r\nlist[1] to list[#list]. If comp\r\nis given, then it must be a function that receives two list elements and\r\nreturns true when the first element must come before the second in the\r\nfinal order, so that, after the sort, i &lt;= j implies\r\nnot comp(list[j],list[i]). If comp is not\r\ngiven, then the standard Lua operator &lt; is used\r\ninstead.\r\n\r\nfunction\r\n在 Lua 中，函数是被看作是\"第一类值（First-Class Value）\"\r\n值得注意的是，我们可以临时创建一个匿名函数来进行参数传递：\r\n12345testFun(tab,    function(key, val)        return key - val;    end);\r\nthread\r\n\r\n在 Lua\r\n里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\r\n线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\r\n\r\n字符串\r\n定义\r\nLua 语言中字符串可以使用以下三种方式来表示：\r\n\r\n单引号间的一串字符。\r\n双引号间的一串字符。\r\n[[** 与 **]] 间的一串字符。\r\n\r\n特别的，我们可以通过嵌套来给字符串中加入引号：\r\n12a = &quot;&#x27;test&#x27;&quot;print(a) -- &#x27;a&#x27;\r\n字符串格式化\r\nLua 提供了 string.format()\r\n函数来生成具有特定格式的字符串，这个函数的格式很像 C 语言中的\r\nprintf()。同时由于格式字符串的存在,\r\n使得产生的长字符串可读性大大提高了。\r\n格式字符串可能包含以下的转义码:\r\n\r\n%c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\r\n%d, %i - 接受一个数字并将其转化为有符号的整数格式\r\n%o - 接受一个数字并将其转化为八进制数格式\r\n%u - 接受一个数字并将其转化为无符号整数格式\r\n%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\r\n%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\r\n%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\r\n%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\r\n%f - 接受一个数字并将其转化为浮点数格式\r\n%g(%G) - 接受一个数字并将其转化为%e(%E,\r\n对应%G)及%f中较短的一种格式\r\n%q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\r\n%s - 接受一个字符串并按照给定的参数格式化该字符串\r\n\r\n为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\r\n\r\n\r\n符号: 一个+号表示其后的数字转义符将让正数显示正号.\r\n默认情况下只有负数显示符号.\r\n\r\n\r\n占位符: 一个0, 在后面指定了字串宽度时占位用.\r\n不填时的默认占位符是空格.\r\n\r\n\r\n对齐标识: 在指定了字串宽度时, 默认为右对齐,\r\n增加-号可以改为左对齐.\r\n\r\n\r\n宽度数值\r\n\r\n\r\n小数位数/字串裁切: 在宽度数值后增加的小数部分n,\r\n若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位,\r\n若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.\r\n\r\n\r\n匹配\r\nLua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数\r\nstring.find, string.gmatch, string.gsub,\r\nstring.match。\r\n字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类\r\n%d 匹配任意数字。所以你可以使用模式串\r\n%d%d/%d%d/%d%d%d%d 搜索 dd/mm/yyyy\r\n格式的日期：\r\n123s = &quot;Deadline is 30/05/1999, firm&quot;date = &quot;%d%d/%d%d/%d%d%d%d&quot;print(string.sub(s, string.find(s, date)))    --&gt; 30/05/1999\r\n赋值语句：\r\n123456789101112-- Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量a, b = 10, 2*x           -- a=10; b=2*x-- 遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：x, y = y, x              -- swap &#x27;x&#x27; for &#x27;y&#x27;-- 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略：a. 变量个数 &gt; 值的个数      -- 按变量个数补足nilb. 变量个数 &lt; 值的个数      -- 多余的值会被忽略--&gt; 常见的错误情况:a, b, c = 0print(a,b,c)             --&gt; 0   nil   nil\r\n循环\r\n相对于其它语言来说，Lua的循环结构是特殊而合理的：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法名称\r\n描述\r\n\r\n\r\n\r\n\r\nwhile\r\n循环\r\n在条件为 true\r\n时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\r\n\r\n\r\nfor\r\n循环\r\n重复执行指定语句，重复次数可在 for 语句中控制。\r\n\r\n\r\nrepeat...until\r\n重复执行循环，直到 指定的条件为真时为止\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n控制语句\r\n描述\r\n\r\n\r\n\r\n\r\nbreak\r\n语句\r\n退出当前循环或语句，并开始脚本执行紧接着的语句。\r\n\r\n\r\ngoto 语句\r\n将程序的控制点转移到一个标签处。\r\n\r\n\r\n\r\n值得注意的是，lua中并不包含 continue 控制语句，要想实现\r\ncontinue 的功能，我们可以利用 goto 语句：\r\n12345for i=1, 10 do\tif i % 2 == 0 then goto continue end    print(i)    ::continue::end\r\n\r\nloops\r\n- Why does Lua have no \"continue\" statement? - Stack Overflow\r\n\r\n流程控制\r\n我们利用 if...elseif...else 语句来完成流程控制\r\n1234567if( 布尔表达式 1) then   --[ 在布尔表达式 1 为 true 时执行该语句块 --]elseif( 布尔表达式 2) then   --[ 在布尔表达式 2 为 true 时执行该语句块 --]else    --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]end\r\n函数\r\n\r\n在Lua中，函数是对语句和表达式进行抽象的主要方法。\r\n\r\nLua 函数主要有两种用途：\r\n\r\n1.完成指定的任务，这种情况下函数作为调用语句使用；\r\n2.计算并返回值，这种情况下函数作为赋值语句的表达式使用。\r\n\r\n函数定义\r\nLua 编程语言函数定义格式如下：\r\n1234optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)    function_body    return result_params_comma_separatedend\r\n\r\noptional_function_scope:\r\n该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字\r\nlocal。\r\nfunction_name: 指定函数名称。\r\nargument1, argument2, argument3..., argumentn:\r\n函数参数，多个参数以逗号隔开，函数也可以不带参数。\r\nfunction_body:\r\n函数体，函数中需要执行的代码语句块。\r\nresult_params_comma_separated:\r\n函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\r\n\r\n\"重载\"\r\n关于函数的\"重载\"能力：Lua能自动去适应传入的参数，如果传入的参数个数多于定义的个数，则会自动忽略后面多于的参数，如果传入的参数个数少于定义的个数，则会将不足的参数用nil补齐。如：\r\n1234567function Add(a,b,c)     if c == nil then         return a + b     else         return a + b + c     endend\r\n可变参数：\r\n\r\nLua 函数可以接受可变数目的参数，和 C\r\n语言类似，在函数参数列表中使用三点 ...\r\n表示函数有可变的参数。\r\n\r\n1234567891011function average(...)   result = 0   local arg=&#123;...&#125;    --&gt; arg 为一个表，局部变量   for i,v in ipairs(arg) do      result = result + v   end   print(&quot;总共传入 &quot; .. #arg .. &quot; 个数&quot;)   return result/#argendprint(&quot;平均值为&quot;,average(10,5,3,4,5,6))\r\n我们常将可变参数通过 &#123;...&#125;\r\n来组合为table，此时，我们可以通过select方法来访问可变参数的信息：\r\n\r\nselect('#', …) 返回可变参数的长度。\r\nselect(n, …) 用于返回从起点 n\r\n开始到结束位置的所有参数列表。\r\n\r\n请注意，select方法中的参数并非是table，这当然意味着select只适用于可变参数，不适合table\r\n\r\nselect (index, ···)\r\nIf index is a number, returns all arguments after argument number\r\nindex; a negative number indexes from the end (-1 is the last argument).\r\nOtherwise, index must be the string \"#\", and select returns the total\r\nnumber of extra arguments it received.\r\n\r\n运算符\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n操作符\r\n描述\r\n实例\r\n\r\n\r\n\r\n\r\n^\r\n乘幂\r\n10^2 输出结果 100\r\n\r\n\r\n//\r\n整除(&gt;=lua5.3)\r\n5//2 输出结果 2\r\n\r\n\r\n~=\r\n不等于\r\n(1 ~= 2) 为 true。\r\n\r\n\r\nand\r\n逻辑与\r\n(true and false) 为 false。\r\n\r\n\r\nor\r\n逻辑或\r\n(false or false) 为 true。\r\n\r\n\r\nnot\r\n逻辑非\r\nnot(true and false) 为 true。\r\n\r\n\r\n.\r\n连接两个字符串\r\na..b，若a为 \"Hello \" ，b为 \"World\",\r\n输出结果为 \"Hello World\"\r\n\r\n\r\n#\r\n一元运算符，返回字符串或表的长度。\r\n#\"Hello\" 返回 5\r\n\r\n\r\n\r\n特别的，当对\r\ntable 使用 # 运算时会遇到的问题\r\n123456&gt; a = &#123;&quot;1&quot;, &quot;2&quot;, nil, &quot;3&quot;&#125;&gt; #a4&gt; b = &#123;&quot;1&quot;, &quot;2&quot;,&quot;3&quot;, nil&#125;&gt; #b3\r\n其获取长度时，依靠的其实是最大索引值：\r\n在获取表的长度时，根据的是表的最大索引的值:\r\n123456789101112131415tab1 = &#123;&quot;1&quot;,&quot;2&quot;&#125;print(&quot;tab1长度&quot;..#tab1)tab2 = &#123;key1=&quot;1&quot;,&quot;2&quot;&#125;print(&quot;tab2长度&quot;..#tab2)tab3 = &#123;&#125;tab3[1]=&quot;1&quot;tab3[2]=&quot;2&quot;tab3[4]=&quot;4&quot;print(&quot;tab3长度&quot;..#tab3)-- tab1长度2-- tab2长度1-- tab3长度4\r\n而当下标越位超过 1 时：\r\n下标越过 1 位以上，长度还是为 2：\r\n1234567tab3=&#123;&#125;tab3[1]=&quot;1&quot;tab3[2]=&quot;2&quot;tab3[5]=&quot;5&quot;print(&quot;tab3的长度&quot;,#tab3)-- tab3的长度    2\r\n\r\n当我们获取 table 的长度的时候无论是使用 # 还是\r\ntable.getn\r\n其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。\r\n可以使用以下方法来代替：\r\n1234567&gt;function table_leng(t) local leng=0 for k, v in pairs(t) do   leng=leng+1 end return leng;&gt;end\r\n\r\n实现三目运算\r\n使用 Lua 的逻辑运算符实现就需要一些小技巧，写法如下（具体可查看Lua\r\n中的三目运算符）\r\n1(condition and &#123;result1&#125; or &#123;result2&#125;)[1]\r\n例：\r\n12local isAppel = falseprint(isAppel and &quot;苹果&quot; or &quot;梨&quot;)\r\n原理：\r\n\r\n\r\n(A and B), 若 A 为 false 返回 A(返回false) ;\r\n(A or B), 若 A 为 false 返回 B ;\r\n除 nil 外其他数据类型被当做 true\r\n\r\n\r\n元表\r\nLua中我们使用元表来增强Table的表现：通过为table赋予元表，我们可以改变对table进行操作时的默认行为，以达到更多的效果。\r\n当我们为一个 table 指定好对应的 metatable\r\n后，我们就可以为元表增添即时字段来修改上层 table 行为了\r\n为指定的表设定元表\r\n两个主要方法：\r\n\r\nsetmetatable(table, metatable): 对指定 table\r\n设置元表(metatable)，如果元表(metatable)中存在 __metatable\r\n键值，setmetatable 会失败。\r\ngetmetatable(table):\r\n返回对象的元表(metatable)。\r\n\r\n为元表增添元方法\r\n仅列出部分主要方法\r\n__index 元方法\r\n生效情况：当你通过键来访问 table 的时候，如果这个键没有值，那么 Lua\r\n就会寻找该 table 的 metatable 中的__index 键。当 __index生效时：\r\n__index包含表格\r\n若__index包含一个表格，Lua 会在表格中查找相应的键。\r\n1234other = &#123; foo = 3 &#125;t = setmetatable(&#123;&#125;, &#123; __index = other &#125;)print(t.foo) -- 3print(t.bar) -- nil\r\n若__index包含函数\r\n若__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。\r\n123456mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123;  __index = function(mytable, key)    print(mytable, key)  end&#125;)print(mytable.key1, mytable.key2)\r\n\r\n总结\r\nLua 查找一个表元素时的规则，其实就是如下 3 个步骤:\r\n\r\n1.在表中查找，如果找到，返回该元素，找不到则继续\r\n2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。\r\n3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回\r\nnil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index\r\n方法是一个函数，则返回该函数的返回值。\r\n\r\n该部分内容来自作者寰子：https://blog.csdn.net/xocoder/article/details/9028347\r\n\r\n__newindex 元方法\r\n生效情况：当你给表的一个缺少的索引赋值，解释器就会查找__newindex\r\n元方法。如果存在则调用该方法而不进行赋值操作。\r\n\r\n__newindex 元方法用来对表更新，__index则用来对表访问 。\r\n\r\n1234567891011mymetatable = &#123;&#125;mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123; __newindex = mymetatable &#125;)print(mytable.key1)mytable.newkey = &quot;新值2&quot;print(mytable.newkey,mymetatable.newkey)mytable.key1 = &quot;新值1&quot;print(mytable.key1,mymetatable.key1)\r\n重载操作符：__add、__sub等元方法：\r\n\r\n以下实例演示了两表相加操作：\r\n实例\r\n1234567891011121314151617181920212223242526272829303132333435&gt;-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数&gt;function table_maxn(t)   local mn = 0   for k, v in pairs(t) do       if mn &lt; k then           mn = k       end   end   return mn&gt;end&gt;-- 两表相加操作&gt;mytable = setmetatable(&#123; 1, 2, 3 &#125;, &#123; __add = function(mytable, newtable)   for i = 1, table_maxn(newtable) do     table.insert(mytable, table_maxn(mytable)+1,newtable[i])   end   return mytable end&gt;&#125;)&gt;secondtable = &#123;4,5,6&#125;&gt;mytable = mytable + secondtable&gt;for k,v in ipairs(mytable) doprint(k,v)&gt;end&gt;-- 以上实例执行输出结果为：&gt;-- 1    1&gt;-- 2    2&gt;-- 3    3&gt;-- 4    4&gt;-- 5    5&gt;-- 6    6\r\n\r\n全部的操作符元方法如下：\r\n\r\n\r\n\r\n模式\r\n描述\r\n\r\n\r\n\r\n\r\n__add\r\n对应的运算符 '+'.\r\n\r\n\r\n__sub\r\n对应的运算符 '-'.\r\n\r\n\r\n__mul\r\n对应的运算符 '*'.\r\n\r\n\r\n__div\r\n对应的运算符 '/'.\r\n\r\n\r\n__mod\r\n对应的运算符 '%'.\r\n\r\n\r\n__unm\r\n对应的运算符 '-'.\r\n\r\n\r\n__concat\r\n对应的运算符 '..'.\r\n\r\n\r\n__eq\r\n对应的运算符 '=='.\r\n\r\n\r\n__lt\r\n对应的运算符 '&lt;'.\r\n\r\n\r\n__le\r\n对应的运算符 '&lt;='.\r\n\r\n\r\n\r\n__call 元方法\r\n\r\n__call: The call operation\r\nfunc(args).\r\nThis event happens when Lua tries to call a non-function\r\nvalue (that is, func is not a function). The\r\nmetamethod is looked up in func. If present, the metamethod\r\nis called with func as its first argument, followed by the\r\narguments of the original call (args). All results of the\r\ncall are the results of the operation. This is the only metamethod that\r\nallows multiple results.\r\n\r\n1234567891011121314151617181920212223242526-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数function table_maxn(t)    local mn = 0    for k, v in pairs(t) do        if mn &lt; k then            mn = k        end    end    return mnend-- 定义元方法__callmytable = setmetatable(&#123;10&#125;, &#123;  __call = function(mytable, newtable)        sum = 0        for i = 1, table_maxn(mytable) do                sum = sum + mytable[i]        end    for i = 1, table_maxn(newtable) do                sum = sum + newtable[i]        end        return sum  end&#125;)newtable = &#123;10,20,30&#125;print(mytable(newtable)) -- 70\r\n__tostring 元方法\r\n__tostring 元方法用于修改表的输出行为。\r\n12345678910mytable = setmetatable(&#123; 10, 20, 30 &#125;, &#123;    __tostring = function(mytable)        sum = 0        for k, v in pairs(mytable) do            \tsum = sum + v            end        return &quot;表所有元素的和为 &quot; .. sum    end&#125;)print(mytable) -- 表所有元素的和为 60\r\n绕开元方法\r\n以__newindex为例：设置了元方法 __newindex\r\n后，在对新索引键(newkey)赋值时，会调用元方法，而自身不再主动进行赋值。而对于已存在的索引键(oldkey)，则会进行赋值，而不调用元方法\r\nnewindex。为了保证我们仍然能实现赋值语句本身的功能，我们在__newindex调用的方法中，会需要绕开该元方法本身直接进行赋值，这时我们需要用到\r\nrawser、rawget\r\n两个函数，它们能在完成本身功能时避免激活元方法\r\n\r\nrawset (table, index, value)\r\nSets the real value of table[index] to\r\nvalue, without using the __newindex metavalue.\r\ntable must be a table, index any value\r\ndifferent from nil and NaN, and value any\r\nLua value.\r\n\r\n\r\nrawget (table, index)\r\nGets the real value of table[index], without using the\r\n__index metavalue. table must be a table;\r\nindex may be any value.\r\n\r\n12345678910mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123;    __newindex = function(mytable, key, value)        rawset(mytable, key, &quot;\\&quot;&quot;..value..&quot;\\&quot;&quot;)    end&#125;)mytable.key1 = &quot;new value&quot;mytable.key2 = 4print(mytable.key1, mytable.key2) -- new value    &quot;4&quot;\r\n协程 - coroutine：\r\nLua\r\n协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。\r\n线程和协同程序区别\r\n线程与协同程序的主要区别在于：一个具有多个线程的程序可以同时运行几个线程，而在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。\r\n基本语法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n描述\r\n\r\n\r\n\r\n\r\ncoroutine.create()\r\n创建 coroutine，返回 coroutine\r\n(thread)， 参数是一个函数当和 resume\r\n配合使用的时候就唤醒函数调用\r\n\r\n\r\ncoroutine.resume()\r\n重启 coroutine，和 create 配合使用\r\n\r\n\r\ncoroutine.yield()\r\n挂起 coroutine，将 coroutine\r\n设置为挂起状态这个和 resume 配合使用能有很多有用的效果\r\n\r\n\r\ncoroutine.status()\r\n查看 coroutine 的状态※: coroutine\r\n的状态共三种：dead，suspended，running\r\n\r\n\r\ncoroutine.wrap（）\r\n创建 coroutine\r\n并返回一个函数，如调用该函数就进入 coroutine和\r\ncreate 功能重复\r\n\r\n\r\ncoroutine.running()\r\n返回正在跑的 coroutine，一个 coroutine\r\n就是一个线程当使用running的时候，就是返回一个 corouting\r\n的线程号\r\n\r\n\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738-- coroutine_test.lua 文件co = coroutine.create(    function(i)        print(i);    end) -- 刚创建时并未执行coroutine.resume(co, 1)   -- 1print(coroutine.status(co))  -- dead -- 执行完毕print(&quot;----------&quot;)  -- ---------- co = coroutine.wrap(    function(i)        print(i);    end) co(10)  -- 10 -- warp创建和create创建的调用方式是不一样的，因为create返回的是thread对象，而wrap返回的是functionprint(&quot;----------&quot;)  -- ---------- co2 = coroutine.create(function()    for i=1,10 do        print(i)        if i == 3 then            print(coroutine.status(co2))  -- running            print(coroutine.running())  -- thread:XXXXXX        end        coroutine.yield()    endend)coroutine.resume(co2) --1coroutine.resume(co2) --2coroutine.resume(co2) --3 print(coroutine.status(co2))   -- suspendedprint(coroutine.running())  -- thread: 0x7fb801c04c88    true\r\n\r\n\r\ncoroutine.creat方法只要建立了一个协程\r\n，那么这个协程的状态默认就是suspend。使用resume方法启动后，会变成running状态；遇到yield时将状态设为suspend；如果遇到return，那么将协程的状态改为dead。\r\ncoroutine.resume方法需要特别注意的一点是，这个方法只要调用就会返回一个boolean值。\r\ncoroutine.resume方法如果调用成功，那么返回true；如果有yield方法，同时返回yield括号里的参数；如果没有yield，那么继续运行直到协程结束；直到遇到return，将协程的状态改为dead，并同时返回return的值。\r\ncoroutine.resume方法如果调用失败(调用状态为dead的协程会导致失败)，那么返回false，并且带上一句\"cannot\r\nresume dead coroutine\"\r\nwrap不会返回boolean值，但是当coroutine执行完dead后，如继续执行该coroutine则会导致程序报错。\r\ncoroutine.yield 除了挂起协程外，还可以同时返回数据给 resume\r\n,并且还可以同时定义下一次唤醒时需要传递的参数。\r\n\r\n1234567891011121314151617cor = coroutine.create(function(a)    print(&quot;参数 a 值为：&quot;, a);    local b, c = coroutine.yield(a + 1); --这里表示挂起协程，并且将a+1的值进行返回，并且指定下一次唤醒需要 b,c 两个参数。    print(&quot;参数 b, c 值分别为：&quot;, b, c);    return b * c; --协程结束，并且返回 b*c 的值。end);print(&quot;第一次调用：&quot;, coroutine.resume(cor, 1));print(&quot;第二次调用：&quot;, coroutine.resume(cor, 2, 2));print(&quot;第三次调用：&quot;, coroutine.resume(cor));--[[参数 a 值为：    1第一次调用：    true    2参数 b, c 值分别为：    2    2第二次调用：    true    4第三次调用：    false    cannot resume dead coroutine ]]\r\n123456789101112131415161718192021cor = coroutine.wrap(function(a)    print(&quot;参数 a 值为：&quot;, a);    local b, c = coroutine.yield(a + 1); --这里表示挂起协程，并且将a+1的值进行返回，并且指定下一次唤醒需要 b,c 两个参数。    print(&quot;参数 b, c 值分别为：&quot;, b, c);    return b * c; --协程结束，并且返回 b*c 的值。end);print(&quot;第一次调用：&quot;, cor(1));print(&quot;第二次调用：&quot;, cor(2, 2));print(&quot;第三次调用：&quot;, cor());--[[参数 a 值为：   1第一次调用：    2参数 b, c 值分别为：    2       2第二次调用：    4lua: test.lua:18: cannot resume dead coroutinestack traceback:        [C]: in function &#x27;cor&#x27;        test.lua:18: in main chunk        [C]: in ?  ]]\r\n\r\n迭代器\r\n迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。\r\nLua 的迭代器（迭代函数）包含以下两种类型：\r\n\r\n无状态的迭代器\r\n多状态的迭代器\r\n\r\n泛型 for 调用迭代器\r\n泛型 for 的执行过程：\r\n\r\n首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for\r\n需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用\r\nnil 补足，多出部分会被忽略。\r\n第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for\r\n结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。\r\n第三，将迭代函数返回的值赋给变量列表。\r\n第四，如果返回的第一个值为nil循环结束，否则执行循环体。\r\n第五，回到第二步再次调用迭代函数\r\n\r\n如：\r\n123456array = &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;for key,value in ipairs(array)do   print(key, value)end\r\n无状态的迭代器\r\n类似pairs, ipairs的，没有更多信息(状态)的迭代器\r\n1234567891011function square(iteratorMaxCount, currentNumber)   if currentNumber &lt; iteratorMaxCount   then      currentNumber = currentNumber+1   return currentNumber, currentNumber*currentNumber   endendfor i,n in square(3,0) do   print(i,n)end\r\n多状态的迭代器\r\n为了保存更多信息，使用闭包来构造迭代器\r\n1234567891011121314151617181920array = &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;function elementIterator (collection)   local index = 0   local count = #collection   -- 闭包函数   return function ()      index = index + 1      if index &lt;= count      then         --  返回迭代器的当前元素         return collection[index]      end   endendfor element in elementIterator(array)do   print(element)end\r\n模块化\r\n从 Lua 5.1 开始，Lua\r\n加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API\r\n接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\r\n123456789101112131415161718192021-- 文件名为 Test1.lua-- 定义一个名为 module 的模块(Table)module = &#123;&#125; -- 定义一个常量module.constant = &quot;这是一个常量&quot; -- 定义一个函数function module.func1()    io.write(&quot;这是一个公有函数！\\n&quot;)end local function func2()    print(&quot;这是一个私有函数！&quot;)end function module.func3()    func2()end return module\r\n由上可知，模块的结构就是一个 table\r\n的结构，因此可以像操作调用 table\r\n里的元素那样来操作调用模块里的常量或函数。其中：\r\n\r\nfunc1 声明为程序块的全局变量，我们以这样的方式实现了\r\npublic 属性，可以在引入后随意调用.\r\nfunc2 则声明为程序块的局部变量，即表示一个 private\r\n函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的函数来调用.\r\n\r\n面向对象\r\n利用function实现面向对象\r\n闭包\r\n一句话说就是，在函数中引用外部函数来进行嵌套的函数。\r\n12345678def outer(x):    def inner(y):        return x + y    return innerprint(outer(6)(5))&gt;&gt;&gt; 11\r\n如代码所示，在outer函数内，又定义了一个inner函数，并且inner函数又引用了外部函数outer的变量x，这就是一个闭包了。在输出时，outer(6)(5),第一个括号传进去的值返回inner函数，其实就是返回6\r\n+ y，所以再传第二个参数进去，就可以得到返回值，6 + 5。\r\n实现\r\n123456789101112131415161718-- 元类Rectangle = &#123;area = 0, length = 0, breadth = 0&#125;-- 派生类的方法 newfunction Rectangle:new (o,length,breadth)  o = o or &#123;&#125;  setmetatable(o, self)  self.__index = self  -- 子类没设置area这三个属性时，会导回Rectangle  self.length = length or 0  self.breadth = breadth or 0  self.area = length*breadth;  return oend-- 派生类的方法 printAreafunction Rectangle:printArea ()  print(&quot;矩形面积为 &quot;,self.area)end\r\n\r\nLua中的self - 知乎\r\n(zhihu.com)\r\n\r\n利用table实现\r\n\r\n封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性\r\n\r\ntable已经完备\r\n\r\n继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。\r\n\r\n我们需要自己实现clone/copy函数\r\n\r\n多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。\r\n\r\nLua function已完备\r\n\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748-- clone functionfunction clone(tb)    local ins = &#123;&#125;    for key, var in pairs(tb) do        ins[key] = var    end    return insend-- copy functionfunction copy(dist, tb)    for key, var in pairs(tb) do        dist[key] = var    endend-- define original tabletable = &#123;&#125;table.funHello = function(tb)    print(&quot;Hello &quot;..tb.name)endtable.new = function(name)    local self = clone(table);    self.name = name    return selfend-- 实例化local tb1 = table.new(&quot;World&quot;)tb1:funHello(tb1)  -- 事实上，常规地使用 . 或者 : 来引用funHello是几乎完全一样的，但是为了提升可读性，我们需要做出区分-- 继承tb2 = &#123;&#125;tb2.new = function(name)    local self = table.new(name)    copy(self, tb2)    return selfendtb2.tb2Hello = function()    print(&quot;tb2 Hello&quot;)endtb2.funHello = function()    print(&quot;tb2 fun Hello&quot;)endlocal m = tb2.new(&quot;Lili&quot;)m:funHello()m:tb2Hello()\r\n错误处理\r\n程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service\r\n调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。\r\n这里我们主要着眼运行时错误。\r\nRaise Error\r\nLua主要使用两个函数：assert 和 error\r\n来错误。\r\n\r\nassert (v [, message])\r\n\r\nRaises an error if the value of its argument v is false\r\n(i.e., nil or false);\r\n\r\nIn case of error, message is the error object; when\r\nabsent, it defaults to \"assertion failed!\"\r\n\r\notherwise, returns all its arguments.\r\n\r\n\r\nassert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。\r\n\r\n\r\n\r\nerror (message [, level])\r\nRaises an error (see §2.3) with\r\nmessage as the error object. This function never\r\nreturns.\r\nUsually, error adds some information about the error\r\nposition at the beginning of the message, if the message is a string.\r\nThe level argument specifies how to get the error position.\r\nWith level 1 (the default), the error position is where the\r\nerror function was called. Level 2 points the error to\r\nwhere the function that called error was called; and so on.\r\nPassing a level 0 avoids the addition of error position information to\r\nthe message.\r\n\r\n功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\r\n通常情况下，error会附加一些错误位置的信息到message头部。\r\nLevel参数指示获得错误的位置:\r\n\r\nLevel=1[默认]：为调用error位置(文件+行号)\r\nLevel=2：指出哪个调用error的函数的函数\r\nLevel=0:不添加错误位置信息\r\n\r\n\r\n\r\n123456local function add(a,b)   assert(type(a) == &quot;number&quot;, &quot;a 不是一个数字&quot;)   assert(type(b) == &quot;number&quot;, &quot;b 不是一个数字&quot;)   return a+bendadd(10)\r\nProcess Error\r\npcall\r\npcall接收一个函数和要传递给后者的参数，并执行。最后根据执行结果是否有错误返回true或者或false及errorinfo\r\n12345678910111213&gt; if pcall(function_name, ….) then-- 没有错误else-- 存在错误end&gt; pcall(function(i) print(i) end, 33)33true&gt; pcall(function(i) print(i) error(&#x27;error..&#x27;) end, 33)33false   stdin:1: error..\r\npcall会以一种\"保护模式\"来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\r\n不过，通常在错误发生时，我们往往希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。为了获取更多信息，我们可以直接使用的办法：xpcall\r\nxpcall\r\n\r\nxpcall (f, msgh [, arg1, ···])\r\nThis function is similar to pcall,\r\nexcept that it sets a new message handler msgh.\r\n\r\nxpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用\r\ndebug 库来获取关于错误的额外信息了。\r\ndebug库提供了两个通用的错误处理函数:\r\n\r\ndebug.debug：提供一个Lua提示符，让用户来检查错误的原因\r\ndebug.traceback：根据调用桟来构建一个扩展的错误消息\r\n\r\n12345678910111213function myfunction ()   n = n/nilendfunction myerrorhandler( err )   print( &quot;ERROR:&quot;, err )endstatus = xpcall( myfunction, myerrorhandler )print( status )-- ERROR:  test.lua:10: attempt to perform arithmetic on a nil value (global &#x27;n&#x27;)     \t\t -- from xpcall(..)-- false \t\t-- from print( status )\r\ndebug\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n用途\r\n\r\n\r\n\r\n\r\ntraceback ([thread,] [message [, level]])\r\n如果 message 存在且不是字符串或 nil，那么函数不做任何处理直接返回\r\nmessage。 否则，traceback将返回调用栈的栈回溯信息。\r\n字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项\r\nlevel 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback\r\n的那里）。\r\n\r\n\r\ngetinfo ([thread,] f [, what]):\r\n返回关于一个函数信息的表。\r\n你可以直接提供该函数，也可以用一个数字 f\r\n表示该函数——它表示运行在指定线程的调用栈对应层次上的函数： 0\r\n层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数\r\n（除非是尾调用，这种情况不计入栈）等等。 如果 f\r\n是一个比活动函数数量还大的数字， getinfo 返回 nil。\r\n\r\n\r\ngetupvalue (f, up)\r\n此函数返回函数 f 的第 up 个上值的名字和值。\r\n如果该函数没有那个上值，返回 nil 。以 '('\r\n（开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）\r\n\r\n\r\nsetupvalue (f, up, value):\r\n这个函数将 value 设为函数 f 的第 up 个上值。\r\n如果函数没有那个上值，返回 nil 否则，返回该上值的名字。\r\n\r\n\r\n\r\n12345678910111213141516171819202122232425262728function newCounter ()    local n = 0    local k = 0    return function ()        k = n        n = n + 1        return n    endend  counter = newCounter()print(counter())print(counter())local i = 1repeat    name, val = debug.getupvalue(counter, i)    if name then        print (&quot;index&quot;, i, name, &quot;=&quot;, val)                if(name == &quot;n&quot;) then            debug.setupvalue (counter,2,10)        end        i = i + 1    end -- ifuntil not nameprint(counter())\r\n垃圾回收\r\n概述\r\nLua 采用了自动内存管理。\r\n这意味着你不用操心新创建的对象需要的内存如何分配出来，\r\n也不用考虑在对象不再被使用后怎样释放它们所占用的内存。\r\nLua\r\n运行了一个垃圾收集器来收集所有死对象\r\n（即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua\r\n中所有用到的内存，如：字符串、表、用户数据、函数、线程、\r\n内部结构等，都服从自动管理。\r\nLua 实现了一个增量标记-扫描收集器。\r\n它使用这两个数字来控制垃圾收集循环：\r\n垃圾收集器间歇率和垃圾收集器步进倍率。\r\n这两个数字都使用百分数为单位(例如：值 100 在内部表示 1)：\r\n\r\n垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。\r\n增大这个值会减少收集器的积极性。 当这个值比 100\r\n小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200\r\n就会让收集器等到总内存使用量达到之前的两倍时才开始新的循环。\r\n垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。\r\n不要把这个值设得小于\r\n100，那样的话收集器就工作的太慢了以至于永远都干不完一个循环。默认值是\r\n200，这表示收集器以内存分配的\"两倍\"速工作。如果你把步进倍率设为一个非常大的数字(比你的程序可能用到的字节数还大\r\n10%)，收集器的行为就像一个 stop-the-world 收集器。接着你若把间歇率设为\r\n200，收集器的行为就和过去的 Lua 版本一样了：每次 Lua\r\n使用的内存翻倍时，就做一次完整的收集。\r\n\r\n运用\r\n我们可以通过函数collectgarbage ([opt [, arg]])来控制垃圾收集器：\r\n\r\ncollectgarbage(\"setpause\", 200)： 内存增大 2\r\n倍（200/100）时自动释放一次内存 （200 是默认值）。\r\ncollectgarbage(\"setstepmul\",\r\n200)：收集器单步收集的速度相对于内存分配速度的倍率，设置 200\r\n的倍率等于 2 倍（200/100）。（200 是默认值）\r\ncollectgarbage(\"collect\"):\r\n做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：\r\ncollectgarbage(\"count\"): 以 K 字节数为单位返回\r\nLua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua\r\n使用的准确字节数（除非溢出）。\r\ncollectgarbage(\"restart\"):\r\n重启垃圾收集器的自动运行。\r\ncollectgarbage(\"setpause\"): 将 arg 设为收集器的\r\n间歇率。 返回 间歇率 的前一个值。\r\ncollectgarbage(\"setstepmul\"): 返回 步进倍率\r\n的前一个值。\r\ncollectgarbage(\"step\"): 单步运行垃圾收集器。\r\n步长\"大小\"由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非\r\n0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。\r\n如果收集器结束一个循环将返回 true 。\r\ncollectgarbage(\"stop\"): 停止垃圾收集器的运行。\r\n在调用重启前，收集器只会因显式的调用运行。\r\n\r\n实例\r\n12345678mytable = &#123;&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;&#125;print(collectgarbage(&quot;count&quot;))mytable = nilprint(collectgarbage(&quot;count&quot;))print(collectgarbage(&quot;collect&quot;))print(collectgarbage(&quot;count&quot;))\r\n执行以上程序，输出结果如下(注意内存使用的变化)：\r\n123420.956054687520.9853515625019.4111328125\r\nMain Origin\r\n\r\nLua Official Site：The Programming\r\nLanguage Lua\r\nLua 教程 |\r\n菜鸟教程 (runoob.com)\r\n\r\n","slug":"Language Learning/LUA/急速入门","date":"2023-06-01T12:22:22.000Z","categories_index":"Language Learning,LUA","tags_index":"Language Learning,LUA","author_index":"JBR_Bunjie"},{"id":"5b286fb1e51c3a9c0edf1921a9c938c7","title":"计算机编码梳理","content":"垃圾回收 - Garbage\r\nCollection\r\n为什么需要GC\r\n\r\n方便\r\n\r\n\r\n为何主流游戏引擎的对象需要有GC机制？ - 霍姚远的回答 - 知乎\r\nhttps://www.zhihu.com/question/518026433/answer/2488730232\r\n为何主流游戏引擎的对象需要有GC机制？ - DBinary的回答 - 知乎\r\nhttps://www.zhihu.com/question/518026433/answer/2518074579\r\n\r\n\r\n\r\n.Net的GC机制\r\n特点\r\n\r\n精准式GC\r\n只处理引用类型的变量：值类型的变量会随着离开对应的作用域而自然销毁，而只有引用类型的变量才涉及到使用堆空间。特别的，我们将引用类型的变量称为”根“\r\nGC并不是实时性的，而且GC的执行会导致进程停滞——这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。使用using语句可以简化资源管理。\r\n\r\n关于GC导致的进程停滞：GC在完成垃圾清理后，会对留存对象进行碎片整理：这会带来内存中对象address变化，如果此时不挂起，那么上一秒还在读取的对象，下一秒写的时候写到另一个对象里去了。因为可能大多数对象已经被move了。这跟线程锁，临界区是同样的原理。\r\n\r\nGC并不是能释放所有的资源。它不能自动释放非托管资源。\r\n\r\n请注意：非托管类型 和 非托管资源\r\n是不一样的！\r\n如果某个类型是以下类型之一，则它是非托管类型 ：\r\n\r\nsbyte、byte、short、ushort、int、uint、long、ulong、nint、nuint、char、float、double、decimal\r\n或 bool\r\n任何枚举类型\r\n任何指针类型\r\n任何仅包含非托管类型字段的用户定义的结构类型。\r\n\r\n非托管资源只是托管资源的相对概念，即：\r\n\r\n\r\nManaged resources basically means \"managed memory\" that is managed by\r\nthe garbage collector. ... Unmanaged resources are then everything that\r\nthe garbage collector does not know about. For example:\r\n\r\nOpen files\r\nOpen network connections\r\nUnmanaged memory\r\nIn XNA: vertex buffers, index buffers, textures, etc.\r\n\r\n\r\n简单的说，这些 非托管资源\r\n仍然是reference，但是它们引用的不是.Net本身能在产生、获取等各种方式下得到的数据，它们是外部资源。它们随程序的运行于managed\r\nresources一同进入了内存中，可gc无法在使用完后想正常内容一样去释放它们，in\r\nshort:\r\n\r\nUnmanaged resources are those that run outside the .NET runtime\r\n(CLR)(aka non-.NET code.) For example, a call to a DLL in the Win32 API,\r\nor a call to a .dll written in C++.\r\n\r\n一个简单的例子是，我们对int进行装箱，产生的Object是\r\n托管资源，因为它由.Net全权接管。而如果我们open一个file，那么file的内容不在托管堆中\r\n\r\n\r\n对于应用创建的大多数对象，可以依赖 .NET\r\n垃圾回收器来进行内存管理。 但是，如果创建包含\r\n非托管资源 的对象，则当你使用完 非托管资源\r\n后，就必须显式释放这些资源。 最常用的 非托管资源\r\n类型是包装操作系统资源的对象，如文件、窗口、网络连接或数据库连接。\r\n虽然垃圾回收器可以跟踪封装非托管资源的对象的生存期，但无法了解如何发布并清理这些非托管资源。\r\n\r\n\r\n\r\n自动内存管理\r\n\r\n自动内存管理\r\n| Microsoft Learn\r\n\r\n初始化新进程时，运行时会为进程保留一个连续的地址空间区域。\r\n这个保留的地址空间被称为托管堆。\r\n托管堆维护着一个指针，用它指向将在堆中分配的下一个对象的地址。\r\n最初，该指针设置为指向托管堆的基址。 托管堆上包含了所有引用类型。\r\n应用程序创建第一个引用类型时，将为托管堆的基址中的类型分配内存。\r\n应用程序创建下一个对象时，垃圾回收器在紧接第一个对象后面的地址空间内为它分配内存。\r\n只要地址空间可用，垃圾回收器就会继续以这种方式为新对象分配空间。\r\n\r\n\r\n垃圾回收器的优化引擎根据所执行的分配决定执行回收的最佳时间。\r\n垃圾回收器在执行回收时，会释放应用程序不再使用的对象的内存...垃圾回收器可以访问由实时\r\n(JIT)\r\n编译器和运行时维护的活动根的列表...并在此过程中创建一个图表...不在该图表中的对象将无法从应用程序的根中访问。\r\n垃圾回收器会考虑无法访问的对象垃圾，并释放为它们分配的内存。\r\n在回收中，垃圾回收器检查托管堆，查找无法访问对象所占据的地址空间块。\r\n发现无法访问的对象时，它就使用内存复制功能来压缩内存中可以访问的对象，释放分配给不可访问对象的地址空间块。\r\n在压缩了可访问对象的内存后，垃圾回收器就会做出必要的指针更正，以便应用程序的根指向新地址中的对象。\r\n它还将托管堆指针定位至最后一个可访问对象之后。\r\n请注意，只有在回收发现大量的无法访问的对象时，才会压缩内存。\r\n如果托管堆中的所有对象均未被回收，则不需要压缩内存。为了改进性能，运行时为单独堆中的大型对象分配内存。\r\n垃圾回收器会自动释放大型对象的内存。\r\n但是，为了避免移动内存中的大型对象，不会压缩此内存。\r\n\r\n\r\n一般执行过程\r\n\r\n首先，CLR暂停进程中的所有线程。防止线程在CLR检查期间访问对象并更改其状态。\r\nCLR进入GC的标记阶段\r\n\r\nCLR遍历堆中某些代下的对象，并全部设为 不可达\r\nCLR检查所有活动根，对于任何活动根直接引用的堆上对象，都会设为\r\n可达\r\n检查被标记为可达对象中存在的根，并将这些根所引用的对象也设为\r\n可达\r\n\r\n标记完毕，对 不可达\r\n对象进行清理，同时对留存下来的对象进行碎片整理(GC Compact)\r\n重新计算对象的偏移位置，以及指针位置，并在完成所有操作后，恢复应用程序进程\r\n\r\n.Net GC的代际设计\r\nCLR的GC是基于代的垃圾回收器，它假设：\r\n\r\n压缩托管堆的一部分内存要比压缩整个托管堆速度快——分代\r\n较新的对象生存期较短，而较旧的对象生存期则较长——高频处理低代际，低频处理高代际\r\n较新的对象趋向于相互关联，并且大致同时由应用程序访问——连续分配内存\r\n\r\n托管堆最多支持三代对象：\r\n\r\n第0代对象：新构造的未被GC检查过的对象\r\n第1代对象：被GC检查过1次且保留下来的对象\r\n第2代对象：被GC检查大于等于2次且保留下来的对象\r\n\r\n第0代回收只会回收第0代对象，第1代回收则会回收第0代和第1代对象，而第2代回收表示完全回收，会回收所有对象。\r\n在GC之外 - 非托管资源\r\n的回收\r\n\r\n如果你的类型使用非托管资源，则应执行以下操作：\r\n\r\n实现清理模式。\r\n这要求你提供 IDisposable.Dispose\r\n实现以启用非托管资源的确定性释放。\r\n当不再需要此对象（或其使用的资源）时，类型使用者可调用 Dispose。\r\nDispose\r\n方法立即释放非托管资源。\r\n在类型使用者忘记调用 Dispose\r\n的情况下，请提供一种方法来释放非托管资源。\r\n有两种方法可以实现此目的：\r\n\r\n使用安全句柄包装非托管资源。 这是推荐采用的方法。 安全句柄派生自\r\nSystem.Runtime.InteropServices.SafeHandle\r\n抽象类，并包含可靠的 Finalize\r\n方法。 在使用安全句柄时，只需实现 IDisposable\r\n接口并在 Dispose\r\n实现中调用安全句柄的 IDisposable.Dispose\r\n方法。 如果未调用安全句柄的 Dispose\r\n方法，则垃圾回收器将自动调用安全句柄的终结器。\r\n—或—\r\n定义终结器。\r\n当类型使用者无法调用 IDisposable.Dispose\r\n以确定性地释放非托管资源时，终止会启用对非托管资源的非确定性释放。\r\n\r\n\r\n\r\n关于IDisposable\r\n首先是对于 Dispose\r\n的实现，这是需要在继承IDisposable类后，再于类中实现的。\r\n特别的，当我们实现了 IDisposable.Dispose 后：\r\n123public class MyClass:IDisposable &#123;    public void Dispose()&#123;&#125;&#125;\r\n我们就可以在代码中以using的语法糖调用：\r\n1using (var m = new Myclass()) &#123;&#125;\r\n这等于：\r\n123456789MyClass mc = null;try &#123;    mc = new MyClass();    ...&#125; finally &#123;    if (mc != null)&#123;        mc.Dispose();    &#125;&#125;\r\n让我们先把安全句柄放在一边，如果我们现在要完整地实现剩下两个方法的话，我们需要这些：\r\n\r\n实现Dispose方法；\r\n提取一个受保护的Dispose虚方法，在该方法中实现具体的释放资源的逻辑；\r\n添加析构函数；\r\n添加一个私有的bool类型的字段，作为释放资源的标记\r\n\r\n我们可以得到这样的一个模板：\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyClass : IDisposable &#123;    private IntPtr unManagedResource &#123; get; set; &#125; = Marshal.AllocHGlobal(100); // 模拟一个非托管资源     public Random ManagedResource &#123; get; set; &#125; = new Random(); // 模拟一个托管资源     private bool disposed; // 释放标记，在真正执行释放操作之前，先检查该标记，防止反复执行释放操作导致的错误    /// &lt;summary&gt; 这是一个析构函数，C#中，析构函数就是一个终结器，它会在没有显式调用Dispose方法时自动执行 &lt;/summary&gt;    ~MyClass() &#123;        Dispose(false); //必须为false    &#125;    /// &lt;summary&gt; 执行与释放或重置非托管资源关联的应用程序定义的任务。&lt;/summary&gt;    public void Dispose() &#123;        Dispose(true); //必须为true        GC.SuppressFinalize(this); //通知垃圾回收器不再调用终结器    &#125;    /// &lt;summary&gt; 非必需的，只是为了更符合其他语言的规范，如C++、java &lt;/summary&gt;    public void Close() &#123;        Dispose();    &#125;    /// &lt;summary&gt; 非密封类可重写的Dispose方法，方便子类继承时可重写 &lt;/summary&gt;    protected virtual void Dispose(bool disposing) &#123;        if (disposed) &#123;            return;        &#125;        // 清理托管资源        if (disposing) &#123;            if (ManagedResource != null) &#123;                ManagedResource = null; // 或者是: ManagedResource.Dispose();            &#125;        &#125;        // 清理非托管资源        if (unManagedResource != IntPtr.Zero) &#123;            Marshal.FreeHGlobal(unManagedResource);            unManagedResource = IntPtr.Zero;        &#125;        // 告诉自己已经被释放        disposed = true;    &#125;&#125;\r\n这个实现的逻辑大体上是这样的：\r\n\r\n我们模拟了两种不同类型的资源，它们最终都可以在Dispose中接受处理。对于非托管资源来说，这使得我们清理非托管资源占用的内存；对于托管资源而言，我们避免了GC的介入以避免GC影响性能\r\n定义析构函数，C#中的析构函数就是所谓的\"终结器\"。如果我们忘记了显式调用Dispose方法，垃圾回收器在扫描内存的时候，会作为释放资源的一种补救措施。虽然MS的文档中明确指出不建议我们这样做。\r\n\r\n析构方法是在C++中的一种说法，因为终结器和析构方法两者特点很像，为了沿袭C++的叫法，称之为析构方法也没有什么不妥，但它们又不完全一致，所以微软后来又确定它叫终结器。\r\n\r\n基于这样的情况，当我们执行 Dispose(true)\r\n后，终结器当然就没有必要再运行了。因此，我们使用\r\nSuppressFinalize 方法来阻止GC对该终结器的执行\r\n最后是 Dispose(bool)\r\n方法重载。在重载中，disposing 参数是一个\r\nBoolean，它指示方法调用是来自 Dispose\r\n方法（其值为 true）还是来自终结器（其值为\r\nfalse）。基于这样的设计，我们需要针对不同的输入执行不同的代码块：\r\n\r\n如果对象已释放，则为条件返回块。\r\n释放非托管资源的块。 无论 disposing\r\n参数的值如何，都会执行此块。\r\n释放托管资源的条件块。 如果 disposing 的值为\r\ntrue，则执行此块。 它释放的托管资源可包括：\r\n\r\n实现 IDisposable\r\n的托管对象。 可用于调用其 Dispose\r\n实现（级联释放）的条件块。 如果你已使用 System.Runtime.InteropServices.SafeHandle\r\n的派生类来包装非托管资源，则应在此处调用 SafeHandle.Dispose()\r\n实现。\r\n占用大量内存或使用短缺资源的托管对象。\r\n将大型托管对象引用分配到 null，使它们更有可能无法访问。\r\n相比以非确定性方式回收它们，这样做释放的速度更快。\r\n\r\n\r\n\r\n实现Dispose方法\r\n在上面的模板中，我们注意到了，实现自 Idisposable 接口的\r\nDispose 方法并没有做实际的清理工作，而是和\r\n~MyClass() 一样，以不同的参数调用了\r\nprotected virtual void Dispose(bool disposing)\r\n函数。这个虚函数是我们 Dispose 方法的核心。\r\n为什么是虚函数？\r\n首先，简单介绍一下虚函数：\r\n一个实例方法声明前带有virtual关键字，那么这个方法就是虚方法。虚方法与非虚方法的最大不同是，虚方法的实现可以由派生类通过方法的重写所取代。\r\nvirtual\r\n- C# 参考 | Microsoft Learn\r\n那么，之所以是虚方法，就是考虑到它如果被其他类继承时，子类也需要实现\r\nDispose\r\n模式，这个虚方法可以提醒子类，清理的时候要注意到父类的清理工作。在子类重载了该方法后，调用\r\nbase.Dispose 方法继续清理父类中可能存在的非托管资源。\r\n非托管资源的Dispose部分以及Finalize相关\r\n非托管资源的Dispose调用顺序大概如下：\r\nmyClass.Dispose() =&gt; myClass.Dispose(true) =&gt;\r\nmyUnmanagedResources.Dispose() =&gt; myUnmanagedResources.Dispose(true)\r\n=&gt; 外部资源的清理函数\r\n其中，最后的清理函数由我们在载入dll等资源时获取到，我们只需要调用即可\r\n这其中，我们至少实现了Dispose Pattern两次，分别位于两个类中\r\n特别的，如果我们没有主动地进行最初的 myClass.Dispose()\r\n调用的话，当下次GC启动且对myClass实例内存的引用计数为零时，就会帮我们自动调用\r\n~myClass\r\n这个终结器。这里我们可以详细了解一下这个终结器：\r\n\r\n终结器 内部大体上以如下方式工作\r\n\r\nnew新对象时，如果该对象的类型定义了Finalize方法，那么在该类型的实例构造器被调用之前，会在一个所谓Finalization Queue\r\n的队列中存储一个指向该对象的指针，该列表由GC内部控制。\r\n当可终结对象被回收时，即，成为垃圾时，这个对象会被分离出来，并将指向它的指针从\r\nFinalization Queue 移动到 freachable Queue\r\n中，该队列亦由GC内部控制，而这个过程被称为是对象的复生（Resurrection）。\r\nCLR会启用一个特殊的高优先级线程来专门调用Finalze方法。freachable\r\n队列为空时，该线程将睡眠；但一旦队列中有记录项出现，线程就会被唤醒，将每一项都从\r\nfreachable\r\n队列中移除，并调用每个对象的Finalize方法。\r\n\r\n\r\n总之就是，当我们没有显式调用Dispose时，终结器就会被唤醒，执行其中的内容并完成非托管资源的清除。这个过程是很漫长的过程，并且会造成较大的性能开销。因此，主动地去进行Dispose总是更好的。另外，也不要使用空的析构函数。如果类包含析构函数，则\r\nFinalize\r\n队列中则会创建一个项。当调用析构函数时，将调用垃圾回收器（GC）来处理该队列。如果析构函数为空，只会导致不必要的性能损失。\r\n对于这个终结过程，我们有两个常用的控制函数：ReRegisterForFinalize()\r\n和\r\nSuppressFinalize()，前者适用于当某一个类成为垃圾时，将指向该对象的指针重新存入\r\nFinialization Queue 中，后者则用来抑制\r\nFinalize 方法的进行，这也就是为什么我们在主动调用的\r\nDispose()\r\n中会主动使用这个方法——因为主动释放之后就没必要再运行\r\nFinalize了。\r\n特别的，如果在 Finalize 方法中，配合\r\nReRegisterForFinalize() 的使用，会使在\r\nFinalization Queue\r\n中的对象可以反复执行复生过程，这样就形成了一个在堆上永远不会死去的对象。\r\n在示例代码中，我们直接就在myClass中调用了外部的内存清理函数，并以\r\nunManagedResource != IntPtr.Zero 检验是否完成了目的。\r\n\r\nc#\r\n- Is IntPtr.Zero equivalent to null? - Stack Overflow\r\n\r\n托管资源的Dispose部分\r\n那为什么我们还需要在 Dispose\r\n中处理托管资源，GC不是会帮我们完成吗？\r\n是的，C#是没有手段去自行释放托管资源的，我们所谓的对托管资源的主动释放，实际上也就是调用\r\ngc.collect 罢了，但是有这些要点是需要强调的：\r\n\r\n对于C#这种存在GC机制的语言，我们实际上不应该总是焦虑内存释放，除非我们实在需要。默认的GC机制只有一个比较大的弊端，那就是我们不能确定，GC到底会在什么时候工作。那么这就出现了我们实在需要主动要求GC执行的理由：当前场景下内存需求剧烈，我们希望GC现在就执行。\r\n当某一个对象不再使用时，可以考虑将对象置为null。这不会加速下一次GC的执行，但是会保证这个资源会因为没有被指向而最终一定导致回收。特别是静态变量，这是我们特别需要注意的：当一个类中存在静态字段或属性时，其实例的静态字段或属性，是不会因为没有对象来指向它就会被GC回收的——静态内容会脱离这个资源，并总是会维持自己的存在，因为类型的静态字段一旦被创建，就被作为“根”存在，基本上不参与GC，所以GC始终不会认为它是个垃圾。清除这些滞留内容的办法，是将对应的内容明确地设置为null，这种行为的典型应用是缓存的过期策略。\r\n\r\n番外：Close\r\n\r\n首先，Dispose和Close基本上应该是一样的。Close是为了那些不熟悉Dispose的开发者设计的。因为基本上所有的developer都知道Close是干吗的(特别是对于那些有C++背景的developer)\r\n...\r\n在.net的framework里，Close()被设计成public的，并且在Close()里面call被隐藏的Dispose()；Dispose()去call另一个virtual的Dispose(bool)函数。所以如果你从这个class继承，你就必须实现Dispose(bool)方法\r\n... 用着call\r\nClose()的时候就会call到你重载的那个Dispose(bool)方法去释放资源。\r\n\r\nSafeHandle\r\nMSDN上对SafeHandle的解释算是比较明确的：\r\n\r\nSafeHandle\r\n类提供了终结器，因此你无需自行编写。\r\n\r\n关于SafeHandle的各种形式，可以查阅：Microsoft.Win32.SafeHandles\r\n命名空间 | Microsoft Learn\r\n\r\nIDisposable.Dispose\r\n的派生类请提供以下内容：\r\n\r\nprotected override void Dispose(bool)\r\n方法，用于替代基类方法并执行派生类的实际清理。 此方法还必须调用\r\nbase.Dispose(bool)（Visual Basic 中的\r\nMyBase.Dispose(bool)）方法，并将释放状态（bool disposing\r\n参数）作为参数传递给它。\r\n从包装非托管资源的 SafeHandle\r\n派生的类（推荐），或对 Object.Finalize\r\n方法的重写。 SafeHandle\r\n类提供了一个使你无需编写代码的终结器。\r\n如果你提供了终结器，它必须调用具有 false 参数的\r\nDispose(bool) 重载。\r\n\r\n以下是一个常规模式的示例，该模式用于实现使用安全句柄的派生类的释放模式：\r\n1234567891011121314151617181920212223using Microsoft.Win32.SafeHandles;using System;using System.Runtime.InteropServices;public class DerivedClassWithSafeHandle : BaseClassWithSafeHandle&#123;    private bool _disposedValue; // To detect redundant calls    private SafeHandle? _safeHandle = new SafeFileHandle(IntPtr.Zero, true); // Instantiate a SafeHandle instance.    // Protected implementation of Dispose pattern.    protected override void Dispose(bool disposing)&#123;        if (!_disposedValue)&#123;            if (disposing)&#123;                _safeHandle?.Dispose();                _safeHandle = null;            &#125;            _disposedValue = true;        &#125;        // Call base class implementation.        base.Dispose(disposing);    &#125;&#125;\r\n\r\nUnity GC\r\n\r\nUnity\r\n- Manual: Garbage collector overview (unity3d.com)\r\n\r\n\r\n是的，Unity使用了一种与.Net不同的GC机制：保守式的Boehm\r\nGC，这里有一段小故事：c#\r\n- Unity's garbage collector - Why non-generational and non-compacting? -\r\nStack Overflow\r\n简而言之，Unity使用，并且仍在使用Boehm\r\nGC是因为当初世界上对C#有两种实现，而unity选择了民间的而非MS的，这在之后成为了一种历史问题。\r\n\r\nUnity Memory 的内容划分\r\n\r\nUnity uses three memory management layers to handle memory in your\r\napplication:\r\n\r\nManaged\r\nmemory: A controlled memory layer that uses a managed heap and a garbage\r\ncollector to automatically allocate and assign memory.\r\nC#\r\nunmanaged memory: A layer of memory management that you can use in\r\nconjunction with the Unity Collections namespace and package. This\r\nmemory type is called “unmanaged” because it doesn’t use a garbage\r\ncollector to manage unused parts of memory.\r\nNative\r\nmemory: C++ memory that Unity uses to run the engine. In most\r\nsituations, this memory is inaccessible to Unity users, but it’s useful\r\nto be aware of it if you want to fine-tune certain aspects of the\r\nperformance of your application.\r\n\r\nUsing managed memory in Unity is the easiest way to\r\nmanage the memory in your application; but it has some disadvantages.\r\nThe garbage collector is convenient to use, but it’s also unpredictable\r\nin how it releases and allocates memory, which might lead to performance\r\nissues such as stuttering, which happens when the garbage collector has\r\nto stop to release and allocate memory. To work around this\r\nunpredictability, you can use the C#\r\nunmanaged memory layer.\r\nThe C# unmanaged memory layer allows you to access\r\nthe native memory layer to fine-tune memory allocations, with the\r\nconvenience of writing C# code.You can use the\r\nUnity.Collectionsnamespace (including NativeArray)\r\nin the Unity core API, and the data structures in the Unity\r\nCollections package to access C# unmanaged memory. If you use\r\nUnity’s C# Job system, or Burst, you must use C# unmanaged memory. For\r\nmore information about this, see the documentation on the Job\r\nsystem and Burst.\r\nMemory\r\nin Unity - Unity 手册 (unity3d.com)\r\n\r\n\r\n在Unity中，内存分配的具体过程也是可以定义的，这涉及到多种内存分配算法，但却并非今天的重点。对应手册的\r\nMemory allocator customization 内容\r\n\r\n触发GC工作实例\r\n以下是一个触发GC的具体实例，来自Unity Docs\r\n\r\nA quantity of memory. Marked A on the diagram is some free memory.\r\nIn the above diagram, the blue box represents a quantity of memory\r\nthat Unity allocates to the managed heap. The white boxes within it\r\nrepresent data values that Unity stores within the managed heap’s memory\r\nspace. When additional data values are needed, Unity allocates them free\r\nspace from the managed heap (annotated A).\r\n\r\nA quantity of memory, with some objects released represented by grey\r\ndashed lines.\r\nAnd when Unity releases an object, the memory that the object\r\noccupied is freed up. However, the free space doesn’t become part of a\r\nsingle large pool of “free memory.”\r\nThe objects on either side of the released object might still be in\r\nuse. Because of this, the freed space is a “gap” between other segments\r\nof memory. Unity can only use this gap to store data of identical or\r\nlesser size than the released object.\r\nThis situation is called memory\r\nfragmentation(即：内存碎片). This happens when\r\nthere is a large amount of memory available in the heap, but it is only\r\navailable in the “gaps” between objects. This means that even though\r\nthere is enough total space for a large memory allocation, the managed\r\nheap can’t find a large enough single block of contiguous memory to\r\nassign to the allocation.\r\n\r\nThe object annotated A, is the new object needed to be added to the\r\nheap. The items annotated B are the memory space that the released\r\nobjects took up, plus the free, unreserved memory. Even though\r\nthere is enough total free space, because there isn’t enough contiguous\r\nspace, the memory for the new object annotated A can’t fit on the heap,\r\nand the garbage collector must run.\r\nIf a large object is allocated and there is insufficient contiguous\r\nfree space to accommodate it, as illustrated above, the Unity memory\r\nmanager performs two operations:\r\n\r\nFirst, the garbage collector runs, if it hasn’t already done so.\r\nThis attempts to free up enough space to fulfill the allocation\r\nrequest.\r\nIf, after the garbage collector runs, there is still not\r\nenough contiguous space to fit the requested amount of memory, the heap\r\nmust expand. The specific amount that the heap expands is\r\nplatform-dependent; however, on most platforms, when the heap expands,\r\nit expands by double the amount of the previous expansion.\r\n\r\nUnity GC的执行方式\r\n\r\nManaged\r\nmemory - Unity 手册 (unity3d.com)\r\n\r\n和.Net一样，只要当脚本尝试在托管堆上进行分配但又没有足够的可用堆内存来容纳分配时，Unity\r\n就会运行垃圾收集器。当垃圾收集器运行时，它会检查堆中的所有对象，并将应用程序不再引用的任何对象标记为删除。然后\r\nUnity 会删除未引用的对象，从而释放内存。\r\n我们可以通过下面的API来fine-tune control over the automatic garbage\r\ncollector:\r\n\r\nSystem.GC.Collect: Performs a full, blocking garbage\r\ncollection.\r\nGarbageCollector.Mode.Disabled:\r\nFully disables the garbage collector. Using\r\nSystem.Gc.Collect in this mode has no effect.\r\nGarbageCollector.Mode.Manual:\r\nDisables automatic invocations of the garbage collector, but you can\r\nstill use System.GC.Collect to run a full collection.\r\nGarbageCollection.CollectIncremental: Runs the garbage\r\ncollector incrementally.\r\n\r\nScripting.GarbageCollector\r\n- Unity 脚本 API (unity3d.com)\r\n而前面也已经说过，Unity中的GC是Boehm GC，它有以下特点：\r\n\r\n实现方式与.Net大体上类似：Unity中，GC是Mark-Sweep方法的实现，它和.Net很像，也使用了类似根的概念。其呈现的大致流程如下：\r\n\r\nTo determine which heap blocks are no longer in use, the garbage\r\ncollector searches through all active reference variables and marks the\r\nblocks of memory that they refer to as “live.” At the end of the search,\r\nthe garbage collector considers any space between the “live” blocks\r\nempty and marks them for use for subsequent allocations. The process of\r\nlocating and freeing up unused memory is called garbage\r\ncollection (GC).\r\n\r\n但是需要注意的是，它无法分辨一个Root\r\n是一个指针还是非指针，所以会对所有当做一个指针做尝试，所以无法使用Copying算法。在BOEHM\r\nGC为了增加分辨能力其会根据已经分配过的内存区间做比较，增加指针黑名单，来增加分辨率。而准确式GC就是GC可以直接分辨出这是个指针还是非指针。而且可以使用Copying算法优化内存的使用。\r\n与.Net类似的另一点是，它会在需要进行GC时占用主线程来进行遍历-标记-垃圾回收的过程，然后在归还主线程控制权。这会导致帧数的突然下降，产生卡顿，由于这是占用主线程进行大量工作的行为，所以当我们优化GC时，实际上优化的是CPU时间，即GC占用主线程的时间减少了而非实际使用的内存。而就具体的运行过程而言，它又有三种工作模式：\r\n\r\n增量式Incremental\r\ngarbage collection: Enabled by default (Project Settings\r\n&gt; Player &gt; Configuration), this mode spreads out the\r\nprocess of garbage collection over multiple frames.\r\n\r\n这种模式是目前(2021.3)的默认的GC工作模式\r\n\r\nBy default, Unity uses it in incremental mode, which means that the\r\ngarbage collector splits up its workload over multiple frames, instead\r\nof stopping the main CPU thread (stop-the-world\r\ngarbage collection) to process all objects on the managed heap. This\r\nmeans that Unity makes shorter interruptions to your application’s\r\nexecution, instead of one long interruption to let the garbage collector\r\nprocess the objects on the managed heap.\r\n\r\n这种模式并不适用于存在大量引用快速变化的情况：在两次增量式GC之间，如果对象的引用发生变化会导致前一次GC的标记失效，需要重新进行遍历标记，而最糟的情况会退化为每一帧都是普通的非分代GC，而实时上要更糟糕一些，增量gc本就会需要运行一些额外的、用来通知gc重新扫描变化的代码。这时，主动地使用gc的非增量模式会是更好的选择。\r\n\r\nIncremental\r\ngarbage collection disabled: If you disable the Incremental\r\nGC Player Setting, the garbage collector stops running your\r\napplication to inspect and process objects on the heap.\r\nDisable\r\nautomatic garbage collection: Use the GarbageCollector.GCMode\r\nAPI to take full control of when Unity should run the garbage\r\ncollector.\r\n\r\n需要说明的是，关闭GC这个操作完全是可行的，并且是具有一定意义的，比如：当我们载入了一个关卡之后，我们就可以考虑关闭GC来保证GC不会拖累CPU时间，而当我们在进行Scene\r\nChange时，我们又可以手动调用System.GC.Collect来主动回收上一个Level的垃圾。\r\n\r\n\r\n无内存压缩：由于没有内存压缩，程序会有内存碎片的问题，其对内存利用率在比起.Net的实现上是更低的，并且应该会随着持续运行而导致碎片不断增多。但是换个思路，由于这是非压缩式的实现，所以GC在执行时导致的卡顿现象也相对较轻。前者可能导致平均帧率降低，后者也许反而会提升1%Low帧之类的东西。\r\n无代际划分，每次GC的执行都是一次Full\r\nGC，但存在一种渐进的GC模式即增量式GC模式，具体见上方工作模式。\r\n\r\nManaged heap expansion\r\nconsiderations\r\nThe unexpected expansion of the heap can be problematic. Unity’s\r\ngarbage collection strategy tends to fragment memory more often. You\r\nshould be aware of the following:\r\n\r\nUnity doesn’t release the memory allocated to the managed heap when\r\nit expands regularly; instead, it retains the expanded heap, even if a\r\nlarge section of it is empty. This is to prevent the need to re-expand\r\nthe heap if further large allocations occur.\r\nOn most platforms, Unity eventually releases the memory that the\r\nempty portions of the managed heap uses back to the operating system.\r\nThe interval at which this happens isn’t guaranteed and is\r\nunreliable.\r\n\r\n查看GC运行状态\r\n\r\nUnity has the following tools to keep track of memory\r\nallocations:\r\n\r\nUnity\r\nProfiler’s CPU Usage module: Provides details of the GC\r\nAlloc per frame\r\nUnity\r\nProfiler’s Memory module: Provides high-level memory usage frame by\r\nframe\r\nThe\r\nMemory Profiler package: A separate Unity package which provides\r\ndetailed information about memory usage during specific frames in your\r\napplication\r\n\r\n\r\nGC的优化之道 -\r\nGarbage Collector best practices\r\n\r\n优化GC的核心不在GC本身——在于减少垃圾的出现。\r\n\r\n\r\nAutomatic memory management allows you to write code quickly and\r\neasily, and with few errors. However, this convenience might have\r\nperformance implications. To optimize your code for performance, you\r\nmust avoid situations where your application triggers the garbage\r\ncollector a lot. This section outlines some common issues and\r\nworkflows that affect when your application triggers the garbage\r\ncollector.\r\n\r\n临时内存申请 - Temporary\r\nallocations\r\n复用对象池 - Reusable\r\nobject pools\r\n重复连接字符串 - Repeated\r\nstring concatenation\r\n数组作方法返回值 - Method\r\nreturning an array value\r\nCollection\r\nand array reuse\r\n闭包与匿名方法 - Closures\r\nand anonymous methods\r\n装箱 - Boxing\r\nArray-valued\r\nUnity APIs\r\n空数组复用 - Empty\r\narray reuse\r\n\r\n\r\nTemporary allocations\r\n\r\nIt’s common for an application to allocate temporary data to the managed\r\nheap in each frame; however, this can affect the performance of the\r\napplication.\r\n\r\n\r\n这实际上是一个积少成多的数学问题，优化GC的第一步是，自己少产生点垃圾。让我们以60帧为游戏的目标帧率，那一分钟内就会\r\nUpdate 3600次。1KB * 3600 ≈\r\n3.6MB，放在.Net，这已经会引发GC了。\r\n\r\n\r\n\r\nProgram Continue to Allocateing Memory: If a\r\nprogram allocates one kilobyte (1KB) of temporary memory each frame, and\r\nit runs at 60 frames per second, then it must allocate 60 kilobytes of\r\ntemporary memory per second. Over the course of a minute, this adds up\r\nto 3.6 megabytes of memory available to the garbage collector.\r\nInvoking the garbage collector: Invoking the\r\ngarbage collector once per second has a negative effect on performance.\r\nIf the garbage collector only runs once per minute, it has to clean up\r\n3.6 megabytes spread across thousands of individual allocations, which\r\nmight result in significant garbage collection times.\r\nLoading operations: Loading operations have an\r\nimpact on performance. If your application generates a lot of temporary\r\nobjects during a heavy asset-loading operation, and Unity references\r\nthose objects until the operation completes, then the garbage collector\r\ncan’t release those temporary objects. This means that the managed heap\r\nneeds to expand, even though Unity releases a lot of the objects that it\r\ncontains a short time later.\r\n\r\nTo get around this, you should try to reduce the amount of frequently\r\nmanaged heap allocations as possible: ideally to 0 bytes per frame, or\r\nas close to zero as you can get.\r\n\r\nReusable object pools\r\n\r\nThere are a lot of cases where you can reduce the number of times\r\nthat your application creates and destroys objects, to avoid generating\r\ngarbage. There are certain types of objects in games, such as\r\nprojectiles, which might appear over and over again even though only a\r\nsmall number are ever in play at once. In cases like this, you can reuse\r\nthe objects, rather than destroy old ones and replace them with new\r\nones.\r\n即，创建一个会在游戏中大量刷新的物体的缓冲池，每次需要的时候就可以直接复用这部分区域，这里，Unity官方举了一个枪械开火的示例：\r\nFor example, it’s not optimal to instantiate a new projectile object\r\nfrom a Prefab every time one is fired. Instead, you can calculate the\r\nmaximum number of projectiles that could ever exist simultaneously\r\nduring gameplay, and instantiate an array of objects of the correct size\r\nwhen the game first enters the gameplay scene. To do this:\r\n\r\nStart with all the projectile GameObjects set to being\r\ninactive.\r\nWhen a projectile is fired, search through the array to find the\r\nfirst inactive projectile in the array, move it to the required position\r\nand set the GameObject to be active.\r\nWhen the projectile is destroyed, set the GameObject to inactive\r\nagain.\r\n\r\nYou can use the ObjectPool\r\nclass, which provides an implementation of this reusable object pool\r\ntechnique.\r\nThe code below shows a simple implementation of a stack-based object\r\npool. You might find it useful to refer to if you’re using an older\r\nversion of Unity which doesn’t contain the ObjectPool API, or if you’d\r\nlike to see an example of how a custom object pool might be\r\nimplemented.\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344using System.Collections.Generic;using UnityEngine;public class ExampleObjectPool : MonoBehaviour &#123;   public GameObject PrefabToPool;   public int MaxPoolSize = 10;     private Stack&lt;GameObject&gt; inactiveObjects = new Stack&lt;GameObject&gt;();     void Start() &#123;       if (PrefabToPool != null) &#123;           for (int i = 0; i &lt; MaxPoolSize; ++i) &#123;               var newObj = Instantiate(PrefabToPool);               newObj.SetActive(false);               inactiveObjects.Push(newObj);           &#125;       &#125;   &#125;   public GameObject GetObjectFromPool() &#123;       while (inactiveObjects.Count &gt; 0) &#123;           var obj = inactiveObjects.Pop();                     if (obj != null) &#123;               obj.SetActive(true);               return obj;           &#125;           else &#123;               Debug.LogWarning(&quot;Found a null object in the pool. Has some code outside the pool destroyed it?&quot;);           &#125;       &#125;             Debug.LogError(&quot;All pooled objects are already in use or have been destroyed&quot;);       return null;   &#125;     public void ReturnObjectToPool(GameObject objectToDeactivate) &#123;       if (objectToDeactivate != null) &#123;           objectToDeactivate.SetActive(false);           inactiveObjects.Push(objectToDeactivate);       &#125;   &#125;&#125;\r\n\r\nRepeated string\r\nconcatenation\r\n\r\nStrings in C# are immutable reference types. A reference type means\r\nthat Unity allocates them on the managed heap and are subject to garbage\r\ncollection. Immutable means that once a string has been created, it\r\ncan’t be changed; any attempt to modify the string results in an\r\nentirely new string. For this reason, you should avoid creating\r\ntemporary strings wherever possible.\r\n\r\n一个例子是：\r\n123456789101112// Bad C# script example: repeated string concatenations create lots of temporary strings.public class ExampleScript : MonoBehaviour &#123;    string ConcatExample(string[] stringArray) &#123;        string result = &quot;&quot;;        for (int i = 0; i &lt; stringArray.Length; i++) &#123;            result += stringArray[i];        &#125;        return result;    &#125;&#125;\r\n如果输入stringArray == &#123;'A', 'B', 'C', 'D', 'E'&#125;，则会出现数个中间的临时的变量：A, AB, ABC, ABCD，要是这也是在Update中调用呢？就这里而言，我们可以做的包括：使用\r\nStringBuilder，使用全局变量，tostring的对象直接占用独立的Text以避免与前缀进行拼接，采用条件限制字符串拼接的进行等\r\nMethod returning an array\r\nvalue\r\n\r\nSometimes it might be convenient to write a method that creates a new\r\narray, fills the array with values and then returns it. However, if this\r\nmethod is called repeatedly, then new memory gets allocated each\r\ntime.\r\n\r\nOne way you can avoid allocating memory every time is to make\r\nuse of the fact that an array is a reference type. You can modify an\r\narray that’s passed into a method as a parameter, and the results remain\r\nafter the method returns.\r\n12345678910111213141516171819// Bad C# script example: Every time the RandomList method is called it allocates a new arraypublic class ExampleScript : MonoBehaviour &#123;    float[] RandomList(int numElements) &#123;        var result = new float[numElements];        for (int i = 0; i &lt; numElements; i++) &#123;            result[i] = Random.value;        &#125;        return result;    &#125;&#125;// Good C# script example: This version of method is passed an array to fill with random values. The array can be cached and re-used to avoid repeated temporary allocationspublic class ExampleScript : MonoBehaviour &#123;    void RandomList(float[] arrayToFill) &#123;        for (int i = 0; i &lt; arrayToFill.Length; i++) &#123;            arrayToFill[i] = Random.value;        &#125;    &#125;&#125;\r\n在上方，我们用一个数组对象作为参数而非数组长度，这样函数体内便不需要创建新的数组，避免了内存分配与垃圾产生。And\r\nthe array can then be re-used and re-filled with random numbers the next\r\ntime this method is called without any new allocations on the managed\r\nheap.\r\nCollection and array reuse\r\n\r\nWhen you use arrays or classes from the System.Collection\r\nnamespace (for example, Lists or Dictionaries), it’s efficient to reuse\r\nor pool the allocated collection or array. Collection classes expose a\r\nClear method, which eliminates a collection’s values but doesn’t release\r\nthe memory allocated to the collection.\r\n\r\nClear方法消除集合的值，但不会释放分配给集合的内存。我们可以直接复用这部分内存——只要它还是可引用的，即，将List等于\r\nSystem.Collection\r\n的类型的变量提升到包含的类中，这样就不需要每帧分配一个新的 List\r\nClosures and anonymous\r\nmethods\r\n\r\nIn general, you should avoid closures in C# whenever possible. You\r\nshould minimize the use of anonymous methods and method references in\r\nperformance-sensitive code, and especially in code that executes on a\r\nper-frame basis.\r\n\r\n我们需要尽可能地避免使用闭包，同时还得小心我们的匿名函数构成了闭包。因为闭包除了函数指针还会将捕获的变量一起包装起来创建到堆上，相当于\r\nnew\r\n了个对象，严重的情况下还会导致C#会创建一个匿名class并将其实例化。\r\n\r\n在 IL2CPP 環境下任何使用匿名方法都會配置 Managed 的記憶體。使用 Mono\r\n則不會發生。 此外，IL2CPP 會因為方法的 指向另一個方法的參數\r\n宣告方法不同而會有不同的 Managed\r\n記憶體配置量。如預期般地用閉包來呼叫會配置最多的記憶體。\r\n但違反一般人的直覺地，預先定義的方法在 IL2CPP\r\n環境下作為參數傳遞時，配置的記憶體幾乎和閉包一樣多。而匿名方法在堆積上產生的臨時垃圾最少，少了一個以上的數量級。\r\n因此，如果專案打算用 IL2CPP 做為執行環境，有三點建議：\r\n\r\n建議程式風格避免傳遞方法作為參數。\r\n真的無法避免的話，採用匿名方法而非預先定義方法。\r\n不管 Mono 或 IL2CPP 都避免使用閉包。\r\n\r\n\r\nBoxing\r\n\r\nBoxing is one of the most common sources of unintended\r\ntemporary memory allocations found in Unity projects. It\r\nhappens when a value-typed variable gets automatically converted to a\r\nreference type. This most often happens when passing primitive\r\nvalue-typed variables (such as int and float) to object-typed methods.\r\nYou should avoid boxing when writing C# code for Unity.\r\n\r\n装箱也会隐式地导致对象的创建。从而产生意想不到的垃圾，而且装箱操作往往很隐蔽，我们需要格外小心，比如：用枚举值当字典的key的时，各种字典操作会调用\r\nObject.getHashCode 获取哈希值 ，该方法会导致装箱。\r\nArray-valued Unity APIs\r\n某些Unity内部函数在返回时，返回的对象是原对象的一份副本。例如，以下代码在每次循环迭代时，都不必要地创建了顶点数组的四个副本：每次访问\r\n.vertices 属性时，这种复制都会执行。\r\n12345678for(int i = 0; i &lt; mesh.vertices.Length; i++)&#123;    float x, y, z;    x = mesh.vertices[i].x;    y = mesh.vertices[i].y;    z = mesh.vertices[i].z;    // ...    DoSomething(x, y, z);   &#125;\r\n我们可以通过在第一次就cache返回的数组来解决。当然，如果我们能直接使用不会分配内存的API不是更好吗？\r\nAlternative non-allocating\r\nAPIs\r\nSome Unity APIs have alternative versions that don’t cause memory\r\nallocations. You should use these when possible. The following table\r\nshows a small selection of common allocating APIs and their\r\nnon-allocating alternatives. The list isn’t exhaustive, but should\r\nindicate the kind of APIs to watch out for.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAllocating API\r\nNon-allocating API\r\nalternative\r\n\r\n\r\n\r\n\r\nPhysics.RaycastAll\r\nPhysics.RaycastNonAlloc\r\n\r\n\r\nAnimator.parameters\r\nAnimator.parameterCount\r\nand Animator.GetParameter\r\n\r\n\r\nRenderer.sharedMaterials\r\nRenderer.GetSharedMaterials\r\n\r\n\r\n...\r\n...\r\n\r\n\r\n\r\nEmpty array reuse\r\n\r\nSome development teams prefer to return empty arrays instead of null\r\nwhen an array-valued method needs to return an empty set. This coding\r\npattern is common in a lot of managed languages, particularly C# and\r\nJava.\r\nIn general, when returning a zero-length array from a method, it’s\r\nmore efficient to return a pre-allocated static instance of the\r\nzero-length array than to repeatedly create empty arrays.\r\n\r\n空数组（长度为0的数组）的创建事实上也会导致堆内存的分配。所以应该将其提前创建出来并复用。\r\n上述问题的原因都是类似的，即大量地创建了短暂使用的对象（垃圾），基本上都可以通过将会反复使用的对象创建为非局部变量来解决（或者更进一步，使用所谓对象池的技术，基本原理是一样的）。有些地方就只能通过避免会造成垃圾产生的接口来解决。总之优化GC，核心在于消灭垃圾。\r\n同.Net下GC的区别\r\n\r\n\"保守式垃圾回收是一种通过近似方式识别和回收垃圾对象的方式。在保守式垃圾回收中，垃圾回收器并不直接访问对象的内部结构和引用关系，而是通过扫描内存中的数据块，识别出可能是指向对象的指针，并将其标记为活动对象。然后，垃圾回收器将从活动对象出发，递归地遍历和标记其他可达的对象，并回收那些未被标记为活动对象的内存。保守式垃圾回收不需要额外的内存开销来维护对象之间的引用关系，但可能会存在一定的误判，即将某些实际上是垃圾的对象错误地标记为活动对象。”\r\n用大白话讲就是Boehm\r\nGC无法区分指针和非指针，这就可能由于误判导致有些已经可以释放的内存无法释放。\r\n\r\nReferences\r\n\r\n自动内存管理\r\n| Microsoft Learn\r\nHow\r\nIDisposable, Dispose, and Finalizers work in C# - YouTube\r\nC#托管堆和垃圾回收（GC）\r\n- xiaoxiaotank - 博客园 (cnblogs.com)\r\n\r\n[C#学习笔记]类型对象指针和同步块索引\r\n- knqiufan - 博客园 (cnblogs.com)\r\n\r\nC#托管堆和垃圾回收\r\n- 知乎 (zhihu.com)\r\nC#技术漫谈之垃圾回收机制(GC)_知识库_博客园\r\n(cnblogs.com)\r\n非托管类型\r\n- C# 参考 | Microsoft Learn\r\n清理未托管资源\r\n| Microsoft Learn\r\nc#\r\n- What exactly are unmanaged resources? - Stack Overflow\r\n温故之.NET托管资源与非托管资源\r\n- 知乎 (zhihu.com)\r\nC#与C++的析构函数\r\n- Justin Liu - 博客园 (cnblogs.com)\r\n深入理解C#中的IDisposable接口\r\n- CharyGao - 博客园 (cnblogs.com)\r\n探讨C#中Dispose方法与Close方法的区别详解\r\n- 董川民 (dongchuanmin.com)\r\nMemory\r\nin Unity - Unity 手册 (unity3d.com)\r\nUnity\r\n- Manual: Garbage collector overview (unity3d.com)\r\nc#\r\n- Unity's garbage collector - Why non-generational and non-compacting? -\r\nStack Overflow\r\nUnity内存问答笔记 -\r\n知乎 (zhihu.com)\r\nMono中的BOEHM GC\r\n原理学习（1） - 知乎 (zhihu.com)\r\nUnity GC 学习总结 -\r\n知乎 (zhihu.com)\r\nUnity\r\nTaiwan: 最佳實踐 - 了解Unity效能 - GC和Managed Heap\r\nUnity\r\n内存优化 | 新诸子 (xinzhuzi.github.io)\r\n\r\n","slug":"Language Learning/GC","date":"2023-05-05T18:52:23.000Z","categories_index":"C#,Language Learning","tags_index":"C#,Language Learning","author_index":"JBR_Bunjie"},{"id":"b0e884d72c7c6bc5c7d44e3b4aa33541","title":"UnityURPToonLitShaderExample 源码分析","content":"最简的\r\nToon Shader 的源码分析 - UnityURPToonLitShaderExample\r\n\r\nWhat is included in this \"simplified version\" toon lit shader\r\nrepository?\r\nThis repository contains a very simple toon lit shader example, to\r\nhelp people writing their first custom toon lit shader in URP. This\r\nexample shader's default result(without editing material params) = the\r\nfollowing picture\r\n\r\n\r\nscreenshot\r\n\r\n\r\nAbout this repository\r\nThis repository is NOT the full version NiloToonURP. This repository\r\nonly contains a very simple and short URP toon shader example, only for\r\ntutorial purposes, it is under MIT license so you can do whatever you\r\nwant with the code. If you want to keep the current tutorial shader,\r\nplease fork it or download a copy now since it may be removed in the\r\nfuture.\r\n\r\nColinLeung-NiloCat/UnityURPToonLitShaderExample:\r\nA very simple toon lit shader example, for you to learn writing custom\r\nlit shader in Unity URP (github.com)\r\n\r\n\r\n如其所说，这实际上是一个过度简化的 Toon\r\nShader，基本不具有太强的可用性，但这也同样意味着，这是一个不错的起点。\r\n虽然我们看到上面的结果还算不错，但是基本上不太可能复现出来\r\n\r\n项目结构：\r\n容易看出，该项目一共仅包含 8 份文件，而实际在项目中生效的文件为：\r\n\r\nSimpleURPToonLitOutlineExample.shader\r\nSimpleURPToonLitOutlineExample_Shared.hlsl\r\nNiloOutlineUtil.hlsl\r\nNiloZOffset.hlsl\r\nNiloInvLerpRemap.hlsl\r\nSimpleURPToonLitOutlineExample_LightingEquation.hlsl\r\n\r\n这是一个组织上还算不赖的项目，不过考虑到未来扩建的可能性，可以考虑将\r\nSimpleURPToonLitOutlineExample_Shared.hlsl\r\n进行进一步的拆分：将该文件拆分为 Input 和\r\nSharedFunction 两个文件\r\n让我们从 SimpleURPToonLitOutlineExample.shader\r\n开始进行代码的分析：\r\n代码与效果分析：\r\nshader 文件主体结构\r\n从头看起，首先在 9~14 行的注释中，有提到该 Shader 的 5 个\r\nPasses：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nForwardLit\r\npass\r\n(this pass will always render to the color buffer\r\n_CameraColorTexture)\r\n\r\n\r\nOutline\r\npass\r\n(this pass will always render to the color buffer\r\n_CameraColorTexture)\r\n\r\n\r\nShadowCaster\r\npass\r\n(only for URP's shadow mapping, this pass won't render at all if\r\nyour character don't cast shadow)\r\n\r\n\r\nDepthOnly\r\npass\r\n(only for URP's depth texture _CameraDepthTexture's rendering,\r\nthis pass won't render at all if your project don't render URP's\r\noffscreen depth prepass)\r\n\r\n\r\nDepthNormals\r\npass\r\n(only for URP's normal texture _CameraNormalsTexture's\r\nrendering)实际上项目并没有对这个 Pass 做出实现当\r\nPass\r\n的LightMode为DepthNormals时，(且在\r\nAssert 中勾选 Depth Texture 时)Unity 会生成_CameraDepthTexture\r\n与_CameraNormalsTexture, 最终传入到 Shader\r\n中的_CameraDepthNormalsTexture，关于_CamerDepthTexture，可见：-\r\nhttps://docs.unity3d.com/Manual/SL-CameraDepthTexture.html-\r\nhttps://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/universalrp-asset.html\r\n\r\n\r\n\r\nUniversal\r\nRender Pipeline Asset | Universal RP | 12.1.11 (unity3d.com)\r\n我们需要处理的环节：\r\n一个 high level setting：_IsFace\r\nhttps://www.bilibili.com/read/cv6504414/\r\n渲染流程\r\nShader file\r\n第一个 Pass 从 117 开始，到 171 行结束。这是 Shader 中的第一个\r\nPass，该 Pass 完成了从间接光到直接光的计算.\r\n这里对间接光的定义是，而直接光则是 MainLight 和 AdditionalLight\r\n的作用集合\r\n先进行光照的运算，这意味着模型的正面最早被渲染，这样可以最大程度地减少\r\nOverDraw 的情况。\r\n整个 Shader file 的四个 Pass 的流程都差不太多，所以针对 Shader\r\n内的各个 Pass 的流程仅作一次说明：\r\n\r\n在 123 行，定义 Pass 的 Name\r\n在 124~131 行，是 Pass Tags，这里定义了 Pass 的\r\nLightMode：\"LightMode\" = \"UniversalForward\"，这意味这个\r\nPass\r\n应该：Render object geometry and evaluate all light contributions\r\n在 135~138 行，设置 Pass State\r\n在 140~170 行，HLSLPROGRAM 2 ENDHLSL\r\n\r\n142~159 行，设置关键字以获取 Shader 变体\r\n161~162 行，设置 Vertex 和 fragment 函数\r\n168 行，引入实在代码\r\nSimpleURPToonLitOutlineExample_Shared.hlsl\r\n\r\n\r\n深入 SimpleURPToonLitOutlineExample_Shared.hlsl\r\n文件：\r\nHLSL Entities\r\nVertex Function:\r\nVertexShaderWork\r\nSimpleURPToonLitOutlineExample_Shared.hlsl 文件的\r\n153~217 行是我们的 Vertex Shader：\r\n而由于在单纯的 UniversalForward 中没有定义任何控制用的宏，所以我们\r\nVertex Shader 只会执行最基本的代码，内容仅包括：\r\n\r\n坐标系转换\r\nuv 计算\r\n\r\n去掉注释后的代码如下：\r\n12345678910111213141516171819202122Varyings VertexShaderWork(Attributes input) &#123;    Varyings output;    VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS);    VertexNormalInputs vertexNormalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS);    float3 positionWS = vertexInput.positionWS;    // Computes fog factor per-vertex.    float fogFactor = ComputeFogFactor(vertexInput.positionCS.z);    // TRANSFORM_TEX is the same as the old shader library.    output.uv = TRANSFORM_TEX(input.uv,_BaseMap);    // packing positionWS(xyz) &amp; fog(w) into a vector4    output.positionWSAndFogFactor = float4(positionWS, fogFactor);    output.normalWS = vertexNormalInput.normalWS; //normlaized already by GetVertexNormalInputs(...)    output.positionCS = TransformWorldToHClip(positionWS);    return output;&#125;\r\n坐标转换过程\r\n我们只使用了 vertexInput 中的 positionWS，这里用两个原因：\r\n首先，如果我们对模型的顶点作出修改后，我们应该将这种变化同步到所有别的空间下。而\r\nFragment Shader 中会同时用到世界坐标与裁剪坐标，这意味着 Vertex Shader\r\n中需要将“最终的世界坐标与裁剪坐标”上载到 v2f\r\n中。为了简化流程，我们直接在世界空间下操作，而后对完成处理的世界坐标再另做一次坐标转换得到裁剪坐标。\r\n雾效\r\n关于 Unity 的内置雾效：\r\n\r\n雾效(Fog)是游戏里经常使用的一种效果。Unity\r\n内置的雾效可以产生基于距离的线性或指数雾效。然而，要想在自己编写的顶点/片元着色器中实现这些雾效，我们需要在\r\nShader 中添加 #pragma multi_compile_fog\r\n指令，同时还需要使用相关的内置宏，例如\r\nUNITY_FOG_COORD、UNITY_TRANSFER_FOG 和 UNTTY_APPLY_FOG\r\n等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。当我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用\r\nUnity 内置的雾效就变得不再可行\r\n\r\n Unity Built-in Fog\r\n关于 Unity Built-in Fog，可参考：Rendering\r\n14 (catlikecoding.com)\r\nFragment\r\n等到了 Fragment Shader 中，我们就开始正式计算光源对物体的影响了：\r\n123456789101112half4 ShadeFinalColor(Varyings input) : SV_TARGET &#123;    // fillin ToonSurfaceData struct:    ToonSurfaceData surfaceData = InitializeSurfaceData(input);    // fillin ToonLightingData struct:    ToonLightingData lightingData = InitializeLightingData(input);    // apply all lighting calculation    half3 color = ShadeAllLights(surfaceData, lightingData);    return half4(color, surfaceData.alpha);&#125;\r\n可以看到的是，Fragment Shader\r\n中首先仍然是对数据的准备：利用我们传入的 Varyings 数据定义了两个结构体：\r\nToonSurfaceData 和 ToonLightingData：\r\n123456789101112struct ToonSurfaceData &#123;    half3   albedo;    half    alpha;    half3   emission;    half    occlusion;&#125;;struct ToonLightingData &#123;    half3   normalWS;    float3  positionWS;    half3   viewDirectionWS;    float4  shadowCoord;&#125;;\r\n它们分别对应了一个初始化函数：\r\n1234567891011121314151617181920212223242526ToonSurfaceData InitializeSurfaceData(Varyings input) &#123;    ToonSurfaceData output;    // albedo &amp; alpha    float4 baseColorFinal = GetFinalBaseColor(input);    output.albedo = baseColorFinal.rgb;    output.alpha = baseColorFinal.a;    DoClipTestToTargetAlphaValue(output.alpha);// early exit if possible    // emission    output.emission = GetFinalEmissionColor(input);    // occlusion    output.occlusion = GetFinalOcculsion(input);    return output;&#125;ToonLightingData InitializeLightingData(Varyings input) &#123;    ToonLightingData lightingData;    lightingData.positionWS = input.positionWSAndFogFactor.xyz;    lightingData.viewDirectionWS = SafeNormalize(GetCameraPositionWS() - lightingData.positionWS);    lightingData.normalWS = normalize(input.normalWS); //interpolated normal is NOT unit vector, we need to normalize it    return lightingData;&#125;\r\n在完成初始化后，利用所得的信息，计算光照影响：\r\n12half3 color = ShadeAllLights(surfaceData, lightingData);color = ApplyFog(color, input);\r\n最后将 color 作为结果进行返回，完成一次渲染\r\n这其中的 ShadeAllLights 必须考虑全部的 Light 的影响，\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970half3 ShadeAllLights(ToonSurfaceData surfaceData, ToonLightingData lightingData)&#123;    // Indirect lighting    half3 indirectResult = ShadeGI(surfaceData, lightingData);    //////////////////////////////////////////////////////////////////////////////////    // Light struct is provided by URP to abstract light shader variables.    // It contains light&#x27;s    // - direction    // - color    // - distanceAttenuation    // - shadowAttenuation    //    // URP take different shading approaches depending on light and platform.    // You should never reference light shader variables in your shader, instead use the    // -GetMainLight()    // -GetLight()    // funcitons to fill this Light struct.    //////////////////////////////////////////////////////////////////////////////////    //==============================================================================================    // Main light is the brightest directional light.    // It is shaded outside the light loop and it has a specific set of variables and shading path    // so we can be as fast as possible in the case when there&#x27;s only a single directional light    // You can pass optionally a shadowCoord. If so, shadowAttenuation will be computed.    Light mainLight = GetMainLight();    float3 shadowTestPosWS = lightingData.positionWS + mainLight.direction * (_ReceiveShadowMappingPosOffset + _IsFace);#ifdef _MAIN_LIGHT_SHADOWS    // compute the shadow coords in the fragment shader now due to this change    // https://forum.unity.com/threads/shadow-cascades-weird-since-7-2-0.828453/#post-5516425    // _ReceiveShadowMappingPosOffset will control the offset the shadow comparsion position,    // doing this is usually for hide ugly self shadow for shadow sensitive area like face    float4 shadowCoord = TransformWorldToShadowCoord(shadowTestPosWS);    mainLight.shadowAttenuation = MainLightRealtimeShadow(shadowCoord);#endif    // Main light    half3 mainLightResult = ShadeSingleLight(surfaceData, lightingData, mainLight, false);    //==============================================================================================    // All additional lights    half3 additionalLightSumResult = 0;#ifdef _ADDITIONAL_LIGHTS    // Returns the amount of lights affecting the object being renderer.    // These lights are culled per-object in the forward renderer of URP.    int additionalLightsCount = GetAdditionalLightsCount();    for (int i = 0; i &lt; additionalLightsCount; ++i)    &#123;        // Similar to GetMainLight(), but it takes a for-loop index. This figures out the        // per-object light index and samples the light buffer accordingly to initialized the        // Light struct. If ADDITIONAL_LIGHT_CALCULATE_SHADOWS is defined it will also compute shadows.        int perObjectLightIndex = GetPerObjectLightIndex(i);        Light light = GetAdditionalPerObjectLight(perObjectLightIndex, lightingData.positionWS); // use original positionWS for lighting        light.shadowAttenuation = AdditionalLightRealtimeShadow(perObjectLightIndex, shadowTestPosWS); // use offseted positionWS for shadow test        // Different function used to shade additional lights.        additionalLightSumResult += ShadeSingleLight(surfaceData, lightingData, light, true);    &#125;#endif    //==============================================================================================    // emission    half3 emissionResult = ShadeEmission(surfaceData, lightingData);    return CompositeAllLightResults(indirectResult, mainLightResult, additionalLightSumResult, emissionResult, surfaceData, lightingData);&#125;\r\n小结\r\n描边流程\r\n基本思路：\r\n描边的基本思路：顶点扩张。利用\r\n\\[\r\nVertexPos\\_Outline = VertexPos + NormalDir * ControlVariable\r\n\\]\r\n来计算 Outline Pass\r\n下的受到扩张的顶点坐标。再裁剪掉正面的三角形即可。\r\n实现过程：\r\nShader 的 173 行到 223 行对应了 Outline\r\n的流程，这里做的事情包括：\r\n\r\n180 行：设置 Pass 的 Name\r\n181~196 行：用于设置 Pass Tags，这里的注释指出，我们可以通过为当前\r\nPass 设置一个我们自定义的\r\nLightMode：\"LightMode\"==\"YourCustomPassTag\"，通过这种方式，我们可以利用\r\nURP 的 RenderFeature 以及\r\ncmd.DrawRenderers()来控制我们的渲染来最大化利用 SRP 批处理。关于\r\nRenderFeature，可参考： How\r\nto create a custom Renderer Feature | Universal RP | 12.1.11\r\n(unity3d.com) Unity\r\n- Scripting API: CommandBuffer (unity3d.com)\r\n198 行，Cull Front\r\n200~222 行，HLSLPROGRAM 2 ENDHLSL\r\n\r\n202 行到 211 行，继承了 ForwardLit 的关键字\r\n213~214 行，设置 vertex 和 fragment 函数\r\n217 行，定义宏 ToonShaderIsOutline\r\n来控制渲染流程——这是我们整个渲染中，相当重要的一环\r\n220 行，引入实在代码\r\nSimpleURPToonLitOutlineExample_Shared.hlsl\r\n\r\n\r\n让我们继续深入\r\nSimpleURPToonLitOutlineExample_Shared.hlsl 文件\r\nHLSL Entities\r\nVertex\r\nFragment\r\n为什么描边需要 fov 和 Distance？\r\nShader 变体：\r\n后记\r\n\r\nWhat is NOT included in this simplified example\r\nshader?\r\nFor simplicity reason, I removed most of the features from the\r\nNiloToonURP (deleted 90% of the original shader), else this example\r\nshader will be way too complex for reading &amp; learning. The removed\r\nfeatures are:\r\n\r\nface anime lighting (auto-fix face ugly lighting due to vertex\r\nnormal without modifying .fbx, very important)\r\nsmooth outline normal auto baking (fix ugly outlines without\r\nmodifying .fbx once you attach a script on character, very\r\nimportant)\r\nauto 2D hair shadow on face (very important, it is very difficult to\r\nproduce good looking shadow result using shadowmap)\r\nsharp const width rim light (Blue Protocol / Genshin Impact)\r\ntricks to render eye/eyebrow over hair\r\nhair \"angel ring\" reflection\r\nPBR specular lighting (GGX)\r\nHSV control shadow &amp; outline color\r\n2D mouth renderer\r\nalmost all the extra texture input options like roughness, specular,\r\nnormal map, detail map...\r\nLOTS of sliders to control lighting, final color &amp; outline\r\nper character \"dither fadeinout / rim light / tint / lerp...\"\r\ncontrol script\r\nvolume override control of global \"dither fadeinout / rim light /\r\ntint / lerp...\"\r\nanime postprocessing\r\nauto phong tessellation\r\nperspective removal per character\r\n***just too much for me to write all removed feature here, the full\r\n/ lite version shader is a totally different level product\r\n\r\n\r\nReference\r\n\r\nColinLeung-NiloCat/UnityURPToonLitShaderExample:\r\nA very simple toon lit shader example, for you to learn writing custom\r\nlit shader in Unity URP (github.com)\r\n【Unity】URP\r\n源码分析(Pass 篇) - 知乎 (zhihu.com)\r\nUniversal\r\nRender Pipeline Asset | Universal RP | 12.1.11 (unity3d.com)\r\nUnity\r\n- Manual: Cameras and depth textures (unity3d.com)\r\n【浅入浅出】Unity\r\n雾效 - 知乎 (zhihu.com)\r\n\r\n","slug":"Rendering/SimpleToonShader","date":"2023-05-03T04:23:23.000Z","categories_index":"Unity,Shader","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"3efe5f95488e956915246e267ac83bb6","title":"Shaderlab 总览及其基本执行逻辑","content":"Shaderlab\r\n总览及其基本执行逻辑\r\nShaderlab 结构总览\r\nShaderlab 是 Unity\r\n所使用的，独立的着色器语言。这是一种跨平台的语言体系，大体包含四部分：\r\n\r\nShaderLab Text\r\nShaderLab Compiler\r\nShaderLab Asset\r\nShaderLab Runtime\r\n\r\n我们将一一解释：\r\nShaderlab Text\r\nShaderLab Text 指的是在 .shader\r\n文件中，由我们所定义的那些代码。它们需要使用或 CG 或\r\nHLSL\r\n等的语法规则来编写。官方文档可见：Reference\r\n而 ShaderLab Text 的基本结构如下：\r\n123456Shader &quot;&lt;name&gt;&quot; &#123;    &lt;optional: Material properties&gt; # 暴露在外的材质属性    &lt;One or more SubShader definitions&gt; # Subshader块是必选的，这是Shader中的实在代码    &lt;optional: fallback&gt; # 回调Shader    &lt;optional: custom editor&gt; #指定该Shader需要采用的editor，比如Amplify Shader Editor等&#125;\r\nProperties\r\n我们利用 Material properties\r\n可选项来可以定义在应用了当前 Shader 的\r\nMaterial 上显示的数据，而中的格式如下：\r\n12345Properties &#123;    [optional: attribute] name(&quot;display text in Inspector&quot;, type name) = default value    [optional: attribute] name(&quot;display text in Inspector&quot;, type name) = default value    ......&#125;\r\n在我们日常编写中，我们不太长见到 attribute\r\n的使用，但事实上 Properties 中是存在很多类型的\r\nattribute 的，注明这些 attribute\r\n能让我们在脚本中实时控制 Properties 更加方便\r\n特别的，如果使用的是 SRP，想使用\r\nSRP Batcher compatibility\r\n特性，我们像下方这样必须把每个 Properties 里的变量放到在 HLSL 代码中的\r\nCBUFFER 中： 特殊的，贴图和采样器本身不需要再 CBUFFER\r\n中声明，但是其相关参数 Texel_size 及 ST\r\n则需要\r\n1234567891011121314151617181920212223242526272829Properties &#123;    _Color (&quot;Colot Tint&quot;, Color) = (1, 1, 1, 1)    _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;    _Layers (&quot;Cloud Level&quot;, Range(8, 128)) = 16    _SpeedX (&quot;Speed X&quot;, float) = 0.05    _SpeedY (&quot;Speed Y&quot;, float) = 0.05    _Alpha (&quot;Cloud Alpha Value&quot;, Range(0, 1)) = 0.6    _HeightOffset (&quot;Height Offset&quot;, float) = 5&#125;SubShader &#123;\t...    HLSLINCLUDE    TEXTURE2D(_MainTex);    SAMPLER(sampler_MainTex);    CBUFFER_START(UnityPerMaterial)        half4 _Color;        float4 _MainTex_ST;        float _Layers;        float _SpeedX;        float _SpeedY;        half _Alpha;        half _HeightOffset;        CBUFFER_END    ENDHLSL    ...&#125;\r\nSubShader\r\nSubShader 是主要逻辑的实现部分，它又可以再次细分：\r\n123456789101112SubShader &#123;    &lt;optional: LOD&gt;    # Level Of Detial，这个值越小，意味着当前Shader的细节越少，也就是说这个Shader越容易被执行，不过当多个SubShader的LOD都比要求的LOD小时，会从上到下地(第一行代码到最后一行地)执行第一个符合条件的SubShader    &lt;optional: tags&gt;    # SubShader Tags，形式为键值对，Unity会根据它们决定何时、如何使用SubShader    &lt;optional: commands&gt;    # 诸如Blend、ZTest等命令    &lt;One or more Pass definitions&gt;&#125;\r\n而最后的 Pass 则是我们实在代码中，具体渲染过程所在的部分了。对于 Pass\r\n本身的结构，可以概括为：\r\n123456789101112Pass &#123;    &lt;optional: name&gt;    # 给Pass设置一个名字，以后可以用这个名字在别的Shader中使用UsePass Command来调用这个名字的Pass    &lt;optional: tags&gt;    # 和SubShader中的tags大同小异，但工作方式并不一样，具体来看就是所管理的键值对并不相同。下方的commands也是如此，请注意，#pragma这样的语句，不是Command    &lt;optional: commands&gt;    &lt;optional: shader code&gt;    # 最终的Shader Code落脚的地方，包裹在HLSLPROGRAM之类的命令中&#125;\r\nShaderLab Compiler\r\n\r\n光有文本是不行的，就如同你写 C++，如果只是写了一堆 CPP\r\n文件，依然是无法被计算机认可并执行的。中间需要有翻译的过程，就是 shader\r\nCompiler 的过程。\r\n\r\n简单来说，Unity 会在后台提供的一种服务，用来帮助我们去把写好的\r\nShaderLab 语言翻译为目标机器能够认可并执行的语言\r\n这事实上包含两层：\r\n\r\n首先，对于我们的电脑本机来说：HLSL 及 CG\r\n等代码是不能直接运行在 DirectX 设备上的，而 Unity\r\n的编译器会把我们写好的这些代码编译成可执行的机器语言\r\n其次，我们所编写的 HLSL 等语言是不能直接运行在\r\nOpenGL，Vulkan\r\n等平台上的，我们得把代码转译为目标平台山的语言\r\n\r\n也就是说，ShaderLab Compiler 的实际行为是：把 ShaderLab Text\r\n翻译成最终目标机器上能够认可和执行的语言，对应的编译代码，我们可以通过点击\r\nInspect 面板下的 Compile and show code 来查看\r\nUnity\r\n- Manual: Shader compilation\r\nShaderLab Asset\r\n我们已经知道，ShaderLab\r\n里面有很多东西都是不能直接使用的，需要进行翻译。而加工之后得到的东西就叫做\r\nShaderLab Asset。Asset 比较常见的地方有两个：\r\n一个就是由 Shader 打成的 AssetBundle。另一个是我们打出来的包里面的\r\nlevel 或 sharedassets 包。\r\nReference:\r\n\r\n【Unity\r\n笔记】ShaderLab 与其底层原理浅谈 - 知乎 (zhihu.com)\r\nUnity\r\n- Manual: ShaderLab (unity3d.com)\r\n\r\n","slug":"Rendering/Shaderlab","date":"2023-05-02T04:23:23.000Z","categories_index":"Unity,Shader","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"db4c4d4811d5722c3a2acb135b7ca20d","title":"PBR","content":"PBR\r\n\r\nPBR，或者用更通俗一些的称呼是指基于物理的渲染(Physically Based\r\nRendering)，它指的是一些在不同程度上都基于与现实世界的物理原理更相符的基本理论所构成的渲染技术的集合。\r\n\r\nPBR 综述\r\nPBR\r\n是基于物理的渲染，具体表现为使用一种更符合物理学规律的方式来模拟光线，这种渲染方式与我们原来的\r\nPhong 或者 Blinn-Phong\r\n光照算法相比总体上看起来要更真实一些。除了看起来更好些以外，由于它与物理性质非常接近，因此我们可以直接以物理参数为依据来编写表面材质，而不必依靠粗劣的修改与调整来让光照效果看上去正常。使用基于物理参数的方法来编写材质还有一个更大的好处，就是不论光照条件如何，这些材质看上去都会是正确的，而在非\r\nPBR 的渲染管线当中有些东西就不会那么真实了。\r\n关于 PBR，有些有趣的东西：在 PBR 出现之前，3d\r\n界如何做”真实感“渲染的？ - 知乎 (zhihu.com)，其中的这条回答比较有意思：\r\n一个误区是 PBR\r\n一定是真实感的渲染，这当然是不完全正确的：比如迪士尼的电影中大量使用\r\nPBR，但是这些动画电影很难说得上是什么“真实感渲染”的结果\r\n\r\nPBS 是为了对光和材质之间的行为进行更加真实的建模。\r\n...\r\n在把 PBS\r\n入当前的游戏项目之前我们需要权衡一下它的优缺点。需要再次提醒读者的是，PBS\r\n并不意味着游戏画面需要追求和照片一样真实的效果。事实上，很多游戏都不需要刻意去追求与照片一样的真实感，玩家眼中的真实感大多也并不是如此\r\nPBS 优点在于 我们只需要个万能的 shader\r\n就可以渲染相当一大部分类型的材质而不是使用传统的做法为每种材质写特定的\r\nshader。同时，PBS\r\n可以保证在各种光照条件下，材质都可以自然地和光源进行交互，而不需要我们反复地调整材质参数。\r\n然而，在使用 PBS 时我们也需要考虑到它带来的代价。如上面提到的，PBS\r\n往往需要更复杂的光照配合，例如大量使用光照探针和反射探针等。而且 PBS\r\n需要开启 HDR 以及一些必不可少的屏幕特效，例如抗锯齿、Bloom\r\n和色调映射，如果这些屏幕特效对当前游戏来说需要消耗过多的性能，那么 PBS\r\n就不适合当前的游戏，我们应该使用传统的 shader 来渲染游戏。使用 PBS\r\n对美工人员来说同样是个挑战。美术资源的制作过程和使用传统的 shader\r\n有很大不同，普通的法\r\n线纹理＋高光反射纹理的组合不再适用，我们需要创建更细腻复杂的纹理集，包括金属值纹理、高光反射纹理、粗糙度纹理、遮挡纹理，有些还需要使用额外的细节纹理来给材质添加更多的细节表面。除了使用图片扫描的传统辅助方法外，这些纹理的制作通常还需要更专业的工具来绘制例如\r\nAllegorithmic Substance Painter Quixel Suite\r\n——Unity Shader 入门精要\r\n\r\n不过，即使是“基于物理的渲染”，其本质上仍然只是对基于物理原理的现实世界的一种近似(我们稍后就会法线，PBR\r\n流程中依然存在着很多妥协)，这也就是为什么它被称为基于物理的着色(Physically\r\nbased Shading) 而非物理着色(Physical Shading)的原因。\r\n判断一种光照模型是否是基于物理的，必须满足以下三个条件（不用担心，我们很快就会了解它们的）：\r\n\r\n基于微平面(Microfacet)的表面模型。\r\n能量守恒。\r\n应用基于物理的 BRDF。\r\n\r\n我们可以反过来说：PBR\r\n并不是某一种特指的算法，而是一类算法的统称。只要一种着色算法满足一定的物理规律（能量守恒等），我们就认为它属于\r\nPBR 算法，反之，则不属于 PBR 算法。\r\nPBR 理论\r\n微平面理论\r\n所有的 PBR\r\n技术都基于微平面理论。这项理论认为，达到微观尺度之后任何平面都可以用被称为微平面(Microfacets)的细小镜面来进行描绘。根据平面粗糙程度的不同，这些细小镜面的取向排列可以相当不一致：\r\n\r\n左图：光滑表面的微平面的法线变化较小，反射光线的方向变化也更小\r\n右图：粗糙表面的微平面的法线变化较大，反射光线的方向变化也更大\r\n这些微小镜面这样无序取向排列的影响就是：一个平面越是粗糙，这个平面上的微平面的排列就越混乱，法线变化也就越频繁且混乱，这样一来，当我们特指镜面光/镜面反射时，入射光线更趋向于向完全不同的方向发散(Scatter)开来，进而产生出分布范围更广泛的镜面反射，其结果也就越”钝“；相对的，对于一个光滑的平面，光线大体上会更趋向于向同一个方向反射，造成更小更锐利的反射。\r\n在这样的微观尺度下，我们认为没有任何平面是完全光滑的。然而由于这些微平面已经微小到无法逐像素地继续对其进行区分，因此我们假设一个粗糙度(Roughness)参数，然后用统计学的方法来估计微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出众多微平面中，朝向方向沿着某个向量\r\n\\(h\\) 方向的比例。这个向量 \\(h\\) 便是位于光线向量 \\(l\\) 和视线向量 \\(v\\) 之间的半程向量(Halfway Vector)。\r\n而微平面的朝向方向与半程向量的方向越是一致，镜面反射的效果就越是强烈越是锐利。通过使用一个介于\r\n0 到 1 之间的粗糙度参数，我们就能概略地估算微平面的取向情况了：\r\n\r\n\r\nimg\r\n\r\n我们可以看到，较高的粗糙度显示出来的镜面反射的轮廓要更大一些。与之相反，较小的粗糙度显示出的镜面反射轮廓则更小更锐利。\r\n能量守恒\r\n微平面近似法使用了这样一种形式的能量守恒(Energy\r\nConservation)：出射光线的能量永远不能超过入射光线的能量（发光面除外）\r\n如上图我们可以看到，随着粗糙度的上升，镜面反射区域会增加，但是镜面反射的亮度却会下降。如果每个像素的镜面反射强度都一样（不管反射轮廓的大小），那么粗糙的平面就会放射出过多的能量，而这样就违背了能量守恒定律。这也就是为什么正如我们看到的一样，光滑平面的镜面反射更强烈而粗糙平面的反射更昏暗。\r\n为了遵守能量守恒定律，我们需要对漫反射光和镜面反射光做出明确的区分。\r\n当一束光线碰撞到一个表面的时候，它就会分离成一个折射部分和一个反射部分：反射部分就是会直接反射开而不进入平面的那部分光线，也就是我们所说的镜面光照。而折射部分就是余下的会进入表面并被吸收的那部分光线，也就是我们所说的漫反射光照。\r\n这里还有一些细节需要处理，因为当光线接触到一个表面的时候折射光是不会立即就被吸收的。通过物理学我们可以得知，光线实际上可以被认为是一束没有耗尽就不停向前运动的能量，而光束是通过碰撞的方式来消耗能量。每一种材料都是由无数微小的粒子所组成，这些粒子都能如下图所示一样与光线发生碰撞。这些粒子在每次的碰撞中都可以吸收光线所携带的一部分或者是全部的能量而后转变成为热量。\r\n\r\n\r\nimg\r\n\r\n一般来说，并非全部能量都会被吸收，而光线也会继续沿着（基本上）随机的方向发散，然后再和其他的粒子碰撞直至能量完全耗尽或者再次离开这个表面。而光线脱离物体表面后将会协同构成该表面的（漫反射）颜色。不过在基于物理的渲染之中我们进行了简化，假设对平面上的每一点所有的折射光都会被完全吸收而不会散开。而有一些被称为\r\n次表面散射(Subsurface Scattering)\r\n技术的着色器技术将这个问题考虑了进去，它们显著地提升了一些诸如皮肤，大理石或者蜡质这样材质的视觉效果，不过伴随而来的代价是性能的下降。\r\n对于金属(Metallic)表面，当讨论到反射与折射的时候还有一个细节需要注意。金属表面对光的反应与非金属（也被称为介电质(Dielectrics)）表面相比是不同的。它们遵从的反射与折射原理是相同的，但是所有的折射光都会被直接吸收而不会散开，只留下反射光或者说镜面反射光。亦即是说，金属表面只会显示镜面反射颜色，而不会显示出漫反射颜色。由于金属与电介质之间存在这样明显的区别，因此它们两者在\r\nPBR\r\n渲染管线中被区别处理，而我们将在文章的后面进一步详细探讨这个问题。\r\n反射光与折射光之间的这个区别使我们得到了另一条关于能量守恒的经验结论：反射光与折射光它们二者之间是互斥的关系。无论何种光线，其被材质表面所反射的能量将无法再被材质吸收。因此，诸如折射光这样的余下的进入表面之中的能量正好就是我们计算完反射之后余下的能量。\r\n我们按照能量守恒的关系，首先计算镜面反射部分，它的值等于入射光线被反射的能量所占的百分比。然后折射光部分就可以直接由镜面反射部分计算得出：\r\n12float kS = calculateSpecularComponent(...); // 反射/镜面 部分float kD = 1.0 - ks;                        // 折射/漫反射 部分\r\n这样我们就能在遵守能量守恒定律的前提下知道入射光线的反射部分与折射部分所占的总量了。按照这种方法折射/漫反射与反射/镜面反射所占的份额都不会超过\r\n1.0，如此就能保证它们的能量总和永远不会超过入射光线的能量。而这些都是我们在前面的光照教程中没有考虑的问题。\r\n反射率方程\r\n在这里我们引入了一种被称为渲染方程(Render\r\nEquation)的东西。它是某些聪明绝顶的人所构想出来的一个精妙的方程式，是如今我们所拥有的用来模拟光的视觉效果最好的模型。基于物理的渲染所坚定遵循的是一种被称为反射率方程(The\r\nReflectance Equation)的渲染方程的特化版本。要正确地理解\r\nPBR，很重要的一点就是要首先透彻地理解反射率方程\r\n反射率方程简写：\r\n\\[\r\nL_0(p,w_0)=\\int_Ωf_r(p,w_i,w_0)Li(p,w_i)n \\cdot w_idw_i\r\n\\]\r\n如果补全绝大多数内容的话，我们能得到一个较为完整的式子：\r\n\\[\r\nL_0(p,w_0)=\\int_Ω(k_d*\\frac{c}{\\pi}+k_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i\r\n\\cdot n)}*Li(p,w_i)*n \\cdot w_i*dw_i\r\n\\]\r\n其中的构建思路\r\n\\[\r\n输出颜色=(漫反射比例\\frac{纹理颜色}{\\pi}+镜面反射比例*\\frac{镜面高光\\times几何遮蔽\\times菲涅尔效应}{4(viewDir\\cdot\r\nnormal)(lightDir\\cdot normal)光源颜色})(lightDir\\cdot normal)\r\n\\]\r\n我们可以逐步细分这个方程：\r\n关于能量\r\nBRDF\r\n\r\n\r\nimg\r\n\r\nCook-Torrance 反射率方程\r\nD：法线分布函数(Normal\r\nDistribution Function，NDF)\r\n\r\n法线分布函数 D，从统计学上近似地表示了与某些（半程）向量\r\nh 取向一致的微平面的比率。举例来说，假设给定向量 h，如果我们的微平面中有\r\n35%与向量 h 取向一致，则法线分布函数或者说 NDF 将会返回\r\n0.35。目前有很多种 NDF\r\n都可以从统计学上来估算微平面的总体取向度，只要给定一些粗糙度的参数。我们马上将要用到的是\r\nTrowbridge-Reitz GGX\r\n\r\n若用 h 表示用来与平面上微平面做比较用的半程向量，a\r\n表示表面粗糙度，则可以有 NDF 方程如下：\r\n\\[\r\nNDF_{GGXTR}(n, h, \\alpha) = \\frac{\\alpha^{2}}{\\pi((n\\cdot\r\nh)^{2}(\\alpha^{2}-1)+1)^2}\r\n\\]\r\n\r\n\r\nimg\r\n\r\n当粗糙度很低（也就是说表面很光滑）的时候，与半程向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF\r\n最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与\r\nhℎ\r\n向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。\r\n实现：\r\n12345678910111213float DistributionGGX(vec3 N, vec3 H, float roughness) &#123;    float a      = roughness * roughness; // 注意这里，a并非是纯粹的粗糙度    float a2     = a * a;    float NdotH  = max(dot(N, H), 0.0);    float NdotH2 = NdotH*NdotH;    float num   = a2;    float denom = (NdotH2 * (a2 - 1.0) + 1.0);    denom = PI * denom * denom;    return num / denom; //molecular&amp;denominator&#125;\r\n\r\n和理论相比，我们直接把粗糙度(roughness)作为参数传给了上述函数；通过这种方式，我们可以针对每一个不同的项对粗糙度做一些修改。*根据迪士尼公司给出的观察以及后来被\r\nEpic Games\r\n公司采用的光照模型，在几何遮蔽函数和法线分布函数中采用粗糙度的平方会让光照看起来更加自然。*\r\n\r\nG：几何分布函数\r\n\r\n几何函数从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量。\r\n这种遮蔽存在两种情况，分别是几何遮蔽(Geometry\r\nObstruction)和几何阴影(Geometry\r\nShadowing)，这两种遮蔽各分别由观察方向和光线方向引起。LearnOpenGL\r\n中图示如下；\r\n\r\n\r\nimg\r\n\r\n\r\n与 NDF\r\n类似，几何函数采用一个材料的粗糙度参数作为输入参数，粗糙度较高的表面其微平面间相互遮蔽的概率就越高。我们将要使用的几何函数是\r\nGGX 与 Schlick-Beckmann 近似的结合体，因此又称为 Schlick-GGX：\r\n\\[\r\nG_{SchlickGGX}(n, v, k) = \\frac{n \\cdot v}{(n \\cdot v)(1-k) + k}\r\n\\]\r\n这里的 k 是 α\r\n的重映射(Remapping)，取决于我们要用的是针对直接光照还是针对 IBL\r\n光照的几何函数。对于 k，有：\r\n\\[\r\nk_{direct} = \\frac{(\\alpha+1)^2}{8}\\\\\r\nk_{IBL} = \\frac{\\alpha^2}{2}\r\n\\]\r\n而同时，为了有效的估算几何部分，需要将观察方向（几何遮蔽）和光线方向向量（几何阴影）都考虑进去。我们可以使用史密斯法(Smith’s\r\nmethod)来把两者都纳入其中：\r\n\\[\r\nG(n, v, l, k) = G_{sub}(n, v, k)G_{sub}(n, l, k)\r\n\\]\r\n实现：\r\n123456789101112131415161718float GeometrySchlickGGX(float NdotV, float roughness) &#123;    float r = (roughness + 1.0);    float k = (r*r) / 8.0;    float num   = NdotV;    float denom = NdotV * (1.0 - k) + k;    return num / denom;&#125;float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) &#123;    float NdotV = max(dot(N, V), 0.0);    float NdotL = max(dot(N, L), 0.0);    float ggx2  = GeometrySchlickGGX(NdotV, roughness);    float ggx1  = GeometrySchlickGGX(NdotL, roughness);    return ggx1 * ggx2;&#125;\r\nF：菲涅尔方程\r\n\r\n菲涅尔（发音为\r\nFreh-nel）方程描述的是被反射的光线对比光线被折射的部分所占的比率，这个比率会随着我们观察的角度不同而不同。当光线碰撞到一个表面的时候，菲涅尔方程会根据观察角度告诉我们被反射的光线所占的百分比。利用这个反射比率和能量守恒原则，我们可以直接得出光线被折射的部分以及光线剩余的能量。\r\n\r\n菲涅尔效应产生的结果往往是，物体边缘大量光线被反射而泛白，因为在这些边缘上，法线往往能与视角接近\r\n90°；而在物体的中央会呈现自己本身的颜色，而对于透明物体来说就会露出其下层的物体。\r\n\r\n\r\nimg\r\n\r\n\r\n当垂直观察的时候，任何物体或者材质表面都有一个基础反射率(Base\r\nReflectivity)，但是如果以一定的角度往平面上看的时候所有反光都会变得明显起来。你可以自己尝试一下，用垂直的视角观察你自己的木制/金属桌面，此时一定只有最基本的反射性。但是如果你从近乎\r\n90\r\n度（译注：应该是指和法线的夹角）的角度观察的话反光就会变得明显的多。如果从理想的\r\n90\r\n度视角观察，所有的平面理论上来说都能完全的反射光线。这种现象因菲涅尔而闻名，并体现在了菲涅尔方程之中。\r\n\r\n落实到方程上，真实世界的菲涅尔等式一般比较复杂，我们在实时渲染中，往往采用一些近似等式，这里我们采用第一种，即\r\nSchlick 菲涅尔近似等式：\r\n\\[\r\nSchlick菲涅尔近似等式：F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0)(1 - (h\r\n\\cdot v))^5\\\\\\\\\r\nEmpricial菲涅尔近似等式：F_{Empricial}(v, n) = max(0, min(1, bias +\r\nscale \\times (1 - v \\cdot n)^{power}))\\\\\\\\...\r\n\\]\r\nFresnel-Schlick 近似法接收一个参数F0，被称为 0°\r\n入射角的反射率，或者说是直接(垂直)观察表面时有多少光线会被反射。\r\n这个参数F0会因为材料不同而不同，而且特别的，对金属材质需要特别处理：\r\n\r\nF0\r\n表示平面的基础反射率，它是利用所谓折射指数(Indices of\r\nRefraction)或者说 IOR\r\n计算得出的。然后正如你可以从球体表面看到的那样，我们越是朝球面掠角的方向上看（此时视线和表面法线的夹角接近\r\n90 度）菲涅尔现象就越明显，反光就越强\r\n问题就在于，Fresnel-Schlick\r\n近似仅仅对电介质或者说非金属表面有定义。对于导体(Conductor)表面（金属），使用它们的折射指数计算\r\nF0\r\n并不能得出正确的结果，这样我们就需要使用一种不同的菲涅尔方程来对导体表面进行计算。由于这样很不方便，所以我们预计算出平面对于法向入射的结果F0，然后基于相应观察角的\r\nFresnel-Schlick\r\n近似对这个值进行插值，用这种方法来进行进一步的估算。这样我们就能对金属和非金属材质使用同一个公式了。\r\n\r\n在 PBR\r\n金属流中我们简单地认为大多数的绝缘体在F0为\r\n0.04\r\n的时候看起来视觉上是正确的，对于金属表面我们根据反射率特别地指定F0，并对\r\nF0 进行插值。这在代码上看起来会像是这样：\r\n123456789vec3 F0 = vec3(0.04);F0      = mix(F0, albedo, metallic);vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0); // 对于金属表面，我们根据初始的 F0 和 金属性 及 反射率 进行线性插值。...vec3 fresnelSchlick(float cosTheta, vec3 F0) &#123;    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0); // 注意这里用的clamp是为了避免黑点&#125;\r\n可以看到，对于非金属表面F0始终为 0.04。\r\n\r\n平面对于法向入射的响应或者说基础反射率可以在一些大型数据库中找到，比如这个。下面列举的这一些常见数值就是从\r\nNaty Hoffman 的课程讲义中所得到的：\r\n\r\n\r\n\r\n材料\r\nF0�0 (线性)\r\nF0�0 (sRGB)\r\n颜色\r\n\r\n\r\n\r\n\r\n水\r\n(0.02, 0.02, 0.02)\r\n(0.15, 0.15, 0.15)\r\n\r\n\r\n\r\n塑料/玻璃（低）\r\n(0.03, 0.03, 0.03)\r\n(0.21, 0.21, 0.21)\r\n\r\n\r\n\r\n塑料（高）\r\n(0.05, 0.05, 0.05)\r\n(0.24, 0.24, 0.24)\r\n\r\n\r\n\r\n玻璃（高）/红宝石\r\n(0.08, 0.08, 0.08)\r\n(0.31, 0.31, 0.31)\r\n\r\n\r\n\r\n钻石\r\n(0.17, 0.17, 0.17)\r\n(0.45, 0.45, 0.45)\r\n\r\n\r\n\r\n铁\r\n(0.56, 0.57, 0.58)\r\n(0.77, 0.78, 0.78)\r\n\r\n\r\n\r\n铜\r\n(0.95, 0.64, 0.54)\r\n(0.98, 0.82, 0.76)\r\n\r\n\r\n\r\n金\r\n(1.00, 0.71, 0.29)\r\n(1.00, 0.86, 0.57)\r\n\r\n\r\n\r\n铝\r\n(0.91, 0.92, 0.92)\r\n(0.96, 0.96, 0.97)\r\n\r\n\r\n\r\n银\r\n(0.95, 0.93, 0.88)\r\n(0.98, 0.97, 0.95)\r\n\r\n\r\n\r\n\r\n这里可以观察到的一个有趣的现象，所有电介质材质表面的基础反射率都不会高于\r\n0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在\r\n0.5 和 1.0\r\n之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么\r\nF0 要用 RGB\r\n三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们只能在金属表面观察的到。\r\n这些金属表面相比于电介质表面所独有的特性引出了所谓的金属工作流的概念。也就是我们需要额外使用一个被称为金属度(Metalness)的参数来参与编写表面材质。金属度用来描述一个材质表面是金属还是非金属的。\r\n理论上来说，一个表面的金属度应该是二元的：要么是金属要么不是金属，不能两者皆是。但是，大多数的渲染管线都允许在\r\n0.0 至 1.0\r\n之间线性的调配金属度。这主要是由于材质纹理精度不足以描述一个拥有诸如细沙/沙状粒子/刮痕的金属表面。通过对这些小的类非金属粒子/刮痕调整金属度值，我们可以获得非常好看的视觉效果。\r\n\r\n另外值得一提的是，当我们采用了菲涅尔方程后，我们会获得一点特殊的便利——我们不再需要再在方程中采用额外的\r\nKs 了——F具有和方程中 Ks\r\n相似的性质。回想一下，F 是干什么的？\r\n\r\n菲涅尔（发音为\r\nFreh-nel）方程描述的是被反射的光线对比光线被折射的部分所占的比率\r\n\r\n而 Ks 和 Kd 是干什么的？\r\n\r\nKd 是入射光线中被折射部分的能量所占的比率，而 Ks\r\n是被反射部分的比率。\r\n\r\n也就是说，F 已经包含了类似 Ks 的性质，所以我们可以直接将\r\nF 用以代替 Ks 的存在，最终我们实际的运算式子如下：\r\n编写 PBR 材质\r\n在了解了 PBR\r\n后面的数学模型之后，最后我们将通过说明美术师一般是如何编写一个我们可以直接输入\r\nPBR 的平面物理属性的来结束这部分的讨论。PBR\r\n渲染管线所需要的每一个表面参数都可以用纹理来定义或者建模。使用纹理可以让我们逐个片段的来控制每个表面上特定的点对于光线是如何响应的：不论那个点是不是金属，粗糙或者平滑，也不论表面对于不同波长的光会有如何的反应。\r\n在下面你可以看到在一个 PBR\r\n渲染管线当中经常会碰到的纹理列表，还有将它们输入 PBR\r\n渲染器所能得到的相应的视觉输出：\r\n\r\n\r\nimg\r\n\r\n反照率：反照率(Albedo)纹理为每一个金属的纹素(Texel)（纹理像素）指定表面颜色或者基础反射率。这和我们之前使用过的漫反射纹理相当类似，不同的是所有光照信息都是由一个纹理中提取的。漫反射纹理的图像当中常常包含一些细小的阴影或者深色的裂纹，而反照率纹理中是不会有这些东西的。它应该只包含表面的颜色（或者折射吸收系数）。\r\n法线：法线贴图纹理和我们之前在法线贴图教程中所使用的贴图是完全一样的。法线贴图使我们可以逐片段的指定独特的法线，来为表面制造出起伏不平的假象。\r\n金属度：金属(Metallic)贴图逐个纹素的指定该纹素是不是金属质地的。根据\r\nPBR 引擎设置的不同，美术师们既可以将金属度编写为灰度值又可以编写为 1 或\r\n0 这样的二元值。\r\n粗糙度：粗糙度(Roughness)贴图可以以纹素为单位指定某个表面有多粗糙。采样得来的粗糙度数值会影响一个表面的微平面统计学上的取向度。一个比较粗糙的表面会得到更宽阔更模糊的镜面反射（高光），而一个比较光滑的表面则会得到集中而清晰的镜面反射。某些\r\nPBR\r\n引擎预设采用的是对某些美术师来说更加直观的光滑度(Smoothness)贴图而非粗糙度贴图，不过这些数值在采样之时就马上用（1.0\r\n– 光滑度）转换成了粗糙度。\r\nAO：环境光遮蔽(Ambient Occlusion)贴图或者说 AO\r\n贴图为表面和周围潜在的几何图形指定了一个额外的阴影因子。比如如果我们有一个砖块表面，反照率纹理上的砖块裂缝部分应该没有任何阴影信息。然而\r\nAO\r\n贴图则会把那些光线较难逃逸出来的暗色边缘指定出来。在光照的结尾阶段引入环境遮蔽可以明显的提升你场景的视觉效果。网格/表面的环境遮蔽贴图要么通过手动生成，要么由\r\n3D 建模软件自动生成。\r\n美术师们可以在纹素级别设置或调整这些基于物理的输入值，还可以以现实世界材料的表面物理性质来建立他们的材质数据。这是\r\nPBR\r\n渲染管·线最大的优势之一，因为不论环境或者光照的设置如何改变这些表面的性质是不会改变的，这使得美术师们可以更便捷地获取物理可信的结果。在\r\nPBR 渲染管线中编写的表面可以非常方便的在不同的 PBR\r\n渲染引擎间共享使用，不论处于何种环境中它们看上去都会是正确的，因此看上去也会更自然。\r\n结合 IBL\r\n\r\nIBL，即 Image based\r\nlighting，可直译为基于图像的光照，它是一类光照技术的集合。其光源不是可分解的直接光源，而是将周围环境整体视为一个大光源。IBL\r\n通常使用（取自现实世界或从 3D 场景生成的）环境立方体贴图 (Cubemap)\r\n，我们可以将立方体贴图的每个像素视为光源，在渲染方程中直接使用它。这种方式可以有效地捕捉环境的全局光照和氛围，使物体更好地融入其环境。\r\n由于基于图像的光照算法会捕捉部分甚至全部的环境光照，通常认为它是一种更精确的环境光照输入格式，甚至也可以说是一种全局光照的粗略近似。基于此特性，IBL\r\n对 PBR\r\n很有意义，因为当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。\r\n\r\n在 IBL\r\n下，有一件事情是很麻烦的：我们无法规避反射率方程中的积分了——直接光源下，积分是可以规避的——因为我们事先已经知道了对积分有贡献的、若干精确的光线方向\r\nwi，然而这次，来自周围环境的每个方向\r\nwi\r\n的入射光都可能具有一些辐射度，使得解决积分变得不那么简单。这为解决积分提出了两个要求：\r\n\r\n对于给定的任何方向向量\r\nwi，我们都能获取这个方向上场景的辐射度。\r\n解决积分需要快速且实时。\r\n\r\n现在看，第一个要求相对容易些。我们已经有了一些思路：表示环境或场景辐照度的一种方式是（预处理过的）环境立方体贴图，给定这样的立方体贴图，我们可以将立方体贴图的每个纹素视为一个光源。使用一个方向向量\r\nwi\r\n对此立方体贴图进行采样，我们就可以获取该方向上的场景辐照度。如此，给定方向向量\r\nwi ，获取此方向上场景辐射度的方法就简化为：\r\n1vec3 radiance =  texture(_cubemapEnvironment, w_i).rgb;\r\n为了以更有效的方式解决积分，我们需要对其大部分结果进行预处理——或称预计算。为此，我们必须深入研究反射方程。原来的反射方程有：\r\n\\[\r\nL_0(p,w_0)=\\int_Ω(k_d*\\frac{c}{\\pi}+k_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i\r\n\\cdot n)}*Li(p,w_i)*n \\cdot w_i*dw_i\r\n\\]\r\n我们可以发现，式子中的漫反射项是与积分无关的——这部分是可以拆开的\r\n\\[\r\nL_0(p,w_0)=\\int_Ω(k_d*\\frac{c}{\\pi}+k_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i\r\n\\cdot n)}*Li(p,w_i)*n \\cdot w_i*dw_i\\\\\r\n=\\int_Ωk_d*\\frac{c}{\\pi}*Li(p,w_i)*n \\cdot w*dw_i +\r\n\\int_Ωk_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i \\cdot n)}*L_i(p,w_i)*n \\cdot\r\nw_i*dw_i\r\n\\]\r\n这样，我们就可以分别考虑两部分的预计算方法\r\n先看漫反射项：\r\n预计算漫反射项\r\n对方程的一些小改变\r\n让我们先对分离出的原始方程做一些变化：\r\n\\[\r\nL_0(p,w_0)=\\int_Ωk_d*\\frac{c}{\\pi}*Li(p,w_i)*n \\cdot w*dw_i\\\\\r\n=k_d\\frac{c}{\\pi}\\int_ΩLi(p,w_i)*n \\cdot w*dw_i\\\\\r\n\\]\r\n不难发现，我们所做的内容也就是将常数项提到了积分外部（颜色 c、折射率\r\nkd 和 π\r\n在整个漫反射积分函数中，是常数），这样我们就获得了一个只依赖于\r\nwi 的积分（假设 p\r\n位于环境贴图的中心），这样我们就可以通过卷积，预计算一个新的立方体贴图，它在每个采样方向——也就是纹素——中存储漫反射积分的结果。\r\n\r\n\r\n\r\n预计算思路\r\n目前，我们的主要目标是计算所有间接漫反射光的积分，其中光照的辐照度以环境立方体贴图的形式给出。我们已经知道，在方向\r\nwi 上采样 HDR 环境贴图，可以获得场景在此方向上的辐射度\r\nL(p,wi)\r\n。虽然如此，要解决积分，我们仍然不能仅从一个方向对环境贴图采样——要从半球\r\nΩ\r\n上所有可能的方向进行采样，这不仅对于片段着色器过于昂贵，并且计算上又不可能从\r\nΩ\r\n的每个可能的方向采样环境光照——理论上可能的方向数量是无限的。后者的解决办法相对容易——我们去对有限数量的方向采样以近似求解，并在半球内以均匀间隔或随机取方向等的方式，可以获得一个相当精确的辐照度近似值，从而离散地计算积分。不过，对于每个片段实时执行此操作仍然太昂贵，因为仍然需要非常大的样本数量才能获得不错的结果，因此我们希望可以预计算。\r\n既然明确了需要预计算，那么我们额外需要思考的就是怎么去做预计算。\r\n我们知道的是，我们的计算总是处于一个半球空间中的——即全部从正面来的光——既然半球的朝向决定了我们捕捉辐照度的位置，我们可以预先计算每个可能的半球朝向的辐照度，把结果保存另一个\r\nCubeMap 中，这样我们就几乎达到了我们的目的。\r\n\r\n下面是一个环境立方体贴图及其生成的辐照度图的示例：\r\n\r\n\r\nimg\r\n\r\n\r\n我们可以以这样的手段去描述我们的半球面：\r\n我们用球坐标 θ 和 ϕ 来代替反射方程的积分 ∫\r\n中的立体角，由于积分是围绕立体角 dw 旋转进行的，那我们用以代替 dw\r\n的球坐标也该定义出相同的性质：我们规定对于围绕半球大圆的航向角 ϕ\r\n，我们在 0 到 2π 内采样，而从半球顶点出发的倾斜角 θ ，采样范围是 0 到\r\nπ/2 。于是我们更新一下反射积分方程：\r\n\\[\r\nL_0(p, \\phi_0,\r\n\\theta_0)=k_d\\frac{c}{\\pi}\\int_{\\phi=0}^{2\\pi}\\int_{\\theta=0}^{\\frac{1}{2}\\pi}L_i(p,\r\n\\phi_i, \\theta_i)\\cos(\\theta)\\sin(\\theta)d\\phi d\\theta\r\n\\]\r\n求解积分需要我们在半球 Ω\r\n内采集固定数量的离散样本并对其结果求平均值。分别给每个球坐标轴指定离散样本数量\r\nn1 和 n2 以求其黎曼和，积分式会转换为以下离散版本：\r\n\\[\r\nLo(p,ϕ_0,θ_0)=k_d\\frac{c}{π}\\frac{1}{n_1n_2}\\sum_{\\phi=0}^{n_1}\\sum_{\\theta=0}^{n_2}Li(p,ϕ_i,θ_i)cos(θ)sin(θ)dϕdθ\r\n\\]\r\n预计算镜面反射\r\n相较于漫反射项，我们的镜面反射显然是一个更加复杂的部分，让我们先做分析：\r\n\\[\r\nL_0(p,w_0)=\\int_Ωk_s*\\frac{DGF}{4*(w_0 \\cdot n)(w_i \\cdot\r\nn)}*L_i(p,w_i)*n \\cdot w_i*dw_i\r\n\\]\r\n我们可以发现，相较于仅有 wi\r\n一个变量的漫反射，我们的镜面反射部分同时存在 wi 与\r\nw0\r\n两个变量——我们无法用两个方向向量采样预计算的立方体图。要想预计算这部分内容，我们得做更多的处理——这里采用的是\r\nEpic Games 的解决方案：分割求和近似法（split sum approximation）。\r\n分割求和近似将方程的镜面部分分割成两个独立的部分，我们可以单独求卷积，然后在\r\nPBR 着色器中求和，以用于间接镜面反射部分\r\nIBL。分割求和近似法类似于我们之前求辐照图预卷积的方法，需要 HDR\r\n环境贴图作为其卷积输入。在该办法中，我们的公式会变为：\r\n\\[\r\nL_0(p,w_0)=\\int_\\Omega L_i(p, w_i)dw_i * \\int_\\Omega f_r()\r\n\\]\r\n让我们分别考虑这两部分\r\n预滤波环境贴图\r\n预滤波环境贴图的方法与我们对辐射度贴图求卷积的方法非常相似。只是对于卷积的每个粗糙度级别，我们会按顺序把模糊后的结果存储在预滤波贴图的\r\nmipmap 中。\r\nGGX 重要性采样\r\n有别于均匀或纯随机地（比如蒙特卡洛）在积分半球 Ω\r\n产生采样向量，我们的采样会根据粗糙度，偏向微表面的半向量的宏观反射方向。采样过程将与我们之前看到的过程相似：开始一个大循环，生成一个随机（低差异）序列值，用该序列值在切线空间中生成样本向量，将样本向量变换到世界空间并对场景的辐射度采样。不同之处在于，我们现在使用低差异序列值作为输入来生成采样向量：\r\n12345const uint SAMPLE_COUNT = 4096u;for(uint i = 0u; i &lt; SAMPLE_COUNT; ++i)&#123;    vec2 Xi = Hammersley(i, SAMPLE_COUNT);&#125;\r\n此外，要构建采样向量，我们需要一些方法定向和偏移采样向量，以使其朝向特定粗糙度的镜面波瓣方向。我们可以如理论教程中所述使用\r\nNDF，并将 GGX NDF 结合到 Epic Games 所述的球形采样向量的处理中：\r\n12345678910111213141516171819202122vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)&#123;    float a = roughness*roughness;    float phi = 2.0 * PI * Xi.x;    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);    // from spherical coordinates to cartesian coordinates    vec3 H;    H.x = cos(phi) * sinTheta;    H.y = sin(phi) * sinTheta;    H.z = cosTheta;    // from tangent-space vector to world-space sample vector    vec3 up        = abs(N.z) &lt; 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);    vec3 tangent   = normalize(cross(up, N));    vec3 bitangent = cross(N, tangent);    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;    return normalize(sampleVec);&#125;\r\n基于特定的粗糙度输入和低差异序列值\r\nXi，我们获得了一个采样向量，该向量大体围绕着预估的微表面的半向量。注意，根据迪士尼对\r\nPBR 的研究，Epic Games 使用了平方粗糙度以获得更好的视觉效果。\r\n使用低差异 Hammersley\r\n序列和上述定义的样本生成方法，我们可以最终完成预滤波器卷积着色器：\r\n123456789101112131415161718192021222324252627282930313233343536373839#version 330 coreout vec4 FragColor;in vec3 localPos;uniform samplerCube environmentMap;uniform float roughness;const float PI = 3.14159265359;float RadicalInverse_VdC(uint bits);vec2 Hammersley(uint i, uint N);vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);void main()&#123;    vec3 N = normalize(localPos);    vec3 R = N;    vec3 V = R;    const uint SAMPLE_COUNT = 1024u;    float totalWeight = 0.0;    vec3 prefilteredColor = vec3(0.0);    for(uint i = 0u; i &lt; SAMPLE_COUNT; ++i)    &#123;        vec2 Xi = Hammersley(i, SAMPLE_COUNT);        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);        vec3 L  = normalize(2.0 * dot(V, H) * H - V);        float NdotL = max(dot(N, L), 0.0);        if(NdotL &gt; 0.0)        &#123;            prefilteredColor += texture(environmentMap, L).rgb * NdotL;            totalWeight      += NdotL;        &#125;    &#125;    prefilteredColor = prefilteredColor / totalWeight;    FragColor = vec4(prefilteredColor, 1.0);&#125;\r\n输入的粗糙度随着预过滤的立方体贴图的 mipmap 级别变化（从 0.0 到\r\n1.0），我们根据据粗糙度预过滤环境贴图，把结果存在 prefilteredColor\r\n里。再用 prefilteredColor\r\n除以采样权重总和，其中对最终结果影响较小（NdotL\r\n较小）的采样最终权重也较小。\r\n捕获预过滤 mipmap 级别\r\n剩下要做的就是让 OpenGL 在多个 mipmap\r\n级别上以不同的粗糙度值预过滤环境贴图。有了最开始的辐照度教程作为基础，实际上很简单：\r\n123456789101112131415161718192021222324252627282930prefilterShader.use();prefilterShader.setInt(&quot;environmentMap&quot;, 0);prefilterShader.setMat4(&quot;projection&quot;, captureProjection);glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_CUBE_MAP, envCubemap);glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);unsigned int maxMipLevels = 5;for (unsigned int mip = 0; mip &lt; maxMipLevels; ++mip)&#123;    // reisze framebuffer according to mip-level size.    unsigned int mipWidth  = 128 * std::pow(0.5, mip);    unsigned int mipHeight = 128 * std::pow(0.5, mip);    glBindRenderbuffer(GL_RENDERBUFFER, captureRBO);    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, mipWidth, mipHeight);    glViewport(0, 0, mipWidth, mipHeight);    float roughness = (float)mip / (float)(maxMipLevels - 1);    prefilterShader.setFloat(&quot;roughness&quot;, roughness);    for (unsigned int i = 0; i &lt; 6; ++i)    &#123;        prefilterShader.setMat4(&quot;view&quot;, captureViews[i]);        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,                               GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, prefilterMap, mip);        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        renderCube();    &#125;&#125;glBindFramebuffer(GL_FRAMEBUFFER, 0);\r\n这个过程类似于辐照度贴图卷积，但是这次我们将帧缓冲区缩放到适当的\r\nmipmap 尺寸， mip 级别每增加一级，尺寸缩小为一半。此外，我们在\r\nglFramebufferTexture2D 的最后一个参数中指定要渲染的目标 mip\r\n级别，然后将要预过滤的粗糙度传给预过滤着色器。\r\n这样我们会得到一张经过适当预过滤的环境贴图，访问该贴图时指定的 mip\r\n等级越高，获得的反射就越模糊。如果我们在天空盒着色器中显示这张预过滤的环境立方体贴图，并在其着色器中强制在其第一个\r\nmip 级别以上采样，如下所示：\r\n1vec3 envColor = textureLod(environmentMap, WorldPos, 1.2).rgb;\r\n我们得到的结果看起来确实像原始环境的模糊版本：\r\n\r\n\r\nimg\r\n\r\n如果 HDR 环境贴图的预过滤看起来差不多没问题，尝试一下不同的 mipmap\r\n级别，观察预过滤贴图随着 mip 级别增加，反射逐渐从锐利变模糊的过程。\r\n预过滤卷积的伪像\r\n当前的预过滤贴图可以在大多数情况下正常工作，不过你迟早会遇到几个与预过滤卷积直接相关的渲染问题。我将在这里列出最常见的一些问题，以及如何修复它们。\r\n高粗糙度的立方体贴图接缝\r\n在具有粗糙表面的表面上对预过滤贴图采样，也就等同于在较低的 mip\r\n级别上对预过滤贴图采样。在对立方体贴图进行采样时，默认情况下，OpenGL\r\n不会在立方体面之间进行线性插值。由于较低的 mip\r\n级别具有更低的分辨率，并且预过滤贴图代表了与更大的采样波瓣卷积，因此缺乏立方体的面和面之间的滤波的问题就更明显：\r\n\r\n\r\nimg\r\n\r\n幸运的是，OpenGL 可以启用\r\nGL_TEXTURE_CUBE_MAP_SEAMLESS，以为我们提供在立方体贴图的面之间进行正确过滤的选项：\r\n1glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);\r\n预过滤卷积的亮点\r\n由于镜面反射中光强度的变化大，高频细节多，所以对镜面反射进行卷积需要大量采样，才能正确反映\r\nHDR\r\n环境反射的混乱变化。我们已经进行了大量的采样，但是在某些环境下，在某些较粗糙的\r\nmip 级别上可能仍然不够，导致明亮区域周围出现点状图案：\r\n\r\n\r\nimg\r\n\r\n一种解决方案是进一步增加样本数量，但在某些情况下还是不够。另一种方案如\r\nChetan\r\nJags\r\n所述，我们可以在预过滤卷积时，不直接采样环境贴图，而是基于积分的 PDF\r\n和粗糙度采样环境贴图的 mipmap ，以减少伪像：\r\n12345678float D   = DistributionGGX(NdotH, roughness);float pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001;float resolution = 512.0; // resolution of source cubemap (per face)float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel);\r\n既然要采样 mipmap ，不要忘记在环境贴图上开启三线性过滤：\r\n12glBindTexture(GL_TEXTURE_CUBE_MAP, envCubemap);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\r\n设置立方体贴图的基本纹理后，让 OpenGL 生成 mipmap：\r\n12345// convert HDR equirectangular environment map to cubemap equivalent[...]// then generate mipmapsglBindTexture(GL_TEXTURE_CUBE_MAP, envCubemap);glGenerateMipmap(GL_TEXTURE_CUBE_MAP);\r\n这个方法效果非常好，可以去除预过滤贴图中较粗糙表面上的大多数甚至全部亮点。\r\n蒙特卡洛积分\r\n\r\n为了充分理解重要性采样，我们首先要了解一种数学结构，称为蒙特卡洛积分。蒙特卡洛积分主要是统计和概率理论的组合。其作用很大，比如：蒙特卡洛可以帮助我们离散地解决人口统计问题，而不必考虑所有人。\r\n具体来讲，假设我们得计算一个国家所有公民的平均身高。为了得到结果，我们可以测量每个公民并对他们的身高求平均，这样会得到你需要的确切答案。但是，由于大多数国家人海茫茫，这个方法不现实：需要花费太多精力和时间。\r\n另一种方法是选择一个小得多的完全随机（无偏）的人口子集，测量他们的身高并对结果求平均。可能只测量\r\n100\r\n人，虽然答案并非绝对精确，但会得到一个相对接近真相的答案，这个理论被称作大数定律。我们的想法是，如果从总人口中测量一组较小的真正随机样本的\r\nN，结果将相对接近真实答案，并随着样本数 N 的增加而愈加接近。\r\n蒙特卡罗积分建立在大数定律的基础上，并采用相同的方法来求解积分。不为所有可能的（理论上是无限的）样本值\r\nx 求解积分，而是简单地从总体中随机挑选样本 N\r\n生成采样值并求平均。随着 N\r\n的增加，我们的结果会越来越接近积分的精确结果：\r\n\\[\r\nO=\\int_{a}^{b}f(x)dx=\\frac{1}{N}\\sum_{i=0}^{N-1}\\frac{f(x)}{pdf(x)}\r\n\\]\r\n为了求解这个积分，我们在 \\(a\\) 到\r\n\\(b\\) 上采样 \\(N\\)\r\n个随机样本，将它们加在一起并除以样本总数来取平均。\\(pdf\\) 代表概率密度函数 (probability density\r\nfunction)，它的含义是特定样本在整个样本集上发生的概率。例如，人口身高的\r\n\\(pdf\\) 看起来应该像这样：\r\n\r\n\r\nimg\r\n\r\n从该图中我们可以看出，如果我们对人口任意随机采样，那么挑选身高为 1.70\r\n的人口样本的可能性更高，而样本身高为 1.50 的概率较低。\r\n当涉及蒙特卡洛积分时，某些样本可能比其他样本具有更高的生成概率。这就是为什么对于任何一般的蒙特卡洛估计，我们都会根据\r\npdf\r\n将采样值作除以或乘以采样概率。到目前为止，我们每次需要估算积分的时候，生成的样本都是均匀分布的，概率完全相等。到目前为止，我们的估计是无偏的，这意味着随着样本数量的不断增加，我们最终将收敛到积分的精确解。\r\n但是，某些蒙特卡洛估算是有偏的，这意味着生成的样本并不是完全随机的，而是集中于特定的值或方向。这些有偏的蒙特卡洛估算具有更快的收敛速度，它们会以更快的速度向精确解收敛，但是由于其有偏性，可能永远不会收敛到精确解。通常来说，这是一个可以接受的折衷方案，尤其是在计算机图形学中。因为只要结果在视觉上可以接受，解决方案的精确性就不太重要。\r\n下文我们将会提到一种（有偏的）重要性采样，其生成的样本偏向特定的方向，在这种情况下，我们会将每个样本乘以或除以相应的\r\npdf 再求和。\r\n蒙特卡洛积分在计算机图形学中非常普遍，因为它是一种以高效的离散方式对连续的积分求近似而且非常直观的方法：对任何面积/体积进行采样——例如半球\r\nΩ ——在该面积/体积内生成数量 N\r\n的随机采样，权衡每个样本对最终结果的贡献并求和。\r\n蒙特卡洛积分是一个庞大的数学主题，在此不再赘述，但有一点需要提到：生成随机样本的方法也多种多样。默认情况下，每次采样都是我们熟悉的完全（伪）随机，不过利用半随机序列的某些属性，我们可以生成虽然是随机样本但具有一些有趣性质的样本向量。例如，我们可以对一种名为低差异序列的东西进行蒙特卡洛积分，该序列生成的仍然是随机样本，但样本分布更均匀：\r\n\r\n\r\nimg\r\n\r\n当使用低差异序列生成蒙特卡洛样本向量时，该过程称为拟蒙特卡洛积分。拟蒙特卡洛方法具有更快的收敛速度，这使得它对于性能繁重的应用很有用。\r\n鉴于我们新获得的有关蒙特卡洛（Monte Carlo）和拟蒙特卡洛（Quasi-Monte\r\nCarlo）积分的知识，我们可以使用一个有趣的属性来获得更快的收敛速度，这就是重要性采样。我们在前文已经提到过它，但是在镜面反射的情况下，反射的光向量被限制在镜面波瓣中，波瓣的大小取决于表面的粗糙度。既然镜面波瓣外的任何（拟）随机生成的样本与镜面积分无关，因此将样本集中在镜面波瓣内生成是有意义的，但代价是蒙特卡洛估算会产生偏差。\r\n本质上来说，这就是重要性采样的核心：只在某些区域生成采样向量，该区域围绕微表面半向量，受粗糙度限制。通过将拟蒙特卡洛采样与低差异序列相结合，并使用重要性采样偏置样本向量的方法，我们可以获得很高的收敛速度。因为我们求解的速度更快，所以要达到足够的近似度，我们所需要的样本更少。因此，这套组合方法甚至可以允许图形应用程序实时求解镜面积分，虽然比预计算结果还是要慢得多。\r\n\r\n重要性采样\r\n低差异序列\r\n在本教程中，我们将使用重要性采样来预计算间接反射方程的镜面反射部分，该采样基于拟蒙特卡洛方法给出了随机的低差异序列。我们将使用的序列被称为\r\nHammersley 序列，Holger\r\nDammertz 曾仔细描述过它。Hammersley 序列是基于 Van Der Corput\r\n序列，该序列是把十进制数字的二进制表示镜像翻转到小数点右边而得。（译注：原文为\r\nVan Der Corpus 疑似笔误，下文各处同）\r\n给出一些巧妙的技巧，我们可以在着色器程序中非常有效地生成 Van Der\r\nCorput 序列，我们将用它来获得 Hammersley 序列，设总样本数为\r\nN，样本索引为 i：\r\n1234567891011121314float RadicalInverse_VdC(uint bits)&#123;    bits = (bits &lt;&lt; 16u) | (bits &gt;&gt; 16u);    bits = ((bits &amp; 0x55555555u) &lt;&lt; 1u) | ((bits &amp; 0xAAAAAAAAu) &gt;&gt; 1u);    bits = ((bits &amp; 0x33333333u) &lt;&lt; 2u) | ((bits &amp; 0xCCCCCCCCu) &gt;&gt; 2u);    bits = ((bits &amp; 0x0F0F0F0Fu) &lt;&lt; 4u) | ((bits &amp; 0xF0F0F0F0u) &gt;&gt; 4u);    bits = ((bits &amp; 0x00FF00FFu) &lt;&lt; 8u) | ((bits &amp; 0xFF00FF00u) &gt;&gt; 8u);    return float(bits) * 2.3283064365386963e-10; // / 0x100000000&#125;// ----------------------------------------------------------------------------vec2 Hammersley(uint i, uint N)&#123;    return vec2(float(i)/float(N), RadicalInverse_VdC(i));&#125;\r\nGLSL 的 Hammersley 函数可以获取大小为 N 的样本集中的低差异样本\r\ni。\r\n无需位运算的 Hammersley 序列\r\n并非所有 OpenGL 相关驱动程序都支持位运算符（例如 WebGL 和 OpenGL ES\r\n2.0），在这种情况下，你可能需要不依赖位运算符的替代版本 Van Der Corput\r\n序列：\r\n123456789101112131415161718192021222324float VanDerCorpus(uint n, uint base)&#123;    float invBase = 1.0 / float(base);    float denom   = 1.0;    float result  = 0.0;    for(uint i = 0u; i &lt; 32u; ++i)    &#123;        if(n &gt; 0u)        &#123;            denom   = mod(float(n), 2.0);            result += denom * invBase;            invBase = invBase / 2.0;            n       = uint(float(n) / 2.0);        &#125;    &#125;    return result;&#125;// ----------------------------------------------------------------------------vec2 HammersleyNoBitOps(uint i, uint N)&#123;    return vec2(float(i)/float(N), VanDerCorpus(i, 2u));&#125;\r\n请注意，由于旧硬件中的 GLSL 循环限制，该序列循环遍历了所有可能的 32\r\n位，性能略差。但是如果你没有位运算符可用的话可以考虑它，它可以在所有硬件上运行。\r\n一个完整的 PBR 构建\r\n编写 PBR Shader -\r\n渲染方程的实现\r\n实现内容的具体简化\r\n实现流程\r\n最后——关于当前的 PBR 模型\r\nReferences\r\n\r\n重新理解 PBR（1） -\r\n知乎 (zhihu.com)\r\n理论 -\r\nLearnOpenGL CN (learnopengl-cn.github.io)\r\n\r\n\r\n","slug":"Rendering/PBR","date":"2023-05-01T04:23:23.000Z","categories_index":"Unity,Shader","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"e381c275e6062a6db30ed6f89e560299","title":"Mapcap","content":"What is Mapcap?\r\n\r\n\r\nMatCap is a method of light expression using pre-rendered images.\r\nThis technique uses a picture of a sphere that represents the material\r\nand light to simulate lighting.\r\nMaterial\r\nCapture(MatCap) Settings | Unity Toon Shader | 0.9.4-preview\r\n(unity3d.com)\r\n\r\n\r\nMaterial capture (\"MatCap\") shaders are popular effects used\r\nin most 3D modeling tools: A material is captured by rendering a sphere\r\ninto a texture. Models can be shaded by making a simple lookup into the\r\nreference texture. This type of shading is very efficient – no\r\ncomplicated computations, only a single texture lookup per pixel. The\r\neffect works great for previewing objects in a 3D modeling tool.\r\nHowever, it is less suited for games: The reference texture only\r\nstores one side of a sphere. The effect breaks down, when the camera\r\nmoves around the object.\r\nMaterial\r\nCapture (MatCap) Shaders (digitalrune.github.io)\r\n\r\n【Unity Shader\r\n实践】基于 MatCap 实现适于移动平台的“次时代”车漆 Shader - 知乎\r\n(zhihu.com)\r\n\r\n应用\r\n真实感渲染\r\n简单来说，我们会用 matcap\r\n贴图来存储很多预制好的光照、色彩等具体效果，这样我们用一张贴图就可以快速得到我们所希望的材质效果。\r\n对于正常的真实感渲染上，matcap\r\n的用法具有较大的局限性——因为真实感渲染下我们往往要求计算过程遵守物理规则，因此一般仅用\r\nmatcap 来节约性能开销：我们可以为场景中的不重要的景物、物件等使用\r\nmatcap，这样能保证它们具有足够质感的同时，尽可能的节约硬件资源。\r\n这一点好像又和 LOD\r\n等东西也可以结合起来看待，有一种处理方法就是，当离人物距离太远时，比如远方的树木，不再执行完整的渲染，而一种永远正对角色的面片，而这种改用这种\r\nmatcap 来实现，或者改用别的节省资源的办法等。\r\n其一般用法可以参看：(美学阿姨)MatCap\r\n材质原理讲解与 UE5 中的实现方法_哔哩哔哩_bilibili\r\n但是，当到了 NPR 领域，就完全不是这么一回事了。\r\nNPR 下的 Matcap\r\n先从 mmd 中说起：\r\nmmd\r\n中一般会有三类贴图，包括：SPA\\SPH、TEX、TOON。后两者很好理解，关键是\r\nSPA\\SPH 贴图。\r\n就简单来说，我们可以参考这个：\r\n\r\nSpa 及 Sph\r\n的高光貼圖介紹 (nagongze.me)\r\n[MMD]\r\nWhy model should use Matcap. by MMDLOID on DeviantArt\r\n\r\n发现了吗，其实 SPA\\SPH\r\n所产生的效果很相似，都是将提前存储好的内容映射到模型上。就细分而言，SPA\\SPH\r\n是基于球体映射的贴图技术，它将 2D 图像映射到 3D\r\n模型的球体表面，用于模拟光照效果。我们用它来为模型表面创建天使环等效果。而\r\nMatcap 贴图则用于模拟模型表面的材质和光照效果。这么看来 SPA\\SPH\r\n好像可以直接归到 Matcap 的一个子类里。\r\n也就是说，我们可以在 NPR 中使用 matcap 来实现很多特殊的内容，比如\r\nAngle Ring 等\r\n实际使用：Matcap 采样 uv\r\n的构造\r\n经典 Matcap 采样\r\n改进 1：\r\nMatCap Shader\r\n改进：解决平面渲染和环境反射问题 - 知乎 (zhihu.com)\r\n补充：法线变换\r\n补一个将模型法线转换到视角空间\r\n\r\n数学推导：\r\n结论：Transformation\r\nof normals into eye space. - OpenGL / OpenGL: Advanced Coding - Khronos\r\nForums\r\n\r\n实际使用案例\r\n\r\nblender\r\n中使用 mmd 中 spa 贴图的节点分享_哔哩哔哩_bilibili\r\n\r\n","slug":"Rendering/Mapcap","date":"2023-04-29T04:23:23.000Z","categories_index":"Unity,Shader","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"a21e0605e124236f924885120b82421a","title":"Custom Right-Click Menu And Shader GUI排列","content":"Custom Right-Click Menu\r\nAnd Shader GUI\r\n\r\nAll the operations in this project should be done in a folder named\r\n\"Editor\", no matter where this folder is though.\r\n\r\nWhat do we want to do?\r\nwe want to set up a custom file template in the right-click menu, so\r\nwe can quickly create the files that we need.\r\nTo archive this, we need to:\r\n\r\nSet up the file template\r\nCreate C# Scripts which could be embedded into the editor to archive\r\nthe file creating logic\r\n\r\nIn this project, I will take the \"URP Unlit Shader\" as an example.\r\nAnd we will learn how to custom the shader ui later, too.\r\nSet up a template for shader\r\nI will put a simple example to explain:\r\n123456789101112131415161718192021222324Shader &quot;Custom URP Shader/#NAME#&quot; &#123;    Properties &#123;&#125;    SubShader &#123;        Tags &#123;&quot;RenderType&quot; = &quot;Opaque&quot; &quot;RenderPipeline&quot; = &quot;UniversalPipeline&quot; &quot;Queue&quot; = &quot;Geometry&quot;&#125;        Pass &#123;            Name &quot;ForwardLit&quot;            Tags &#123;&quot;LightMode&quot; = &quot;UniversalForward&quot;&#125;            HLSLPROGRAM        \t#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;            #pragma vertex vert            #pragma fragment frag            struct appdata &#123;...&#125;;            struct v2f &#123;...&#125;;            v2f vert(appdata v) &#123;...&#125;            half4 frag(v2f i): SV_Target &#123;...&#125;            ENDHLSL        &#125;    &#125;    CustomEditor &quot;ReArchiving.Editor.CreateURPShader&quot;&#125;\r\nThere are three important parts:\r\n\r\nShader \"Custom URP Shader/#NAME#\" in the first line,\r\nthe #NAME# part will be replaced by the script with the\r\nfile's name.\r\nCustomEditor \"ReArchiving.Editor.CreateURPShader\", we\r\nuse the CustomEditor command to archive the Custom UI of a\r\nsingle shader in the Inspector Tab. See: Unity -\r\nManual: ShaderLab: assigning a custom editor (unity3d.com)\r\nAnd the rest part is the entity, we can leave the template code\r\nhere.\r\n\r\nCustom Shader And its Tab\r\nAfter defining the template, we need to define the control\r\nscript!\r\nHere is the code:\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// -----------------------------------------// Base class named `CreateCustomItemInMenu`// -----------------------------------------using UnityEngine;using UnityEditor;using System.IO;using System.Text;using UnityEditor.ProjectWindowCallback;using System.Text.RegularExpressions;public class CreateCustomItemInMenu &#123;    public static string GetSelectedPathOrFallback() &#123;        string path = &quot;Assets&quot;;        foreach (Object obj in Selection.GetFiltered(typeof(Object), SelectionMode.Assets)) &#123;            path = AssetDatabase.GetAssetPath(obj);            if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path)) &#123;                path = Path.GetDirectoryName(path);                break;            &#125;        &#125;        return path;    &#125;&#125;class EndAction : EndNameEditAction &#123;    public override void Action(int instanceId, string pathName, string resourceFile) &#123;        Object o = CreateScriptAssetFromTemplate(pathName, resourceFile);        ProjectWindowUtil.ShowCreatedAsset(o);    &#125;    private static Object CreateScriptAssetFromTemplate(string pathName, string resourceFile) &#123;        string fullPath = Path.GetFullPath(pathName);        StreamReader streamReader = new StreamReader(resourceFile);        string text = streamReader.ReadToEnd(); // read the template info        streamReader.Close();        string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(pathName);        text = Regex.Replace(text, &quot;#NAME#&quot;, fileNameWithoutExtension); // replace `#NAME#` in template and replace to filename        // write the changed resources into the original file        bool encoderShouldEmitUTF8Identifier = true;        bool throwOnInvalidBytes = false;        UTF8Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes);        bool append = false;        StreamWriter streamWriter = new StreamWriter(fullPath, append, encoding);        streamWriter.Write(text);        streamWriter.Close();        AssetDatabase.ImportAsset(pathName);        return AssetDatabase.LoadAssetAtPath(pathName, typeof(Object));    &#125;&#125;// -----------------------------------------// Base class named `CreateURPShader`// -----------------------------------------using UnityEditor;using UnityEngine;public class CreateURPShader : CreateCustomItemInMenu &#123;    private const string TemplatePath = &quot;Assets/CustomShaderGUI/Editor/Template/URPShader.shader&quot;;    [MenuItem(&quot;Assets/Create/Shader/URP Shader&quot;)]    public static void CreateFileFromTemplate() &#123;        ProjectWindowUtil.StartNameEditingIfProjectWindowExists(            0,            ScriptableObject.CreateInstance&lt;EndAction&gt;(),            GetSelectedPathOrFallback() + &quot;/URPShader.shader&quot;,            null,            TemplatePath        );    &#125;&#125;\r\nIt's important to divide the function into parts so that we can reuse\r\nand debug easier.\r\nAnd now you can see the template in the right-click menu:\r\n\r\n\r\nimage-20230409172030993\r\n\r\nDefine the Shader GUI\r\nWe can directly use the built-in properties of unity to custom the\r\nGUI, see:\r\n\r\nShader\r\n面板上常用的一些内置枚举 UI - 知乎 (zhihu.com) &gt; 【Unity\r\nShader】自定义材质面板的小技巧unity shader\r\nbool妈妈说女孩子要自立自强的博客-CSDN 博客\r\n\r\nBut here we choose to use scripts to custom the shader UI which is\r\nmore powerful and flexible.\r\nHere is the basic framework I suggested:\r\nCustom Shader GUI Though\r\nScripts\r\nSetup namespace:\r\nAs for the start, we need to derive from an abstract class\r\nShaderGUI. Unity -\r\nScripting API: ShaderGUI (unity3d.com)\r\n\r\nDerive from this class for controlling how shader properties should\r\nbe presented.\r\nFor a shader to use this custom GUI, use the\r\nCustomEditor property in the shader. Note that\r\nCustomEditor can also be used for classes deriving from\r\nMaterialEditor (search for:\r\nCustom Material Editors). Note: Only the ShaderGUI approach\r\nworks with Substance materials this is therefore the recommended\r\napproach to custom gui for shaders.\r\n\r\n12345namespace ReArchiving.Editor &#123;    public class SimpleShaderGUI : ShaderGUI &#123;        ...    &#125;&#125;\r\nDeclare variables\r\nIn this section, we have three things to do:\r\n\r\ndeclare all the GUIContent which we want to show aside. Suggest\r\ndefining this section with the name GUIDescriptions.\r\ndeclare all the strings which we have defined inside the target\r\nshader. We can define more strings than properties in the target shader\r\nitself because we have to do more operations before using these\r\nvariables and we can exclude the properties that do not exist in the\r\nshader easily at that time. Suggest defining this section with the name\r\nInsideMaterialProperties.\r\ndeclare all the status variables. We use them to decide should\r\ncorresponding variables be displayed.\r\n\r\nHere is the example code of this section:\r\n1234567891011121314151617181920212223242526272829303132333435      #region DataArea      private struct GUIDescriptions &#123;          // Folder          public static readonly GUIContent SurfaceOptionFold = new GUIContent(&quot;Surface Option Fold&quot;);          // Material Properties          public static readonly GUIContent Test = new GUIContent(&quot;Test&quot;);          public static readonly GUIContent MainTex = new GUIContent(&quot;Main Texture&quot;);          public static readonly GUIContent MainColor = new GUIContent(&quot;Main Color&quot;);      &#125;      private struct InsideMaterialProperties &#123;          public static readonly string Test = &quot;_Test&quot;;          public static readonly string MainTex = &quot;_MainTex&quot;;          public static readonly string MainColor = &quot;_MainColor&quot;;      &#125;      // After `Styles` and `MporpertyNames` were defined, we can then announce the variables for checking:      // As you can see, we will use two data types here: one is the `bool` and another one is the `MaterialProperty`// This is because we use the `bool` type to store the Foldout UI which is independent of Properties that are defined in Material// And relatively, the `MaterialProperties` will store the Material related to Properties.      // There is an exception though, that is the `EditorPreKey`, we use that to      // `EditorPreKey`, we use this to store the foldout status(is this foldout opened or not)      private const string EditorPreKey = &quot;ReArchiving:ShaderGUI:&quot;;      // Foldout status      private bool m_SurfaceOptionsFoldout;      // Properties      private MaterialProperty m_WorkflowModeProp;      private MaterialProperty m_Test;      private MaterialProperty m_MainTex;      private MaterialProperty m_MainColor;      #endregion\r\nOverride the OnGUI\r\nfunction:\r\nAlthough we haven't defined the other functions we need to use, we\r\ndefine the override OnGUI function here to help us clear\r\nthe things we need to do. Unity\r\n- Scripting API: ShaderGUI.OnGUI (unity3d.com)\r\nSo, what should we do here?\r\nWe need to decide which property, GUIConent and type we want to show\r\nup in the Inspector tab. So we need to check the Usability of\r\nthe properties and set them up. And that's\r\nwhat we want to do.\r\nAnd, before we start coding, we'd better understand the\r\nOnGUI function. This function has two parameters:\r\nMaterialEditor and MaterialProperty\r\n\r\nMaterialEditor: The MaterialEditor that is calling this\r\nOnGUI (the 'owner'). Unity\r\n- Scripting API: MaterialEditor (unity3d.com)\r\nMaterialProperty: Material properties of the currently\r\nselected shader. Unity\r\n- Scripting API: MaterialProperty (unity3d.com)\r\n\r\n12345678910111213141516171819#region GUI// To define a custom shader GUI use the methods of materialEditor to render controls for the properties array.public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties) &#123;    // Check the usability. Well, we will define the `GetFoldoutState` function later    m_SurfaceOptionsFoldout = GetFoldoutState(&quot;SurfaceOptions&quot;);    // https://docs.unity.cn/cn/2021.3/ScriptReference/ShaderGUI.FindProperty.html    // Returns MaterialProperty if the material property was found, otherwise null.    m_Test = FindProperty(MPropertyNames.Test, properties, false);    m_MainTex = FindProperty(MPropertyNames.MainTex, properties, false);    m_MainColor = FindProperty(MPropertyNames.MainColor, properties, false);    // Modify and apply the custom GUI    EditorGUI.BeginChangeCheck(); // https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html    DrawProperties(materialEditor);    // if (EditorGUI.EndChangeCheck()) SetMaterialKeywords(materialEditor.target as Material);&#125;#endregion\r\nAs we have archived the usability check in the OnGUI\r\nfunction, we just need to archive the DrawProperties()\r\nfunction and GetFoldoutState() function later.\r\nArchive the\r\nGetFoldoutState function\r\nTo archive the folder effects, we need to use the\r\nEditorPrefs Property to make the target variables a folder\r\nfirst. Unity -\r\nScripting API: EditorPrefs (unity3d.com)\r\n12345678910111213#region EditorPrefs// Because weprivate bool GetFoldoutState(string name) &#123;    return EditorPrefs.GetBool($&quot;&#123;EditorPreKey&#125;.&#123;name&#125;&quot;);&#125;private void SetFoldoutState(string name, bool field, bool value) &#123;    if (field == value) return;    EditorPrefs.SetBool($&quot;&#123;EditorPreKey&#125;.&#123;name&#125;&quot;, value);&#125;#endregion\r\nSetup the foldout render\r\nfunction\r\nFinally, we will archive the function that can truly make effects in\r\nthe Inspector tab.\r\nHere, we need to define a startup function that controls all the\r\nfoldouts and then build different functions for every folder. It sounds\r\nlike a big project. But it is a simple job actually. Unity\r\n- Scripting API: EditorGUILayout (unity3d.com) Unity\r\n- Scripting API: EditorGUILayout.BeginFoldoutHeaderGroup\r\n(unity3d.com) Unity\r\n- Scripting API: EditorGUILayout.EndFoldoutHeaderGroup\r\n(unity3d.com)\r\n1234567891011121314151617181920212223#region Propertiesprivate void DrawProperties(MaterialEditor materialEditor) &#123;    // the foldout setup here:    var surfaceOptionsFold =        EditorGUILayout.BeginFoldoutHeaderGroup(m_SurfaceOptionsFoldout, Styles.SurfaceOptionFold);    if (surfaceOptionsFold) &#123;        EditorGUILayout.Space();        DrawSurfaceOption(materialEditor);        EditorGUILayout.Space();    &#125;    SetFoldoutState(&quot;SurfaceOptions&quot;, m_SurfaceOptionsFoldout, surfaceOptionsFold);    EditorGUILayout.EndFoldoutHeaderGroup();&#125;private void DrawSurfaceOption(MaterialEditor materialEditor) &#123;    materialEditor.TexturePropertySingleLine(Styles.MainColor, m_MainTex, m_MainColor);    materialEditor.FloatProperty(m_Test, MPropertyNames.Test);&#125;#endregion\r\n[Optional] Setup keywords\r\nOnce we change the properties in the custom shader UI, we need to\r\nregenerate the corresponding shader variants. Here's an example.\r\n123456789101112131415#region Keywordsprivate void SetKeyword(Material material, string keyword, bool value) &#123;    if (value) material.EnableKeyword(keyword);    else material.DisableKeyword(keyword);&#125;private void SetMaterialKeywords(Material material) &#123;    // https://docs.unity3d.com/ScriptReference/Material-shaderKeywords.html    material.shaderKeywords = null;    SetKeyword(material, &quot;_SPECULAR_SETUP&quot;, material.GetFloat(MPropertyNames.Test) == 0);&#125;#endregion\r\nA Complete Example Script\r\nFind it on: URP_Toon/ToonShaderGUI.cs\r\nat master · ChiliMilk/URP_Toon (github.com)\r\nReference\r\n\r\nBlog:\r\n\r\nStraw1997/UnityCustomShaderGUI:\r\n自定义 Unity Shader GUI (github.com)\r\nsimplest\r\nway to add an option to right click menu - Unity Forum\r\nC#\r\n枚举（Enum） | 菜鸟教程 (runoob.com)\r\n【Unity\r\nShader】自定义材质面板的小技巧unity shader\r\nbool妈妈说女孩子要自立自强的博客-CSDN 博客\r\nShader\r\n面板上常用的一些内置枚举 UI - 知乎 (zhihu.com)\r\n\r\nUnity Manual\r\n\r\nUnity\r\n- Manual: Using shader keywords with the material Inspector\r\n(unity3d.com)\r\nUnity\r\n- Manual: ShaderLab: assigning a custom editor (unity3d.com)\r\nUnity\r\n- Scripting API: ShaderGUI.OnGUI (unity3d.com)\r\nUnity\r\n- Scripting API: MaterialEditor (unity3d.com)\r\nUnity\r\n- Scripting API: MaterialProperty (unity3d.com)\r\nUnity -\r\nScripting API: EditorGUI (unity3d.com)\r\nUnity\r\n- Scripting API: EditorGUI.BeginChangeCheck (unity3d.com)\r\nUnity -\r\nScripting API: EditorPrefs (unity3d.com)\r\nUnity\r\n- Scripting API: EditorGUILayout (unity3d.com)\r\nUnity\r\n- Scripting API: EditorGUILayout.BeginFoldoutHeaderGroup\r\n(unity3d.com)\r\nUnity\r\n- Scripting API: EditorGUILayout.EndFoldoutHeaderGroup\r\n(unity3d.com)\r\n\r\nURP_Toon/ToonShaderGUI.cs\r\nat master · ChiliMilk/URP_Toon (github.com)\r\n\r\n","slug":"Rendering/CustomRightClickMenuAndShaderGUI","date":"2023-04-10T08:32:30.000Z","categories_index":"Unity,Shader","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"23661fa8ae25c981d575d8f076eed3e1","title":"URP源码分析","content":"URP源码分析\r\n依赖信息：\r\n\r\nEditor版本：2021.21f1 LTS\r\nShader版本：URP 12.1.10\r\n\r\nURP Package总览\r\n首先，当我们下载URP资源时，我们的项目的Package中会出现这些内容：\r\n URP资源结构 -\r\ncom.unity.render-pipelines.universal Part\r\n URP资源结构 -\r\ncom.unity.render-pipelines.core Part\r\n这两个Library一起，组成了我们的URP资源，这也是我们在实际使用时引入资源的两个对应的实际位置：\r\n12#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;\r\n由于这两个Package实际上是互相引用的，所以我们就先就着\r\nUniversal RP 来展开：\r\n\r\nDocumentation的包含了大量的说明文档，这些都是帮助我们理解URP资源的好资料。这些内容和官方网站上是完全一致的，所以也没必要就着这里面看——Universal\r\nRender Pipeline overview | Universal RP | 12.1.10 (unity3d.com)\r\nEditor\r\nRuntime：\r\nSamples：示例文件、资源及工程\r\nShaderLibrary\r\nShaders\r\nTests\r\nTextures\r\n\r\n从Core.hlsl开始\r\n这是我们最早接触的一个hlsl文件。\r\n总的来说，这个文件做了这么三件事：\r\n\r\n\r\n\r\n分析\r\n1~2及196\r\n第1~2行与第196行是防止重复引用的判断语句。\r\n4~6\r\n之后的4~5行是注释：\r\n\r\n// VT is not supported in URP (for now) this ensures any shaders\r\nusing the VT // node work by falling to regular texture\r\nsampling.\r\n\r\n并在第6行做了定义：#define FORCE_VIRTUAL_TEXTURING_OFF 1\r\n快速而全面地了解VT，可以看:\r\n\r\nUnity\r\n- Manual: Marking textures as \"Virtual Texturing Only\"\r\n(unity3d.com)\r\nOfficial\r\n- Feedback Wanted: Streaming Virtual Texturing - Unity Forum\r\n\r\n\r\nStreaming Virtual Texturing is a texture streaming feature that\r\nreduces GPU memory usage and Texture loading times when you have many\r\nhigh resolution Textures in your scene. It works by splitting Textures\r\ninto tiles, and progressively uploading these tiles to GPU memory when\r\nthey are needed.\r\n\r\n8~14\r\n第8~14行，我们定义的是集群渲染，这个在过去文档中有过相关描述，论坛中也有相关讨论\r\nUnity\r\n- Manual: Cluster Rendering (unity3d.com) Any\r\ninfo on experimental URP 12 clustered rendering option? - Unity\r\nForum\r\n16~19\r\n引入了四个外部文件，来自core和universal两个位置。这些内容主要做了这些事：\r\n\r\n\r\n\r\n1234#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl&quot;#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl&quot;#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl&quot;\r\n21~46\r\n21~27行检查并定义了宏\r\nSHADER_HINT_NICE_QUALITY，如未定义则默认基于可能存在的移动平台宏\r\nSHADER_API_MOBILE 和Switch SHADER_API_SWITCH\r\n设为0，其他为1。 ShaderLibrary\r\n- DefineSysmbols_装大炮的自行车的博客-CSDN博客\r\n这之后的29~42行，则根据 SHADER_HINT_NICE_QUALITY\r\n及实际调用的API输出分别输出 SHADER_QUALITY_HIGH,\r\nSHADER_QUALITY_MEDIUM,\r\nSHADER_QUALITY_LOW三个宏之一\r\n\r\n// Shader Quality Tiers in Universal. // SRP doesn't use Graphics\r\nSettings Quality Tiers. // We should expose shader quality tiers in the\r\npipeline asset.\r\n// Meanwhile, it's forced to be: // High Quality: Non-mobile\r\nplatforms or shader explicit defined\r\nSHADER_HINT_NICE_QUALITY // Medium: Mobile aside from GLES2\r\n// Low: GLES2\r\n\r\n然后在44~46行对 SHADER_HINT_NICE_QUALITY 取反得到宏\r\nBUMP_SCALE_NOT_SUPPORTED\r\n49~65\r\n根据具体的平台使用(主要是 UNITY_REVERSED_Z 和\r\nUNITY_UV_STARTS_AT_TOP\r\n宏)，UNITY做了关于裁剪空间的兼容性处理，内容如下：\r\n1234567891011121314151617#if UNITY_REVERSED_Z    // TODO: workaround. There&#x27;s a bug where SHADER_API_GL_CORE gets erroneously defined on switch.    #if (defined(SHADER_API_GLCORE) &amp;&amp; !defined(SHADER_API_SWITCH)) || defined(SHADER_API_GLES) || defined(SHADER_API_GLES3)        //GL with reversed z =&gt; z clip range is [near, -far] -&gt; remapping to [0, far]        #define UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) max((coord - _ProjectionParams.y)/(-_ProjectionParams.z-_ProjectionParams.y)*_ProjectionParams.z, 0)    #else        //D3d with reversed Z =&gt; z clip range is [near, 0] -&gt; remapping to [0, far]        //max is required to protect ourselves from near plane not being correct/meaningful in case of oblique matrices.        #define UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) max(((1.0-(coord)/_ProjectionParams.y)*_ProjectionParams.z),0)    #endif#elif UNITY_UV_STARTS_AT_TOP    //D3d without reversed z =&gt; z clip range is [0, far] -&gt; nothing to do    #define UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) (coord)#else    //Opengl =&gt; z clip range is [-near, far] -&gt; remapping to [0, far]    #define UNITY_Z_0_FAR_FROM_CLIPSPACE(coord) max(((coord + _ProjectionParams.y)/(_ProjectionParams.z+_ProjectionParams.y))*_ProjectionParams.z, 0)#endif\r\n原理是：\r\n虽然OpenGL和D3D在从View Space变化到Clip\r\nSpace中的方式都是类似的，但是实际的值域却有所不同：\r\n\r\n屏幕空间差异：当我们使用 渲染到纹理技术 （render\r\nTexture）时，就有可能出现问题，这对应了\r\nUNITY_UV_STARTS_AT_TOP 宏\r\n\r\n\r\nimage-20230409155215810\r\n\r\n\r\n\r\n68~104\r\n根据宏 UNITY_STEREO_INSTANCING_ENABLED 和宏\r\nUNITY_STEREO_MULTIVIEW_ENABLED 的是否启用，对 TEXTURE\r\n类函数做了兼容层。\r\n177~190\r\n定义了两个结构体 VertexPositionInputs 和\r\nVertexNormalnputs，这是两个我们常用的结构体\r\n193~194\r\n从 universal 中引入了两个外置文件：\r\n12#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl&quot;#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Deprecated.hlsl&quot;\r\n让我们先就着 ShaderVariablesFunctions.hlsl 继续\r\nReference\r\n\r\nUniversal\r\nRender Pipeline overview | Universal RP | 12.1.10 (unity3d.com)\r\nUnity\r\n- Manual: Marking textures as \"Virtual Texturing Only\"\r\n(unity3d.com)\r\nOfficial\r\n- Feedback Wanted: Streaming Virtual Texturing - Unity Forum\r\nShaderLibrary\r\n- DefineSysmbols_装大炮的自行车的博客-CSDN博客\r\n\r\n","slug":"Rendering/UpdateToURPPipeline/URPSourceCode","date":"2023-04-08T13:32:05.000Z","categories_index":"Unity","tags_index":"Unity,Shader,URP","author_index":"JBR_Bunjie"},{"id":"54d190e1f1807867e70fac21b913c281","title":"URP Chapter4 - 卡通渲染","content":"Chapter4 - 卡通渲染\r\n上一章我们已经分析了 Unity 内置的 Lit Shader，这是 Unity 在 URP\r\n管线下的默认 Shader\r\n而在这一章，我们将视线转向卡通渲染：\r\nReference\r\n\r\nkwshh/unity_lit_toonshader\r\n(github.com)\r\n\r\n","slug":"Rendering/UpdateToURPPipeline/Chapter4_ToonLit","date":"2023-04-06T13:52:05.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"82ff1fb81877d21689ef75c8cb4f38fd","title":"URP Chapter 3 - Lit","content":"Chapter 3 - Lit\r\n在 URP 管线下，所有我们新创建的材质会默认使用\r\nUniversal Render Pipeline/Lit 作为当前材质的 Shader，这个\r\nShader 是 unity 对 PBR 的基本实现，而本章将对该 Shader\r\n作深入分析，本章所用的 Lit.shader 可以在其 Github 页面找到\r\n从 Lit.shader 的 Properties\r\n开始\r\n范围\r\nProperties 代码块位于 Lit.shader 文件中的\r\n3~70 行，具体代码如下：\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Properties&#123;    // Specular vs Metallic workflow    _WorkflowMode(&quot;WorkflowMode&quot;, Float) = 1.0    [MainTexture] _BaseMap(&quot;Albedo&quot;, 2D) = &quot;white&quot; &#123;&#125;    [MainColor] _BaseColor(&quot;Color&quot;, Color) = (1,1,1,1)    _Cutoff(&quot;Alpha Cutoff&quot;, Range(0.0, 1.0)) = 0.5    _Smoothness(&quot;Smoothness&quot;, Range(0.0, 1.0)) = 0.5    _SmoothnessTextureChannel(&quot;Smoothness texture channel&quot;, Float) = 0    _Metallic(&quot;Metallic&quot;, Range(0.0, 1.0)) = 0.0    _MetallicGlossMap(&quot;Metallic&quot;, 2D) = &quot;white&quot; &#123;&#125;    _SpecColor(&quot;Specular&quot;, Color) = (0.2, 0.2, 0.2)    _SpecGlossMap(&quot;Specular&quot;, 2D) = &quot;white&quot; &#123;&#125;    [ToggleOff] _SpecularHighlights(&quot;Specular Highlights&quot;, Float) = 1.0    [ToggleOff] _EnvironmentReflections(&quot;Environment Reflections&quot;, Float) = 1.0    _BumpScale(&quot;Scale&quot;, Float) = 1.0    _BumpMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;    _Parallax(&quot;Scale&quot;, Range(0.005, 0.08)) = 0.005    _ParallaxMap(&quot;Height Map&quot;, 2D) = &quot;black&quot; &#123;&#125;    _OcclusionStrength(&quot;Strength&quot;, Range(0.0, 1.0)) = 1.0    _OcclusionMap(&quot;Occlusion&quot;, 2D) = &quot;white&quot; &#123;&#125;    [HDR] _EmissionColor(&quot;Color&quot;, Color) = (0,0,0)    _EmissionMap(&quot;Emission&quot;, 2D) = &quot;white&quot; &#123;&#125;    _DetailMask(&quot;Detail Mask&quot;, 2D) = &quot;white&quot; &#123;&#125;    _DetailAlbedoMapScale(&quot;Scale&quot;, Range(0.0, 2.0)) = 1.0    _DetailAlbedoMap(&quot;Detail Albedo x2&quot;, 2D) = &quot;linearGrey&quot; &#123;&#125;    _DetailNormalMapScale(&quot;Scale&quot;, Range(0.0, 2.0)) = 1.0    [Normal] _DetailNormalMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;    // SRP batching compatibility for Clear Coat (Not used in Lit)    [HideInInspector] _ClearCoatMask(&quot;_ClearCoatMask&quot;, Float) = 0.0    [HideInInspector] _ClearCoatSmoothness(&quot;_ClearCoatSmoothness&quot;, Float) = 0.0    // Blending state    _Surface(&quot;__surface&quot;, Float) = 0.0    _Blend(&quot;__blend&quot;, Float) = 0.0    _Cull(&quot;__cull&quot;, Float) = 2.0    [ToggleUI] _AlphaClip(&quot;__clip&quot;, Float) = 0.0    [HideInInspector] _SrcBlend(&quot;__src&quot;, Float) = 1.0    [HideInInspector] _DstBlend(&quot;__dst&quot;, Float) = 0.0    [HideInInspector] _ZWrite(&quot;__zw&quot;, Float) = 1.0    [ToggleUI] _ReceiveShadows(&quot;Receive Shadows&quot;, Float) = 1.0    // Editmode props    _QueueOffset(&quot;Queue offset&quot;, Float) = 0.0    // ObsoleteProperties    [HideInInspector] _MainTex(&quot;BaseMap&quot;, 2D) = &quot;white&quot; &#123;&#125;    [HideInInspector] _Color(&quot;Base Color&quot;, Color) = (1, 1, 1, 1)    [HideInInspector] _GlossMapScale(&quot;Smoothness&quot;, Float) = 0.0    [HideInInspector] _Glossiness(&quot;Smoothness&quot;, Float) = 0.0    [HideInInspector] _GlossyReflections(&quot;EnvironmentReflections&quot;, Float) = 0.0    [HideInInspector][NoScaleOffset]unity_Lightmaps(&quot;unity_Lightmaps&quot;, 2DArray) = &quot;&quot; &#123;&#125;    [HideInInspector][NoScaleOffset]unity_LightmapsInd(&quot;unity_LightmapsInd&quot;, 2DArray) = &quot;&quot; &#123;&#125;    [HideInInspector][NoScaleOffset]unity_ShadowMasks(&quot;unity_ShadowMasks&quot;, 2DArray) = &quot;&quot; &#123;&#125;&#125;\r\n可以看到，Lit.shader 中同时定义了 Unity 所实现的、两种\r\nPBR 工作流中所需要的全部属性。\r\n接下来，我们将试对属性定义中代码的书写逻辑，及同下方的部分逻辑一起，作大致说明：\r\n定义工作流\r\n可以看到，Properties\r\n中开头第一段代码就是用于工作流类型定义的代码：\r\n1_WorkflowMode(&quot;WorkflowMode&quot;, Float) = 1.0\r\n但是奇怪的是，我们的面板上所实在展示的并不是浮点数——是字符串：\r\n 面板上的 WorkflowMode\r\n属性对应的并不是浮点是而是字符文字\r\n这些我们\r\n定义工作流后，我们的 Inspector\r\n面板会发生变化，两种工作流对应的面板如下：\r\n Specular 工作流下的 Inspector\r\n面板\r\n Metallic 工作流下的 Inspector\r\n面板\r\n可以看到当对应的工作流不同时，我们的 Surface Input\r\n下的数据会发生变化。关于 Surface Input\r\n，我们后面还会再次看到。\r\n其他 Suface\r\nOptions 内容与 Advanced Options 内容\r\n第一个 Pass：ForwardLit\r\n80~150\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// ------------------------------------------------------------------      //  Forward pass. Shades all light in a single pass. GI + emission + Fog      Pass      &#123;          // Lightmode matches the ShaderPassName set in UniversalRenderPipeline.cs. SRPDefaultUnlit and passes with          // no LightMode tag are also rendered by Universal Render Pipeline          Name &quot;ForwardLit&quot;          Tags&#123;&quot;LightMode&quot; = &quot;UniversalForward&quot;&#125;          Blend[_SrcBlend][_DstBlend]          ZWrite[_ZWrite]          Cull[_Cull]          HLSLPROGRAM          #pragma exclude_renderers gles gles3 glcore          #pragma target 4.5          // -------------------------------------          // Material Keywords          #pragma shader_feature_local _NORMALMAP          #pragma shader_feature_local _PARALLAXMAP          #pragma shader_feature_local _RECEIVE_SHADOWS_OFF          #pragma shader_feature_local _ _DETAIL_MULX2 _DETAIL_SCALED          #pragma shader_feature_local_fragment _SURFACE_TYPE_TRANSPARENT          #pragma shader_feature_local_fragment _ALPHATEST_ON          #pragma shader_feature_local_fragment _ALPHAPREMULTIPLY_ON          #pragma shader_feature_local_fragment _EMISSION          #pragma shader_feature_local_fragment _METALLICSPECGLOSSMAP          #pragma shader_feature_local_fragment _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A          #pragma shader_feature_local_fragment _OCCLUSIONMAP          #pragma shader_feature_local_fragment _SPECULARHIGHLIGHTS_OFF          #pragma shader_feature_local_fragment _ENVIRONMENTREFLECTIONS_OFF          #pragma shader_feature_local_fragment _SPECULAR_SETUP          // -------------------------------------          // Universal Pipeline keywords          #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN          #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS          #pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS          #pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING          #pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION          #pragma multi_compile_fragment _ _SHADOWS_SOFT          #pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION          #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3          #pragma multi_compile_fragment _ _LIGHT_LAYERS          #pragma multi_compile_fragment _ _LIGHT_COOKIES          #pragma multi_compile _ _CLUSTERED_RENDERING          // -------------------------------------          // Unity defined keywords          #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING          #pragma multi_compile _ SHADOWS_SHADOWMASK          #pragma multi_compile _ DIRLIGHTMAP_COMBINED          #pragma multi_compile _ LIGHTMAP_ON          #pragma multi_compile _ DYNAMICLIGHTMAP_ON          #pragma multi_compile_fog          #pragma multi_compile_fragment _ DEBUG_DISPLAY          //--------------------------------------          // GPU Instancing          #pragma multi_compile_instancing          #pragma instancing_options renderinglayer          #pragma multi_compile _ DOTS_INSTANCING_ON          #pragma vertex LitPassVertex          #pragma fragment LitPassFragment          #include &quot;Packages/com.unity.render-pipelines.universal/Shaders/LitInput.hlsl&quot;          #include &quot;Packages/com.unity.render-pipelines.universal/Shaders/LitForwardPass.hlsl&quot;          ENDHLSL      &#125;\r\nLitForwardPass.hlsl\r\n外部实现：为了更清晰的代码\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#ifndef UNIVERSAL_FORWARD_LIT_PASS_INCLUDED#define UNIVERSAL_FORWARD_LIT_PASS_INCLUDED#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;// GLES2 has limited amount of interpolators#if defined(_PARALLAXMAP) &amp;&amp; !defined(SHADER_API_GLES)#define REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR#endif#if (defined(_NORMALMAP) || (defined(_PARALLAXMAP) &amp;&amp; !defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR))) || defined(_DETAIL)#define REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR#endif// keep this file in sync with LitGBufferPass.hlslstruct Attributes&#123;    float4 positionOS   : POSITION;    float3 normalOS     : NORMAL;    float4 tangentOS    : TANGENT;    float2 texcoord     : TEXCOORD0;    float2 staticLightmapUV   : TEXCOORD1;    float2 dynamicLightmapUV  : TEXCOORD2;    UNITY_VERTEX_INPUT_INSTANCE_ID&#125;;struct Varyings&#123;    float2 uv                       : TEXCOORD0;#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)    float3 positionWS               : TEXCOORD1;#endif    float3 normalWS                 : TEXCOORD2;#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR)    half4 tangentWS                : TEXCOORD3;    // xyz: tangent, w: sign#endif    float3 viewDirWS                : TEXCOORD4;#ifdef _ADDITIONAL_LIGHTS_VERTEX    half4 fogFactorAndVertexLight   : TEXCOORD5; // x: fogFactor, yzw: vertex light#else    half  fogFactor                 : TEXCOORD5;#endif#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)    float4 shadowCoord              : TEXCOORD6;#endif#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)    half3 viewDirTS                : TEXCOORD7;#endif    DECLARE_LIGHTMAP_OR_SH(staticLightmapUV, vertexSH, 8);#ifdef DYNAMICLIGHTMAP_ON    float2  dynamicLightmapUV : TEXCOORD9; // Dynamic lightmap UVs#endif    float4 positionCS               : SV_POSITION;    UNITY_VERTEX_INPUT_INSTANCE_ID    UNITY_VERTEX_OUTPUT_STEREO&#125;;void InitializeInputData(Varyings input, half3 normalTS, out InputData inputData)&#123;    inputData = (InputData)0;#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)    inputData.positionWS = input.positionWS;#endif    half3 viewDirWS = GetWorldSpaceNormalizeViewDir(input.positionWS);#if defined(_NORMALMAP) || defined(_DETAIL)    float sgn = input.tangentWS.w;      // should be either +1 or -1    float3 bitangent = sgn * cross(input.normalWS.xyz, input.tangentWS.xyz);    half3x3 tangentToWorld = half3x3(input.tangentWS.xyz, bitangent.xyz, input.normalWS.xyz);    #if defined(_NORMALMAP)    inputData.tangentToWorld = tangentToWorld;    #endif    inputData.normalWS = TransformTangentToWorld(normalTS, tangentToWorld);#else    inputData.normalWS = input.normalWS;#endif    inputData.normalWS = NormalizeNormalPerPixel(inputData.normalWS);    inputData.viewDirectionWS = viewDirWS;#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)    inputData.shadowCoord = input.shadowCoord;#elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)    inputData.shadowCoord = TransformWorldToShadowCoord(inputData.positionWS);#else    inputData.shadowCoord = float4(0, 0, 0, 0);#endif#ifdef _ADDITIONAL_LIGHTS_VERTEX    inputData.fogCoord = InitializeInputDataFog(float4(input.positionWS, 1.0), input.fogFactorAndVertexLight.x);    inputData.vertexLighting = input.fogFactorAndVertexLight.yzw;#else    inputData.fogCoord = InitializeInputDataFog(float4(input.positionWS, 1.0), input.fogFactor);#endif#if defined(DYNAMICLIGHTMAP_ON)    inputData.bakedGI = SAMPLE_GI(input.staticLightmapUV, input.dynamicLightmapUV, input.vertexSH, inputData.normalWS);#else    inputData.bakedGI = SAMPLE_GI(input.staticLightmapUV, input.vertexSH, inputData.normalWS);#endif    inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(input.positionCS);    inputData.shadowMask = SAMPLE_SHADOWMASK(input.staticLightmapUV);    #if defined(DEBUG_DISPLAY)    #if defined(DYNAMICLIGHTMAP_ON)    inputData.dynamicLightmapUV = input.dynamicLightmapUV;    #endif    #if defined(LIGHTMAP_ON)    inputData.staticLightmapUV = input.staticLightmapUV;    #else    inputData.vertexSH = input.vertexSH;    #endif    #endif&#125;/////////////////////////////////////////////////////////////////////////////////                  Vertex and Fragment functions                            /////////////////////////////////////////////////////////////////////////////////// Used in Standard (Physically Based) shaderVaryings LitPassVertex(Attributes input)&#123;    Varyings output = (Varyings)0;    UNITY_SETUP_INSTANCE_ID(input);    UNITY_TRANSFER_INSTANCE_ID(input, output);    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);    VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz);    // normalWS and tangentWS already normalize.    // this is required to avoid skewing the direction during interpolation    // also required for per-vertex lighting and SH evaluation    VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS);    half3 vertexLight = VertexLighting(vertexInput.positionWS, normalInput.normalWS);    half fogFactor = 0;    #if !defined(_FOG_FRAGMENT)        fogFactor = ComputeFogFactor(vertexInput.positionCS.z);    #endif    output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap);    // already normalized from normal transform to WS.    output.normalWS = normalInput.normalWS;#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR) || defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)    real sign = input.tangentOS.w * GetOddNegativeScale();    half4 tangentWS = half4(normalInput.tangentWS.xyz, sign);#endif#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR)    output.tangentWS = tangentWS;#endif#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)    half3 viewDirWS = GetWorldSpaceNormalizeViewDir(vertexInput.positionWS);    half3 viewDirTS = GetViewDirectionTangentSpace(tangentWS, output.normalWS, viewDirWS);    output.viewDirTS = viewDirTS;#endif    OUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV);#ifdef DYNAMICLIGHTMAP_ON    output.dynamicLightmapUV = input.dynamicLightmapUV.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;#endif    OUTPUT_SH(output.normalWS.xyz, output.vertexSH);#ifdef _ADDITIONAL_LIGHTS_VERTEX    output.fogFactorAndVertexLight = half4(fogFactor, vertexLight);#else    output.fogFactor = fogFactor;#endif#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)    output.positionWS = vertexInput.positionWS;#endif#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)    output.shadowCoord = GetShadowCoord(vertexInput);#endif    output.positionCS = vertexInput.positionCS;    return output;&#125;// Used in Standard (Physically Based) shaderhalf4 LitPassFragment(Varyings input) : SV_Target&#123;    UNITY_SETUP_INSTANCE_ID(input);    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);#if defined(_PARALLAXMAP)#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)    half3 viewDirTS = input.viewDirTS;#else    half3 viewDirWS = GetWorldSpaceNormalizeViewDir(input.positionWS);    half3 viewDirTS = GetViewDirectionTangentSpace(input.tangentWS, input.normalWS, viewDirWS);#endif    ApplyPerPixelDisplacement(viewDirTS, input.uv);#endif    SurfaceData surfaceData;    InitializeStandardLitSurfaceData(input.uv, surfaceData);    InputData inputData;    InitializeInputData(input, surfaceData.normalTS, inputData);    SETUP_DEBUG_TEXTURE_DATA(inputData, input.uv, _BaseMap);#ifdef _DBUFFER    ApplyDecalToSurfaceData(input.positionCS, surfaceData, inputData);#endif    half4 color = UniversalFragmentPBR(inputData, surfaceData);    color.rgb = MixFog(color.rgb, inputData.fogCoord);    color.a = OutputAlpha(color.a, _Surface);    return color;&#125;#endif\r\n统一的 input：\r\n保证相同的 CBUFFER\r\nReference\r\n\r\nLit.shader 源代码：Graphics/Lit.shader\r\nat 2021.3/HDRP/templates/add-hdrp-blank · Unity-Technologies/Graphics\r\n(github.com)\r\nLit\r\nShader | Universal RP | 12.1.10 (unity3d.com)\r\n\r\n","slug":"Rendering/UpdateToURPPipeline/Chapter3_Lit","date":"2023-04-05T13:32:05.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"d9fb18f440aa390dd7a583e8d02caf3f","title":"URP Chapter2 - 光与影","content":"Chapter2 - 光与影\r\n这一章节我们开始研究 URP 管线中的光照与阴影函数，让我们从光照开始\r\n使用空项目\r\n这一次我们不再使用 Unity 下的示例工程——让我们现从 Hub 重新创建一个\r\nURP Core 的新项目，并以其为基础进行接下来的工作\r\n\r\n\r\nimage-20230329202320686\r\n\r\n使用 Hub 中的 URP Temple 来创建新项目\r\n从 Lambert 模型开始\r\n\r\n对应代码可以参考\r\nReference\r\n\r\n事实上，URP 中已经预定义了多种光照模型，这其中就包括了 Lambert\r\n光\r\n主光源\r\n设置 LightMode\r\n应用材质\r\n解释：\r\n此属性仅在渲染路径设置为 Forward 时可用\r\nDepth Priming Mode 属性决定了 Unity 何时执行\r\ndepth priming ——它可以通过减少像素着色器执行次数来改善 GPU\r\n帧时间。其带来的性能提升取决于不透明通道中重叠像素的数量以及 Unity\r\n可以通过使用深度优化跳过的像素着色器的复杂度。该功能具有前期内存和性能成本。该功能使用深度预处理来确定哪些像素着色器调用\r\nUnity 可以跳过，并且如果尚不可用，则添加深度预处理。\r\n选项有：\r\n\r\n禁用：Unity 不执行深度优化。\r\n自动：如果有需要深度预处理的渲染通道，则 Unity\r\n执行深度预处理和深度优化。\r\n强制：Unity 始终执行深度优化。为此，Unity\r\n还为每个渲染通道执行深度预处理。\r\n请注意，无论此设置如何，在某些（基于平铺的延迟渲染的）硬件上运行时都会禁用深度优化。\r\n\r\n在 Android、iOS 和 Apple TV 上，Unity\r\n仅在强制模式下执行深度优化。在这些平台通用的平铺 GPU 上，深度启动与 MSAA\r\n结合使用时可能会降低性能。\r\n简而言之，“Depth Priming Mode”是一个属性，它决定了 Unity\r\n何时执行深度优化，以改善 GPU 帧时间。\r\n Depth Priming Mode\r\n\r\nThis property determines when Unity performs depth priming. Depth\r\nPriming can improve GPU frame timings by reducing the number of pixel\r\nshader executions. The performance improvement depends on the amount of\r\noverlapping pixels in the opaque pass and the complexity of the pixel\r\nshaders that Unity can skip by using depth priming. The feature has an\r\nupfront memory and performance cost. The feature uses a depth prepass to\r\ndetermine which pixel shader invocations Unity can skip, and the feature\r\nadds the depth prepass if it's not available yet. The options are:\r\n\r\nDisabled: Unity does not perform depth\r\npriming.\r\nAuto: If there is a Render Pass that requires a\r\ndepth prepass, Unity performs the depth prepass and depth priming.\r\nForced: Unity always performs depth priming. To do\r\nthis, Unity also performs a depth prepass for every render pass.\r\nNote: Depth priming is disabled at runtime on certain\r\nhardware (Tile Based Deferred Rendering) regardless of this\r\nsetting.\r\n\r\nOn Android, iOS, and Apple TV, Unity performs depth priming only in\r\nthe Forced mode. On tiled GPUs, which are common to those platforms,\r\ndepth priming might reduce performance when combined with MSAA.\r\nThis property is available only if Rendering Path is\r\nset to Forward\r\n\r\n影\r\n\r\nModify the alpha value in ShadowCaster, but it seems ShadowCaster\r\nonly cares if the alpha value exists. If alpha &gt;= 0, the object has\r\nshadow. If alpha &lt; 0, the object has no shadow. Alpha's value doesn't\r\nchange the strength like the Built-in pipeline.\r\nQuestion\r\n- transparent object's shadow strength - Unity Forum\r\n？\r\n关于“实时调变半透明物体阴影”这一问题，看样子是没有能成功的解决办法\r\n那么就只能自我开脱：我们到底是需要“阴影”，还是只是需要给当前的下层不透明物体加深颜色？对于水面来说，显然是后者\r\n那么我们至于要做到这一点即可——而单纯的混色就已经可以完成这一要求了——没必要再花大力气去做可变阴影\r\n\r\n\r\nIn Unity’s Universal Render Pipeline (URP), GrabPass is\r\nnot supported. However, there are some alternative methods to achieve\r\nsimilar effects such as refraction. One method is to use\r\nOpaqueTexture which captures a texture of opaque objects\r\nafter they have been rendered 1.\r\nAnother method is to use multiple cameras and layers to control the\r\nrendering order of objects and capture the desired texture 2. You may want to\r\ncheck out these resources for more detailed information on how to\r\nimplement these methods in URP.\r\n\r\nReference\r\n\r\nUnityShader 入门精要-URP 管线 2. 基础光照 -\r\n王子饼干的文章 - 知乎 https://zhuanlan.zhihu.com/p/232193169\r\nLightMode 设置：\r\n\r\nUnity -\r\nManual: ShaderLab: assigning tags to a Pass (unity3d.com)\r\nURP\r\nShaderLab Pass tags | Universal RP | 12.1.10 (unity3d.com)\r\n\r\n\r\n\r\n","slug":"Rendering/UpdateToURPPipeline/Chapter2_ShadowAndLight","date":"2023-04-05T13:32:05.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"db175e84108ce0ad0ee0d7331217eb60","title":"URP Chapter1 - 从官方示例开始","content":"Chapter1 - 从官方示例开始\r\n\r\n本章涵盖内容：\r\n\r\n官方 URP Pipeline Custom Shader 部分的教程与示例\r\n\r\n\r\n曾今的第一个Shader程序\r\n回想一下，我们在入门精要中的第一个unlit shader是什么？\r\n是不是像下面这样的直接输出颜色的shader？\r\n12345678910111213141516171819202122232425262728293031323334Shader &quot;Example/BeforeURPTutorialShaderBasic&quot;&#123;    /*一个最基础的着色器*/    Properties&#123;        _Color(&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)    &#125;    SubShader&#123;        pass&#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag                        fixed4 _Color;                        struct appdata &#123;                float4 vertex : POSITION;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;            &#125;;                        float4 vert(app_data o):SV_POSITION&#123;                v2f v;                v.pos = UnityObjectToClipPos(o.vertex)                return v;            &#125;                        fixed4 frag(v2f i):SV_TARGET&#123;                return _BaseColor;            &#125;            ENDCG        &#125;    &#125;&#125;\r\n是的，这就是我们曾经使用过的，最最基础的Shader。从大体上看，我们定义了：\r\n\r\n外部汇入Shader的属性\r\nCG代码块\r\n\r\n自定义vertex和fragment Shader名称\r\n构造输入输出数据结构体\r\n使用CG语义编写具体的vertex和fragment Shader内容\r\n\r\n\r\n通过实现以上的内容，我们完成了built-in管线下的，Shader的编写。\r\n那么，相对的，我们在URP管线中则应该构造这样子的shader来实现对应功能：\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Shader &quot;Example/URPTutorialShaderBasic&quot; &#123;    Properties &#123;        _Color(&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)    &#125;    SubShader &#123;        // Place.01        Tags &#123;            &quot;RenderPipline&quot;=&quot;UniversalPipline&quot;            &quot;RenderType&quot;=&quot;Opaque&quot;        &#125;        Pass &#123;        \t// Place.02            HLSLPROGRAM            #pragma vertex vert            #pragma fragment frag                \t// Place.03            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;            struct appdata &#123;                float4 vertex : POSITION;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;            &#125;;            sampler2D _MainTex;            float4 _MainTex_ST;            half4 _Color;            v2f vert(appdata v) &#123;                v2f o;                                \t\t// Place.04        \t\to.pos = TransformObjectToHClip(v.vertex.xyz);                // or: o.pos = mul(UNITY_MATRIX_MVP, v.vertex);                                return o;            &#125;            half4 frag(v2f i) : SV_Target &#123;                return _Color;            &#125;            ENDHLSL        &#125;    &#125;&#125;\r\n可以看到，换用URP管线后，有这些变化：\r\n\r\nPlace.01：我们得明确地声明该Shader需要使用\r\nUniversalPipline 了\r\n原来书写的 CG 代码块变成了 HLSL\r\n代码块\r\n原来引入的 CG 头文件也变成了对应的 HLSL\r\n文件\r\n基于我们的头文件的更替，我们换用了一套和CG几乎完全不同的\r\nAPI。\r\n\r\n是的，原先在入门精要里用了一整本书的那些CG函数，现在我们都不能用了——我们得重新熟悉这些“换了个马甲”的HLSL函数。\r\n为什么是HLSL\r\nCG已经是一个停止更新很久(2012年Nvidia就已经停止了维护)的语言了，而HLSL则一直更新到了现在(截至3/25/2023)，虽然HLSL本身并非一门跨平台的语言(DirextX专用语言)，但是请注意，我们事实上书写的是Shaderlab语言——只是采用了HLSL语法(标准)\r\n绘制纹理\r\n代码\r\n\r\n请注意打上 // Place.0x 的全部内容\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Shader &quot;Example/URPTutorialTextureShader&quot; &#123; \t// Place.01    Properties &#123;        [MainTexture] _MainTex (&quot;Basic Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;    &#125;    SubShader &#123;        Tags &#123; \t\t\t// Place.02            &quot;RenderPipline&quot;=&quot;UniversalRenderPipeline&quot;            &quot;RenderType&quot;=&quot;Opaque&quot;        &#125;        Pass &#123;            HLSLPROGRAM            #pragma vertex vert            #pragma fragment frag                    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;                        struct appdata &#123;                float4 vertex : POSITION;                float2 uv : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float2 uv : TEXCOORD0;            &#125;; \t\t\t// Place.03            TEXTURE2D(_MainTex);            SAMPLER(sampler_MainTex);            CBUFFER_START(UnityPerMaterial)                float4 _MainTex_ST;            CBUFFER_END                        v2f vert(appdata v) &#123;                v2f o;                                \t\to.pos = TransformObjectToHClip(v.vertex.xyz);                o.uv = TRANSFORM_TEX(v.uv, _MainTex);                                return o;            &#125;            half4 frag(v2f i) : SV_Target &#123; \t\t\t\t// Place.04                float4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);                return color;            &#125;            ENDHLSL        &#125;    &#125;&#125;\r\n回想我们读取在 CGPROGRAM 中读取 Texture\r\n的主要步骤：\r\n\r\n建立采样器 sampler2D\r\n获取材质面板上的 Tiling 与 Offset\r\n利用 tex2D 来进行最终的取样过程\r\n\r\n而我们现在在URP管线的 HLSLPROGRAM\r\n中改写的这些内容，就主要集中在以上代码部分中的各个 Place\r\n部分：\r\n\r\n设置 [MainTexture]，这会方便我们在脚本中调用：\r\n\r\n\r\n\r\nMaterial.mainTexture\r\nBy default, Unity considers a texture with the property name\r\n\"_MainTex\" to be the main texture. Use the\r\n[MainTexture] ShaderLab\r\nProperties attribute to make Unity consider a texture with a\r\ndifferent property name to be the main texture. When the main texture is\r\nset using the [MainTexture] attribute, it is not visible in\r\nthe Game view when you use the texture streaming debugging\r\nview mode or a custom debug tool.\r\n\r\nUnity\r\n- Scripting API: Material.mainTexture (unity3d.com)\r\n\r\n\r\n改写 UniversalPipeline 为\r\nUniversalRenderPipeline：事实上这两种写法好像都有效，Unity\r\n2021.3版本的文档也在左右互博：\r\n\r\n\r\n在中文URP 12.1.1文档中的 编写自定义着色器\r\n一章中，所有对应内容皆为 UniversalPipeline 编写自定义着色器\r\n| Universal RP | 12.1.1 (unity3d.com)\r\n在英文URP 12.1.10文档中的 Writing custom shaders\r\n一章中同样如此 Writing\r\ncustom shaders | Universal RP | 12.1.10 (unity3d.com)\r\n但是在 Unity Manual 中则是这样的：\r\n\r\nRenderPipeline tag\r\nThe RenderPipeline tag tells Unity whether a SubShader\r\nis compatible with the Universal Render Pipeline (URP) or the High\r\nDefinition Render Pipeline (HDRP).\r\nSyntax and valid values\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nSignature\r\nFunction\r\n\r\n\r\n\r\n\r\n“RenderPipeline” = “[name]”\r\nTells Unity whether this SubShader is\r\ncompatible with URP or HDRP.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nParameter\r\nValue\r\nFunction\r\n\r\n\r\n\r\n\r\n[name]\r\nUniversalRenderPipeline\r\nThis SubShader is compatible with URP\r\nonly.\r\n\r\n\r\n\r\nHighDefinitionRenderPipeline\r\nThis SubShader is compatible with HDRP\r\nonly.\r\n\r\n\r\n\r\n(any other value, or not declared)\r\nThis SubShader is not compatible with URP\r\nor HDRP.\r\n\r\n\r\n\r\nUnity\r\n- Manual: ShaderLab: assigning tags to a SubShader (unity3d.com)\r\n\r\n\r\n这样明显的左右互搏...所以应该是可以通用的\r\n\r\n相较于CG中直接声明sample2D，HLSL中将 Sampler 与\r\nTexture\r\n区分开来——我们得先声明一个纹理，然后才能为其指定采样器。而之后的，我们在CBUFFER代码块中像\r\nCGPROGRAM 中一样，使用 _ST\r\n后缀来声明纹理属性\r\nAPI改变——原来的 tex2D 变为\r\nSAMPLE_TEXTURE2D\r\n\r\n关于\r\nHLSLPROGRAM 中的 CBuffer 语句块与采样器\r\n获取深度缓冲及重建其世界坐标\r\n\r\n此示例中的 Unity 着色器使用深度纹理和屏幕空间 UV\r\n坐标来重建像素的世界空间位置。该着色器在网格上绘制棋盘图案，使位置可视化。\r\n\r\n\r\n本节中的代码较官方示例中的代码有所不同：我们额外设置了渲染队列，修改了RenderType\r\n\r\n在URP中，我们可以直接在Shader中拿到\r\nDepth Texture：通过在 URP 资源的 General 部分中，启用\r\nDepth Texture，我们可以直接在ShaderLab中拿到当前的深度缓冲，并利用它来重建世界坐标：\r\n 启用深度缓冲\r\n具体步骤可以参考以下代码，需要说明的内容已经在注释中注明\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081Shader &quot;Example/URPTutorialReconstructWorldPos&quot; &#123;    Properties &#123;&#125;    SubShader &#123;        Tags &#123;            &quot;RenderPipeline&quot;=&quot;UniversalRenderPipeline&quot;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;        &#125;        Pass &#123;            HLSLPROGRAM                        #pragma vertex vert            #pragma fragment frag            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;                        // 我们在这里引入了重要的着色器头文件，DeclareDepthTexture.hlsl，它包含了用于对摄像机深度纹理进行采样的函数 SampleSceneDepth            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;                        struct appdata &#123;                float4 vertex : POSITION;                float2 uv : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;            &#125;;            // 可以发现，我们并没有像入门精要那样显式地去声明我们需要使用的深度纹理，因为我们这里并不是后处理步骤            v2f vert(appdata v) &#123;                v2f o;                o.pos = TransformObjectToHClip(v.vertex.xyz);                                return o;            &#125;            // 我们所需要实现的功能集中在Fragment Shader中            half4 frag(v2f i) : SV_Target &#123;                // 由于深度纹理对应的应是屏幕空间，而 i.pos 则对应裁剪空间，那么我们就可以通过继续对 i.pos 进行后续变换来方便我们采样                // 首先，采样深度缓冲区的 UV 坐标，由像素位置除以渲染目标分辨率 _ScaledScreenParams 得到(透视除法)                float2 uv = i.pos.xy / _ScaledScreenParams.xy;                                // 开始采样，并根据不同的情况调整z值                #if UNITY_REVERSED_Z                    real depth = SampleSceneDepth(uv);                \t// 这里我们使用了real类型，这是unity所定义的类型，可参看：https://forum.unity.com/threads/what-does-real-in-shaders-of-lightweight-pipeline-means-it-seems-some-sort-of-number.547402/                #else                \t// 匹配 opengl 的 NDC                    real depth = lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(uv));                #endif                //要使重建函数正常工作，深度值必须位于归一化设备坐标 (NDC) 空间中。在 D3D 中，Z 处于 [0,1] 范围内，而在 OpenGL 中，Z 处于 [-1, 1] 范围内                // 使用 ComputeWorldSpacePosition 函数开始重建，我们呢现在已经具有：NDC 下 xy，NDC 下 z                float3 worldPos = ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);                // 可视化世界空间                uint scale = 10;                uint3 worldIntPos = uint3(abs(worldPos.xyz * scale));                bool white = (worldIntPos.x &amp; 1) ^ (worldIntPos.y &amp; 1) ^ (worldIntPos.z &amp; 1);                // ^ 异或                half4 color = white ? half4(1, 1, 1, 1) : half4(0, 0, 0, 1);                                #if UNITY_REVERSED_Z                    // 具有 REVERSED_Z 的平台（如 D3D）的情况。                    if(depth &lt; 0.0001)                        return half4(0,0,0,1);                #else                    // 没有 REVERSED_Z 的平台（如 OpenGL）的情况。                    if(depth &gt; 0.9999)                        return half4(0,0,0,1);                #endif                                return color;            &#125;            ENDHLSL        &#125;    &#125;&#125;\r\n小结\r\nIn this chapter, we have finished the short official tutorial of\r\nUnity,\r\nThank God, there are not so many challenges and changes. You can see\r\nthe example below, you can find out that it's almost as same as\r\nCGPROGRAM we wrote before.\r\n123456789101112131415161718192021222324252627282930313233343536373839Shader &quot;Example/URPTutorialVisualizingNormalShader&quot; &#123;    Properties &#123;&#125;    SubShader &#123;        Tags &#123;            &quot;RenderPipeline&quot;=&quot;UniversalPipeline&quot;            &quot;RenderType&quot;=&quot;Opaque&quot;        &#125;        Pass &#123;            HLSLPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;            struct appdata &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;            &#125;;            v2f vert(appdata v) &#123;                v2f o;                o.pos = TransformObjectToHClip(v.vertex);                o.worldNormal = TransformObjectToWorldNormal(v.normal);                return o;            &#125;            half4 frag(v2f i) : SV_Target &#123;                return half4(i.worldNormal * 0.5 + 0.5, 1.0);            &#125;            ENDHLSL        &#125;    &#125;&#125;\r\n","slug":"Rendering/UpdateToURPPipeline/Chapter1_BasicUnlitShader","date":"2023-04-04T13:32:05.000Z","categories_index":"Unity","tags_index":"Unity,Shader,URP Pipeline","author_index":"JBR_Bunjie"},{"id":"edde6f65aa71985a04dfce2cbb091e0c","title":"Chapter0 - URP 管线分析系列概览","content":"Chapter0 - URP\r\n管线分析系列概览\r\n章节安排\r\n\r\nChapter 1：Unity URP 管线 自定义Shader 小节全内容\r\nChapter 2：了解 URP 管线下的光与影\r\nChapter 3：URP 管线默认 Shader：Lit.shader 分析\r\nChapter 4：URP 管线下卡通渲染 Shader 的编写\r\nChapter 5：\r\n\r\n步入 URP Pipline 之前\r\n我们已经知道，Unity Shader 入门精要中所使用的渲染管线是 built-in\r\n管线，这种管线庞大、笨重、可定制性差。虽然 Unity 早早地就将 built-in\r\n管线开源，但是这并不能掩盖管线本身的缺点。\r\n于是，Unity 官方推出了 SRP 管线。同时，还给出了 URP 和 HDRP 管线，SRP\r\n管线有很多好处，而现在我们需要做的，就是开始 URP 管线和 SRP\r\n管线的学习。\r\n切换到 URP 管线\r\n文档：\r\n\r\nActivating URP, HDRP, or a custom render pipeline based on\r\nSRP\r\nTo set the active render pipeline to one that is based on SRP, tell\r\nUnity which Render Pipeline Asset to use as the default active render\r\npipeline, and optionally which Render Pipeline Assets to use for each\r\nquality level.\r\nTo do this:\r\n\r\nIn your Project folder, locate the Render Pipeline Asset(s) that\r\nyou want to use.\r\nSet the default render pipeline, which Unity uses when there is\r\nno override for a given quality level. If you do not set this, Unity\r\nuses the Built-in Render Pipeline when no override applies.\r\nSelect Edit &gt; Project\r\nSettings &gt; Graphics.\r\nDrag the Render Pipeline Asset on to the Scriptable\r\nRender Pipeline Setting field.\r\nOptional\r\n\r\n: Set override Render Pipeline Assets for different quality\r\nlevels.\r\n1. Select **Edit** &gt; **Project Settings** &gt; **Quality**.\r\n2. Drag the Render Pipeline Asset on to the **Render Pipeline** field.\r\n\r\nSeries Main Reference：\r\n\r\nUnity\r\n- Manual: How to get, set, and configure the active render pipeline\r\n(unity3d.com)\r\n编写自定义着色器\r\n| Universal RP | 12.1.1 (unity3d.com)\r\n编写\r\nURP 着色器 | Alex Technical Art (cuihongzhi1991.github.io)\r\nUnityShader 入门精要-URP 管线 1. 关于 URP - 王子饼干的文章 - 知乎\r\nhttps://zhuanlan.zhihu.com/p/228582171\r\nUnity -\r\nManual: HLSL in Unity (unity3d.com)\r\n\r\n","slug":"Rendering/UpdateToURPPipeline/Chapter0","date":"2023-04-03T13:32:05.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"43a3ae9eb97a236c0b66c1ff3212a8e3","title":"Volumetric Cloud","content":"Volumetric Cloud\r\nBased On RayMarching\r\n求包围盒\r\n\"从摄像机发出射线，每次前进一点判断是否在体积雾包围盒范围内然后再采样计算颜色。我们通过计算摄像机与体积雾包围盒相交的点，直接从该交点沿射线方向前进，来减少无效的步进。\"\r\nReferece\r\n\r\n(80) FMX2017\r\nTechnical Directing Special: Real-time Volumetric Cloud Rendering -\r\nYouTube\r\n\r\n","slug":"Rendering/Volume Rendering/VolumeClouds","date":"2023-03-31T04:23:23.000Z","categories_index":"Unity,Shader","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"36e65544b0ba9be0c7ba1f8cd3f769cc","title":"Advanced CSharp","content":"Advanced CSharp\r\nreadonly, const &amp; static\r\nVirtual, Interface &amp;\r\nAbstract\r\nDelegate, Action, Func &amp;\r\nEvent\r\nDelegate\r\nQuick Start\r\n用实例快速了解 delegate：\r\n123456789101112131415public class Program &#123;    public delegate void TestDelegate();    private static void MyTestDelegateFunction() &#123;        Console.WriteLine(&quot;My Test&quot;);    &#125;    public static void Main(string[] args) &#123;        TestDelegate testDelegateFunction;        testDelegateFunction = MyTestDelegateFunction;        testDelegateFunction();    &#125;&#125;\r\n\r\nA delegate\r\nis a type that represents references to methods with a particular\r\nparameter list and return type. When you instantiate a delegate, you can\r\nassociate its instance with any method with a compatible signature and\r\nreturn type. You can invoke (or call) the method through the delegate\r\ninstance.\r\nDelegates\r\n- C# Programming Guide - C# | Microsoft Learn\r\n\r\nDelegates Overview\r\nDelegates have the following properties:\r\n\r\nDelegates are similar to C++ function pointers, but\r\ndelegates are fully object-oriented, and unlike C++ pointers to member\r\nfunctions, delegates encapsulate both an object instance and a\r\nmethod.\r\nDelegates allow methods to be passed as parameters.\r\nDelegates can be used to define callback methods.\r\nDelegates can be chained together; for example, multiple methods can\r\nbe called on a single event.\r\nMethods don't have to match the delegate type exactly. For more\r\ninformation, see Using\r\nVariance in Delegates.\r\nLambda expressions are a more concise way of writing inline code\r\nblocks. Lambda expressions (in certain contexts) are compiled to\r\ndelegate types. For more information about lambda expressions, see Lambda\r\nexpressions.\r\n\r\n简单来说，Delegate\r\n即委托，可以用于托管任意数量的、和自己定义了一样参数的函数，事实上，和委托形态最接近的数据结构是——链表。你也许会从这下面的例子中找到结论：\r\n123456789101112131415161718192021222324252627282930public class Program &#123;    public delegate void TestDelegate(int a, int b);    private static void MyTestDelegateFunction1(int i, int t) &#123;        Console.WriteLine(i + t);    &#125;    private static void MyTestDelegateFunction2(int x, int y) &#123;        Console.WriteLine(x * y);    &#125;    public static void Main(string[] args) &#123;        TestDelegate testDelegateFunction;        testDelegateFunction = MyTestDelegateFunction1;        // TestDelegate testDelegateFunction = new TestDelegate(MyTestDelegateFunction1);        testDelegateFunction += MyTestDelegateFunction2;        testDelegateFunction(2, 3);        testDelegateFunction -= MyTestDelegateFunction1;        testDelegateFunction(2, 3);    &#125;&#125;// Output:// 5// 6// 6\r\n当然，我们也可以改写上面这个例子：\r\n12345678910public class Program &#123;    public delegate void TestDelegate(int a, int b);    public static void Main(string[] args) &#123;        TestDelegate testDelegateFunction = (int i, int t) =&gt; &#123; Console.WriteLine(i + t); &#125;;        testDelegateFunction += (int x, int y) =&gt; &#123; Console.WriteLine(x * y); &#125;;        testDelegateFunction(2, 3);    &#125;&#125;\r\n但是使用 Lambda 表达的另一个问题是——由于我们没有函数标识，我们无法从\r\ndelegate 中移除对应的函数了！\r\nAction&amp;Func\r\n一些区别\r\n首先注意的是，我们这样去创建一个 Action：\r\n1Action&lt;float&gt; TestAction;\r\n注意和 Delegate 的区别——是的，这里没有返回值\r\n让我们转向 Func：\r\n1Func&lt;bool&gt; TestFunc;\r\n简直是和 Action 如出一辙！那这两者的功能各自又是什么？\r\n使用\r\n让我们依然使用实例来了解具体细节：\r\n123456789101112public class Program &#123;    public static void Main(string[] args) &#123;        Action&lt;float, float&gt; testAction;        Func&lt;bool&gt; testFunc;        testAction = (float a, float b) =&gt; &#123; Console.WriteLine(a * b); &#125;;        testFunc = () =&gt; &#123; return false; &#125;;        testAction(3, 4);        Console.WriteLine(testFunc());    &#125;&#125;\r\n你可能已经猜到了：Action 是只接受输入的函数委托，Func\r\n则是以输出为主的函数委托。\r\n欸？为什么是“为主”？让我们借用一下这两张图：\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\nAction: Action\r\nDelegate (System) | Microsoft Learn\r\nFunc: Func\r\nDelegate (System) | Microsoft Learn\r\n\r\n为什么需要 Action&amp;Func？\r\n当我们使用 Delegate\r\n时，我们一共做了两部：先显式定义委托本身，然后再用委托实例去完成过程，但是当使用\r\nAction&amp;Func 时，我们的代码结构就可以得到省略：\r\n1234567891011121314151617// From：public class Program &#123;    public delegate int explicitDelegate(int a, int b);    public static void Main(string[] args) &#123;        explicitDelegate a = (int i, int t) =&gt; &#123; return i * t; &#125;;        Console.WriteLine(a(3, 4));    &#125;&#125;// To：public class Program &#123;    public static void Main(string[] args) &#123;        Func&lt;int, int, int&gt; a = (int i, int t) =&gt; &#123; return i * t; &#125;;        Console.WriteLine(a(3, 4));    &#125;&#125;\r\n什么时候会用到委托？\r\n让我们看向这样一个例子：\r\n1234567891011121314151617using UnityEngine;public class ActionOnTimer : MonoBehaviour&#123;    private float timer;    public void SetTimer(float timer) &#123;        this.timer = timer;    &#125;    private void Update() &#123;        timer -= Time.deltaTime;    &#125;    public bool IsTimerComplete() &#123;        return timer &lt;= Of;    &#125;&#125;\r\n可以看到，这是一个计时器，timer 是我们的定时。如果我们希望 1s\r\n后做点什么？\r\n1234567891011121314151617using UnityEngine;public class Testing : MonoBehaviour&#123;    [SerializeField] private ActionOnTimer actionOnTimer;    private bool hasTimerElapsed;    private void start() &#123;        actionOnTimer.SetTimer(1f);    &#125;    private void Update() &#123;        if (!hasTimerElapsed &amp;&amp; actionOnTimer.IsTimerComplete()) &#123;            Debug.Log(&quot;Timer complete!&quot;);            hasTimerElapsed = true;        &#125;    &#125;&#125;\r\n好，好。我们已经在 1s\r\n后做了点事，不过我们的实现确实称不上好...我们将太多的逻辑延申了出来——如果\r\nActionOnTimer 可以更紧凑就好了。\r\n让我们用 delegate 来改造原始的 ActionOnTimer：\r\n1234567891011121314151617181920212223using UnityEngine;public class ActionOnTimer : MonoBehaviour&#123;    private Action timeCallback;    private float timer;    public void SetTimer(float timer, Action timeCallback) &#123;        this.timeCallback = timeCallback;        this.timer = timer;    &#125;    private void Update() &#123;        if (timer &gt; 0f) &#123;            timer -= Time.deltaTime;            if (IsTimerComplete()) timerCallback();        &#125;    &#125;    public bool IsTimerComplete() &#123;        return timer &lt;= Of;    &#125;&#125;\r\n那现在？现在我们的调用就可以相当紧凑了：\r\n12345678using UnityEngine;public class Testing : MonoBehaviour&#123;    [SerializeField] private ActionOnTimer actionOnTimer;    private void start() &#123;        actionOnTimer.SetTimer(1f, () =&gt; &#123; Debug.Log(&quot;Timer Complete&quot;); &#125;);    &#125;&#125;\r\n是不是很简单？\r\n特别的，我在这里列举了一些我们在委托中需要注意的事情：\r\n\r\n多播委托的坑 - 知乎\r\n(zhihu.com)\r\n\r\n另外需要提到的一点是，Unity 里存在一个\r\nUnityAction，你也许会好奇这是什么：\r\n\r\nActually UnityAction&lt;T&gt; and\r\nSystem.Action&lt;T&gt; are both the same generic delegate\r\ndeclarations, just seperate reimplementations. AFAIK UnityEvents used\r\nSystem.Actions in the past and just recently switched to their own\r\nversion. Both are not really serializable since they are just plain C#\r\ndelegate which are generally hard up to implossible to serialize. So the\r\nexact reason why they shipped their own version is kinda unclear. For me\r\nthe most sound explanation would be the independence from the System\r\nnamespace / mscorlib implementation. Though that's just speculation.\r\nBe warned that even though both generic delegate are implemented\r\nexactly the same, doesn't make them compatible to each other out of the\r\nbox. A cast should be possible though.\r\nWhat's\r\nthe difference between UnityAction and C# Actions? - Unity Forum\r\n\r\n具体采用则可以参考：Why\r\nchoose UnityEvent over native C# events? - Stack Overflow\r\nEvent\r\n那让我们继续，下面是 Event——一种特殊的委托\r\n\r\nEvents enable a class\r\nor object to notify other classes or objects when something of interest\r\noccurs. The class that sends (or raises) the event is called\r\nthe publisher and the classes that receive (or handle)\r\nthe event are called subscribers.\r\nEvents\r\n- C# Programming Guide - C# | Microsoft Learn\r\n\r\n也就是说，Event 下鲜明地存在两种角色：Publishers 和\r\nSubscribers，并且这是一个一对多的关系：由 Publishers 发出事件并且由\r\nSubscribers 接收。有没有想起什么？对，这看上去就和观察者模式很像！\r\n\r\n随便打开电脑中的一个应用，很有可能它就使用了MVC 架构，\r\n而究其根本，是因为观察者模式。 观察者模式应用广泛，Java\r\n甚至将其放到了核心库之中（java.util.Observer），而\r\nC#直接将其嵌入了语法（event关键字）。\r\n观察者模式 · Design\r\nPatterns Revisited · 游戏设计模式 (tkchu.me)\r\n\r\n但是我们这里是 event 的 part，所以让我们回到 event\r\n本身上来——还是看看代码吧：\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;namespace SimpleEvent &#123;  /***********发布器类***********/  public class EventTest &#123;    private int value;    public delegate void NumManipulationHandler();    public event NumManipulationHandler ChangeNum;    protected virtual void OnNumChanged() &#123;      if ( ChangeNum != null ) &#123;        ChangeNum(); /* 事件被触发 */      &#125; else &#123;        Console.WriteLine( &quot;event not fire&quot; );        Console.ReadKey(); /* 回车继续 */      &#125;    &#125;    public EventTest() &#123;      int n = 5;      SetValue( n );    &#125;    public void SetValue( int n ) &#123;      if ( value != n ) &#123;        value = n;        OnNumChanged();      &#125;    &#125;  &#125;  /***********订阅器类***********/  public class subscribEvent &#123;    public void printf() &#123;      Console.WriteLine( &quot;event fire&quot; );      Console.ReadKey(); /* 回车继续 */    &#125;  &#125;  /***********触发***********/  public class MainClass &#123;    public static void Main() &#123;      EventTest e = new EventTest(); /* 实例化Publisher对象 */      subscribEvent v = new subscribEvent(); /* 实例化Subscriber对象 */      e.ChangeNum += new EventTest.NumManipulationHandler( v.printf ); /* 注册 */      e.SetValue( 7 );      e.SetValue( 11 );    &#125;  &#125;&#125;\r\n事实上，event 使用流程都大体如下：\r\n\r\n\r\nNo alt text provided for this\r\nimage\r\n\r\n可以发现，event 是对 delegate\r\n的一层额外包装，它在执行上看仍然可以看作是一个 delegate，发挥着 delegate\r\n的功能。那为什么我们还需要 event？\r\n\r\nDelegates\r\nvs. events - C# | Microsoft Learn\r\n\r\n另外，这里是存在一些预制的 delegate 的，比如我们将用到的\r\neventHandler\r\n\r\n1public delegate void EventHandler(object? sender, EventArgs e);\r\nEventHandler\r\nDelegate (System) | Microsoft Learn\r\n\r\n1234567891011121314151617181920212223242526272829// Publishersusing System;using UnityEngine;public class TestingEvents : MonoBehaviour &#123;    public event EventHandler OnSpacePressed;    private void Update() &#123;        if (Input.GetKeyDown(KeyCode.Space)) &#123;            OnSpacePressed?.Invoke(this, EventArgs.Empty);        &#125;    &#125;&#125;// Subscribersusing System;using UnityEngine;public class TestingEventSubscriber : MonoBehaviour &#123;    private void Start() &#123;        TestingEvents testingEvents = GetComponent&lt;TestingEvents&gt;();        testingEvents.OnSpacePressed += TestingEvents_OnSpacePressed;    &#125;    // We should match the signature of target event    private void TestingEvents_OnSpacePressed(object sender, EventArgs e) &#123;        Debug.Log(&quot;Space!&quot;);    &#125;&#125;\r\n另外需要介绍的是 EventHandler 支持的泛型：\r\n123456789101112131415161718192021222324252627282930313233343536// Publishersusing System;using UnityEngine;public class TestingEvents : MonoBehaviour &#123;    public event EventHandler&lt;OnSpacePressedEventArgs&gt; OnSpacePressed;    public class OnSpacePressedEventArgs : EventArgs &#123;        public int pressedCount;    &#125;    private int pressedCount;    private void Update() &#123;        if (Input.GetKeyDown(KeyCode.Space)) &#123;            pressedCount++;            OnspacePressed?.Invoke(this, new OnSpacePressedEventArgs&#123; pressedCount = pressedCount &#125;);        &#125;    &#125;&#125;// Subscribersusing System;using UnityEngine;public class TestingEventSubscriber : MonoBehaviour &#123;    private void Start() &#123;        TestingEvents testingEvents = GetComponent&lt;TestingEvents&gt;();        testingEvents.OnSpacePressed += TestingEvents_OnSpacePressed;    &#125;    // We should match the signature of target event    private void TestingEvents_OnSpacePressed(object sender, TestingEvents.OnSpacePressedEventArgs e) &#123;        Debug.Log(&quot;Space!&quot; + e.pressedCount);    &#125;&#125;\r\n\r\nThe EventHandler&lt;TEventArgs&gt; delegate is a predefined delegate\r\nthat represents an event handler method for an event that generates\r\ndata. The advantage of using EventHandler&lt;TEventArgs&gt; is that you\r\ndo not need to code your own custom delegate if your event generates\r\nevent data. You simply provide the type of the event data object as the\r\ngeneric parameter.\r\n\r\n小结\r\n就让我们这样归类这三者吧：\r\n\r\nDelegate：链表形式的、面向对象的函数指针。接收一致参数的函数委托，并同时执行所有受委托的函数输出结果。同时，Delegate\r\n是既接收输入，又能完成输出的类型。\r\nAction&amp;Func：对 Delegate\r\n在不同方面的“简化”，能让代码逻辑更加清晰。\r\nEvent：观察者模式的直接实现，Delegate 的特化\r\n\r\nAttribute 与 Reflection\r\n元数据\r\n有关程序及其类型的数据被称为元数据（metadata），它们保存在程序的程序集中。可以这样来形象了解元数据：\r\n\r\n我们先假装 C#没有反射吧！我现在要你在 C#上实现一个函数。函数参数是\r\nObject，函数的功能就是执行这个类内所有参数为空的公有成员方法。好了，你写吧！\r\n...\r\n...\r\n\"这怎么可能写的出来啊！！运行时获取类里面的所有成员方法！类里有啥成员方法只有编译器和写类的程序员才知道吧！！\"\r\n没错...那么如果允许你，在类里加点东西，来实现这个功能呢？\r\n那好像就简单了...\r\n我们可以这样:\r\n\r\n把 C#这个函数的参数限定一下，参数类型改为 MyObject\r\n写一个 class MyObject，让所有类都继承自 class MyObject;MyObject\r\n内只实现一个方法:public FuncData[] getFuncData();\r\n声明 struct FuncData;FuncData\r\n里就几个属性:返回值类型、函数名称、参数列表(参数类型、名称)\r\n给每个类都手写一个 FuncData 的表\r\n\r\n4\r\n实现起来好像很麻烦，又臭又长又机械...但是到此为止，你基本上就是实现了一个很简单的反射功能了...\r\n好了，然后聪明的你应该就知道了，C#默认就实现了以上功能，也就是说\r\nC#编译器默认就会帮你写好这个 FuncData——和\r\nPropData(类内所有属性的数据表)，他们被合称为 MetaData，元数据。\r\nC#反射呢，就是基于 MetaData\r\n实现的，一个能让代码在执行的时候，知道代码(类)们的属性的一个功能。\r\nhttps://www.zhihu.com/question/308374020/answer/621704342\r\n另：关于 Type：Type\r\nClass (System) | Microsoft Learn\r\n\r\nAttribute\r\n\r\n类 Attribute\r\n将预定义的系统信息或用户定义的自定义信息与目标元素相关联。\r\n目标元素可以是程序集、类、构造函数、委托、枚举、事件、字段、接口、方法、可移植可执行文件模块、参数、属性、返回值、结构或其他属性。\r\nAttribute 提供的信息也称为元数据。\r\n应用程序可以在运行时检查元数据，以控制程序处理数据的方式，或者在运行时之前由外部工具检查元数据，以控制应用程序本身的处理或维护方式。\r\n例如，.NET\r\n预定义并使用属性类型来控制运行时行为，某些编程语言使用属性类型来表示\r\n.NET 通用类型系统不直接支持的语言功能。\r\nAttribute\r\n类 (System) | Microsoft Learn\r\n\r\n是的，Attribute\r\n是用来添加元数据的，如编译器指令和注释、描述、方法、类等其他信息。.Net\r\n框架提供了两种类型的特性：预定义特性和自定义特性。\r\n预定义特性\r\n\r\n为了构造自定义特性，我们得先了解一些预定义的\r\n\r\n.Net 框架提供了三种预定义特性：\r\n\r\nAttributeUsage\r\nConditional\r\nObsolete\r\n\r\n这里列举了两个我们可能会经常见到的：\r\nAttributeUsage\r\n预定义特性 AttributeUsage\r\n描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。\r\n规定该特性的语法如下：\r\n12345[AttributeUsage(   validon,   AllowMultiple=allowmultiple,   Inherited=inherited)]\r\n其中：\r\n\r\n参数 validon 规定特性可被放置的语言元素。它是枚举器\r\nAttributeTargets 的值的组合。默认值是\r\nAttributeTargets.All。\r\n参数 allowmultiple（可选的）为该特性的\r\nAllowMultiple 属性（property）提供一个布尔值。如果为\r\ntrue，则该特性是多用的。默认值是 false（单用的）。\r\n参数 inherited（可选的）为该特性的 Inherited\r\n属性（property）提供一个布尔值。如果为\r\ntrue，则该特性可被派生类继承。默认值是 false（不被继承）。\r\n\r\n我们后方的用例就存在该特性。\r\nObsolete\r\n这是一个我们经常会见到的特性，它标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为\r\nobsolete（过时的）。\r\n规定该特性的语法如下：\r\n1[Obsolete(message, iserror=false)]\r\n其中：\r\n\r\n参数\r\nmessage，是一个字符串，描述项目为什么过时以及该替代使用什么。\r\n参数 iserror，是一个布尔值。如果该值为\r\ntrue，编译器应把该项目的使用当作一个错误。默认值是\r\nfalse（编译器生成一个警告）。\r\n\r\n下面的实例演示了该特性：\r\n12345678910111213using System;public class MyClass &#123;   [Obsolete(&quot;Don&#x27;t use OldMethod, use NewMethod instead&quot;, true)]   static void OldMethod() &#123;      Console.WriteLine(&quot;It is the old method&quot;);   &#125;   static void NewMethod() &#123;      Console.WriteLine(&quot;It is the new method&quot;);   &#125;   public static void Main() &#123;      OldMethod();   &#125;&#125;\r\n当尝试编译该程序时，编译器会给出一个错误消息说明：\r\n1Don&#x27;t use OldMethod, use NewMethod instead\r\n自定义特性\r\n\r\n在 C# 中，特性是继承自 Attribute 基类的类。\r\n\r\n通过定义继承自 Attribute 基类的新类来创建特性。\r\n1public class MySpecialAttribute : Attribute &#123;&#125;\r\n通过上述代码，可在基本代码中的其他位置将 [MySpecial]（或\r\n[MySpecialAttribute]）用作特性。\r\n12[MySpecial]public class SomeOtherClass &#123;&#125;\r\n我们需要继续充实这个自定义特性，才能得到一个真正可用的自定义特性：\r\n\r\n让我们构建一个名为 DeBugInfo\r\n的自定义特性，该特性将存储调试程序获得的信息。它存储下面的信息：\r\n\r\nbug 的代码编号\r\n辨认该 bug 的开发人员名字\r\n最后一次审查该代码的日期\r\n一个存储了开发人员标记的字符串消息\r\n\r\n每个特性必须至少有一个构造函数。必需的 定位(positional)\r\n参数应通过构造函数传递。下面的代码演示了 DeBugInfo 类：\r\n\r\n123456789101112131415161718192021222324252627282930// 一个自定义特性 BugFix 被赋给类及其成员[AttributeUsage(    AttributeTargets.Class |    AttributeTargets.Constructor |    AttributeTargets.Field |    AttributeTargets.Method |    AttributeTargets.Property,    AllowMultiple = true)]public class DeBugInfo : Attribute &#123;    private int bugNo;    private string developer;    private string lastReview;    public string message;    public DeBugInfo(int bg, string dev, string d) &#123;        this.bugNo = bg;        this.developer = dev;        this.lastReview = d;    &#125;    public int BugNo &#123; get &#123; return bugNo; &#125; &#125;    public string Developer &#123; get &#123; return developer; &#125; &#125;    public string LastReview &#123; get &#123; return lastReview; &#125; &#125;    public string Message &#123;        get &#123; return message; &#125;        set &#123; message = value; &#125;\t&#125;&#125;\r\n还是一样，我们通过把特性放置在紧接着它的目标之前，来应用该特性：\r\n123456789101112131415161718192021[DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12/8/2012&quot;, Message = &quot;Return type mismatch&quot;)][DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10/10/2012&quot;, Message = &quot;Unused variable&quot;)]class Rectangle &#123;  // 成员变量  protected double length;  protected double width;  public Rectangle(double l, double w) &#123;      length = l;      width = w;  &#125;  [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;, Message = &quot;Return type mismatch&quot;)]  public double GetArea() &#123;      return length * width;  &#125;  [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;)]  public void Display()&#123;      Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);      Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);      Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());  &#125;&#125;\r\n可是，我们的特性没有对这段代码产生任何实质性的影响。我们还需要做些什么？\r\n\r\nThe fact that you can define custom attributes and place them in your\r\nsource code would be of little value without some way of retrieving that\r\ninformation and acting on it. By using reflection, you can retrieve the\r\ninformation that was defined with custom attributes. The key method is\r\nGetCustomAttributes, which returns an array of objects that\r\nare the run-time equivalents of the source code attributes.\r\nAccess\r\nattributes using reflection - C# | Microsoft Learn\r\n\r\nReflection\r\n\r\n反射指程序可以访问、检测和修改它本身状态或行为的一种能力。\r\n\r\n对于一个特性来说，其具体的执行，例如：\r\n12[Author(&quot;P. Ackerman&quot;, Version = 1.1)]class SampleClass &#123; &#125;\r\n在概念上等效于以下代码：\r\n123var anonymousAuthorObject = new Author(&quot;P. Ackerman&quot;) &#123;    Version = 1.1&#125;;\r\n但是，在为特性查询 SampleClass 之前，代码将不会执行。\r\n而对 SampleClass 调用 GetCustomAttributes\r\n则会导致构造并初始化一个 Author 对象。\r\n如果该类具有其他特性，则将以类似方式构造其他特性对象。 然后\r\nGetCustomAttributes 会以数组形式返回 Author\r\n对象和任何其他特性对象。\r\n之后你便可以循环访问此数组，根据每个数组元素的类型确定所应用的特性，并从特性对象中提取信息。关于\r\nGetCustomAttributes，可见：MemberInfo.GetCustomAttributes\r\nMethod (System.Reflection) | Microsoft Learn\r\n下面是完整的示例。\r\n定义自定义特性、将其应用于多个实体，并通过反射对其进行检索：\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Multiuse attribute.[System.AttributeUsage(System.AttributeTargets.Class |                       System.AttributeTargets.Struct,                       AllowMultiple = true)  // Multiuse attribute.]public class AuthorAttribute : System.Attribute &#123;    string Name;    public double Version;    public AuthorAttribute(string name) &#123;        Name = name;        Version = 1.0;    &#125;    public string GetName() =&gt; Name;&#125;// Class with the Author attribute.[Author(&quot;P. Ackerman&quot;)]public class FirstClass &#123;    // ...&#125;// Class without the Author attribute.public class SecondClass &#123;    // ...&#125;// Class with multiple Author attributes.[Author(&quot;P. Ackerman&quot;), Author(&quot;R. Koch&quot;, Version = 2.0)]public class ThirdClass &#123;    // ...&#125;class TestAuthorAttribute &#123;    public static void Main(string[] args) &#123;        PrintAuthorInfo(typeof(FirstClass));        PrintAuthorInfo(typeof(SecondClass));        PrintAuthorInfo(typeof(ThirdClass));    &#125;    private static void PrintAuthorInfo(System.Type t) &#123;        System.Console.WriteLine($&quot;Author information for &#123;t&#125;&quot;);        // Using reflection.        System.Attribute[] attrs = System.Attribute.GetCustomAttributes(t);  // Reflection.        // Displaying output.        foreach (System.Attribute attr in attrs) &#123;            if (attr is AuthorAttribute a) &#123; // see https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#declaration-and-type-patterns                System.Console.WriteLine($&quot;   &#123;a.GetName()&#125;, version &#123;a.Version:f&#125;&quot;);            &#125;        &#125;    &#125;&#125;/* Output:    Author information for FirstClass       P. Ackerman, version 1.00    Author information for SecondClass    Author information for ThirdClass       R. Koch, version 2.00       P. Ackerman, version 1.00*/\r\n可以看到的是，我们提取出了注解中的全部信息。知道了这一办法后，我们就可以反过来完善\r\nAttribute 的例子了！\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104using System;using System.Reflection;namespace BugFixApplication&#123;    // 一个自定义特性 BugFix    [AttributeUsage(AttributeTargets.Class |    AttributeTargets.Constructor |    AttributeTargets.Field |    AttributeTargets.Method |    AttributeTargets.Property,    AllowMultiple = true)]    public class DeBugInfo : Attribute &#123;        private int bugNo;        private string developer;        private string lastReview;        public string? message;        public DeBugInfo(int bg, string dev, string d) &#123;            this.bugNo = bg;            this.developer = dev;            this.lastReview = d;        &#125;        public int BugNo &#123; get &#123; return bugNo; &#125; &#125;        public string Developer &#123; get &#123; return developer; &#125; &#125;        public string LastReview &#123; get &#123; return lastReview; &#125; &#125;        public string? Message &#123;            get &#123; return message; &#125;            set &#123; message = value; &#125;        &#125;\t&#125;   [DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12/8/2012&quot;, Message = &quot;Return type mismatch&quot;)]   [DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10/10/2012&quot;, Message = &quot;Unused variable&quot;)]   class Rectangle &#123;      // 成员变量      protected double length;      protected double width;      public Rectangle(double l, double w) &#123;         length = l;         width = w;      &#125;      [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;, Message = &quot;Return type mismatch&quot;)]      public double GetArea() &#123;         return length * width;      &#125;      [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;)]      public void Display() &#123;         Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);         Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);         Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());      &#125;   &#125;      class ExecuteRectangle &#123;      static void Main(string[] args) &#123;         Rectangle r = new Rectangle(4.5, 7.5);         r.Display();         Type type = typeof(Rectangle);         // 遍历 Rectangle 类的特性         foreach (Object attributes in type.GetCustomAttributes(false)) &#123;            if (attributes is DeBugInfo dbi) &#123;               Console.WriteLine(&quot;Bug no: &#123;0&#125;&quot;, dbi.BugNo);               Console.WriteLine(&quot;Developer: &#123;0&#125;&quot;, dbi.Developer);               Console.WriteLine(&quot;Last Reviewed: &#123;0&#125;&quot;, dbi.LastReview);               Console.WriteLine(&quot;Remarks: &#123;0&#125;&quot;, dbi.Message);            &#125;         &#125;                  // 遍历方法特性         foreach (MethodInfo m in type.GetMethods()) &#123;            foreach (Attribute a in m.GetCustomAttributes(true)) &#123;               if (a is DeBugInfo dbi) &#123;                  Console.WriteLine(&quot;Bug no: &#123;0&#125;, for Method: &#123;1&#125;&quot;, dbi.BugNo, m.Name);                  Console.WriteLine(&quot;Developer: &#123;0&#125;&quot;, dbi.Developer);                  Console.WriteLine(&quot;Last Reviewed: &#123;0&#125;&quot;, dbi.LastReview);                  Console.WriteLine(&quot;Remarks: &#123;0&#125;&quot;, dbi.Message);               &#125;            &#125;         &#125;      &#125;   &#125;&#125;/* Output:    Length: 4.5    Width: 7.5    Area: 33.75    Bug No: 49    Developer: Nuha Ali    Last Reviewed: 10/10/2012    Remarks: Unused variable    Bug No: 45    Developer: Zara Ali    Last Reviewed: 12/8/2012    Remarks: Return type mismatch    Bug No: 55, for Method: GetArea    Developer: Zara Ali    Last Reviewed: 19/10/2012    Remarks: Return type mismatch    Bug No: 56, for Method: Display    Developer: Zara Ali    Last Reviewed: 19/10/2012    Remarks:*/\r\n更多可见：\r\n\r\n教程：定义和读取自定义特性。\r\n- C# | Microsoft Learn\r\nC#之玩转反射\r\n- y-z-f - 博客园 (cnblogs.com)\r\n[C#]理解和入门依赖注入 -\r\n知乎 (zhihu.com)\r\n【C#入门详解\r\n16】-反射、依赖注入 - 知乎 (zhihu.com)\r\n\r\n?、??、?.、is\r\n??\r\n1value ?? expression\r\n?? 会判断 value 是否为 null，如果是则执行\r\nexpression，而不是则返回 value。\r\n另外，??\r\n运算符要求两个操作数都具有相同的类型或可以隐式转换为相同的类型。\r\n因此，这样的书写便是不符合规则的\r\n123456789101112class Program &#123;    static A ab;    public static void NewA() &#123;        ab = new A();    &#125;    public static void Main(string[] args)&#123;        ab = ab ?? NewA();    &#125;&#125;public class A &#123;&#125;\r\n应该是这样的：\r\n123456789101112class Program &#123;    static A ab;    public static A NewA() &#123;        return new A();    &#125;    public static void Main(string[] args) &#123;        ab = ab ?? NewA();    &#125;&#125;public class A &#123;&#125;\r\n?.invode\r\n多线程\r\n线程\r\nTask\r\nUnity 协程 Coroutine\r\n\r\nUnity\r\n开发不可避免的要用到协程(Coroutine)，协程能在同步代码中做异步任务，避免了异步操作加回调的\r\n编码 方式\r\n\r\n\r\n聊一聊\r\nUnity 协程背后的实现原理 - iwiniwin - 博客园 (cnblogs.com)\r\nC#图解教程之枚举器和迭代器｜\r\nZhendong's blog (hzd.plus)\r\nUnity\r\n协程的原理与应用 - 知乎 (zhihu.com)\r\n\r\nDOTS\r\nDOTS 即 Data Oriented Technology Stack，是 Unity\r\n关于面向数据编程的一系列技术栈\r\n在正式介绍 DOTS\r\n之前，我想你应该先了解一下什么是面向数据编程，你也许需要先读下这篇文章：\r\n","slug":"Language Learning/AdvancedCSharp","date":"2023-03-19T04:23:23.000Z","categories_index":"C#,Language Learning","tags_index":"C#,Language Learning","author_index":"JBR_Bunjie"},{"id":"41644c3248ea1210fc5e02792aa4d4c9","title":"Shader Book Github Issue Collections","content":"Shader Book Github Issue\r\nCollections\r\nsaturate\r\n和 max · Issue #198 · candycat1992/Unity_Shaders_Book\r\n(github.com)\r\n为什么后来从 sature 改到了 max？\r\n\r\n\r\nQ: 在基础光照那一章中，我看到计算 worldNormal 与 worldLightDir\r\n的时候用的是 saturate，而后面章节使用的是\r\nmax（0，…），这两个方法在计算结果上会产生什么差异吗？\r\n\r\n\r\nA: 对于那些值范围在-1 到 1\r\n的变量，两个方法在计算结果上没有区别。不过，saturate 在 Unity\r\n里通常会编译成两个指令，大致是 min(max(val, 0.0),\r\n1.0)，如果自己知道值的范围可以直接使用 max 来节省一条运算指令。\r\n\r\n\r\nAQ: 我在 Unity 里面，点 Shader 属性中 “Compile and show\r\ncode”按钮，看到\r\n12u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\r\n对应的是\r\nsaturate(dot(lightDir, worldNormal));。所以应该不是解析成\r\nmin(max(val, 0.0), 1.0)吧？\r\n因为今天看到《Real-time Rendering 3rd》5.5 节 115 页 中提到\r\n\r\nstaturate is faster than the more general\r\nmax function on most hardware.\r\n\r\n所以有点奇怪。\r\n\r\n\r\nAA: @alasja\r\n我之前的回答的确说得很模糊，这里补充下。\r\n在 Unity 里，同一份 ShaderLab\r\n代码在不同目标平台上、甚至不同设备上编译结果都是不同的。比如同样一份\r\nfragment shader：\r\n123456fixed4 frag (v2f i) : SV_Target&#123;\tfixed4 col = i.uv.xyxy;\tcol = saturate(col);\treturn col;&#125;\r\n在 DX9 下，编译出来就是：\r\n12345678910-- Fragment shader for &quot;d3d9&quot;:// Stats: 1 mathShader Disassembly://// Generated by Microsoft (R) HLSL Shader Compiler 10.1    ps_3_0    dcl_texcoord_pp v0.xy    mov_sat_pp oC0, v0.xyxy// approximately 1 instruction slot used\r\nDX11 下就是：\r\n1234567891011121314151617181920212223242526-- Fragment shader for &quot;d3d11&quot;:Shader Disassembly://// Generated by Microsoft (R) D3D Shader Disassembler////// Input signature://// Name                 Index   Mask Register SysValue  Format   Used// -------------------- ----- ------ -------- -------- ------- ------// TEXCOORD                 0   xy          0     NONE   float   xy// SV_POSITION              0   xyzw        1      POS   float////// Output signature://// Name                 Index   Mask Register SysValue  Format   Used// -------------------- ----- ------ -------- -------- ------- ------// SV_Target                0   xyzw        0   TARGET   float   xyzw//      ps_4_0      dcl_input_ps linear v0.xy      dcl_output o0.xyzw   0: mov_sat o0.xyzw, v0.xyxy   1: ret// Approximately 0 instruction slots used\r\nOpenGL ES2.0 下是：\r\n12345678910111213#ifdef FRAGMENTvarying highp vec2 xlv_TEXCOORD0;void main ()&#123;  lowp vec4 col_1;  highp vec4 tmpvar_2;  tmpvar_2 = xlv_TEXCOORD0.xyxy;  col_1 = tmpvar_2;  lowp vec4 tmpvar_3;  tmpvar_3 = clamp (col_1, 0.0, 1.0);  col_1 = tmpvar_3;  gl_FragData[0] = tmpvar_3;&#125;\r\nOpenGLES 3.0 下是：\r\n123456789101112131415161718#ifdef FRAGMENT#version 300 esprecision highp int;in highp vec2 vs_TEXCOORD0;layout(location = 0) out mediump vec4 SV_Target0;void main()&#123;    SV_Target0 = vs_TEXCOORD0.xyxy;#ifdef UNITY_ADRENO_ES3    SV_Target0 = min(max(SV_Target0, 0.0), 1.0);#else    SV_Target0 = clamp(SV_Target0, 0.0, 1.0);#endif    return;&#125;#endif\r\nMetal 下是：\r\n1234567891011121314151617181920212223-- Fragment shader for &quot;metal&quot;:Shader Disassembly:#include &lt;metal_stdlib&gt;#include &lt;metal_texture&gt;using namespace metal;struct Mtl_FragmentIn&#123;    float2 TEXCOORD0 [[ user(TEXCOORD0) ]] ;&#125;;struct Mtl_FragmentOut&#123;    float4 SV_Target0 [[ color(0) ]];&#125;;fragment Mtl_FragmentOut xlatMtlMain(    Mtl_FragmentIn input [[ stage_in ]])&#123;    Mtl_FragmentOut output;    output.SV_Target0 = input.TEXCOORD0.xyxy;    output.SV_Target0 = clamp(output.SV_Target0, 0.0f, 1.0f);    return output;&#125;\r\nVulkan 太长了我就不粘贴了……\r\n你可以看出来在一些平台下，比如 DX9、DX11 下，编译出来的确是使用真正的\r\nsaturate 运算操作，而在大多数移动平台上，比如 ES 2.0、Metal\r\n等，是编译成了 clamp，而在 ES 3.0\r\n下跟设备还有关系。至于为什么要分这么多种情况，Unity\r\n应该是根据各个平台每种操作耗时的平衡，选择同等运算结果下最优的等价操作来代替\r\nsaturate。\r\n\r\n\r\n关于屏幕后处理效果的疑问\r\n· Issue #59 · candycat1992/Unity_Shaders_Book (github.com)\r\n\r\n的确，屏幕后处理本身本质上是在近裁剪平面处又渲染了一个四边形，这个四边形使用的是我们自定义的材质和\r\nshader，它的确本身会走一遍流水管线。\r\n网上说的它是“流水线的最后阶段”，是想指明我们操作的顺序，也就是说我们会在进行完其他物体的渲染后，最后进行这个操作。\r\n\r\n高斯模糊代码化简建议\r\n· Issue #194 · candycat1992/Unity_Shaders_Book (github.com)\r\n","slug":"Rendering/UnityShaderBook/ProblemCollections","date":"2023-03-08T13:29:45.000Z","categories_index":"Unity","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"2451d72464fab185c69a4d12737f61d9","title":"Unity Shader入门精要笔记 - Chapter12","content":"Unity Shader入门精要笔记 -\r\nChapter12\r\n\r\nIf you are doing a series of post-processing \"blits\", it's best for\r\nperformance to get and release a temporary render texture for each blit,\r\ninstead of getting one or two render textures upfront and reusing them.\r\nThis is mostly beneficial for mobile (tile-based) and multi-GPU systems:\r\nGetTemporary will internally do a DiscardContents\r\ncall which helps to avoid costly restore operations on the previous\r\nrender texture contents.\r\n\r\n","slug":"Rendering/UnityShaderBook/Chapter12","date":"2023-03-08T13:29:25.000Z","categories_index":"Unity","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"56562ce640a8509a88d7ae0465a97a36","title":"Unity Shader入门精要笔记 - Chapter9","content":"Chapter 9:\r\n更复杂的光照 - more complex lights\r\n\r\nLast Changed: 3/10/2023\r\n\r\n1. 渲染路径\r\nUnity渲染路径文档：\r\n\r\nUnity -\r\nManual: Rendering paths in the Built-in Render Pipeline\r\n(unity3d.com)\r\n\r\n关于书中提及的与编译指令 pragma multi_compile_fwdbase\r\n类似的官方文档：Unity\r\n- Manual: Declaring and using shader keywords in HLSL\r\n(unity3d.com)\r\n\r\n关于 shader variant，可以参考这篇文章：unity ShaderVariants处理 -\r\n知乎 (zhihu.com)\r\n\r\nYou can write shader snippets that share common\r\ncode, but have different functionality when a given keyword is enabled\r\nor disabled.\r\nWhen Unity compiles these shader snippets, it creates separate shader\r\nprograms for the different combinations of enabled and disabled\r\nkeywords. These individual shader programs are called shader\r\nvariants.\r\n\r\n\r\n简单来说，这种操作类似于，我们通过在Shader运行时动态的改变宏(这里是\r\nKeyword)的方式来动态得到我们需要的结果。\r\n\r\n利用Inspector来快速检测以及debug：[Unity]各种Debug方法笔记_unity\r\ndebug_HytMiao的博客-CSDN博客\r\n\r\nForward\r\n\r\nUnity\r\n- Manual: Forward rendering path (unity3d.com)\r\n\r\n\r\n\r\n\r\n\r\n\r\nforward_rendering.png-175.5kB\r\n\r\nDeferred\r\n\r\nUnity\r\n- Manual: Deferred Shading rendering path (unity3d.com)\r\n\r\nOverview\r\nWhen using deferred shading, there is no limit on the number of\r\nlights that can affect a GameObject. All lights are\r\nevaluated per-pixel, which means that they all interact correctly with\r\nnormal maps, etc. Additionally, all lights can have\r\ncookies and shadows.\r\nDeferred shading has the advantage that the processing overhead\r\nof lighting is proportional to the number of pixels the\r\nlight shines on. This is determined by the size of the light volume in\r\nthe Scene regardless of how many GameObjects it\r\nilluminates. Therefore, performance can be improved by keeping\r\nlights small. Deferred shading also has highly consistent and\r\npredictable behaviour. The effect of each light is computed per-pixel,\r\nso there are no lighting computations that break down on large\r\ntriangles.\r\nOn the downside, deferred shading has no real support for\r\nanti-aliasing and can’t handle semi-transparent GameObjects (these are\r\nrendered using forward\r\nrendering). There is also no support for the Mesh\r\nRenderer’s Receive Shadows flag and culling masks are\r\nonly supported in a limited way. You can only use up to four culling\r\nmasks. That is, your culling layer mask must at least\r\ncontain all layers minus four arbitrary layers, so 28 of the 32 layers\r\nmust be set. Otherwise you get graphical artifacts.\r\n\r\n\r\n2. 光源种类\r\n\r\n每一个光源有五个属性：\r\n\r\n位置\r\n方向\r\n颜色\r\n强度\r\n衰减\r\n\r\n\r\n平行光\r\n\r\n最简单的光源：\r\n\r\n影响范围无限大，因此，平行光光源的位置属性没有意义——它的几何属性只有方向\r\n光照强度没有衰减\r\n\r\n\r\n在场景中，一般只有太阳会作为平行光存在。Unity中默认场景中的初始光源即为Directional\r\nLight\r\n\r\n\r\ndirectional_ligth.png-51.6kB\r\n\r\n点光源\r\n\r\n\r\npoint_ligtht.png-89.4kB\r\n\r\n\r\n可以注意到场景中的 Sun 变为了一个 Lamp\r\n\r\n\r\n需要开启Scene视图中的光照才能看到效果\r\n\r\n聚光灯\r\n\r\n\r\nspot_light.png-74.5kB\r\n\r\n面光源\r\n仅用于烘培，\r\n光照衰减\r\n阴影\r\nUnity采用\"Screenspace Shadow\r\nMap\"即\"屏幕空间的阴影映射技术\"来实现阴影采样——Unity先调用\r\nLightMode 为 ShadowCaster\r\n的Pass来得到可投射阴影的光源的可投射阴影的光源的\r\n阴影映射纹理 以及摄像机的 深度纹理，根据光源的\r\n阴影映射纹理 和摄像机的 深度纹理\r\n来得到屏幕空间的 阴影图——如摄像机的 深度\r\n图中记录的表面深度大于转换到 阴影映射纹理\r\n中的深度值，就说明该表面虽然是可见的，但是却处于该光源的阴影中。\r\n当开始涉及阴影的计算时，我们会同时涉及到两方面的处理：\r\n\r\n一个物体接收别人投射的阴影——我们在Shader中对阴影映射纹理进行采样，并把采样结果与最后的光照结果相乘来得到最终的阴影效果\r\n一个物体向别的物体投射阴影——将当前物体加入对应光源的生成阴影映射纹理的计算过程中，从而让其他物体在对阴影纹理采样时可以得到相关信息\r\n\r\n\r\nunity中的坐标系：\r\nunity在模型空间和世界空间中使用的是左手坐标系，但在观察空间当中，unity改用右手坐标系——此时摄像机的前向为-z方向，而之前则对应+z方向；当最后变化到屏幕空间时，unity采用NDC坐标系——重新使用左手坐标系\r\n\r\n一个完整的Foward路径Shader\r\n1\r\n\r\n有参考：\r\n\r\n【Unity\r\nShaders】Shader中的光照 - 王大王 - 博客园 (cnblogs.com)\r\n\r\n\r\n\r\n\r\n\r\n\r\n","slug":"Rendering/UnityShaderBook/Chapter9","date":"2023-03-08T13:29:05.000Z","categories_index":"Unity","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"2bc7a87b3796f4bb992e3de5b4dfef67","title":"Unity Shader入门精要笔记 - Chapter8","content":"Unity Shader入门精要笔记 -\r\nChapter8\r\nAlpha Test\r\n只要没通过透明度测试，就舍弃该片元\r\nImportant HLSL Functions\r\nClip Function\r\n\r\nhttps://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-clip\r\n&gt; Discards the current pixel if the specified value is less than\r\nzero. &gt; 12// HLSLclip(x)\r\n\r\nSubShader Tags\r\n\r\nUnity\r\n- Manual: ShaderLab: assigning tags to a SubShader (unity3d.com)\r\n\r\nPass Command\r\n一个Pass块就已经定义了一次完整的渲染流程。不过有时候在使用Shader时,\r\n会发现只进行一次渲染是不够的：还要在它的基础上在加上一次或者多次才行，这就是多Pass的渲染的由来。\r\n当运行一个SubShader时，Unity会从头开始，顺序地运行所有Pass块\r\n\r\n但如果Pass的数目过多，往往会造成性能下降。因此，我们应当尽量使用最小数目的Pass\r\n\r\nAlpha Blend\r\n我们利用Alpha Blend来真正实现透明效果\r\n","slug":"Rendering/UnityShaderBook/Chapter8","date":"2023-03-08T13:28:45.000Z","categories_index":"Unity","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"874669ee5557de0847d70a81a2b48640","title":"Unity Shader入门精要笔记 - Chapter7","content":"Unity Shader入门精要笔记 -\r\nChapter7\r\nAlbedo Texture\r\n纹理中最常见的类型，我们用来取代单纯的_Diffuse颜色\r\nBump Mapping\r\n法线纹理，我们有两种具体的存储方式： - 高度纹理/高度图 - 记录相对高度\r\n- 法线纹理(Default) - 模型空间存储 - 绝对法线信息 -\r\n切线空间存储(Default) - 法线扰动(相对法线信息) -\r\n直接在切线空间中计算相关结果 - 转换到世界空间后再计算结果 -\r\n可以通过高度图转化而来：-&gt;Normal Map-&gt;Create From\r\nGrayScale，之后Unity会根据高度图生成一张在切线空间下的法线纹理 &gt;\r\n在使用法线纹理前，请先将其Texture Type属性设置为Normal\r\nMap，这样我们才能调用Unity中的build-in function来快速解析Normal\r\nMap(内置函数能帮我们根据不同的压缩模式来针对性地加载贴图数据) &gt;\r\n另：关于贴图的压缩模式，可见：http://wiki.polycount.com/wiki/Normal_Map_Compression\r\n切线空间\r\n\r\n切线空间定义于每一个顶点之上\r\n\r\n切线与副切线及其计算\r\n切线\r\n在一开始仅有Normal既定的情况下，一点上的切线是存在无数条的\r\n在这所有的切线之中，我们选择与当下点的uv坐标中，u轴同向的那条切线作为我们的T轴或x轴\r\n副切线\r\n当我们定好了T轴与N轴后，我们就可以通过cross运算得到我们的B轴：Binormal了\r\n但是我们完成cross运算后得到的副切线存在两个可选的方向，这时，利用Unity在tangent的w分量下预留的值来决定\r\n12345678fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);fixed tangentSign = v.tangent.w; // * unity_WorldTransformParams.w; // Shader入门精要中未采用，但官方示例中存在// unity_WorldTransformParams.w，定义于unityShaderVariables.cginc中// 模型的Scale值是三维向量，即vec3，当这三个值中有奇数个值为负时（1个或者3个值全为负时），unity_WorldTransformParams.w = -1，否则为1.fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\r\nTBN矩阵\r\n用于在 Object Space 和 Tangent Space\r\n间进行转换\r\n这在实际上类似于view矩阵的变换：\r\n\r\n参见文档Technical Artist\\Opengl\\learnopengl-cn.readthedocs.io\\01GettingStarted\\06Transform.md\\1.7.1.2.2.1 View/Camera transformation\r\n\r\n结论为：做将原点移动至当前顶点位置的变换，其中由于切线空间更多为向量服务，所以我们更关心坐标轴上的rotation，而非原点到顶点上的transform\r\n注意区分变换的方向，搞明白当前是从切线空间变换到世界空间还是相反\r\n可参考资料：\r\n\r\n切线空间（Tangent\r\nSpace）完全解析 - 知乎 (zhihu.com)\r\nU3D内建着色器源码剖析 110页下4.2.8中相关内容\r\n关于顶点的法线、切线、副切线\r\n- 知乎 (zhihu.com)\r\nUnity\r\n- Scripting API: Mesh.tangents (unity3d.com)\r\nCHAI'S BLOG »\r\n切线的tangent.w的值1或-1的意义 (warmcat.org)\r\n\r\n番外：\r\nDCC Software\r\n\r\n所谓DCC，就是Digital Content\r\nCreation的缩写，即数字内容创作。DCC的范围包括二维/三维、音频/视频剪辑合成、动态/互动内容创作、图像编辑等。\r\n2.1\r\nDCC工具链与引擎工具链 - 知乎 (zhihu.com)\r\n\r\n随记 - 计算光方向\r\n我们开始使用如下built-in函数来取代先前章节用来计算光线向量的方法：\r\n123//fixed3 world_light = normalize(_WorldSpaceLightPos0.xyz);// =&gt;fixed3 world_light = UnityWorldSpaceLightDir(i.worldPos);\r\n查看该函数源码，可以看到： 123456789101112inline float3 UnityWorldSpaceLightDir( in float3 worldPos )&#123;    #ifndef USING_LIGHT_MULTI_COMPILE        return _WorldSpaceLightPos0.xyz - worldPos * _WorldSpaceLightPos0.w;    #else        #ifndef USING_DIRECTIONAL_LIGHT //务必注意，这里是`#if n def`，不要误以为平行光会进入该分支！        return _WorldSpaceLightPos0.xyz - worldPos;        #else //如果是平行光，则直接返回该点位置        return _WorldSpaceLightPos0.xyz;        #endif    #endif&#125; ### 随记 - 遮罩纹理 Mask\r\nTexture\r\nAO - Ambient Occlusion -\r\n环境光遮蔽\r\n随记 - Texture种类\r\n\r\n用来定义模型反射率的Tex(MainTex) - Albedo\r\n用来定义表面法线的Normal Map - Normal\r\n用来控制模型漫反射光照色调的渐变纹理：RampTex 1diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb \r\n用来控制模型\r\n\r\nPROBLEM 1:\r\n\r\nNone of the overloads accepts 2 arguments\r\n\r\nPay attention to your vars type 123//float4 _MainTex//// =&gt;sampler2D _MainTex\r\n优化\r\n节约插值寄存器，当两个纹理的操作相同时，仅保留其中一个float4\r\nST向量\r\n","slug":"Rendering/UnityShaderBook/Chapter7","date":"2023-03-08T13:28:36.000Z","categories_index":"Unity","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"a89249a3d5a65fa935d2ff8b3c1ccd10","title":"Unity Shader入门精要笔记 - Chapter6","content":"Unity Shader入门精要笔记 -\r\nChapter6\r\n_WorldSpaceLightPos0\r\n\r\nlighting.cginc\r\nhttps://docs.unity3d.com/Manual/SL-UnityShaderVariables.html\r\n\r\ntype: float4\r\n\r\nDirectional lights: (world space direction, 0).\r\nOther lights: (world space position, 1).\r\n\r\n","slug":"Rendering/UnityShaderBook/Chapter6","date":"2023-03-08T13:28:06.000Z","categories_index":"Unity","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"3db882bf7fb70ea2d6999c8bcc582857","title":"Unity Shader入门精要笔记 - Chapter0. 在一切开始之前！","content":"Chapter 0: 开始 - 准备工作\r\n在开始阅读本书之前可以提前准备的资料：\r\n\r\n彩图：《Unity\r\nShader入门精要》随书彩色插图 (candycat1992.github.io)\r\n实例工程仓库：candycat1992/Unity_Shaders_Book:\r\n书籍《Unity Shader入门精要》源代码 (github.com)\r\n勘误列表：《Unity\r\nShader入门精要》勘误 (candycat1992.github.io)\r\n\r\n需要的项目设置：\r\n项目色彩空间设置：\r\n\r\n\r\nimage-20230316185827423\r\n\r\n\r\n书中的实例都是处于色彩空间为Gamma下的，而在Unity2021.3LTS下默认是Linear空间下的\r\n\r\n","slug":"Rendering/UnityShaderBook/Chapter0","date":"2023-03-08T13:27:04.000Z","categories_index":"Unity","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"a9ca2d76681f03e5325e9c1e5a8365f0","title":"Unity Shader入门精要笔记 - Chapter5","content":"Unity Shader入门精要笔记 -\r\nChapter5\r\n对texcoord的解释\r\n什么是TEXCOORD\r\nWhat\r\nare the TEXCOORDs and how can I get them in a ComputeShader? - Unity\r\nForum\r\n明明没有输入texcoord，怎么会有初始值？\r\ntexcoord和position等一样，是保存于模型顶点(应该不是VAO，但是可用VAO来理解)上的一类数据\r\nUnity\r\nShader基础篇：浅谈TEXCOORDn | 烟雨迷离半世殇的成长之路\r\n(lfzxb.top)\r\n\r\n\r\n简单来说texcoord就是存在顶点里的一组数据，我们可以通过这组数据在渲染的时候进行贴图采样，比如我们常用的第一套uv作为基础纹理，通常基础纹理我们可以根据需求进行一些区域的uv重用（比如左右脸贴图一样，可以映射到统一贴图区域），第二套uv经常用于光照贴图，光照贴图要求是uv不可以重复，所以通常不能用第一套uv，第三套uv用于更加奇特的需求，以此类推...\r\ntexcoord应该是更加标准的名称，不过因为这个坐标系里面用uvw作为三个轴名称，所以美术那边普遍称作uv\r\n\r\n\r\n在Unity\r\nShader中，编写时有以下报错：\r\n1. 定义Struct报错\r\nStruct定义好后的结尾应该加上分号:\r\n123struct a2v &#123;    ...&#125;; // ; 必须加上\r\n2. 定义Properties过程中出错\r\n定义Properties时的初始值中，不应该加上\"f\":\r\n12_Color(&quot;Color Tint&quot;, Color) = (1.0, 1.0, 1.0, 1.0)  // √_Color(&quot;Color Tint&quot;, Color) = (1.0f, 1.0f, 1.0f, 1.0f)  // ×\r\nUnity ShaderLab Function\r\n我们在可视化纹理坐标的小数部分时，用到了如下语句：\r\n1234o.color = frac(v.texcoord);if(any(saturate(v.texcoord)) - v.texcoord) &#123;    o.color.b = 0.5;&#125;\r\n2.3 HLSL常用函数介绍\r\n- 知乎 (zhihu.com)\r\nfrac函数\r\n这是HLSL的内置函数，其作用是去取x的小数部分\r\n逻辑为：\r\n123float frac(float v) &#123;  return v - floor(v);&#125;\r\n可以参考：Shader实验室：frac函数 -\r\n知乎 (zhihu.com)\r\n\r\n它在坐标轴上的效果如下：\r\n\r\n\r\nimg\r\n\r\n**周期性：而如果我们将对x*2，则可以将该图像的周期翻倍**\r\n\r\nlength\r\n这是上述参考内容中引用的其他HLSL函数，其功能为：\r\nlength\r\n- Win32 apps | Microsoft Learn\r\n\r\nReturns the length of the specified floating-point vector.\r\n\r\n示例：\r\nshader\r\n- GLSL - length function - Stack Overflow\r\nsaturate函数\r\nsaturate\r\n(HLSL reference) - Win32 apps | Microsoft Learn\r\nsaturate（x） 返回将x钳制到[0,1]范围之间的值；\r\nany函数\r\nany\r\n- Win32 apps | Microsoft Learn\r\n\r\nDetermines if any components of the specified value are non-zero.\r\nReturn true if any components of the x\r\nparameter are non-zero; otherwise, false.\r\n\r\n","slug":"Rendering/UnityShaderBook/Chapter5","date":"2023-03-08T13:27:04.000Z","categories_index":"Unity","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"8f44e2f23c42716c29e08931dd66d3e9","title":"高级光照","content":"Shadow Mapping\r\n基本的 Shadow 算法思想：\r\n阴影就是光所不及的地方，也就是说，我只要能获取到哪些地方是光照不到的，那么就能推断出阴影位置。\r\n而一般来说，物体间产生的遮挡关系就是阴影的直接来源，而这个遮挡关系，正好可以用深度关系推测出来。\r\n也就是说，我们以各个光源为原点建立空间系，生成深度图。一个区域如果能被照亮，那么他一定会被记录深度，而没有被记录深度的地方，要么是被裁剪了，要么是被遮挡了。\r\n生成 Shadow Map 的大致流程\r\n从上面可以看出来，Shadow Map 是一种 RT，并且是 Per Light 的，并且这种\r\nRT 的生成还和 Light Type 有一定的关联\r\nDirectional Light 的 Shadow\r\nMap\r\n生成\r\n\r\n顶点着色器：对于所有的 Directional\r\nLight，我们在渲染物体时，我们得建立特殊的 view 及 proj 矩阵：\r\n\r\nview 和 proj 矩阵不再以摄像机为主，我们会以 Light\r\n为关键建立矩阵，以得到独特的 Light Space\r\n\r\nFragment：由于我们已经指定了 Depth 的输出对象是一张\r\nRT，并且又没必要处理仍何颜色计算，我们大可以直接将 Fragment\r\n的处理过程空着。GPU 会默认帮我们在完成 Fragment\r\n后设置深度缓冲，当然我们也可以自己在 Frag 中去设置，但是没必要，还会破坏\r\nEarly-z\r\n\r\n当这么一个 Prepass 执行完后，我们就可以得到一张 RT 了，直接将这张 RT\r\n汇入下一个 Pass 中，就可以使用了\r\n使用\r\n在使用 Shadow Map 时，也是 Per Light 的，因为我们得重新计算一次顶点的\r\nLight Space 坐标，以确认这个顶点是否被照亮\r\n\r\n顶点着色器：在正常的顶点属性设置与输出中，必须要增加一条 Light Space\r\n下 Vertex Pos 的输出。我们在 Vertex Shader 阶段完成坐标系的转换以减少\r\nFragment 阶段的运算量\r\nFragment：对 Shadow Map 进行采样并与当前的 Light Space\r\n坐标进行比对，只有 Equal 才能通过。\r\n\r\n关于取样：可预见的，我们可以使用 Screen Pos 下的 LigthPos.xy\r\n对深度图进行取样，如结果与 LightPos.z 不符则可认为在阴影中\r\n\r\n\r\n\r\n对于我们初步生成的 Shadow Map，我们一般会遇到这些问题：\r\n\r\n阴影失真：\r\n\r\n我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做阴影失真(Shadow\r\nAcne)\r\n\r\n\r\nimg\r\n\r\n\r\n由于使用 Shadow Bias 来解决 Shadow Acne，导致阴影悬浮\r\n\r\n使用阴影偏移的直接导致我们对物体的实际深度应用了平移。如果偏移足够大，就可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：\r\n\r\n\r\nimg\r\n\r\n\r\n使用普通的偏移值通常就能避免 peter panning。\r\n\r\n\r\n光的视锥不可见的区域的处理：\r\n这事实上包含两个部分：一个是由于 Shadow Map\r\n的大小限制导致的采样超出问题；另一部分则是生成 Shadow Map 时，由于 Near\r\n与 Far 值的设计导致的视锥大小问题\r\n\r\n 未解决任何问题的情况\r\n 解决了采样问题，现在如果我们采样深度贴图 0 到 1\r\n坐标范围以外的区域，纹理函数总会返回一个 1.0 的深度值，阴影值为\r\n0.0。但是，仍有一部分是黑暗区域。那里的坐标超出了光的正交视锥的远平面。你可以看到这片黑色区域总是出现在光源视锥的极远处。\r\n\r\n解决全部问题：检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能“解决”深度贴图采样超出的问题\r\n\r\n阴影的锯齿问题：\r\n这是一个大问题，让我们从 LearnOpenGL\r\n里所给出的解决方案开始，一步步推进：\r\n\r\n阴影现在已经附着到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影映射对分辨率的依赖很快变得很明显。\r\n\r\n\r\nimg\r\n\r\n因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会产生锯齿边。\r\n你可以通过增加深度贴图的分辨率的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。\r\n\r\nPCF\r\n\r\n...一个（并不完整的）解决方案叫做 PCF（percentage-closer\r\nfiltering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。\r\n一个简单的 PCF\r\n的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：\r\n\r\n代码：\r\n123456789101112// 最初的shadow值直接来自于深度取样值：float shadow = currentDepth - bias &gt; closestDepth  ? 1.0 : 0.0;// 现在，我们在一个frag上，对其对应的贴图纹素及周围8个纹素一同采样，并混合结果：float shadow = 0.0;vec2 texelSize = 1.0 / textureSize(shadowMap, 0);for (int x = -1; x &lt;= 1; ++x) &#123;    for (int y = -1; y &lt;= 1; ++y) &#123;        float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;        shadow += currentDepth - bias &gt; pcfDepth ? 1.0 : 0.0;    &#125;&#125;shadow /= 9.0;\r\n\r\nPoint Light 的 Shadow Map\r\n生成\r\n使用\r\nHDR\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/05Advanced Lighting/General","date":"2023-03-08T02:34:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"c50f04e3270f35cd6ea407c3d7483e86","title":"高级 OpenGL","content":"高级 OpenGL\r\n先简单回顾一下一般性的渲染管线：\r\n\r\n\r\nimg\r\n\r\n入门精要里的管线是这样的：\r\n 渲染流水线中的三个概念阶段\r\n GPU\r\n的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由\r\nGPU 固定实现的，开发者没有任何控制权。实线表示该 shader\r\n必须由开发者编程实现，虚线表示该 Shader 是可选的\r\n深度测试\r\n\r\n接下来三节都处于后片元阶段，我想先列举入门精要中的几张图来加强理解：\r\n\r\n逐片元操作阶段所做的操作。只有通过了所有的测试后，新生成的片元才能和颜色缓冲区中已经存在的像素颜色进行混合，最后再写入颜色缓冲区中\r\n\r\n模板测试和深度测试的简化流程图。\r\n 混合操作的简化流程图\r\n\r\n使用\r\n在坐标系统小节中，我们渲染了一个\r\n3D 箱子，并且运用了深度缓冲(Depth Buffer，或者 Z\r\nBuffer)来防止被阻挡的面渲染到其它面的前面。\r\n首先，从渲染管线上来看，深度测试几乎已经是整个流水线上的最后一步了——在模板测试之后，在\r\nblend 操作之前。\r\n此时，GPU\r\n会将会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较。这个比较过程是接受配置的——我们来控制\r\nOpenGL 什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。在 OpenGL\r\n中，可以用：glDepthFunc(); 来设置比较运算符\r\nOpenGL 中，具体配置内容包括：\r\n\r\n\r\n\r\n函数\r\n描述\r\n\r\n\r\n\r\n\r\nGL_ALWAYS\r\n永远通过深度测试\r\n\r\n\r\nGL_NEVER\r\n永远不通过深度测试\r\n\r\n\r\nGL_LESS\r\n在片段深度值小于缓冲的深度值时通过测试\r\n\r\n\r\nGL_EQUAL\r\n在片段深度值等于缓冲区的深度值时通过测试\r\n\r\n\r\nGL_LEQUAL\r\n在片段深度值小于等于缓冲区的深度值时通过测试\r\n\r\n\r\nGL_GREATER\r\n在片段深度值大于缓冲区的深度值时通过测试\r\n\r\n\r\nGL_NOTEQUAL\r\n在片段深度值不等于缓冲区的深度值时通过测试\r\n\r\n\r\nGL_GEQUAL\r\n在片段深度值大于等于缓冲区的深度值时通过测试\r\n\r\n\r\n\r\n在 Unity 中，这个配置项作为 Shaderlab 中的一个\r\nTag——ZTest 存在，可参考：Unity - Manual:\r\nShaderLab command: ZTest (unity3d.com)，与之相关的还有Unity - Manual:\r\nShaderLab command: ZWrite (unity3d.com)\r\n在 OpenGL\r\n中，深度测试默认是禁用的，所以如果要启用深度测试的话，我们需要用\r\nGL_DEPTH_TEST 选项来启用它：\r\n1glEnable(GL_DEPTH_TEST);\r\n当它启用的时候，如果一个片段通过了深度测试的话，OpenGL\r\n会在深度缓冲中储存该片段的 z\r\n值；如果没有通过深度缓冲，则会丢弃该片段。如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用\r\nGL_DEPTH_BUFFER_BIT\r\n来清除深度缓冲，否则你会仍在使用上一次渲染迭代中的写入的深度值：\r\n1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\r\n可以想象，在某些情况下你会需要对所有片段都执行深度测试并丢弃相应的片段，但不希望更新深度缓冲。基本上来说，你在使用一个只读的(Read-only)深度缓冲。OpenGL\r\n允许我们禁用深度缓冲的写入，只需要设置它的深度掩码(Depth\r\nMask)设置为GL_FALSE就可以了：\r\n1glDepthMask(GL_FALSE);\r\n注意这只在深度测试被启用的时候才有效果。\r\n运作\r\n\r\n深度缓冲就像颜色缓冲(Color\r\nBuffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以\r\n16、24 或 32 位 float\r\n的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是 24 位的。\r\n\r\n\r\nA depth buffer stores depth information to control which\r\nareas of polygons are rendered rather than hidden from view. A\r\nstencil buffer is used to mask pixels in an image, to produce\r\nspecial effects, including compositing; decaling; dissolves, fades, and\r\nswipes; outlines and silhouettes; and two-sided stencil.\r\nDepth\r\nand stencil buffers - UWP applications | Microsoft Learn\r\n\r\n当深度测试(Depth Testing)被启用的时候，OpenGL\r\n会将一个片段的深度值与深度缓冲的内容进行对比，如果通过，片段会来到 Blend\r\n操作前，并且深度缓冲也会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。\r\nEarly Z\r\n虽然一般意义上的深度缓冲的确是要等到在片段着色器及模板测试(Stencil\r\nTesting)运行完毕之后，才在屏幕空间中运行的。但这样子实在是太过浪费——这个\r\nfrag\r\n已经完成了几乎全部的运算了，现在却要就这样丢弃。因此，我们希望尽可能早地知道哪些片元是需要丢弃的。正好，现在大部分的\r\nGPU 都提供了称为 Early Z 或\r\nEarly Depth Testing\r\n的硬件特性，这种技术能够在片元着色器之前就进行深度测试，以便我们尽可能地减少\r\nGPU 的运算量。\r\n简而言之，early-z\r\n的解决方式非常简单：它直接修改了传统渲染管线，在光栅化和片元阶段中间，加入一个\r\nearly-z 阶段。这个阶段进行的操作和原本逐像素处理阶段的 z-test（为了与\r\nearly-z 区别，这个阶段也会被成为late-z）操作完全一样，现代的\r\ngpu 已经都开始包含这样的硬件设计。但是 early-z\r\n有以下两个主要的缺点：\r\n\r\n一旦进行了手动写入深度值、开启alpha test或者丢弃像素等操作，那么\r\ngpu 就会关闭 early z 直到下次 clear z-buffer 后才会重新开启（不过现在的\r\ngpu 也在逐渐优化，使其更智能开关 early z）。之所以 gpu 会选择关闭 early\r\nz 是因为上述那些操作可能会在片元阶段与 late-z\r\n阶段之间修改深度缓存中的深度值，导致提前的 early-z\r\n的结果并不正确。我们也可以在 fragment shader 中使用\r\nlayout(early_fragment_tests)来强制打开 early z。值得一提的是，至少在\r\nUnity 中，因为 alpha test 所导致的 early z 关闭是 per\r\nobject 的。General\r\nquestions regarding Early-Z - Unity Forum\r\nearly-z\r\n的优化效果并不稳定，最理想条件下所有绘制顺序都是由近及远，那么\r\nearly-z\r\n可以完全避免过度绘制。但是相反的状态下，则会起不到任何效果。所以有些时候为了完全发挥\r\nearly-z\r\n的功效，我们会在每帧绘制时对场景的物体按照到摄像机的距离由远及近进行排序。这个操作会在\r\ncpu 端进行，当场景复杂到一定程度，频繁的排序将会占用 cpu\r\n的大量计算资源。\r\n\r\n片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL\r\n不能提前知道深度值。\r\nDepth Prepass/Z prepass\r\n\r\n\r\nRegarding Z-Prepass, the idea seems to imply that it renders\r\nadditional drawcalls (although extremely lightweight). Does Early-Z\r\ndepend on it in order to work? Could it actually become a bottleneck in\r\nyour pipeline due to the initial pre-pass costs?\r\n\r\nThe idea behind a Z prepass is to fill in the depth buffer\r\nwith cheap draws so that you avoid over shading (leveraging\r\nearly z on the subsequent “full fat” draws). There was a frame breakdown\r\nof Cyberpunk 2077 that showed they used a Z prepass that only rendered a\r\nhandful of visible meshes, presumably only those that are fully opaque\r\nand were considered big enough to block a lot. Other renderers, like\r\nUnity’s HDRP, ended up adding a Z prepass to make grass rendering more\r\nefficient, so they render everything that uses ZWrite into the\r\nZ prepass. And yes, there’s no perfect solution. You can eventually\r\nspend more time rendering the Z prepass than the savings you get from\r\nhaving one.\r\nGPUs that use tile based deferred renderering, like Mali and Adreno,\r\nare basically doing hardware level Z prepass btw. They basically made\r\nthe choice to always do a Z prepass for everything ... except they don’t\r\nbecause they can also swap to immediate mode rendering per tile if it\r\ndoesn’t think it’ll be faster to do TBDR for that tile. Like if there’s\r\nonly one or two triangles visible, or none of the triangles write to\r\ndepth.\r\n\r\n这个做法很简单：第一个 pass\r\n仅写入深度，不做任何复杂的片元计算，不输出任何颜色。第二个 pass\r\n关闭深度写入，并将深度比较函数设为“相等”。这样，无论场景中的物体的绘制顺序是怎样的，我们都可以凭借不大的代价，提前绘制好当前场景的深度缓存。这样，在第二个\r\npass 时，early-z\r\n就可以用这个深度缓存中的值和当前深度值进行比较，只绘制深度相等的片元并直接丢弃任何其他的片元。并且由于当前的深度缓存已经是完全正确的结果了，第二个\r\npass 便可以关闭深度写入。\r\n需要注意的是，z-perpass 必须配合 early-z 才能发挥效果，如果没有\r\nearly-z 的话，第二个 pass\r\n的深度测试依旧在片元后，因此所有片元都会在片元阶段进行复杂计算。\r\n\r\nz-perpass 的思想和延迟渲染管线有些相似，差别在于：\r\n\r\n第一，z-perpass 的第一个 pass\r\n只计算深度，并且结果直接存储在深度缓存。而延迟渲染会同时计算更多其他的屏幕空间数据，并将这些数据存储在额外的\r\nframebuffer（GBuffer）中，这需要更大的缓存。\r\n第二，z-perpass 的第二个 pass\r\n依旧需要对全场景的各个物体进行绘制（至少顶点阶段是如此），而延迟渲染的第二个\r\npass 类似于后处理本质上只绘制了一个屏幕大小的矩形。\r\n\r\n\r\n另外还有几种改进方法，可参考：渲染杂谈：early-z、z-culling、hi-z、z-perpass\r\n到底是什么？ - 修行哥的文章 - 知乎\r\nhttps://zhuanlan.zhihu.com/p/389396050\r\n深度值精度\r\n简单来说，默认的深度值伴随投影变换产生，其直接关系有：\r\n\\[\r\nDepth = 0.5Z_{ndc}+0.5;\\\\\r\nZ_{ndc} = Z_{clip}/W_{clip}\\\\\r\nPosition_{clip} = M_{proj} * Position_{view}\r\n\\]\r\n经过这样的变换，原本线性的 Z 分量就变成了非线性的，一般来说，Depth\r\n最终的取值函数类似于这样：\r\n\\[\r\nDepth = \\frac{\\frac{1}{n} + \\frac{1}{z}}{\\frac{1}{n}-\\frac{1}{f}}\r\n\\]\r\nLearning OpenGL 中将它与直觉上的线性的深度值做了对比：\r\n\r\n... 它做的就是在 z 值很小的时候提供非常高的精度，而在 z\r\n值很远的时候提供更少的精度。花时间想想这个：我们真的需要对 1000\r\n单位远的深度值和只有 1\r\n单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。\r\n\r\n\r\n由于非线性方程与 1/z 成正比，在 1.0 和 2.0 之间的 z 值将会变换至 1.0\r\n到 0.5 之间的深度值，这就是一个 float 提供给我们的一半精度了，这在 z\r\n值很小的情况下提供了非常大的精度。在 50.0 和 100.0 之间的 z 值将会只占\r\n2%的 float 精度，这正是我们所需要的。\r\n如果你不知道这个方程是怎么回事也不用担心。重要的是要记住深度缓冲中的值在屏幕空间中不是线性的（在透视矩阵应用之前在观察空间中是线性的）。深度缓冲中\r\n0.5 的值并不代表着物体的 z 值是位于平截头体的中间了，这个顶点的 z\r\n值实际上非常接近近平面！你可以在下图中看到 z\r\n值和最终的深度缓冲值之间的非线性关系：\r\n\r\n\r\nimg\r\n\r\n可以看到，深度值很大一部分是由很小的 z\r\n值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换 z\r\n值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。如果你想深度了解投影矩阵究竟做了什么，我建议阅读这篇文章。\r\n\r\n可是，这样子的 Buffer\r\n值并不总是符合我们需求的，在开阔的场景中，这可能会导致\r\nZ-Fighting(即下方的深度冲突)的出现：两个物体在 Buffer\r\n中的深度值因为精度问题导致具体的值一致了，这让两个物体的渲染效果不断闪烁\r\n这时候，我们可能会去做一个叫 Reverse-Z 的操作，简单来说，就是反转原始\r\nProj 矩阵中的 M33 与 M34 位中分母 Near 与 Far 的位置。若一个原始 Proj\r\n如下：\r\n\\[\r\n\\begin{bmatrix}\r\n\\frac{\\cot{\\frac{FOV}{2}}}{Aspect} &amp; 0 &amp; 0 &amp; 0\\\\\r\n0 &amp; \\frac{\\cot{FOV}}{2} &amp; 0 &amp; 0\\\\\r\n0 &amp; 0 &amp; -\\frac{Far + Near}{Far - Near} &amp;\r\n-\\frac{2*Near*Far}{Far - Near}\\\\\r\n0 &amp; 0 &amp; -1 &amp; 0\r\n\\end{bmatrix}\r\n\\]\r\n则修改后的 Proj 如下：\r\n\\[\r\n\\begin{bmatrix}\r\n\\frac{\\cot{\\frac{FOV}{2}}}{Aspect} &amp; 0 &amp; 0 &amp; 0\\\\\r\n0 &amp; \\frac{\\cot{FOV}}{2} &amp; 0 &amp; 0\\\\\r\n0 &amp; 0 &amp; -\\frac{Far + Near}{Near - Far} &amp;\r\n-\\frac{2*Near*Far}{Near - Far}\\\\\r\n0 &amp; 0 &amp; -1 &amp; 0\r\n\\end{bmatrix}\r\n\\]\r\n此时的方程为：\r\n\\[\r\nDepth = \\frac{\\frac{1}{f} + \\frac{1}{z}}{\\frac{1}{f}-\\frac{1}{n}}\r\n\\]\r\n具体的原理可参考：\r\n\r\nReversed-Z\r\n详解 - jackmaxwell - 博客园 (cnblogs.com)\r\n程序媛转 TA\r\n之面试篇二：z-fighting，以及 z 精度的最佳分辨率函数 - 知乎\r\n(zhihu.com)\r\n\r\n深度冲突\r\n一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。\r\n\r\n在我们一直使用的场景中，有几个地方的深度冲突还是非常明显的。箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是共面的(Coplanar)。这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。\r\n如果你将摄像机移动到其中一个箱子的内部，你就能清楚地看到这个效果的，箱子的底部不断地在箱子底面与地板之间切换，形成一个锯齿的花纹：\r\n\r\n\r\nimg\r\n\r\n深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在\r\nz\r\n值比较大的时候有着更小的精度)。深度冲突不能够被完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突：\r\n\r\n第一个也是最重要的技巧是永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正\r\ny\r\n轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。\r\n第二个技巧是尽可能将近平面设置远一些。在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。另外，这个在不管反未反转\r\nDepth 都有效，我们总有 Near\r\n值越大，函数曲线越趋于平滑，产生的精度越高；不过，当我们反转之后，各个数值段能获取到的精度已经经过一次平衡了，也就没必要过分纠结\r\nNear 平面值的设置了。\r\n另外一个很好的技巧是牺牲一些性能，使用更高精度的深度缓冲。大部分深度缓冲的精度都是\r\n24 位的，但现在大部分的显卡都支持 32\r\n位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。\r\n\r\n我们上面讨论的三个技术是最普遍也是很容易实现的抗深度冲突技术了。还有一些更复杂的技术，但它们依然不能完全消除深度冲突。深度冲突是一个常见的问题，但如果你组合使用了上面列举出来的技术，你可能不会再需要处理深度冲突了。\r\n\r\n模板测试\r\n\r\n当片段着色器处理完一个片段之后，模板测试(Stencil\r\nTest)会开始执行，被保留下来的片段才会进入深度测试。和深度测试一样，模版测试也可能会丢弃片段。模板测试是根据又一个缓冲来进行的，它叫做模板缓冲(Stencil\r\nBuffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。\r\n\r\n\r\n一个模板缓冲中，（通常）每个模板值(Stencil Value)是 8\r\n位的。所以每个像素/片段一共能有 256\r\n种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。\r\n\r\n模板缓冲的一个简单的例子如下：\r\n\r\n\r\nimg\r\n\r\n模板缓冲首先会被清除为 0，之后在模板缓冲中使用 1\r\n填充了一个空心矩形。场景中的片段将会只在片段的模板值为 1\r\n的时候会被渲染（其它的都被丢弃了）。\r\n模板缓冲操作允许我们在渲染片段时将模板缓冲设定为一个特定的值。我们有两个函数用来控制模板缓冲：glStencilFunc\r\n和 glStencilOp。\r\n使用模板测试\r\n首先是 glStencilFunc，它会决定当前的 Frag\r\n是否通过模板测试。\r\nglStencilFunc 一共包含三个参数，最终构成\r\nglStencilFunc(GLenum func, GLint ref, GLuint mask)：\r\n\r\nfunc：设置模板测试函数(Stencil Test\r\nFunction)。这个测试函数将会应用到已储存的模板值上和\r\nglStencilFunc\r\n函数的ref值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL\r\n和 GL_ALWAYS。它们的语义和深度缓冲的函数类似。\r\nref：设置了模板测试的参考值(Reference\r\nValue)。模板缓冲的内容将会与这个值进行比较。\r\nmask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为\r\n1。\r\n\r\n例如，对于上面的例子，我们希望仅输出 stencil value = 1 的\r\nFrag，那么我们可以这么设置：\r\n1glStencilFunc(GL_EQUAL, 1, 0xFF)\r\n但是，glStencilFunc 仅仅描述了OpenGL\r\n应该对模板缓冲内容做什么，而不是我们应该如何更新缓冲。这就需要\r\nglStencilOp 这个函数了。\r\nglStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)\r\n一共包含三个选项，我们能够设定每个选项应该采取的行为：\r\n\r\nsfail：模板测试失败时采取的行为。\r\ndpfail：模板测试通过，但深度测试失败时采取的行为。\r\ndppass：模板测试和深度测试都通过时采取的行为。\r\n\r\n每个选项都可以选用以下的其中一种行为：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n行为\r\n描述\r\n\r\n\r\n\r\n\r\nGL_KEEP\r\n保持当前储存的模板值\r\n\r\n\r\nGL_ZERO\r\n将模板值设置为 0\r\n\r\n\r\nGL_REPLACE\r\n将模板值设置为 glStencilFunc\r\n函数设置的ref值\r\n\r\n\r\nGL_INCR\r\n如果模板值小于最大值则将模板值加 1\r\n\r\n\r\nGL_INCR_WRAP\r\n与 GL_INCR\r\n一样，但如果模板值超过了最大值则归零\r\n\r\n\r\nGL_DECR\r\n如果模板值大于最小值则将模板值减 1\r\n\r\n\r\nGL_DECR_WRAP\r\n与 GL_DECR 一样，但如果模板值小于 0\r\n则将其设置为最大值\r\n\r\n\r\nGL_INVERT\r\n按位翻转当前的模板缓冲值\r\n\r\n\r\n\r\n默认情况下 glStencilOp\r\n是设置为(GL_KEEP, GL_KEEP, GL_KEEP)的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。\r\n在有了上面两个函数：glStencilFunc 和\r\nglStencilOp\r\n之后，我们就可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃。\r\n现在，我们可以尝试启用 GL_STENCIL_TEST\r\n来启用模板测试了。在这一行代码之后，所有的渲染调用都会以某种方式影响着模板缓冲。\r\n1glEnable(GL_STENCIL_TEST);\r\n需要注意的是，和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。所以，我们现在的\r\nglClear 应该长这样：\r\n1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\r\n和深度测试的 glDepthMask\r\n函数一样，模板缓冲也有一个类似的函数。glStencilMask\r\n允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为\r\n1，不影响输出，但如果我们将它设置为0x00，写入缓冲的所有模板值最后都会变成\r\n0.这与深度测试中的 glDepthMask(GL_FALSE)是等价的。\r\n12glStencilMask(0xFF); // 每一位写入模板缓冲时都保持原样glStencilMask(0x00); // 每一位在写入模板缓冲时都会变成0（禁用写入）\r\n大部分情况下你都只会使用0x00或者0xFF作为模板掩码(Stencil\r\nMask)，但是知道有选项可以设置自定义的位掩码总是好的。\r\n物体轮廓\r\n让我们以一个使用模板测试完成的例子来讲解模板测试可以用来干什么，这个例子是物体轮廓(Object\r\nOutlining)。\r\n\r\n\r\nimg\r\n\r\n物体轮廓所能做的事情正如它名字所描述的那样。我们将会为每个（或者一个）物体在它的周围创建一个很小的有色边框。当你想要在策略游戏中选中一个单位进行操作的，想要告诉玩家选中的是哪个单位的时候，这个效果就非常有用了。为物体创建轮廓的步骤如下：\r\n\r\n在绘制（需要添加轮廓的）物体之前，将模板函数设置为\r\nGL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为 1。\r\n渲染物体。\r\n禁用模板写入以及深度测试。\r\n将每个物体缩放一点点。\r\n使用一个不同的片段着色器，输出一个单独的（边框）颜色。\r\n再次绘制物体，但只在它们片段的模板值不等于 1 时才绘制。\r\n再次启用模板写入和深度测试。\r\n\r\n这个过程将每个物体的片段的模板缓冲设置为\r\n1，当我们想要绘制边框的时候，我们主要绘制放大版本的物体中模板测试通过的部分，也就是物体的边框的位置。我们主要使用模板缓冲丢弃了放大版本中属于原物体片段的部分。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);// 前提：我们已经设置好了glStencilOp为(KEEP, KEEP, REPLACE)，并且这之后都没有变过。其实这么设计值并不算正确，或者说，这样子实现的就不是物体的绝对轮廓，而是物体在可视结果下的全部轮廓// 此时，经过glClear模板缓冲内全部为0// Plane的渲染，模板无关，先渲染，并且使用遮罩防止它修改模板缓冲glStencilFunc(GL_ALWAYS, 0, 0xFF);glStencilMask(0x00);glBindVertexArray(planeVAO);glBindTexture(GL_TEXTURE_2D, floorTexture);shader.setMat4(&quot;model&quot;, model);glDrawArrays(GL_TRIANGLES, 0, 6);glBindVertexArray(0);// 此时模板缓冲应该仍然全为0，开始修改Func与Mask，现在，在Cube对应位置的模板缓冲应该为1glStencilFunc(GL_ALWAYS, 1, 0xFF);glStencilMask(0xFF);glBindVertexArray(cubeVAO);glBindTexture(GL_TEXTURE_2D, cubeTexture);model = glm::mat4(1.0f);model = glm::translate(model, glm::vec3(-1.0f, 0.0f, -1.0f));shader.setMat4(&quot;model&quot;, model);glDrawArrays(GL_TRIANGLES, 0, 36);model = glm::mat4(1.0f);model = glm::translate(model, glm::vec3(2.0f, 0.0f, 0.0f));shader.setMat4(&quot;model&quot;, model);glDrawArrays(GL_TRIANGLES, 0, 36);// 我们将Func修改为(GL_NOTEQUAL, 1, 0xFF)，并且使用的Mask为0x00防止写入(应该没必要,So I comment it out)// 只有模板缓冲中值不为1的部分才能通过，并且不会影响已有的模板缓冲，不然会被REPLACE(根据没有修改过的Op)glStencilFunc(GL_NOTEQUAL, 1, 0xFF);// glStencilMask(0x00);glDisable(GL_DEPTH_TEST); //这里关闭了深度缓冲是另一个有意思的点，这样做是因为我们不想让立方体的边框被地板的边框遮挡shaderSingleColor.use();float scale = 1.1f;glBindVertexArray(cubeVAO);glBindTexture(GL_TEXTURE_2D, cubeTexture);model = glm::mat4(1.0f);model = glm::translate(model, glm::vec3(-1.0f, 0.0f, -1.0f));model = glm::scale(model, glm::vec3(scale, scale, scale));shaderSingleColor.setMat4(&quot;model&quot;, model);glDrawArrays(GL_TRIANGLES, 0, 36);model = glm::mat4(1.0f);model = glm::translate(model, glm::vec3(2.0f, 0.0f, 0.0f));model = glm::scale(model, glm::vec3(scale, scale, scale));shaderSingleColor.setMat4(&quot;model&quot;, model);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);// Re-InitglStencilMask(0xFF);glStencilFunc(GL_ALWAYS, 0, 0xFF);glEnable(GL_DEPTH_TEST);\r\n这个轮廓算法的结果看起来会像是这样的：\r\n\r\n\r\nimg\r\n\r\n混合\r\n\r\nOpenGL\r\n中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid\r\nColor)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。\r\n\r\n事实上，LearnOpenGL 在这一节既介绍了 Blend，又介绍了 Alpha Test\r\n两个东西。我们可以对这两种做法做一个快速的区分：Blend 是利用\r\nAlpha，基于一定的运算方法去混合两种颜色(一般是当前的 FragColor 和 Color\r\nBuffer 混合才被视为 Blend)，而 Alpha Test 则是判断对应 Frag 的 Alpha\r\n是否符合要求，不符合直接 Discard;\r\nAlpha Test\r\n这里主要的操作就集中在 Discard 指令上，Unity\r\n也有这个指令，但是我们一般采用另一个：clip()，但实际上，Clip()\r\n就是 Discard 的调用，因为：\r\n1if (x &lt; 0) discard; // == clip(x)\r\n在 OpenGL 中也没有什么不一样的，根据采样贴图得到的\r\nAlpha，设定阈值与对应逻辑即可。\r\n不过在这一小节中，有这么一小段是值得注意的：\r\n\r\n注意，当采样纹理的边缘的时候，OpenGL\r\n会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了\r\nGL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你\r\nalpha 纹理的时候，请将纹理的环绕方式设置为 GL_CLAMP_TO_EDGE：\r\n12glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\r\n\r\nBlend 操作\r\n\r\nUnity -\r\nManual: ShaderLab command: Blend (unity3d.com)\r\n\r\n相较于 Alpha Test，Blend 就要复杂的多，但还是让我们一步一步来。\r\n和 OpenGL 大多数的功能一样，我们可以启用 GL_BLEND 来启用混合：\r\n1glEnable(GL_BLEND);\r\n启用了混合之后，我们需要告诉 OpenGL\r\n它该如何混合。\r\nOpenGL 中的混合是通过下面这个方程来实现的：\r\n\\[\r\n\\vec{C_{result}}=\\vec{C_{source}} * \\vec{F_{source}} \\space (One \\space\r\nCalculation \\space Method) \\space\r\n\\vec{C_{destination}}*\\vec{F_{destination}}\r\n\\]\r\n\r\nC_source：源颜色向量。这是源自纹理的颜色向量。\r\nC_destination：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。\r\nF_source：源因子值。指定了 alpha 值对源颜色的影响。\r\nF_destination：目标因子值。指定了 alpha 值对目标颜色的影响。\r\n\r\n片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程(Blend\r\nEquation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由\r\nOpenGL 自动设定，但源因子和目标因子的值，即 F_source 和 F_destination\r\n则可以由我们来决定——和之前一样，通过一个 OpenGL 函数，这次是\r\nglBlendFunc\r\nglBlendFunc(GLenum sfactor, GLenum dfactor)\r\n函数接受两个参数，来设置源和目标因子。OpenGL\r\n为我们定义了很多个选项，下面列出了大部分最常用的选项。注意常数颜色向量\r\nC_constant 可以通过 glBlendColor 函数来另外设置。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n选项\r\n值\r\n\r\n\r\n\r\n\r\nGL_ZERO\r\n因子等于 0\r\n\r\n\r\nGL_ONE\r\n因子等于 1\r\n\r\n\r\nGL_SRC_COLOR\r\n因子等于源颜色向量 C_source\r\n\r\n\r\nGL_ONE_MINUS_SRC_COLOR\r\n因子等于 1 - C_source\r\n\r\n\r\nGL_DST_COLOR\r\n因子等于目标颜色向量 C_destination\r\n\r\n\r\nGL_ONE_MINUS_DST_COLOR\r\n因子等于 1 - C_destination\r\n\r\n\r\nGL_SRC_ALPHA\r\n因子等于 C_source 的 alpha\r\n分量\r\n\r\n\r\nGL_ONE_MINUS_SRC_ALPHA\r\n因子等于 1 - C_source 的 alpha\r\n分量\r\n\r\n\r\nGL_DST_ALPHA\r\n因子等于 C_destination 的 alpha\r\n分量\r\n\r\n\r\nGL_ONE_MINUS_DST_ALPHA\r\n因子等于 1 - C_destination 的\r\nalpha 分量\r\n\r\n\r\nGL_CONSTANT_COLOR\r\n因子等于常数颜色向量 C_constant\r\n\r\n\r\nGL_ONE_MINUS_CONSTANT_COLOR\r\n因子等于 1 - C_constant\r\n\r\n\r\nGL_CONSTANT_ALPHA\r\n因子等于 C_constant 的 alpha 分量\r\n\r\n\r\nGL_ONE_MINUS_CONSTANT_ALPHA\r\n因子等于 1 - C_constant 的 alpha 分量\r\n\r\n\r\n\r\n除了使用 glBlendFunc\r\n来设置统一的混合因子外，我们还可以使用 glBlendFuncSeparate\r\n为 RGB 和 alpha 通道分别设置不同的选项：\r\n1glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);\r\n这个函数和我们之前设置的那样设置了 RGB 分量，但这样只能让最终的 alpha\r\n分量被源颜色向量的 alpha 值所影响到，可翻阅：glBlendFuncSeparate\r\n- OpenGL 4 Reference Pages (khronos.org)\r\n方程中中央的运算符，也是可以指定的：glBlendEquation(GLenum mode)\r\n允许我们设置运算符，它提供了三个选项：\r\n\r\nGL_FUNC_ADD：默认选项，将两个分量相加：C_result=Src + Dst。\r\nGL_FUNC_SUBTRACT：将两个分量相减： C_result=Src - Dst\r\nGL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反：C_result=Dst -\r\nSrc。\r\n\r\n通常我们都可以省略调用 glBlendEquation，因为 GL_FUNC_ADD\r\n对大部分的操作来说都是我们希望的混合方程。\r\n当我们开始渲染透明物体时，我们就需要因地制宜地考虑是否采用深度测试以及指定渲染顺序了，Unity\r\n用一个\"Queue\"的 Tag\r\n来解决了一部分的渲染顺序的问题，至少能让透明物体都在同一个阶段去渲染。而对于深度的问题，问题就开始复杂了起来：\r\n\r\n如果是多个透明物体间的互相遮挡，那么就必须严格控制渲染顺序，就算是两个透明物体\r\nAB，先渲染谁后渲染谁都会造成完全不一样的结果。\r\n如果是单个透明物体，但是我们不希望出现其内部结构的话，入门精要里的有一个巧妙的解决办法：我们在\r\nShader 中定义两个 Pass，第一个 Pass 只写入深度，第二个 Pass\r\n用来渲染物体，这样就能避免模型内部被暴露。特别的，如果一个模型中存在循环重叠的问题，我们就得考虑拆分模型/分隔网格了。\r\n\r\n\r\n\r\nrender_order_3.png-15.3kB\r\n\r\n面剔除\r\n\r\n尝试在脑子中想象一个 3D\r\n立方体，数数你从任意方向最多能同时看到几个面。如果你的想象力不是过于丰富了，你应该能得出最大的面数是\r\n3。你可以从任意位置和任意方向看向这个球体，但你永远不能看到 3\r\n个以上的面。所以我们为什么要浪费时间绘制我们不能看见的那 3\r\n个面呢？如果我们能够以某种方式丢弃这几个看不见的面，我们能省下超过\r\n50%的片段着色器执行数！\r\n\r\n现代的图形渲染引擎中，一般都会提供面剔除功能。它发生在光栅化阶段中，体现为：只渲染正面朝向摄像机的面片，而背朝摄像机的则被剔除。当然，这种剔除的方向也是可以指定的：我们可以通过启用\r\nGL_CULL_FACE 来启用面剔除功能\r\n1glEnable(GL_CULL_FACE);\r\n启用之后，可以指定提出方向，可以是正向剔除或者背部剔除：\r\n123glCullFace(GL_BACK);// or:glCullFace(GL_FRONT);\r\n面剔除的实现原理\r\n实际上，这种面剔除直接来自于我们为 OpenGL\r\n提供的数据——是我们直接告诉了 OpenGL 哪些面是正向面(Front\r\nFace)，哪些面是背向面(Back\r\nFace)的——这其中有一个很聪明的技巧，就是顶点数据的环绕顺序(Winding\r\nOrder)：\r\n\r\n\r\nimg\r\n\r\n我们已经知道，OpenGL\r\n是右手系。当我们定义一个三角面片时，如果在当前视角下，这个面片的旋转方向是\r\nCounter-clockwise 的，则会被认为是正面的面片，反之如是 Clockwise\r\n的，则被认为是反面的面片。不过，我们也可以人为地去修改这样一个正反向的认定标准：\r\n12glFrontFace(GL_CCW); \t// counter-clockwise为正向glFrontFace(GL_CW);\t\t// clockwise为正向\r\n\r\n当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从观察者视角所见的了。\r\n\r\n这是因为一个模型间存在各三角形面片间独立的顶点关系，这种关系体现在环绕顺序上虽然是相对的，但是却是稳定的——它不会随着\r\nTransform\r\n的进行而发生变化。这样的话，我们在模型上预定义的环绕关系就可以在面剔除的阶段发挥巨大作用。\r\n帧缓冲\r\n\r\n到目前为止，我们已经使用了很多屏幕缓冲了：用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。这些缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存在内存(这里应该是指显存，原文：The\r\ncombination of these buffers is stored somewhere in GPU memory and is\r\ncalled a framebuffer.)中。OpenGL\r\n允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。\r\n我们目前所做的所有操作都是在默认帧缓冲的渲染缓冲上进行的。默认的帧缓冲是在你创建窗口的时候生成和配置的（GLFW\r\n帮我们做了这些）。有了我们自己的帧缓冲，我们就能够有更多方式来渲染了。\r\n你可能不能很快理解帧缓冲的应用，但渲染你的场景到不同的帧缓冲能够让我们在场景中加入类似镜子的东西，或者做出很酷的后期处理效果。首先我们会讨论它是如何工作的，之后我们将来实现这些炫酷的后期处理效果。\r\n\r\n自定义帧缓冲\r\n首先是创建，不过帧缓冲的创建和别的 Buffer\r\n的创建也没什么区别：我们会使用一个叫做 glGenFramebuffers\r\n的函数来创建一个帧缓冲对象(Framebuffer Object, FBO)：\r\n12unsigned int fbo;glGenFramebuffers(1, &amp;fbo);\r\n然后就是老一套的绑定激活，做一些操作，之后解绑帧缓冲。我们先用\r\nglBindFramebuffer 来绑定帧缓冲。\r\n1glBindFramebuffer(GL_FRAMEBUFFER, fbo);\r\n在绑定到 GL_FRAMEBUFFER\r\n目标之后，所有的读取和写入帧缓冲的操作将会影响当前绑定的帧缓冲。\r\n\r\n我们也可以使用 GL_READ_FRAMEBUFFER 或\r\nGL_DRAW_FRAMEBUFFER，将一个帧缓冲分别绑定到读取目标或写入目标。绑定到\r\nGL_READ_FRAMEBUFFER 的帧缓冲将会使用在所有像是 glReadPixels\r\n的读取操作中，而绑定到 GL_DRAW_FRAMEBUFFER\r\n的帧缓冲将会被用作渲染、清除等写入操作的目标。大部分情况你都不需要区分它们，通常都会使用\r\nGL_FRAMEBUFFER，绑定到两个上。\r\n\r\n不过，在正式使用帧缓冲之前，我们还有一些事情要做——这个帧缓冲还不完整，而一个完整的帧缓冲需要满足以下的组件：\r\n\r\n附加至少一个缓冲（颜色、深度或模板缓冲）。\r\n至少有一个颜色附件(Attachment)。\r\n所有的附件都必须是完整的（保留了内存）。\r\n每个缓冲都应该有相同的样本数。(如果你不知道什么是样本，不要担心，我们将在之后的教程中讲到)\r\n\r\n创建附件\r\n纹理附件\r\n\r\n附件是一个内存位置，它能够作为帧缓冲的一个缓冲，可以将它想象为一个图像。当创建一个附件的时候我们有两个选项：纹理或渲染缓冲对象(Renderbuffer\r\nObject)。\r\n\r\n\r\n当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就像它是一个普通的颜色/深度或模板缓冲一样。使用纹理的优点是，所有渲染操作的结果将会被储存在一个纹理图像中，我们之后可以在着色器中很方便地使用它。\r\n\r\n为帧缓冲创建一个纹理和创建一个普通的纹理差不多：\r\n12345678unsigned int texture;glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n主要的区别就是，我们将维度设置为了屏幕大小（尽管这不是必须的），并且我们给纹理的data参数传递了NULL。对于这个纹理，我们仅仅分配了内存而没有填充它。填充这个纹理将会在我们渲染到帧缓冲之后来进行。同样注意我们并不关心环绕方式或多级渐远纹理，我们在大多数情况下都不会需要它们。\r\n如果你想将你的屏幕渲染到一个更小或更大的纹理上，你需要（在渲染到你的帧缓冲之前）再次调用\r\nglViewport，使用纹理的新维度作为参数，否则只有一小部分的纹理或屏幕会被渲染到这个纹理上。\r\n现在。将我们创建好的空纹理附加到帧缓冲上：\r\n1glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0);\r\nglFrameBufferTexture2D 有以下的参数：\r\n\r\ntarget：帧缓冲的目标（绘制、读取或者两者皆有）\r\nattachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的0意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。\r\ntextarget：你希望附加的纹理类型\r\ntexture：要附加的纹理本身\r\nlevel：多级渐远纹理的级别。我们将它保留为 0。\r\n\r\n当然，除了颜色外，我们还可以附加更多如深度、模板缓冲等的纹理到帧缓冲对象中：\r\n\r\n附加深度缓冲时，我们将附件类型设置为\r\nGL_DEPTH_ATTACHMENT。注意纹理的格式(Format)和内部格式(Internalformat)类型将变为\r\nGL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。\r\n要附加模板缓冲的话，你要将第二个参数设置为\r\nGL_STENCIL_ATTACHMENT，并将纹理的格式设定为 GL_STENCIL_INDEX。\r\n特别的是，我们也可以将深度缓冲和模板缓冲一起，附加为一个纹理。纹理的每\r\n32 位数值中，将包含 24 位的深度信息和 8\r\n位的模板信息。要将深度和模板缓冲附加为一个纹理的话，我们使用\r\nGL_DEPTH_STENCIL_ATTACHMENT\r\n类型，并配置纹理的格式，让它包含合并的深度和模板值：\r\n\r\n123glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0);\r\n渲染缓冲对象附件\r\n\r\n渲染缓冲对象(Renderbuffer Object)是在纹理之后引入到 OpenGL\r\n中，作为一个可用的帧缓冲附件类型的，所以在过去纹理是唯一可用的附件。和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，它会将数据储存为\r\nOpenGL 原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。\r\n渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用\r\nglReadPixels\r\n来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。\r\n因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的\r\nglfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。\r\n\r\n创建一个渲染缓冲对象的代码和帧缓冲的代码很类似：\r\n12unsigned int rbo;glGenRenderbuffers(1, &amp;rbo);\r\n类似，我们需要绑定这个渲染缓冲对象，让之后所有的渲染缓冲操作影响当前的\r\nrbo：\r\n1glBindRenderbuffer(GL_RENDERBUFFER, rbo);\r\n由于渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试。我们需要深度和模板值用于测试，但不需要对它们进行采样，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。\r\n调用 glRenderbufferStorage 函数来具体设置这个 rbo\r\n的：\r\n1glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600);\r\n创建一个渲染缓冲对象和纹理对象类似，不同的是这个对象是专门被设计作为帧缓冲附件使用的，而不是纹理那样的通用数据缓冲(General\r\nPurpose Data Buffer)。这里我们选择 GL_DEPTH24_STENCIL8\r\n作为内部格式，它封装了 24 位的深度和 8 位的模板缓冲。\r\n最后一件事就是附加这个渲染缓冲对象：\r\n1glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);\r\n渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。性能方面它不会产生非常大的影响的。\r\n检测可用性\r\n在完成所有的条件之后，我们可以以 GL_FRAMEBUFFER 为参数调用\r\nglCheckFramebufferStatus\r\n来检查帧缓冲是否完整：它将会检测当前绑定的帧缓冲，并返回规范中这些值的其中之一。如果它返回的是\r\nGL_FRAMEBUFFER_COMPLETE，帧缓冲就是完整的了。\r\n12if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)  // 执行胜利的舞蹈\r\n之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中。由于我们的帧缓冲不是默认帧缓冲，渲染指令将不会对窗口的视觉输出有任何影响。出于这个原因，渲染到一个不同的帧缓冲被叫做离屏渲染(Off-screen\r\nRendering)。要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到0。\r\n1glBindFramebuffer(GL_FRAMEBUFFER, 0);\r\n渲染到纹理\r\n既然我们已经知道帧缓冲（大概）是怎么工作的了，是时候实践它们了。我们将会将场景渲染到一个附加到帧缓冲对象上的颜色纹理中，之后将在一个横跨整个屏幕的四边形上绘制这个纹理。这样视觉输出和没使用帧缓冲时是完全一样的，但这次是打印到了一个四边形上。这为什么很有用呢？我们会在下一部分中知道原因。\r\n首先要创建一个帧缓冲对象，并绑定它，这些都很直观：\r\n123unsigned int framebuffer;glGenFramebuffers(1, &amp;framebuffer);glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\r\n接下来我们需要创建一个纹理图像，我们将它作为一个颜色附件附加到帧缓冲上。我们将纹理的维度设置为窗口的宽度和高度，并且不初始化它的数据：\r\n1234567891011// 生成纹理unsigned int texColorBuffer;glGenTextures(1, &amp;texColorBuffer);glBindTexture(GL_TEXTURE_2D, texColorBuffer);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glBindTexture(GL_TEXTURE_2D, 0);// 将它附加到当前绑定的帧缓冲对象glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0);\r\n我们还希望 OpenGL\r\n能够进行深度测试（如果你需要的话还有模板测试），所以我们还需要添加一个深度（和模板）附件到帧缓冲中。由于我们只希望采样颜色缓冲，而不是其它的缓冲，我们可以为它们创建一个渲染缓冲对象。还记得当我们不需要采样缓冲的时候，渲染缓冲对象是更好的选择吗？\r\n创建一个渲染缓冲对象不是非常复杂。我们需要记住的唯一事情是，我们将它创建为一个深度和模板附件渲染缓冲对象。我们将它的内部格式设置为\r\nGL_DEPTH24_STENCIL8，对我们来说这个精度已经足够了。\r\n12345unsigned int rbo;glGenRenderbuffers(1, &amp;rbo);glBindRenderbuffer(GL_RENDERBUFFER, rbo);glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600);glBindRenderbuffer(GL_RENDERBUFFER, 0);\r\n当我们为渲染缓冲对象分配了足够的内存之后，我们就可以解绑这个渲染缓冲了。\r\n接下来，作为完成帧缓冲之前的最后一步，我们将渲染缓冲对象附加到帧缓冲的深度和模板附件上：\r\n1glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);\r\n最后，我们希望检查帧缓冲是否是完整的，如果不是，我们将打印错误信息。\r\n123if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)    std::cout &lt;&lt; &quot;ERROR::FRAMEBUFFER:: Framebuffer is not complete!&quot; &lt;&lt; std::endl;glBindFramebuffer(GL_FRAMEBUFFER, 0);\r\n现在这个帧缓冲就完整了，我们只需要绑定这个帧缓冲对象，让渲染到帧缓冲的缓冲中而不是默认的帧缓冲中。之后的渲染指令将会影响当前绑定的帧缓冲。所有的深度和模板操作都会从当前绑定的帧缓冲的深度和模板附件中（如果有的话）读取。如果你忽略了深度缓冲，那么所有的深度测试操作将不再工作，因为当前绑定的帧缓冲中不存在深度缓冲。\r\n所以，要想绘制场景到一个纹理上，我们需要采取以下的步骤：\r\n\r\n将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景\r\n绑定默认的帧缓冲\r\n绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。\r\n\r\n为了绘制这个四边形，我们将会新创建一套简单的着色器。我们将不会包含任何花哨的矩阵变换，因为我们提供的是标准化设备坐标的顶点坐标，所以我们可以直接将它们设定为顶点着色器的输出。顶点着色器是这样的：\r\n12345678910#version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec2 aTexCoords;out vec2 TexCoords;void main() &#123;    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);    TexCoords = aTexCoords;&#125;\r\n并没有太复杂的东西。片段着色器会更加基础，我们做的唯一一件事就是从纹理中采样：\r\n12345678910#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D screenTexture;void main() &#123;    FragColor = texture(screenTexture, TexCoords);&#125;\r\n接着就靠你来为屏幕四边形创建并配置一个 VAO\r\n了。帧缓冲的一个渲染迭代将会有以下的结构：\r\n1234567891011121314151617// 第一处理阶段(Pass)glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);glClearColor(0.1f, 0.1f, 0.1f, 1.0f);glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 我们现在不使用模板缓冲glEnable(GL_DEPTH_TEST);DrawScene();// 第二处理阶段glBindFramebuffer(GL_FRAMEBUFFER, 0); // 返回默认glClearColor(1.0f, 1.0f, 1.0f, 1.0f);glClear(GL_COLOR_BUFFER_BIT);screenShader.use();glBindVertexArray(quadVAO);glDisable(GL_DEPTH_TEST);glBindTexture(GL_TEXTURE_2D, textureColorbuffer);glDrawArrays(GL_TRIANGLES, 0, 6);\r\n要注意一些事情。第一，由于我们使用的每个帧缓冲都有它自己一套缓冲，我们希望设置合适的位，调用\r\nglClear，清除这些缓冲。第二，当绘制四边形时，我们将禁用深度测试，因为我们是在绘制一个简单的四边形，并不需要关系深度测试。在绘制普通场景的时候我们将会重新启用深度测试。\r\n有很多步骤都可能会出错，所以如果你没有得到输出的话，尝试调试程序，并重新阅读本节的相关部分。如果所有的东西都能够正常工作，你将会得到下面这样的视觉输出：\r\n\r\n\r\nimg\r\n\r\n左边展示的是视觉输出，它和深度测试中是完全一样的，但这次是渲染在一个简单的四边形上。如果我们使用线框模式渲染场景，就会变得很明显，我们在默认的帧缓冲中只绘制了一个简单的四边形。\r\n所以这个有什么用处呢？因为我们能够以一个纹理图像的方式访问已渲染场景中的每个像素，我们可以在片段着色器中创建出非常有趣的效果。这些有趣效果统称为后期处理(Post-processing)效果。\r\n基于色彩的后处理效果\r\n由于离屏渲染的采用，我们得到了一张正常渲染结果的 RT，现在可以像 Unity\r\n中的 Blit()调用一样去做出很多有意思的视觉效果，这些统称为后处理。\r\n反相\r\n从屏幕纹理中取颜色值，然后用 1.0 减去它，就能达到反相的效果：\r\n123void main() &#123;    FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0);&#125;\r\n\r\n\r\nimg\r\n\r\n灰度\r\n另外一个常见的效果是图像灰度化(Grayscale)，它移除了场景中除了黑白灰以外所有的颜色。这实际上是采用一种算法去计算像素亮度，最简单的就是取所有的颜色分量，将它们平均化：\r\n12345void main() &#123;    FragColor = texture(screenTexture, TexCoords);    float average = (FragColor.r + FragColor.g + FragColor.b) / 3.0;    FragColor = vec4(average, average, average, 1.0);&#125;\r\n这已经能创造很好的结果了，但人眼会对绿色更加敏感一些，而对蓝色不那么敏感，所以为了获取物理上更精确的效果，我们需要使用加权的(Weighted)通道：\r\n123456void main() &#123;    FragColor = texture(screenTexture, TexCoords);    float average = 0.2126 * FragColor.r + 0.7152 * FragColor.g + 0.0722 * FragColor.b;    // 这里实际上是我们一般会采用的亮度的计算公式，你可以参考这篇文章：https://www.cnblogs.com/wildtester/p/15862624.html    FragColor = vec4(average, average, average, 1.0);&#125;\r\n\r\n\r\nimg\r\n\r\n\r\n你可能不会立刻发现有什么差别，但在更复杂的场景中，这样的加权灰度效果会更真实一点。\r\n\r\n基于卷积的后处理效果\r\n在一个纹理图像上做后期处理的另外一个好处是，我们可以从纹理的其它地方采样颜色值。比如说我们可以在当前纹理坐标的周围取一小块区域，对当前纹理值周围的多个纹理值进行采样。我们可以结合它们创建出很有意思的效果。\r\n这实际上是卷积操作，而卷积操作的核心就是其中的卷积核(Kernel)。核是一个类矩阵的数值数组，它的中心为当前的像素，它会用它的核值乘以周围的像素值，并将结果相加变成一个值。所以，基本上我们是在对当前像素周围的纹理坐标添加一个小的偏移量，并根据核将结果合并。下面是核的一个例子：\r\n\\[\r\n\\begin{bmatrix}\r\n2 &amp; 2 &amp; 2\\\\\r\n2 &amp; -15 &amp; 2\\\\\r\n2 &amp; 2 &amp; 2\r\n\\end{bmatrix}\r\n\\]\r\n你在网上找到的大部分核将所有的权重加起来之后都应该会等于\r\n1，如果它们加起来不等于\r\n1，这就意味着最终的纹理颜色将会比原纹理值更亮或者更暗了。而在这个核中，我们共取了\r\n8 个周围像素值，将它们乘以\r\n2，而把当前的像素乘以-15。这个核的例子将周围的像素乘上了一个权重，并将当前像素乘以一个比较大的负权重来平衡结果。\r\n后面你会发现，虽然它们都是被称为卷积的操作，但是对于采用不同的卷积核并辅以不同的计算方式时，我们就能获得不同的执行结果。\r\n锐化\r\n核是后期处理一个非常有用的工具，它们使用和实验起来都很简单，网上也能找到很多例子。我们需要稍微修改一下片段着色器，让它能够支持核。我们假设使用的核都是\r\n3x3 核（实际上大部分核都是）：\r\n12345678910111213141516171819202122232425262728const float offset = 1.0 / 300.0;void main() &#123;    vec2 offsets[9] = vec2[](        vec2(-offset,  offset), // 左上        vec2( 0.0f,    offset), // 正上        vec2( offset,  offset), // 右上        vec2(-offset,  0.0f),   // 左        vec2( 0.0f,    0.0f),   // 中        vec2( offset,  0.0f),   // 右        vec2(-offset, -offset), // 左下        vec2( 0.0f,   -offset), // 正下        vec2( offset, -offset)  // 右下    );    float kernel[9] = float[](        -1, -1, -1,        -1,  9, -1,        -1, -1, -1    );    vec3 sampleTex[9];    for(int i = 0; i &lt; 9; i++) sampleTex[i] = vec3(texture(screenTexture, TexCoords.st + offsets[i]));    vec3 col = vec3(0.0);    for(int i = 0; i &lt; 9; i++) col += sampleTex[i] * kernel[i];    FragColor = vec4(col, 1.0);&#125;\r\n在片段着色器中，我们首先为周围的纹理坐标创建了一个 9\r\n个vec2偏移量的数组。偏移量是一个常量，你可以按照你的喜好自定义它。之后我们定义一个核，在这个例子中是一个锐化(Sharpen)核，它会采样周围的所有像素，锐化每个颜色值。最后，在采样时我们将每个偏移量加到当前纹理坐标上，获取需要采样的纹理，之后将这些纹理值乘以加权的核值，并将它们加到一起。\r\n这个锐化核看起来是这样的：\r\n\r\n\r\nimg\r\n\r\n这能创建一些很有趣的效果，比如说你的玩家打了麻醉剂/兴奋剂所感受到的效果。\r\n模糊\r\n创建模糊(Blur)效果的核是类似这样的：\r\n\\[\r\n\\begin{bmatrix}\r\n1 &amp; 2 &amp; 1\\\\\r\n2 &amp; 4 &amp; 2\\\\\r\n1 &amp; 2 &amp; 1\r\n\\end{bmatrix}\r\n\\]\r\n另外值得一提的是，高斯模糊所采用的也是卷积，只是它的卷积核更复杂一些，是使用高斯方程计算出来的：\r\n\\[\r\nG(x,y)=\\frac{1}{2\\pi\\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma ^ 2}}\r\n\\]\r\n其中，x 和 y 分别是当前位置到中心位置的整数距离，σ 是标准方差并且常取\r\n1，并且需要对最终结果做归一化以防止图片亮度发生变化。那么在这里，由于所有值的和是\r\n16，所以直接返回合并的采样颜色将产生非常亮的颜色，所以我们需要将核的每个值都除以\r\n16。最终的核数组将会是：\r\n12345float kernel[9] = float[](    1.0 / 16, 2.0 / 16, 1.0 / 16,    2.0 / 16, 4.0 / 16, 2.0 / 16,    1.0 / 16, 2.0 / 16, 1.0 / 16);\r\n通过在片段着色器中改变核的 float\r\n数组，我们完全改变了后期处理效果。它现在看起来是这样子的：\r\n\r\n\r\nimg\r\n\r\n这样的模糊效果创造了很多的可能性。我们可以随着时间修改模糊的量，创造出玩家醉酒时的效果，或者在主角没带眼镜的时候增加模糊。模糊也能够让我们来平滑颜色值，我们将在之后教程中使用到。\r\n你可以看到，只要我们有了这个核的实现，创建炫酷的后期处理特效是非常容易的事。我们再来看最后一个很流行的效果来结束本节的讨论。\r\n边缘检测\r\n下面的边缘检测(Edge-detection)核和锐化核非常相似：\r\n\\[\r\n\\begin{bmatrix}\r\n1 &amp; 1 &amp; 1\\\\\r\n1 &amp; -8 &amp; 1\\\\\r\n1 &amp; 1 &amp; 1\r\n\\end{bmatrix}\r\n\\]\r\n这个核高亮了所有的边缘，而暗化了其它部分，在我们只关心图像的边角的时候是非常有用的。\r\n\r\n\r\nimg\r\n\r\n你可能不会奇怪，像是 Photoshop\r\n这样的图像修改工具/滤镜使用的也是这样的核。因为显卡处理片段的时候有着极强的并行处理能力，我们可以很轻松地在实时的情况下逐像素对图像进行处理。所以图像编辑工具在图像处理的时候会更倾向于使用显卡。\r\n\r\n译注：\r\n注意，核在对屏幕纹理的边缘进行采样的时候，由于还会对中心像素周围的 8\r\n个像素进行采样，其实会取到纹理之外的像素。由于环绕方式默认是\r\nGL_REPEAT，所以在没有设置的情况下取到的是屏幕另一边的像素，而另一边的像素本不应该对中心像素产生影响，这就可能会在屏幕边缘产生很奇怪的条纹。为了消除这一问题，我们可以将屏幕纹理的环绕方式都设置为\r\nGL_CLAMP_TO_EDGE。这样子在取到纹理外的像素时，就能够重复边缘的像素来更精确地估计最终的值了。\r\n\r\n终局\r\n在完成所有的帧缓冲操作之后，不要忘记删除这个帧缓冲对象：\r\n1glDeleteFramebuffers(1, &amp;fbo);\r\n立方体贴图 - CubeMap\r\n我们已经使用 2D\r\n纹理很长时间了，但除此之外仍有更多的纹理类型等着我们探索。在本节中，我们将讨论的是将多个纹理组合起来映射到一张纹理上的一种纹理类型：立方体贴图(Cube\r\nMap)。\r\n\r\n需要说明的是，我们之前所使用的确实是 TEXTURE2D，但是这里的 CUBEMAP\r\n并非就等于 3D TEXTURE，应该说 CubeMap 最多只能算是 3D TEXTURE\r\n的一种，而我们在实际使用中往往将两者区分开来使用，关于 3D\r\nTEXTURE，可参考：Unity -\r\nManual: 3D textures (unity3d.com) 与 Introduction\r\nTo Textures in Direct3D 11 - Win32 apps | Microsoft\r\nLearn。另外当然也有 1D TEXTURE，它们通常是以 1 pixel 的 height\r\n已经足够长的 width 出现，虽然它们实际上的形式是 2D 的，但是比起实在的 2D\r\nTEXTURE，它们已经少了一个维度(y 轴已经被指定为\r\n1)，比如说一些用于做色带映射的 ToonMap。\r\n\r\n简单来说，立方体贴图就是一个包含了 6 个 2D 纹理的纹理，每个 2D\r\n纹理都组成了立方体的一个面：一个有纹理的立方体。你可能会奇怪，这样一个立方体有什么用途呢？为什么要把\r\n6 张纹理合并到一张纹理中，而不是直接使用 6\r\n个单独的纹理呢？立方体贴图有一个非常有用的特性，它可以通过一个方向向量来进行索引/采样。假设我们有一个\r\n1x1x1\r\n的单位立方体，方向向量的原点位于它的中心。使用一个橘黄色的方向向量来从立方体贴图上采样一个纹理值会像是这样：\r\n\r\n\r\nimg\r\n\r\n 详解\r\nCubemap、IBL 与球谐光照 - 知乎\r\n(zhihu.com)，你可以用这张图去和我们使用的 vertices 做对比\r\n方向向量的大小并不重要，只要提供了方向，OpenGL\r\n就会获取方向向量（最终）所击中的纹素，并返回对应的采样纹理值——这和\r\nTexture2D 确实有所不同。\r\n如果我们假设将这样的立方体贴图应用到一个立方体上，采样立方体贴图所使用的方向向量将和立方体（插值的）顶点位置非常相像。这样子，只要立方体的中心位于原点，我们就能使用立方体的实际位置向量来对立方体贴图进行采样了。接下来，我们可以将所有顶点的纹理坐标当做是立方体的顶点位置。最终得到的结果就是可以访问立方体贴图上正确面(Face)纹理的一个纹理坐标。\r\n创建立方体贴图\r\n立方体贴图是和其它纹理一样的，所以如果想创建一个立方体贴图的话，我们需要生成一个纹理，并将其绑定到纹理目标上，之后再做其它的纹理操作。这次要绑定到\r\nGL_TEXTURE_CUBE_MAP：\r\n123unsigned int textureID;glGenTextures(1, &amp;textureID);glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);\r\n因为立方体贴图包含有 6 个纹理，每个面一个，我们需要调用 glTexImage2D\r\n函数 6\r\n次，参数和之前教程中很类似。但这一次我们将纹理目标(target)参数设置为立方体贴图的一个特定的面，告诉\r\nOpenGL\r\n我们在对立方体贴图的哪一个面创建纹理。这就意味着我们需要对立方体贴图的每一个面都调用一次\r\nglTexImage2D。\r\n由于我们有 6 个面，OpenGL 给我们提供了 6\r\n个特殊的纹理目标，专门对应立方体贴图的一个面。\r\n\r\n\r\n\r\n纹理目标\r\n方位\r\n\r\n\r\n\r\n\r\nGL_TEXTURE_CUBE_MAP_POSITIVE_X\r\n右\r\n\r\n\r\nGL_TEXTURE_CUBE_MAP_NEGATIVE_X\r\n左\r\n\r\n\r\nGL_TEXTURE_CUBE_MAP_POSITIVE_Y\r\n上\r\n\r\n\r\nGL_TEXTURE_CUBE_MAP_NEGATIVE_Y\r\n下\r\n\r\n\r\nGL_TEXTURE_CUBE_MAP_POSITIVE_Z\r\n后\r\n\r\n\r\nGL_TEXTURE_CUBE_MAP_NEGATIVE_Z\r\n前\r\n\r\n\r\n\r\n和 OpenGL 的很多枚举(Enum)一样，它们背后的 int\r\n值是线性递增的，所以如果我们有一个纹理位置的数组或者\r\nvector，我们就可以从 GL_TEXTURE_CUBE_MAP_POSITIVE_X\r\n开始遍历它们，在每个迭代中对枚举值加 1，遍历了整个纹理目标：\r\n123456int width, height, nrChannels;unsigned char *data;for(unsigned int i = 0; i &lt; textures_faces.size(); i++) &#123;    data = stbi_load(textures_faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, 0);    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);&#125;\r\n这里我们有一个叫做 textures_faces 的\r\nvector，它包含了立方体贴图所需的所有纹理路径，并以表中的顺序排列。这将为当前绑定的立方体贴图中的每个面生成一个纹理。\r\n因为立方体贴图和其它纹理没什么不同，我们也需要设定它的环绕和过滤方式：\r\n12345glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\r\n不要被 GL_TEXTURE_WRAP_R\r\n吓到，它仅仅是为纹理的R坐标设置了环绕方式，它对应的是纹理的第三个维度（和位置的z一样）。我们将环绕方式设置为\r\nGL_CLAMP_TO_EDGE，这是因为正好处于两个面之间的纹理坐标可能不能击中一个面（由于一些硬件限制），所以通过使用\r\nGL_CLAMP_TO_EDGE，OpenGL\r\n将在我们对两个面之间采样的时候，永远返回它们的边界值。\r\n在绘制使用立方体贴图的物体之前，我们要先激活对应的纹理单元，并绑定立方体贴图，这和普通的\r\n2D 纹理没什么区别。\r\n在片段着色器中，我们使用了一个不同类型的采样器，samplerCube，我们将使用\r\ntexture\r\n函数使用它进行采样，但这次我们将使用一个vec3的方向向量而不是vec2。使用立方体贴图的片段着色器会像是这样的：\r\n123456in vec3 textureDir; // 代表3D纹理坐标的方向向量uniform samplerCube cubemap; // 立方体贴图的纹理采样器void main()&#123;    FragColor = texture(cubemap, textureDir); // == FragColor = texture(skybox, normalize(TexCoords));&#125;\r\n我们可以用立方体贴图来实现很多东西，当然，其中最广为人知的一个技术想必就是创建天空盒(Skybox)了。\r\n天空盒\r\n我们很快就能法线，立方体贴图能完美满足天空盒的需求：我们有一个 6\r\n面的立方体，每个面都需要一个纹理。在上面的图片中，他们使用了夜空的几张图片，让玩家产生其位于广袤宇宙中的错觉，但实际上他只是在一个小小的盒子当中。\r\n你可以在网上找到很多像这样的天空盒资源。比如说这个网站就提供了很多天空盒。天空盒图像通常有以下的形式：\r\n\r\n\r\nimg\r\n\r\n如果你将这六个面折成一个立方体，你就会得到一个完全贴图的立方体，模拟一个巨大的场景。一些资源可能会提供了这样格式的天空盒，你必须手动提取六个面的图像，但在大部分情况下它们都是\r\n6 张单独的纹理图像。\r\n加载天空盒\r\n关于天空盒的加载，我觉得有这些东西是需要指出的。\r\n首先是用来读取 Skybox 的模型的定义：观察 LearnOpenGL\r\n网站为我们提供的顶点数据，我们可以发现：这个箱子模型比我们原先所使用的刚好大了一号——它被用来框住我们的摄像机。如果是你，你会怎么去实现这个\r\nSkybox 的功能？LearnOpenGL 给出的解决方案是：直接去定义 Skybox 模型的\r\nView Space 坐标去框住摄像机，并让它的 Front\r\n方向朝内以保证不会被剔除，在此基础上去读取了 CubeMap\r\n的内容。为了实现这个目的，我们需要一个单位矩阵的 Model\r\nMatrix，一个只有旋转属性而抛弃了位移的 View\r\nMatrix，这样就能保证它所定义的 Vertices 可以直接达成效果。\r\n关于优化的内容：LearnOpenGL\r\n先举了首先渲染天空盒，之后再渲染场景中的其它物体的例子。这样子能够工作，但不是非常高效。基于上方的原因，先渲染天空盒时是不会开启深度测试的，我们不仅会对屏幕上的每一个像素运行一遍片段着色器，后续的不透明物体的渲染也不会享受到任何红利。\r\n而 LearnOpenGL\r\n所谓的“最后渲染天空盒\"，其实应该是指在所有不透明物体后，进行 Skybox\r\n的绘制。这样子的话，深度缓冲就会填充满所有物体的深度值了，我们只需要在提前深度测试通过的地方渲染天空盒的片段就可以了，很大程度上减少了片段着色器的调用。\r\n另一个问题是，天空盒很可能会渲染在所有其他对象之上，因为它只是一个\r\n1x1x1 的立方体（译注：意味着距离摄像机的距离也只有\r\n1），会通过大部分的深度测试。如果将 Skybox\r\n的渲染顺序调后的话，禁用深度测试来进行渲染就不是解决方案了——因为天空盒将会复写场景中的其它物体。我们需要欺骗深度缓冲，让它认为天空盒有着最大的深度值\r\n1.0，只要它前面有一个物体，深度测试就会失败。也就是说，我们得手动修改\r\ngl_position 的值：直接将输出位置的 z 分量等于它的 w 分量，让 z\r\n分量永远等于 1.0，这样子的话，当透视除法执行之后，z\r\n分量会变为w / w = 1.0。\r\n12345void main() &#123;    TexCoords = aPos;    vec4 pos = projection * view * vec4(aPos, 1.0);    gl_Position = pos.xyww;&#125;\r\n最终的标准化设备坐标将永远会有一个等于 1.0 的 z\r\n值：最大的深度值。结果就是天空盒只会在没有可见物体的地方渲染了（只有这样才能通过深度测试，其它所有的东西都在天空盒前面）。\r\n我们还要改变一下深度函数，将它从默认的 GL_LESS 改为\r\nGL_LEQUAL。深度缓冲将会填充上天空盒的 1.0\r\n值，所以我们需要保证天空盒在值小于或等于深度缓冲而不是小于时通过深度测试。\r\n环境映射——反射与折射\r\n反射这个属性表现为物体（或物体的一部分）反射它周围环境，即根据观察者的视角，物体的颜色或多或少等于它的环境。镜子就是一个反射性物体：它会根据观察者的视角反射它周围的环境。\r\n反射的原理并不难。下面这张图展示了我们如何计算反射向量，并如何使用这个向量来从立方体贴图中采样：\r\n\r\n\r\nimg\r\n\r\n具体做法可简述为：我们有对某片元的一个观察方向，根据 Normal 算\r\nReflect Dir，依照它来对 CubeMap 进行采样\r\n而环境映射的另一种形式是折射，它和反射很相似。折射是光线由于传播介质的改变而产生的方向变化。在常见的类水表面上所产生的现象就是折射，光线不是直直地传播，而是弯曲了一点。将你的半只胳膊伸进水里，观察出来的就是这种效果。\r\n折射是通过斯涅尔定律(Snell’s\r\nLaw)来描述的，使用环境贴图的话看起来像是这样：\r\n\r\n\r\nimg\r\n\r\n同样，我们有一个观察向量，一个法向量，与一个与之前稍有不同的折射向量\r\nR。\r\n\r\n通常来说，我们在得到折射方向后就可以直接用它来对立方体进行采样了，即使这并不符合物理规律——对一个透明物体来说，这应该是存在两次折射的，一次入射一次出射。但是想要在实时渲染中模拟出第二次折射的方向是比较复杂的，而且仅模拟一次得到的效果也挺像那么回事的——那么根据图形学第一准则：“如果它看上去是对的，那么它就是对的”。\r\n\r\n折射也可以使用 GLSL 的内建 refract\r\n函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率(Refractive\r\nIndex)。\r\n折射率决定了材质中光线弯曲的程度，每个材质都有自己的折射率。一些最常见的折射率可以在下表中找到：\r\n\r\n\r\n\r\n材质\r\n折射率\r\n\r\n\r\n\r\n\r\n空气\r\n1.00\r\n\r\n\r\n水\r\n1.33\r\n\r\n\r\n冰\r\n1.309\r\n\r\n\r\n玻璃\r\n1.52\r\n\r\n\r\n钻石\r\n2.42\r\n\r\n\r\n\r\n我们使用这些折射率就可以来计算光传播的两种材质间的比值了。\r\n动态环境贴图\r\n现在我们使用的都是静态图像的组合来作为天空盒，看起来很不错，但它没有在场景中包括可移动的物体。我们一直都没有注意到这一点，因为我们只使用了一个物体。如果我们有一个镜子一样的物体，周围还有多个物体，镜子中可见的只有天空盒，看起来就像它是场景中唯一一个物体一样。\r\n通过使用帧缓冲，我们能够为物体的 6\r\n个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做动态环境映射(Dynamic\r\nEnvironment\r\nMapping)，因为我们动态创建了物体周围的立方体贴图，并将其用作环境贴图。\r\n虽然它看起来很棒，但它有一个很大的缺点：我们需要为使用环境贴图的物体渲染场景\r\n6\r\n次，这是对程序是非常大的性能开销。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。\r\n高级数据\r\n\r\n对各种 Buffer 数据的再审视\r\n\r\n让我们在开始更多新内容前先回忆一下先前的操作。我们的 Application\r\n阶段与 Render 阶段的、最直接的沟通就是各种 Buffer 的创建，而在这些\r\nBuffer 的创建过程中，存在一些范式——它们都以一个 Unsigned Int\r\n为基础，基于不同的 Target 去\r\nGenBuffer，然后是做绑定，分配大小等等诸如此类的东西。现在，我们来关注一下这个真正生效的这一步——正式分配内存的这一步：\r\n\r\nOpenGL\r\n中的缓冲只是一个管理特定内存块的对象，没有其它更多的功能了。在我们将它绑定到一个缓冲目标(Buffer\r\nTarget)时，我们才赋予了其意义。当我们绑定一个缓冲到\r\nGL_ARRAY_BUFFER\r\n时，它就是一个顶点数组缓冲，但我们也可以很容易地将其绑定到\r\nGL_ELEMENT_ARRAY_BUFFER。OpenGL\r\n内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。\r\n到目前为止，我们一直是调用 glBufferData\r\n函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的data参数设置为NULL，那么这个函数将只会分配内存，但不进行填充。这在我们需要预留(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。\r\n\r\n除了使用一次函数调用填充整个缓冲之外，我们也可以使用\r\nglBufferSubData，填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以提供一个偏移量，指定从何处开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用\r\nglBufferSubData 之前必须要先调用\r\nglBufferData。\r\n1glBufferSubData(GL_ARRAY_BUFFER, 24, sizeof(data), &amp;data); // 范围： [24, 24 + sizeof(data)]\r\n分批顶点属性\r\n通过使用\r\nglVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。在之前对顶点数组缓冲的操作中，我们对属性进行了交错(Interleave)处理，也就是说，我们将每一个顶点的位置、法线和/或纹理坐标紧密放置在一起。既然我们现在已经对缓冲有了更多的了解，我们可以采取另一种方式。\r\n我们可以做的是，将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存。与交错布局\r\n123123123123 不同，我们将采用分批(Batched)的方式 111222333。\r\n当从文件中加载顶点数据的时候，你通常获取到的是一个位置数组、一个法线数组和/或一个纹理坐标数组。我们需要花点力气才能将这些数组转化为一个大的交错数据数组。使用分批的方式会是更简单的解决方案，我们可以很容易使用\r\nglBufferSubData 函数实现：\r\n1234567float positions[] = &#123; ... &#125;;float normals[] = &#123; ... &#125;;float tex[] = &#123; ... &#125;;// 填充缓冲glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &amp;positions);glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &amp;normals);glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &amp;tex);\r\n这样子我们就能直接将属性数组作为一个整体传递给缓冲，而不需要事先处理它们了。我们仍可以将它们合并为一个大的数组，再使用\r\nglBufferData 来填充缓冲，但对于这种工作，使用\r\nglBufferSubData 会更合适一点。\r\n我们还需要更新顶点属性指针来反映这些改变：\r\n123glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(sizeof(positions)));glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)(sizeof(positions) + sizeof(normals)));\r\n注意stride参数等于顶点属性的大小，因为下一个顶点属性向量能在\r\n3 个（或 2 个）分量之后找到。\r\n这给了我们设置顶点属性的另一种方法。使用哪种方法都不会对\r\nOpenGL\r\n有什么立刻的好处，它只是设置顶点属性的一种更整洁的方式。具体使用的方法将完全取决于你的喜好与程序类型。\r\n复制缓冲\r\n当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。glCopyBufferSubData\r\n能够让我们相对容易地从一个缓冲中复制数据到另一个缓冲中。这个函数的原型如下：\r\n1void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);\r\nreadtarget和writetarget参数需要填入复制源和复制目标的缓冲目标。比如说，我们可以将\r\nVERTEX_ARRAY_BUFFER 缓冲复制到 VERTEX_ELEMENT_ARRAY_BUFFER\r\n缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。\r\n但如果我们想读写数据的两个不同缓冲都为顶点数组缓冲该怎么办呢？我们不能同时将两个缓冲绑定到同一个缓冲目标上。正是出于这个原因，OpenGL\r\n提供给我们另外两个缓冲目标，叫做 GL_COPY_READ_BUFFER 和\r\nGL_COPY_WRITE_BUFFER。我们接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为readtarget和writetarget参数。\r\n接下来 glCopyBufferSubData\r\n会从readtarget中读取size大小的数据，并将其写入writetarget缓冲的writeoffset偏移量处。下面这个例子展示了如何复制两个顶点数组缓冲：\r\n1234float vertexData[] = &#123; ... &#125;;glBindBuffer(GL_COPY_READ_BUFFER, vbo1);glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));\r\n高级 GLSL\r\n这一节中，LearnOpenGL 主要讨论了 OpenGL\r\n中的一些系统语义。我们已经见过的 gl_Position 就属于语义\r\n顶点着色器变量\r\n我们已经见过 gl_Position\r\n了，它是顶点着色器的裁剪空间输出位置向量。如果你想在屏幕上显示任何东西，在顶点着色器中设置\r\ngl_Position 是必须的步骤。这已经是它的全部功能了。\r\ngl_PointSize\r\n我们能够选用的其中一个图元是\r\nGL_POINTS，如果使用它的话，每一个顶点都是一个图元，都会被渲染为一个点。我们可以通过\r\nOpenGL 的 glPointSize\r\n函数来设置渲染出来的点的大小，但我们也可以在顶点着色器中修改这个值。\r\nGLSL 定义了一个叫做 gl_PointSize 输出变量，它是一个 float\r\n变量，你可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，你就能对每个顶点设置不同的值了。\r\n在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，你需要启用\r\nOpenGL 的 GL_PROGRAM_POINT_SIZE：\r\n1glEnable(GL_PROGRAM_POINT_SIZE);\r\n一个简单的例子就是将点的大小设置为裁剪空间位置的 z\r\n值，也就是顶点距观察者的距离。点的大小会随着观察者距顶点距离变远而增大。\r\n1234void main() &#123;    gl_Position = projection * view * model * vec4(aPos, 1.0);    gl_PointSize = gl_Position.z;&#125;\r\n结果就是，当我们远离这些点的时候，它们会变得更大：\r\n\r\n\r\nimg\r\n\r\n你可以想到，对每个顶点使用不同的点大小，会在粒子生成之类的技术中很有意思。\r\ngl_VertexID\r\ngl_Position 和 gl_PointSize\r\n都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。我们可以对它们进行写入，来改变结果。顶点着色器还为我们提供了一个有趣的输入变量，我们只能对它进行读取，它叫做\r\ngl_VertexID。\r\n整型变量 gl_VertexID 储存了正在绘制顶点的当前 ID。当（使用\r\nglDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用\r\nglDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。\r\n虽然现在它没有什么具体的用途，但知道我们能够访问这个信息总是好的。\r\n片段着色器变量\r\n在片段着色器中，我们也能访问到一些有趣的变量。GLSL\r\n提供给我们两个有趣的输入变量：gl_FragCoord 和 gl_FrontFacing。\r\ngl_FragCoord\r\n在讨论深度测试的时候，我们已经见过 gl_FragCoord 很多次了，因为\r\ngl_FragCoord 的 z 分量等于对应片段的深度值。然而，我们也能使用它的 x 和\r\ny 分量来实现一些有趣的效果。\r\ngl_FragCoord 的 x 和 y\r\n分量是片段的窗口空间(Window-space)坐标(即能获取该像素对应的屏幕坐标)，其原点为窗口的左下角。我们已经使用\r\nglViewport 设定了一个 800x600 的窗口了，所以片段窗口空间坐标的 x\r\n分量将在 0 到 800 之间，y 分量在 0 到 600 之间。\r\n通过利用片段着色器，我们可以根据片段的窗口坐标，计算出不同的颜色。gl_FragCoord\r\n的一个常见用处是用于对比不同片段计算的视觉输出效果，这在技术演示中可以经常看到。比如说，我们能够将屏幕分成两部分，在窗口的左侧渲染一种输出，在窗口的右侧渲染另一种输出。下面这个例子片段着色器会根据窗口坐标输出不同的颜色：\r\n1234void main()　&#123;    if(gl_FragCoord.x &lt; 400) FragColor = vec4(1.0, 0.0, 0.0, 1.0);    else FragColor = vec4(0.0, 1.0, 0.0, 1.0);&#125;\r\n因为窗口的宽度是 800。当一个像素的 x 坐标小于 400\r\n时，它一定在窗口的左侧，所以我们给它一个不同的颜色。\r\n\r\n\r\nimg\r\n\r\n我们现在会计算出两个完全不同的片段着色器结果，并将它们显示在窗口的两侧。举例来说，你可以将它用于测试不同的光照技巧。\r\ngl_FrontFacing\r\n片段着色器另外一个很有意思的输入变量是 gl_FrontFacing。在面剔除教程中，我们提到\r\nOpenGL\r\n能够根据顶点的环绕顺序来决定一个面是正向还是背向面。如果我们不使用面剔除，那么\r\ngl_FrontFacing\r\n将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分。举例来说，我们能够对正向面计算出不同的颜色。\r\ngl_FrontFacing 变量是一个\r\nbool，如果当前片段是正向面的一部分那么就是true，否则就是false。比如说，我们可以这样子创建一个立方体，在内部和外部使用不同的纹理：\r\n123456789101112#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D frontTexture;uniform sampler2D backTexture;void main() &#123;    if(gl_FrontFacing) FragColor = texture(frontTexture, TexCoords);    else FragColor = texture(backTexture, TexCoords);&#125;\r\n如果我们往箱子里面看，就能看到使用的是不同的纹理。\r\n\r\n\r\nimg\r\n\r\n注意，如果你开启了面剔除，你就看不到箱子内部的面了，所以现在再使用\r\ngl_FrontFacing 就没有意义了。\r\ngl_FragDepth\r\n输入变量 gl_FragCoord\r\n能让我们读取当前片段的窗口空间坐标，并获取它的深度值，但是它是一个只读(Read-only)变量。我们不能修改片段的窗口空间坐标，但实际上修改片段的深度值还是可能的。GLSL\r\n提供给我们一个叫做 gl_FragDepth\r\n的输出变量，我们可以使用它来在着色器内设置片段的深度值。\r\n要想设置深度值，我们直接写入一个 0.0 到 1.0 之间的 float\r\n值到输出变量就可以了：\r\n1gl_FragDepth = 0.0; // 这个片段现在的深度值为 0.0\r\n如果着色器没有写入值到\r\ngl_FragDepth，它会自动取用gl_FragCoord.z的值。\r\n然而，由我们自己设置深度值有一个很大的缺点，只要我们在片段着色器中对\r\ngl_FragDepth 进行写入，OpenGL 就会禁用所有的 Early Z——因为 OpenGL\r\n无法在片段着色器运行之前得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。\r\n在写入 gl_FragDepth 时，你就需要考虑到它所带来的性能影响。\r\n然而，从 OpenGL 4.2\r\n起，我们仍可以对两者进行一定的调和，在片段着色器的顶部使用深度条件(Depth\r\nCondition)重新声明 gl_FragDepth 变量：\r\n1layout (depth_&lt;condition&gt;) out float gl_FragDepth;\r\ncondition可以为下面的值：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n条件\r\n描述\r\n\r\n\r\n\r\n\r\nany\r\n默认值。提前深度测试是禁用的，你会损失很多性能\r\n\r\n\r\ngreater\r\n你只能让深度值比gl_FragCoord.z更大\r\n\r\n\r\nless\r\n你只能让深度值比gl_FragCoord.z更小\r\n\r\n\r\nunchanged\r\n如果你要写入gl_FragDepth，你将只能写入gl_FragCoord.z的值\r\n\r\n\r\n\r\n通过将深度条件设置为greater或者less，OpenGL\r\n就能假设你只会写入比当前片段深度值更大或者更小的值了。这样子的话，当深度值比片段的深度值要小的时候，OpenGL\r\n仍是能够进行提前深度测试的。\r\n下面这个例子中，我们对片段的深度值进行了递增，但仍然也保留了一些提前深度测试：\r\n12345678#version 420 core // 注意GLSL的版本！out vec4 FragColor;layout (depth_greater) out float gl_FragDepth;void main() &#123;    FragColor = vec4(1.0);    gl_FragDepth = gl_FragCoord.z + 0.1;&#125;\r\n接口块\r\n到目前为止，每当我们希望从顶点着色器向片段着色器发送数据时，我们都声明了几个对应的输入/输出变量。将它们一个一个声明是着色器间发送数据最简单的方式了，但当程序变得更大时，你希望发送的可能就不只是几个变量了，它还可能包括数组和结构体。\r\n为了帮助我们管理这些变量，GLSL 为我们提供了一个叫做接口块(Interface\r\nBlock)的东西，来方便我们组合这些变量。接口块的声明和 struct\r\n的声明有点相像，不同的是，现在根据它是一个输入还是输出块(Block)，使用 in\r\n或 out 关键字来定义的。\r\n12345678910111213141516#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;out VS_OUT &#123;    vec2 TexCoords;&#125; vs_out;void main() &#123;    gl_Position = projection * view * model * vec4(aPos, 1.0);    vs_out.TexCoords = aTexCoords;&#125;\r\n这次我们声明了一个叫做 VS_OUT 的接口块，对应的实例名为\r\nvs_out，它打包了我们希望发送到下一个着色器中的所有输出变量。这只是一个很简单的例子，但你可以想象一下，它能够帮助你管理着色器的输入和输出。当我们希望将着色器的输入或输出打包为数组时，它也会非常有用。\r\n之后，我们还需要在下一个着色器，即片段着色器，中定义一个输入接口块。块名(Block\r\nName)应该是和着色器中一样的（VS_OUT），但实例名(Instance\r\nName)（顶点着色器中用的是\r\nvs_out）可以是随意的，但要避免使用误导性的名称，比如对实际上包含输入变量的接口块命名为\r\nvs_out。\r\n123456789101112#version 330 coreout vec4 FragColor;in VS_OUT &#123;    vec2 TexCoords;&#125; fs_in;uniform sampler2D texture;void main() &#123;    FragColor = texture(texture, fs_in.TexCoords);&#125;\r\n只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来。这是帮助你管理代码的又一个有用特性，它在几何着色器这样穿插特定着色器阶段的场景下会很有用。\r\nUniform 缓冲对象\r\n我们已经使用 OpenGL\r\n很长时间了，学会了一些很酷的技巧，但也遇到了一些很麻烦的地方。比如说，当使用多于一个的着色器时，尽管大部分的\r\nuniform\r\n变量都是相同的，我们还是需要不断地设置它们，所以为什么要这么麻烦地重复设置它们呢？\r\nOpenGL 为我们提供了一个叫做 Uniform 缓冲对象(Uniform Buffer\r\nObject)的工具，它允许我们定义一系列在多个着色器中相同的全局\r\nUniform 变量。当使用 Uniform\r\n缓冲对象的时候，我们只需要设置相关的 uniform\r\n一次。当然，我们仍需要手动设置每个着色器中不同的 uniform。并且创建和配置\r\nUniform 缓冲对象会有一点繁琐。\r\n我们还是按照创建缓冲的一般范式来：先调用 glGenBuffers\r\n创建一个缓冲对象冲，绑定到 GL_UNIFORM_BUFFER 目标，并调用 glBufferData\r\n以分配内存。\r\n12345unsigned int uboExampleBlock;glGenBuffers(1, &amp;uboExampleBlock);glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);glBufferData(GL_UNIFORM_BUFFER, 152, NULL, GL_STATIC_DRAW); // 分配152字节的内存glBindBuffer(GL_UNIFORM_BUFFER, 0);\r\n在 Uniform\r\n缓冲对象中储存数据是有一些规则的，我们将会在之后继续讨论它。不过现在，我们先改写一个简单的顶点着色器，将\r\nprojection 和 view 矩阵存储到所谓的 Uniform 块(Uniform Block)中：\r\n12345678910111213#version 330 corelayout (location = 0) in vec3 aPos;layout (std140) uniform Matrices &#123;    mat4 projection;    mat4 view;&#125;;uniform mat4 model;void main() &#123;    gl_Position = projection * view * model * vec4(aPos, 1.0);&#125;\r\n在我们大多数的例子中，我们都会在每个渲染迭代中，对每个着色器设置\r\nprojection 和 view Uniform 矩阵。这是利用 Uniform\r\n缓冲对象的一个非常完美的例子，因为现在我们只需要存储这些矩阵一次就可以了。\r\n这里，我们声明了一个叫做 Matrices 的 Uniform 块，它储存了两个 4x4\r\n矩阵。Uniform\r\n块中的变量可以直接访问，不需要加块名作为前缀。接下来，我们在 OpenGL\r\n代码中将这些矩阵值存入缓冲中，每个声明了这个 Uniform\r\n块的着色器都能够访问这些矩阵。\r\n你现在可能会在想layout (std140)这个语句是什么意思。它的意思是说，当前定义的\r\nUniform 块对它的内容使用一个特定的内存布局。这个语句设置了 Uniform\r\n块布局(Uniform Block Layout)。\r\nUniform 块布局\r\nUniform\r\n块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉\r\nOpenGL 内存的哪一部分对应着着色器中的哪一个 uniform 变量。\r\n假设着色器中有以下的这个 Uniform 块：\r\n12345678layout (std140) uniform ExampleBlock &#123;    float value;    vec3  vector;    mat4  matrix;    float values[3];    bool  boolean;    int   integer;&#125;;\r\n我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。每个元素的大小都是在\r\nOpenGL 中有清楚地声明的，而且直接对应\r\nC++数据类型，其中向量和矩阵都是大的 float 数组。OpenGL\r\n没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个\r\nvec3 放置在 float 边上。不是所有的硬件都能这样处理，可能会在附加这个\r\nfloat 之前，先将 vec3 填充(Pad)为一个 4 个 float\r\n的数组。这个特性本身很棒，但是会对我们造成麻烦。\r\n默认情况下，GLSL 会使用一个叫做共享(Shared)布局的 Uniform\r\n内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。使用共享布局时，GLSL\r\n是可以为了优化而对 uniform\r\n变量的位置进行变动的，只要变量的顺序保持不变。因为我们无法知道每个\r\nuniform 变量的偏移量，我们也就不知道如何准确地填充我们的 Uniform\r\n缓冲了。我们能够使用像是 glGetUniformIndices\r\n这样的函数来查询这个信息，但这超出本节的范围了。\r\n虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个 uniform\r\n变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用\r\nstd140 布局。std140\r\n布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。\r\n每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在 Uniform\r\n块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用 std140\r\n布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned\r\nOffset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量必须等于基准对齐量的倍数。\r\n布局规则的原文可以在 OpenGL 的 Uniform 缓冲规范这里找到，但我们将会在下面列出最常见的规则。GLSL\r\n中的每个变量，比如说 int、float 和 bool，都被定义为 4 字节量。每 4\r\n个字节将会用一个N来表示。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类型\r\n布局规则\r\n\r\n\r\n\r\n\r\n标量，比如 int 和 bool\r\n每个标量的基准对齐量为 N。\r\n\r\n\r\n向量\r\n2N 或者 4N。这意味着 vec3 的基准对齐量为\r\n4N。\r\n\r\n\r\n标量或向量的数组\r\n每个元素的基准对齐量与 vec4 的相同。\r\n\r\n\r\n矩阵\r\n储存为列向量的数组，每个向量的基准对齐量与\r\nvec4 的相同。\r\n\r\n\r\n结构体\r\n等于所有元素根据规则计算后的大小，但会填充到\r\nvec4 大小的倍数。\r\n\r\n\r\n\r\n和 OpenGL\r\n大多数的规范一样，使用例子就能更容易地理解。我们会使用之前引入的那个叫做\r\nExampleBlock 的 Uniform 块，并使用 std140\r\n布局计算出每个成员的对齐偏移量：\r\n1234567891011121314layout (std140) uniform ExampleBlock &#123;                     // 基准对齐量       // 对齐偏移量    float value;     // 4               // 0    vec3 vector;     // 16              // 16  (必须是16的倍数，所以 4-&gt;16)    mat4 matrix;     // 16              // 32  (列 0)                     // 16              // 48  (列 1)                     // 16              // 64  (列 2)                     // 16              // 80  (列 3)    float values[3]; // 16              // 96  (values[0])                     // 16              // 112 (values[1])                     // 16              // 128 (values[2])    bool boolean;    // 4               // 144    int integer;     // 4               // 148&#125;;\r\n作为练习，尝试去自己计算一下偏移量，并和表格进行对比。使用计算后的偏移量值，根据\r\nstd140 布局的规则，我们就能使用像是 glBufferSubData\r\n的函数将变量数据按照偏移量填充进缓冲中了。虽然 std140\r\n布局不是最高效的布局，但它保证了内存布局在每个声明了这个 Uniform\r\n块的程序中是一致的。\r\n通过在 Uniform\r\n块定义之前添加layout (std140)语句，我们告诉 OpenGL 这个\r\nUniform 块使用的是 std140\r\n布局。除此之外还可以选择两个布局，但它们都需要我们在填充缓冲之前先查询每个偏移量。我们已经见过shared布局了，剩下的一个布局是packed。当使用紧凑(Packed)布局时，是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将\r\nuniform 变量从 Uniform 块中优化掉，这在每个着色器中都可能是不同的。\r\n构造完整的 Uniform 缓冲\r\n我们已经讨论了如何在着色器中定义 Uniform\r\n块，并设定它们的内存布局了，但我们还没有讨论该如何使用它们。\r\n每当我们需要对缓冲更新或者插入数据，我们应该使用 glBufferSubData\r\n来更新 ubo。我们只需要更新这个 Uniform\r\n缓冲一次，所有使用这个缓冲的着色器就都使用的是更新后的数据了。但是，如何才能让\r\nOpenGL 知道哪个 Uniform 缓冲对应的是哪个 Uniform 块呢？\r\n在 OpenGL 上下文中，定义了一些绑定点(Binding Point)，我们可以将一个\r\nUniform 缓冲链接至它。在创建 Uniform\r\n缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的 Uniform\r\n块绑定到相同的绑定点，把它们连接到一起。下面的这个图示展示了这个：\r\n\r\n\r\nimg\r\n\r\n你可以看到，我们可以绑定多个 Uniform 缓冲到不同的绑定点上。因为着色器\r\nA 和着色器 B 都有一个链接到绑定点 0 的 Uniform 块，它们的 Uniform\r\n块将会共享相同的 uniform\r\n数据，uboMatrices，前提条件是两个着色器都定义了相同的 Matrices Uniform\r\n块。\r\n\r\n这和我们的 Texture 的绑定是相通的\r\n\r\n为了将 Uniform 块绑定到一个特定的绑定点中，我们需要调用\r\nglUniformBlockBinding\r\n函数，它的第一个参数是一个程序对象，之后是一个 Uniform\r\n块索引和链接到的绑定点。Uniform 块索引(Uniform Block\r\nIndex)是着色器中已定义 Uniform 块的位置值索引。这可以通过调用\r\nglGetUniformBlockIndex 来获取，它接受一个程序对象和 Uniform\r\n块的名称。我们可以用以下方式将图示中的 Lights Uniform 块链接到绑定点\r\n2：\r\n12unsigned int lights_index = glGetUniformBlockIndex(shaderA.ID, &quot;Lights&quot;);glUniformBlockBinding(shaderA.ID, lights_index, 2);\r\n注意我们需要对每个着色器重复这一步骤。\r\n\r\n从 OpenGL 4.2 版本起，你也可以添加一个布局标识符，显式地将 Uniform\r\n块的绑定点储存在着色器中，这样就不用再调用 glGetUniformBlockIndex 和\r\nglUniformBlockBinding 了。下面的代码显式地设置了 Lights Uniform\r\n块的绑定点。\r\n1layout(std140, binding = 2) uniform Lights &#123; ... &#125;;\r\n\r\n接下来，我们还需要绑定 Uniform 缓冲对象到相同的绑定点上，这可以使用\r\nglBindBufferBase 或 glBindBufferRange\r\n来完成。\r\n123glBindBufferBase(GL_UNIFORM_BUFFER, 2, uboExampleBlock);// 或glBindBufferRange(GL_UNIFORM_BUFFER, 2, uboExampleBlock, 0, 152);\r\n\r\nglBindbufferBase 需要一个目标，一个绑定点索引和一个\r\nUniform 缓冲对象作为它的参数。这个函数将 uboExampleBlock 链接到绑定点 2\r\n上，自此，绑定点的两端都链接上了。\r\nglBindBufferRange\r\n需要一个附加的偏移量和大小参数，这样子你可以绑定 Uniform\r\n缓冲的特定一部分到绑定点中。通过使用 glBindBufferRange\r\n函数，你可以让多个不同的 Uniform 块绑定到同一个 Uniform\r\n缓冲对象上。\r\n\r\n现在，所有的东西都配置完毕了，我们可以开始向 Uniform\r\n缓冲中添加数据了。只要我们需要，就可以使用 glBufferSubData\r\n函数，用一个字节数组添加所有的数据，或者更新缓冲的一部分。要想更新\r\nuniform 变量 boolean，我们可以用以下方式更新 Uniform 缓冲对象：\r\n1234glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);int b = true; // GLSL中的bool是4字节的，所以我们将它存为一个integerglBufferSubData(GL_UNIFORM_BUFFER, 144, 4, &amp;b);glBindBuffer(GL_UNIFORM_BUFFER, 0);\r\n同样的步骤也能应用到 Uniform 块中其它的 uniform\r\n变量上，但需要使用不同的范围参数。\r\n一个简单的例子\r\n所以，我们来展示一个真正使用 Uniform\r\n缓冲对象的例子。如果我们回头看看之前所有的代码例子，我们不断地在使用 3\r\n个矩阵：投影、观察和模型矩阵。在所有的这些矩阵中，只有模型矩阵会频繁变动。如果我们有多个着色器使用了这同一组矩阵，那么使用\r\nUniform 缓冲对象可能会更好。\r\n我们会将投影和模型矩阵存储到一个叫做 Matrices 的 Uniform\r\n块中。我们不会将模型矩阵存在这里，因为模型矩阵在不同的着色器中会不断改变，所以使用\r\nUniform 缓冲对象并不会带来什么好处。\r\n123456789101112#version 330 corelayout (location = 0) in vec3 aPos;layout (std140) uniform Matrices &#123;    mat4 view;    mat4 projection;&#125;;uniform mat4 model;void main() &#123;    gl_Position = projection * view * model * vec4(aPos, 1.0);&#125;\r\n这里没什么特别的，除了我们现在使用的是一个 std140 布局的 Uniform\r\n块。我们将在例子程序中，显示 4\r\n个立方体，每个立方体都是使用不同的着色器程序渲染的。这 4\r\n个着色器程序将使用相同的顶点着色器，但使用的是不同的片段着色器，每个着色器会输出不同的颜色。\r\n首先，我们将顶点着色器的 Uniform 块设置为绑定点\r\n0。注意我们需要对每个着色器都设置一遍。\r\n123456789unsigned int uniformBlockIndexRed    = glGetUniformBlockIndex(shaderRed.ID, &quot;Matrices&quot;);unsigned int uniformBlockIndexGreen  = glGetUniformBlockIndex(shaderGreen.ID, &quot;Matrices&quot;);unsigned int uniformBlockIndexBlue   = glGetUniformBlockIndex(shaderBlue.ID, &quot;Matrices&quot;);unsigned int uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, &quot;Matrices&quot;);glUniformBlockBinding(shaderRed.ID,    uniformBlockIndexRed, 0);glUniformBlockBinding(shaderGreen.ID,  uniformBlockIndexGreen, 0);glUniformBlockBinding(shaderBlue.ID,   uniformBlockIndexBlue, 0);glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, 0);\r\n接下来，我们创建 Uniform 缓冲对象本身，并将其绑定到绑定点 0：\r\n12345678unsigned int uboMatricesglGenBuffers(1, &amp;uboMatrices);glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);glBufferData(GL_UNIFORM_BUFFER, 2 * sizeof(glm::mat4), NULL, GL_STATIC_DRAW);glBindBuffer(GL_UNIFORM_BUFFER, 0);glBindBufferRange(GL_UNIFORM_BUFFER, 0, uboMatrices, 0, 2 * sizeof(glm::mat4));\r\n首先我们为缓冲分配了足够的内存，它等于 glm::mat4 大小的两倍。GLM\r\n矩阵类型的大小直接对应于 GLSL 中的\r\nmat4。接下来，我们将缓冲中的特定范围（在这里是整个缓冲）链接到绑定点\r\n0。\r\n剩余的就是填充这个缓冲了。因为我们已经为缓冲对象分配了足够的内存，我们可以使用\r\nglBufferSubData 来直接在 Render Loop\r\n中去输入我们的矩阵：\r\n123456glm::mat4 view = camera.GetViewMatrix();glm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), glm::value_ptr(view)); // 先后顺序一定要与Shader中的保持一致glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4), sizeof(glm::mat4), glm::value_ptr(projection));glBindBuffer(GL_UNIFORM_BUFFER, 0);\r\nUniform 缓冲对象的部分就结束了。每个包含了 Matrices 这个 Uniform\r\n块的顶点着色器将会包含储存在 uboMatrices\r\n中的数据。所以，如果我们现在要用 4 个不同的着色器绘制 4\r\n个立方体，它们的投影和观察矩阵都会是一样的。\r\n123456789glBindVertexArray(cubeVAO);shaderRed.use();glm::mat4 model;model = glm::translate(model, glm::vec3(-0.75f, 0.75f, 0.0f));  // 移动到左上角shaderRed.setMat4(&quot;model&quot;, model);glDrawArrays(GL_TRIANGLES, 0, 36);// ... 绘制绿色立方体// ... 绘制蓝色立方体// ... 绘制黄色立方体\r\n唯一需要设置的 uniform 只剩 model uniform 了。在像这样的场景中使用\r\nUniform 缓冲对象会让我们在每个着色器中都剩下一些 uniform\r\n调用。最终的结果会是这样的：\r\n\r\n\r\nimg\r\n\r\n因为修改了模型矩阵，每个立方体都移动到了窗口的一边，并且由于使用了不同的片段着色器，它们的颜色也不同。这只是一个很简单的情景，我们可能会需要使用\r\nUniform\r\n缓冲对象，但任何大型的渲染程序都可能同时激活有上百个着色器程序，这时候\r\nUniform 缓冲对象的优势就会很大地体现出来了。\r\nUniform 缓冲对象比起独立的 uniform 有很多好处:\r\n\r\n第一，一次设置很多 uniform 会比一个一个设置多个 uniform\r\n要快很多。\r\n第二，比起在多个着色器中修改同样的 uniform，在 Uniform\r\n缓冲中修改一次会更容易一些。\r\n最后一个好处可能不会立即显现，如果使用 Uniform\r\n缓冲对象的话，你可以在着色器中使用更多的 uniform。OpenGL\r\n限制了它能够处理的 uniform 数量，这可以通过\r\nGL_MAX_VERTEX_UNIFORM_COMPONENTS 来查询。当使用 Uniform\r\n缓冲对象时，最大的数量会更高。所以，当你达到了 uniform\r\n的最大数量时（比如再做骨骼动画(Skeletal\r\nAnimation)的时候），你总是可以选择使用 Uniform 缓冲对象。\r\n\r\n几何着色器\r\n在顶点和片段着色器之间有一个可选的几何着色器(Geometry\r\nShader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。然而，几何着色器最有趣的地方在于，它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。\r\n\r\n如果你不清楚几何着色器处于管线中的什么位置，你可以回到最上方\r\n\r\n先看一个几何着色器的例子：\r\n12345678910111213#version 330 corelayout (points) in;layout (line_strip, max_vertices = 2) out;void main() &#123;    gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0);    EmitVertex();    gl_Position = gl_in[0].gl_Position + vec4( 0.1, 0.0, 0.0, 0.0);    EmitVertex();    EndPrimitive();&#125;\r\n在几何着色器的顶部，我们需要声明：\r\n\r\n从顶点着色器输入的图元类型。这需要在 in\r\n关键字前声明一个布局修饰符(Layout\r\nQualifier)。这个输入布局修饰符可以从顶点着色器接收下列任何一个图元值：（括号内的数字表示的是一个图元所包含的最小顶点数）\r\n\r\npoints：绘制 GL_POINTS 图元（1）\r\nlines：绘制 GL_LINES 或 GL_LINE_STRIP\r\n图元（2）\r\nlines_adjacency：绘制 GL_LINES_ADJACENCY 或\r\nGL_LINE_STRIP_ADJACENCY 图元（4）\r\ntriangles：绘制 GL_TRIANGLES、GL_TRIANGLE_STRIP 或\r\nGL_TRIANGLE_FAN 图元（3）\r\ntriangles_adjacency：绘制 GL_TRIANGLES_ADJACENCY 或\r\nGL_TRIANGLE_STRIP_ADJACENCY 图元（6）\r\n\r\n以上是能提供给 glDrawArrays\r\n渲染函数的几乎所有图元了。如果我们想要将顶点绘制为\r\nGL_TRIANGLES，我们就要将输入修饰符设置为triangles。\r\n\r\n\r\n接下来，我们还需要指定几何着色器输出的图元类型，这需要在 out\r\n关键字前面加一个布局修饰符。和输入布局修饰符一样，输出布局修饰符也可以接受几个图元值：\r\n\r\npoints\r\nline_strip\r\ntriangle_strip\r\n\r\n\r\n有了这 3\r\n个输出修饰符，我们就可以使用输入图元创建几乎任意的形状了。要生成一个三角形的话，我们将输出定义为triangle_strip，并输出\r\n3 个顶点。\r\n几何着色器同时希望我们设置一个它最大能够输出的顶点数量（如果你超过了这个值，OpenGL\r\n将不会绘制多出的顶点），这个也可以在 out\r\n关键字的布局修饰符中设置。在这个例子中，我们将输出一个line_strip，并将最大顶点数设置为\r\n2 个。\r\n如果你不知道什么是线条(Line\r\nStrip)：线条连接了一组点，形成一条连续的线，它最少要由两个点来组成。在渲染函数中每多加一个点，就会在这个点与前一个点之间形成一条新的线。在下面这张图中，我们有\r\n5 个顶点：\r\n\r\n\r\nimg\r\n\r\n如果使用的是上面定义的着色器，那么这将只能输出一条线段，因为最大顶点数等于\r\n2。\r\n为了生成更有意义的结果，我们需要某种方式来获取前一着色器阶段的输出。GLSL\r\n提供给我们一个内建(Built-in)变量，在内部看起来（可能）是这样的：\r\n12345in gl_Vertex &#123;    vec4  gl_Position;    float gl_PointSize;    float gl_ClipDistance[];&#125; gl_in[];\r\n这里，它被声明为一个接口块，它包含了几个很有意思的变量，其中最有趣的一个是\r\ngl_Position，它是和顶点着色器输出非常相似的一个向量。\r\n要注意的是，它被声明为一个数组，因为大多数的渲染图元包含多于 1\r\n个的顶点，而几何着色器的输入是一个图元的所有顶点。\r\n有了之前顶点着色器阶段的顶点数据，我们就可以使用 2\r\n个几何着色器函数，EmitVertex 和\r\nEndPrimitive，来生成新的数据了。几何着色器希望你能够生成并输出至少一个定义为输出的图元。在我们的例子中，我们需要至少生成一个线条图元。\r\n123456789void main() &#123;    gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0);    EmitVertex();    gl_Position = gl_in[0].gl_Position + vec4( 0.1, 0.0, 0.0, 0.0);    EmitVertex();    EndPrimitive();&#125;\r\n每次我们调用 EmitVertex 时，gl_Position\r\n中的向量会被添加到图元中来。当 EndPrimitive\r\n被调用时，所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元。在一个或多个\r\nEmitVertex 调用之后重复调用 EndPrimitive\r\n能够生成多个图元。在这个例子中，我们发射了两个顶点，它们从原始顶点位置平移了一段距离，之后调用了\r\nEndPrimitive，将这两个顶点合成为一个包含两个顶点的线条。\r\n现在你（大概）了解了几何着色器的工作方式，你可能已经猜出这个几何着色器是做什么的了。它接受一个点图元作为输入，以这个点为中心，创建一条水平的线图元。如果我们渲染它，看起来会是这样的：\r\n\r\n\r\nimg\r\n\r\n目前还并没有什么令人惊叹的效果，但考虑到这个输出是通过调用下面的渲染函数来生成的，它还是很有意思的：\r\n1glDrawArrays(GL_POINTS, 0, 4);\r\n虽然这是一个比较简单的例子，它的确向你展示了如何能够使用几何着色器来（动态地）生成新的形状。在之后我们会利用几何着色器创建出更有意思的效果，但现在我们仍将从创建一个简单的几何着色器开始。\r\n使用几何着色器\r\n为了展示几何着色器的用法，我们将会渲染一个非常简单的场景，我们只会在标准化设备坐标的\r\nz 平面上绘制四个点。这些点的坐标是：\r\n123456float points[] = &#123;    -0.5f,  0.5f, // 左上     0.5f,  0.5f, // 右上     0.5f, -0.5f, // 右下    -0.5f, -0.5f  // 左下&#125;;\r\n顶点着色器只需要在 z\r\n平面绘制点就可以了，所以我们将使用一个最基本顶点着色器：\r\n123456#version 330 corelayout (location = 0) in vec2 aPos;void main() &#123;    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);&#125;\r\n直接在片段着色器中硬编码，将所有的点都输出为绿色：\r\n123456#version 330 coreout vec4 FragColor;void main() &#123;    FragColor = vec4(0.0, 1.0, 0.0, 1.0);&#125;\r\n为点的顶点数据生成一个 VAO 和一个 VBO，然后使用 glDrawArrays\r\n进行绘制：\r\n123shader.use();glBindVertexArray(VAO);glDrawArrays(GL_POINTS, 0, 4);\r\n结果是在黑暗的场景中有四个（很难看见的）绿点：\r\n\r\n\r\nimg\r\n\r\n但我们之前不是学过这些吗？是的，但是现在我们将会添加一个几何着色器，为场景添加活力。\r\n出于学习目的，我们将会创建一个传递(Pass-through)几何着色器，它会接收一个点图元，并直接将它传递(Pass)到下一个着色器：\r\n123456789#version 330 corelayout (points) in;layout (points, max_vertices = 1) out;void main() &#123;    gl_Position = gl_in[0].gl_Position;    EmitVertex();    EndPrimitive();&#125;\r\n现在这个几何着色器应该很容易理解了，它只是将它接收到的顶点位置不作修改直接发射出去，并生成一个点图元。\r\n和顶点与片段着色器一样，几何着色器也需要编译和链接，但这次在创建着色器时我们将会使用\r\nGL_GEOMETRY_SHADER 作为着色器类型：\r\n123456geometryShader = glCreateShader(GL_GEOMETRY_SHADER);glShaderSource(geometryShader, 1, &amp;gShaderCode, NULL);glCompileShader(geometryShader);...glAttachShader(program, geometryShader);glLinkProgram(program);\r\n着色器编译的代码和顶点与片段着色器代码都是一样的。记得要检查编译和链接错误！\r\n如果你现在编译并运行程序，会看到和下面类似的结果：\r\n\r\n\r\nimg\r\n\r\n这和没使用几何着色器时是完全一样的！我承认这是有点无聊，但既然我们仍然能够绘制这些点，所以几何着色器是正常工作的，现在是时候做点更有趣的东西了！\r\n造几个房子\r\n绘制点和线并没有那么有趣，所以我们会使用一点创造力，利用几何着色器在每个点的位置上绘制一个房子。要实现这个，我们可以将几何着色器的输出设置为\r\ntriangle_strip，并绘制三个三角形：其中两个组成一个正方形，另一个用作房顶。\r\nOpenGL 中，三角形带(Triangle\r\nStrip)是绘制三角形更高效的方式，它使用顶点更少。在第一个三角形绘制完之后，每个后续顶点将会在上一个三角形边上生成另一个三角形：每\r\n3 个临近的顶点将会形成一个三角形。如果我们一共有 6\r\n个构成三角形带的顶点，那么我们会得到这些三角形：(1, 2, 3)、(2, 3,\r\n4)、(3, 4, 5)和(4, 5, 6)，共形成 4 个三角形。一个三角形带至少需要 3\r\n个顶点，并会生成 N-2 个三角形。使用 6 个顶点，我们创建了 6-2 = 4\r\n个三角形。下面这幅图展示了这点：\r\n\r\n\r\nimg\r\n\r\n通过使用三角形带作为几何着色器的输出，我们可以很容易创建出需要的房子形状，只需要以正确的顺序生成\r\n3\r\n个相连的三角形就行了。下面这幅图展示了顶点绘制的顺序，蓝点代表的是输入点：\r\n\r\n\r\nimg\r\n\r\n变为几何着色器是这样的：\r\n123456789101112131415161718192021#version 330 corelayout (points) in;layout (triangle_strip, max_vertices = 5) out;void build_house(vec4 position) &#123;    gl_Position = position + vec4(-0.2, -0.2, 0.0, 0.0);    // 1:左下    EmitVertex();    gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0);    // 2:右下    EmitVertex();    gl_Position = position + vec4(-0.2,  0.2, 0.0, 0.0);    // 3:左上    EmitVertex();    gl_Position = position + vec4( 0.2,  0.2, 0.0, 0.0);    // 4:右上    EmitVertex();    gl_Position = position + vec4( 0.0,  0.4, 0.0, 0.0);    // 5:顶部    EmitVertex();    EndPrimitive();&#125;void main() &#123;    build_house(gl_in[0].gl_Position);&#125;\r\n这个几何着色器生成了 5\r\n个顶点，每个顶点都是原始点的位置加上一个偏移量，来组成一个大的三角形带。最终的图元会被光栅化，然后片段着色器会处理整个三角形带，最终在每个绘制的点处生成一个绿色房子：\r\n\r\n\r\nimg\r\n\r\n你可以看到，每个房子实际上是由 3\r\n个三角形组成的——全部都是使用空间中一点来绘制的。这些绿房子看起来是有点无聊，所以我们会再给每个房子分配一个不同的颜色。为了实现这个，我们需要在顶点着色器中添加一个额外的顶点属性，表示颜色信息，将它传递至几何着色器，并再次发送到片段着色器中。\r\n下面是更新后的顶点数据：\r\n123456float points[] = &#123;    -0.5f,  0.5f, 1.0f, 0.0f, 0.0f, // 左上     0.5f,  0.5f, 0.0f, 1.0f, 0.0f, // 右上     0.5f, -0.5f, 0.0f, 0.0f, 1.0f, // 右下    -0.5f, -0.5f, 1.0f, 1.0f, 0.0f  // 左下&#125;;\r\n然后我们更新顶点着色器，使用一个接口块将颜色属性发送到几何着色器中：\r\n12345678910111213#version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec3 aColor;out VS_OUT &#123;    vec3 color;&#125; vs_out;void main()&#123;    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);    vs_out.color = aColor;&#125;\r\n接下来我们还需要在几何着色器中声明相同的接口块（使用一个不同的接口名）：\r\n123in VS_OUT &#123;    vec3 color;&#125; gs_in[];\r\n因为几何着色器是作用于输入的一组顶点的，从顶点着色器发来输入数据总是会以数组的形式表示出来，即便我们现在只有一个顶点。\r\n我们并不是必须要用接口块来向几何着色器传递数据。如果顶点着色器发送的颜色向量是out vec3 vColor，我们也可以这样写：\r\n1in vec3 vColor[];\r\n然而，接口块在几何着色器这样的着色器中会更容易处理一点。实际上，几何着色器的输入能够变得非常大，将它们合并为一个大的接口块数组会更符合逻辑一点。\r\n接下来我们还需要为下个片段着色器阶段声明一个输出颜色向量：\r\n1out vec3 fColor;\r\n因为片段着色器只需要一个（插值的）颜色，发送多个颜色并没有什么意义。所以，fColor\r\n向量就不是一个数组，而是一个单独的向量。当发射一个顶点的时候，每个顶点将会使用最后在\r\nfColor\r\n中储存的值，来用于片段着色器的运行。对我们的房子来说，我们只需要在第一个顶点发射之前，使用顶点着色器中的颜色填充\r\nfColor 一次就可以了。\r\n123456789101112fColor = gs_in[0].color; // gs_in[0] 因为只有一个输入顶点gl_Position = position + vec4(-0.2, -0.2, 0.0, 0.0);    // 1:左下EmitVertex();gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0);    // 2:右下EmitVertex();gl_Position = position + vec4(-0.2,  0.2, 0.0, 0.0);    // 3:左上EmitVertex();gl_Position = position + vec4( 0.2,  0.2, 0.0, 0.0);    // 4:右上EmitVertex();gl_Position = position + vec4( 0.0,  0.4, 0.0, 0.0);    // 5:顶部EmitVertex();EndPrimitive();\r\n所有发射出的顶点都将嵌有最后储存在 fColor\r\n中的值，即顶点的颜色属性值。所有的房子都会有它们自己的颜色了：\r\n\r\n\r\nimg\r\n\r\n仅仅是为了有趣，我们也可以假装这是冬天，将最后一个顶点的颜色设置为白色，给屋顶落上一些雪。\r\n12345678910111213fColor = gs_in[0].color;gl_Position = position + vec4(-0.2, -0.2, 0.0, 0.0);    // 1:左下EmitVertex();gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0);    // 2:右下EmitVertex();gl_Position = position + vec4(-0.2,  0.2, 0.0, 0.0);    // 3:左上EmitVertex();gl_Position = position + vec4( 0.2,  0.2, 0.0, 0.0);    // 4:右上EmitVertex();gl_Position = position + vec4( 0.0,  0.4, 0.0, 0.0);    // 5:顶部fColor = vec3(1.0, 1.0, 1.0);EmitVertex();EndPrimitive();\r\n最终结果看起来是这样的：\r\n\r\n\r\nimg\r\n\r\n你可以将你的代码与这里的\r\nOpenGL 代码进行比对。\r\n你可以看到，有了几何着色器，你甚至可以将最简单的图元变得十分有创意。因为这些形状是在\r\nGPU\r\n的超快硬件中动态生成的，这会比在顶点缓冲中手动定义图形要高效很多。因此，几何缓冲对简单而且经常重复的形状来说是一个很好的优化工具，比如体素(Voxel)世界中的方块和室外草地的每一根草。\r\n法向量可视化\r\n在这一部分中，我们将使用几何着色器来实现一个真正有用的例子：显示任意物体的法向量。当编写光照着色器时，你可能会最终会得到一些奇怪的视觉输出，但又很难确定导致问题的原因。光照错误很常见的原因就是法向量错误，这可能是由于不正确加载顶点数据、错误地将它们定义为顶点属性或在着色器中不正确地管理所导致的。我们想要的是使用某种方式来检测提供的法向量是正确的。检测法向量是否正确的一个很好的方式就是对它们进行可视化，几何着色器正是实现这一目的非常有用的工具。\r\n思路是这样的：我们首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。伪代码看起来会像是这样：\r\n1234shader.use();DrawScene();normalDisplayShader.use();DrawScene();\r\n这次在几何着色器中，我们会使用模型提供的顶点法线，而不是自己生成，为了适配（观察和模型矩阵的）缩放和旋转，我们在将法线变换到观察空间坐标之前，先使用法线矩阵变换一次（几何着色器接受的位置向量是观察空间坐标，所以我们应该将法向量变换到相同的空间中）。这可以在顶点着色器中完成：\r\n1234567891011121314151617#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;out VS_OUT &#123;    vec3 normal;&#125; vs_out;uniform mat4 view;uniform mat4 model;void main()&#123;    gl_Position = view * model * vec4(aPos, 1.0);    mat3 normalMatrix = mat3(transpose(inverse(view * model)));    vs_out.normal = normalize(vec3(vec4(normalMatrix * aNormal, 0.0)));&#125;\r\n变换后的观察空间法向量会以接口块的形式传递到下个着色器阶段。接下来，几何着色器会接收每一个顶点（包括一个位置向量和一个法向量），并在每个位置向量处绘制一个法线向量：\r\n12345678910111213141516171819202122232425262728#version 330 corelayout (triangles) in;layout (line_strip, max_vertices = 6) out;in VS_OUT &#123;    vec3 normal;&#125; gs_in[];const float MAGNITUDE = 0.4;uniform mat4 projection;void GenerateLine(int index)&#123;    gl_Position = projection * gl_in[index].gl_Position;    EmitVertex();    gl_Position = projection * (gl_in[index].gl_Position +                                vec4(gs_in[index].normal, 0.0) * MAGNITUDE);    EmitVertex();    EndPrimitive();&#125;void main()&#123;    GenerateLine(0); // 第一个顶点法线    GenerateLine(1); // 第二个顶点法线    GenerateLine(2); // 第三个顶点法线&#125;\r\n像这样的几何着色器应该很容易理解了。注意我们将法向量乘以了一个\r\nMAGNITUDE 向量，来限制显示出的法向量大小（否则它们就有点大了）。\r\n因为法线的可视化通常都是用于调试目的，我们可以使用片段着色器，将它们显示为单色的线（如果你愿意也可以是非常好看的线）：\r\n1234567#version 330 coreout vec4 FragColor;void main()&#123;    FragColor = vec4(1.0, 1.0, 0.0, 1.0);&#125;\r\n现在，首先使用普通着色器渲染模型，再使用特别的法线可视化着色器渲染，你将看到这样的效果：\r\n\r\n\r\nimg\r\n\r\n尽管我们的纳米装现在看起来像是一个体毛很多而且带着隔热手套的人，它能够很有效地帮助我们判断模型的法线是否正确。你可以想象到，这样的几何着色器也经常用于给物体添加毛发(Fur)。\r\n\r\n你可能会对 gl_position 开始出现疑问：这到底是不是一个类似于\r\nSV_POSITION\r\n的变量？嗯，实际上应该是的，但这里的问题其实出在，我们没必要一定在\r\nVertex Shader 阶段就将这个变量变换到 Clip Space\r\n上，我们完全可以保持它不变，然后再于 Geometry Shader\r\n中进行变换——这完全是可行的。并且我们得建立这个认知：几何着色器中的\r\ngl_Position\r\n是从顶点着色器中传过来的。也就是说顶点着色器中算出来的顶点是什么空间的，那么几何着色器中就是哪个空间的。\r\n\r\n实例化\r\n\r\n假设你有一个绘制了很多模型的场景，而大部分的模型包含的是同一组顶点数据，只不过进行的是不同的世界空间变换。想象一个充满草的场景：每根草都是一个包含几个三角形的小模型。你可能会需要绘制很多根草，最终在每帧中你可能会需要渲染上千或者上万根草。因为每一根草仅仅是由几个三角形构成，渲染几乎是瞬间完成的，但上千个渲染函数调用却会极大地影响性能。\r\n\r\n如果我们需要渲染大量物体时，代码看起来会像这样：\r\n1234for(unsigned int i = 0; i &lt; amount_of_models_to_draw; i++) &#123;    DoSomePreparations(); // 绑定VAO，绑定纹理，设置uniform等    glDrawArrays(GL_TRIANGLES, 0, amount_of_vertices);&#125;\r\n如果像这样绘制模型的大量实例(Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。\r\n与绘制顶点本身相比，使用 glDrawArrays 或\r\nglDrawElements 函数告诉 GPU\r\n去绘制你的顶点数据会消耗更多的性能，因为 OpenGL\r\n在绘制顶点数据之前需要做很多准备工作（比如告诉 GPU\r\n该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的 CPU 到\r\nGPU 总线(CPU to GPU Bus)上进行的）。所以，即便渲染顶点非常快，命令 GPU\r\n去渲染却未必。\r\n如果我们能够将数据一次性发送给 GPU，然后使用一个绘制函数让\r\nOpenGL\r\n利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)。\r\n实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时\r\nCPU -&gt; GPU\r\n的通信，它只需要一次即可。如果想使用实例化渲染，我们只需要将\r\nglDrawArrays 和 glDrawElements\r\n的渲染调用分别改为 glDrawArraysInstanced 和\r\nglDrawElementsInstanced\r\n就可以了。这些渲染函数的实例化版本需要一个额外的参数，叫做实例数量(Instance\r\nCount)，它能够设置我们需要渲染的实例个数。这样我们只需要将必须的数据发送到\r\nGPU 一次，然后使用一次函数调用告诉 GPU 它应该如何绘制这些实例。GPU\r\n将会直接渲染这些实例，而不用不断地与 CPU 进行通信。\r\n这个函数本身并没有什么用。渲染同一个物体一千次对我们并没有什么用处，每个物体都是完全相同的，而且还在同一个位置。我们只能看见一个物体！处于这个原因，GLSL\r\n在顶点着色器中嵌入了另一个内建变量，gl_InstanceID。\r\n在使用实例化渲染调用时，gl_InstanceID 会从 0\r\n开始，在每个实例被渲染时递增 1。比如说，我们正在渲染第 43\r\n个实例，那么顶点着色器中它的 gl_InstanceID 将会是\r\n42。因为每个实例都有唯一的 ID，我们可以建立一个数组，将 ID\r\n与位置值对应起来，将每个实例放置在世界的不同位置。\r\n如果不用实例化绘制的具体特性\r\n为了体验一下实例化绘制，我们将会在标准化设备坐标系中使用一个渲染调用，绘制\r\n100 个 2D 四边形。我们会索引一个包含 100 个偏移向量的 uniform\r\n数组，将偏移值加到每个实例化的四边形上。最终的结果是一个排列整齐的四边形网格：\r\n\r\n\r\nimg\r\n\r\n每个四边形由 2 个三角形所组成，一共有 6 个顶点。每个顶点包含一个 2D\r\n的标准化设备坐标位置向量和一个颜色向量。\r\n下面就是这个例子使用的顶点数据，为了大量填充屏幕，每个三角形都很小：\r\n12345678910float quadVertices[] = &#123;    // 位置          // 颜色    -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,     0.05f, -0.05f,  0.0f, 1.0f, 0.0f,    -0.05f, -0.05f,  0.0f, 0.0f, 1.0f,    -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,     0.05f, -0.05f,  0.0f, 1.0f, 0.0f,     0.05f,  0.05f,  0.0f, 1.0f, 1.0f&#125;;\r\n片段着色器会从顶点着色器接受颜色向量，并将其设置为它的颜色输出，来实现四边形的颜色：\r\n12345678#version 330 coreout vec4 FragColor;in vec3 fColor;void main() &#123;    FragColor = vec4(fColor, 1.0);&#125;\r\n到现在都没有什么新内容，但从顶点着色器开始就变得很有趣了：\r\n12345678910111213#version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec3 aColor;out vec3 fColor;uniform vec2 offsets[100];void main() &#123;    vec2 offset = offsets[gl_InstanceID];    gl_Position = vec4(aPos + offset, 0.0, 1.0);    fColor = aColor;&#125;\r\n这里我们定义了一个叫做 offsets 的数组，它包含 100\r\n个偏移向量。在顶点着色器中，我们会使用 gl_InstanceID 来索引\r\noffsets 数组，获取每个实例的偏移向量。如果我们要实例化绘制 100\r\n个四边形，仅使用这个顶点着色器我们就能得到 100\r\n个位于不同位置的四边形。\r\n当前，我们仍要设置这些偏移位置，我们会在进入渲染循环之前使用一个嵌套\r\nfor 循环计算：\r\n1234567891011glm::vec2 translations[100];int index = 0;float offset = 0.1f;for(int y = -10; y &lt; 10; y += 2) &#123;    for(int x = -10; x &lt; 10; x += 2) &#123;        glm::vec2 translation;        translation.x = (float)x / 10.0f + offset;        translation.y = (float)y / 10.0f + offset;        translations[index++] = translation;    &#125;&#125;\r\n这里，我们创建 100 个位移向量，表示 10x10 网格上的所有位置。除了生成\r\ntranslations 数组之外，我们还需要将数据转移到顶点着色器的 uniform\r\n数组中：\r\n12345678shader.use();for(unsigned int i = 0; i &lt; 100; i++) &#123;    stringstream ss;    string index;    ss &lt;&lt; i;    index = ss.str();    shader.setVec2((&quot;offsets[&quot; + index + &quot;]&quot;).c_str(), translations[i]);&#125;\r\n在这一段代码中，我们将 for 循环的计数器 i 转换为一个\r\nstring，我们可以用它来动态创建位置值的字符串，用于 uniform\r\n位置值的索引。接下来，我们会对 offsets uniform\r\n数组中的每一项设置对应的位移向量。\r\n现在所有的准备工作都做完了，我们可以开始渲染四边形了。对于实例化渲染，我们使用\r\nglDrawArraysInstanced 或\r\nglDrawElementsInstanced。因为我们使用的不是索引缓冲，我们会调用\r\nglDrawArrays 版本的函数：\r\n12glBindVertexArray(quadVAO);glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 100);\r\nglDrawArraysInstanced 的参数和 glDrawArrays\r\n完全一样，除了最后多了个参数用来设置需要绘制的实例数量。因为我们想要在\r\n10x10 网格中显示 100 个四边形，我们将它设置为\r\n100.运行代码之后，你应该能得到熟悉的 100 个五彩的四边形。\r\n实例化数组\r\n虽然之前的实现在目前的情况下能够正常工作，但是如果我们要渲染远超过\r\n100 个实例的时候（这其实非常普遍），我们最终会超过最大能够发送至着色器的\r\nuniform 数据大小上限。它的一个代替方案是实例化数组(Instanced\r\nArray)，它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。\r\n使用顶点属性时，顶点着色器的每次运行都会让 GLSL\r\n获取新一组适用于当前顶点的属性。而当我们将顶点属性定义为一个实例化数组时，顶点着色器就只需要对每个实例，而不是每个顶点，更新顶点属性的内容了。这允许我们对逐顶点的数据使用普通的顶点属性，而对逐实例的数据使用实例化数组。\r\n为了给你一个实例化数组的例子，我们将使用之前的例子，并将偏移量\r\nuniform\r\n数组设置为一个实例化数组。我们需要在顶点着色器中再添加一个顶点属性：\r\n1234567891011#version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aOffset;out vec3 fColor;void main() &#123;    gl_Position = vec4(aPos + aOffset, 0.0, 1.0);    fColor = aColor;&#125;\r\n我们不再使用 gl_InstanceID，现在不需要索引一个 uniform\r\n数组就能够直接使用 offset 属性了。\r\n因为实例化数组和 position 与 color\r\n变量一样，都是顶点属性，我们还需要将它的内容存在顶点缓冲对象中，并且配置它的属性指针。我们首先将（上一部分的）translations\r\n数组存到一个新的缓冲对象中：\r\n12345unsigned int instanceVBO;glGenBuffers(1, &amp;instanceVBO);glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec2) * 100, &amp;translations[0], GL_STATIC_DRAW);glBindBuffer(GL_ARRAY_BUFFER, 0);\r\n之后我们还需要设置它的顶点属性指针，并启用顶点属性：\r\n12345glEnableVertexAttribArray(2);glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);glBindBuffer(GL_ARRAY_BUFFER, 0);glVertexAttribDivisor(2, 1);\r\n这段代码很有意思的地方在于最后一行，我们调用了\r\nglVertexAttribDivisor。这个函数告诉了 OpenGL\r\n该什么时候更新顶点属性的内容至新一组数据。它的第一个参数是需要的顶点属性，第二个参数是属性除数(Attribute\r\nDivisor)。默认情况下，属性除数是 0，告诉 OpenGL\r\n我们需要在顶点着色器的每次迭代时更新顶点属性。将它设置为\r\n1 时，我们告诉 OpenGL\r\n我们希望在渲染一个新实例的时候更新顶点属性。而设置为 2 时，我们希望每 2\r\n个实例更新一次属性，以此类推。我们将属性除数设置为 1，是在告诉\r\nOpenGL，处于位置值 2 的顶点属性是一个实例化数组。\r\n\r\n你可能会对这里的 glVertexAttribDivisor\r\n感到疑惑，我们输入的顶点属性不是和顶点一致的吗？怎么又谈到更新的事情？\r\n让我们仔细对比这里的具体内容：\r\n对于普通的顶点属性，我们又类似下方的设计：\r\n12345678910float quadVertices[] = &#123; // 位置          // 颜色 -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,  0.05f, -0.05f,  0.0f, 1.0f, 0.0f, -0.05f, -0.05f,  0.0f, 0.0f, 1.0f, -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,  0.05f, -0.05f,  0.0f, 1.0f, 0.0f,  0.05f,  0.05f,  0.0f, 1.0f, 1.0f&#125;;\r\n可以发现的是，对于普通的顶点属性，首先它的数量是和顶点完全一致的并且是逐顶点细化的，这让我们可以控制每个顶点的渲染效果。\r\n而对于我们现在新用到的顶点属性的设计，则不是以逐顶点为目的的，这一点从数量上就能反映出来：\r\n1glm::vec2 translations[100];\r\n这 100 个内容，不是为某个顶点服务的，而是为我们将要先后渲染的 100 的\r\nInstance\r\n服务的。而同时，它还有另一个特点：就是一个模型中，每个顶点所用到的数据都是相同的。也就是说，这种新式的顶点属性的目的是逐模型的，而显而易见的，默认的顶点属性指针是为前者而设计的——它只会在单个模型渲染过程中，依照对应的目的进行移动。而为了达成逐模型渲染的目的，我们必须手动拨动指针进行位移——这就是为什么我们需要修改\r\nglVertexAttribDivisor\r\n\r\n如果我们现在使用\r\nglDrawArraysInstanced，再次渲染四边形，会得到以下输出：\r\n\r\n\r\nimg\r\n\r\n这和之前的例子是完全一样的，但这次是使用实例化数组实现的，这让我们能够传递更多的数据到顶点着色器（只要内存允许）来用于实例化绘制。\r\n为了更有趣一点，我们也可以使用\r\ngl_InstanceID，从右上到左下逐渐缩小四边形：\r\n12345void main() &#123;    vec2 pos = aPos * (gl_InstanceID / 100.0);    gl_Position = vec4(pos + aOffset, 0.0, 1.0);    fColor = aColor;&#125;\r\n结果就是，第一个四边形的实例会非常小，随着绘制实例的增加，gl_InstanceID\r\n会越来越接近 100，四边形也就越来越接近原始大小。像这样将实例化数组与\r\ngl_InstanceID 结合使用是完全可行的。\r\n\r\n\r\nimg\r\n\r\n如果你还是不确定实例化渲染是如何工作的，或者想看看所有代码是如何组合起来的，你可以在这里找到程序的源代码。\r\n虽然很有趣，但是这些例子并不是实例化的好例子。是的，它们的确让你知道实例化是怎么工作的，但是我们还没接触到它最有用的一点：绘制巨大数量的相似物体。出于这个原因，我们将会在下一部分进入太空探险，见识实例化渲染真正的威力。\r\n小行星带\r\n想象这样一个场景，在宇宙中有一个大的行星，它位于小行星带的中央。这样的小行星带可能包含成千上万的岩块，在很不错的显卡上也很难完成这样的渲染。实例化渲染正是适用于这样的场景，因为所有的小行星都可以使用一个模型来表示。每个小行星可以再使用不同的变换矩阵来进行少许的变化。\r\n为了展示实例化渲染的作用，我们首先会不使用实例化渲染，来渲染小行星绕着行星飞行的场景。这个场景将会包含一个大的行星模型，它可以在这里下载，以及很多环绕着行星的小行星。小行星的岩石模型可以在这里下载。\r\n在代码例子中，我们将使用在模型加载小节中定义的模型加载器来加载模型。\r\n为了得到想要的效果，我们将会为每个小行星生成一个变换矩阵，用作它们的模型矩阵。变换矩阵首先将小行星位移到小行星带中的某处，我们还会加一个小的随机偏移值到这个偏移量上，让这个圆环看起来更自然一点。接下来，我们应用一个随机的缩放，并且以一个旋转向量为轴进行一个随机的旋转。最终的变换矩阵不仅能将小行星变换到行星的周围，而且会让它看起来更自然，与其它小行星不同。最终的结果是一个布满小行星的圆环，其中每一个小行星都与众不同。\r\n1234567891011121314151617181920212223242526272829unsigned int amount = 1000;glm::mat4 *modelMatrices;modelMatrices = new glm::mat4[amount];srand(glfwGetTime()); // 初始化随机种子float radius = 50.0;float offset = 2.5f;for(unsigned int i = 0; i &lt; amount; i++) &#123;    glm::mat4 model;    // 1. 位移：分布在半径为 &#x27;radius&#x27; 的圆形上，偏移的范围是 [-offset, offset]    float angle = (float)i / (float)amount * 360.0f;    float displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset;    float x = sin(angle) * radius + displacement;    displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset;    float y = displacement * 0.4f; // 让行星带的高度比x和z的宽度要小    displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset;    float z = cos(angle) * radius + displacement;    model = glm::translate(model, glm::vec3(x, y, z));    // 2. 缩放：在 0.05 和 0.25f 之间缩放    float scale = (rand() % 20) / 100.0f + 0.05;    model = glm::scale(model, glm::vec3(scale));    // 3. 旋转：绕着一个（半）随机选择的旋转轴向量进行随机的旋转    float rotAngle = (rand() % 360);    model = glm::rotate(model, rotAngle, glm::vec3(0.4f, 0.6f, 0.8f));    // 4. 添加到矩阵的数组中    modelMatrices[i] = model;&#125;\r\n这段代码看起来可能有点吓人，但我们只是将小行星的x和z位置变换到了一个半径为\r\nradius 的圆形上，并且在半径的基础上偏移了-offset 到\r\noffset。我们让y偏移的影响更小一点，让小行星带更扁平一点。接下来，我们应用了缩放和旋转变换，并将最终的变换矩阵储存在\r\nmodelMatrices 中，这个数组的大小是 amount。这里，我们一共生成 1000\r\n个模型矩阵，每个小行星一个。\r\n在加载完行星和岩石模型，并编译完着色器之后，渲染的代码看起来是这样的：\r\n12345678910111213// 绘制行星shader.use();glm::mat4 model;model = glm::translate(model, glm::vec3(0.0f, -3.0f, 0.0f));model = glm::scale(model, glm::vec3(4.0f, 4.0f, 4.0f));shader.setMat4(&quot;model&quot;, model);planet.Draw(shader);// 绘制小行星for(unsigned int i = 0; i &lt; amount; i++) &#123;    shader.setMat4(&quot;model&quot;, modelMatrices[i]);    rock.Draw(shader);&#125;\r\n我们首先绘制了行星的模型，并对它进行位移和缩放，以适应场景，接下来，我们绘制\r\namount\r\n数量的岩石模型。在绘制每个岩石之前，我们首先需要在着色器内设置对应的模型变换矩阵。\r\n最终的结果是一个看起来像是太空的场景，环绕着行星的是看起来很自然的小行星带：\r\n\r\n\r\nimg\r\n\r\n这个场景每帧包含 1001 次渲染调用，其中 1000 个是岩石模型。你可以在这里找到源代码。\r\n当我们开始增加这个数字的时候，你很快就会发现场景不再能够流畅运行了，帧数也下降很厉害。当我们将\r\namount 设置为 2000 的时候，场景就已经慢到移动都很困难的程度了。\r\n现在，我们来尝试使用实例化渲染来渲染相同的场景。我们首先对顶点着色器进行一点修改：\r\n1234567891011121314#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 2) in vec2 aTexCoords;layout (location = 3) in mat4 instanceMatrix;out vec2 TexCoords;uniform mat4 projection;uniform mat4 view;void main() &#123;    gl_Position = projection * view * instanceMatrix * vec4(aPos, 1.0);    TexCoords = aTexCoords;&#125;\r\n我们不再使用模型 uniform 变量，改为一个 mat4\r\n的顶点属性，让我们能够存储一个实例化数组的变换矩阵。然而，当我们顶点属性的类型大于\r\nvec4 时，就要多进行一步处理了。顶点属性最大允许的数据大小等于一个\r\nvec4。因为一个 mat4 本质上是 4 个 vec4，我们需要为这个矩阵预留 4\r\n个顶点属性。因为我们将它的位置值设置为 3，矩阵每一列的顶点属性位置值就是\r\n3、4、5 和 6。\r\n接下来，我们需要为这 4\r\n个顶点属性设置属性指针，并将它们设置为实例化数组：\r\n12345678910111213141516171819202122232425262728// 顶点缓冲对象unsigned int buffer;glGenBuffers(1, &amp;buffer);glBindBuffer(GL_ARRAY_BUFFER, buffer);glBufferData(GL_ARRAY_BUFFER, amount * sizeof(glm::mat4), &amp;modelMatrices[0], GL_STATIC_DRAW);for(unsigned int i = 0; i &lt; rock.meshes.size(); i++)&#123;    unsigned int VAO = rock.meshes[i].VAO;    glBindVertexArray(VAO);    // 顶点属性    GLsizei vec4Size = sizeof(glm::vec4);    glEnableVertexAttribArray(3);    glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)0);    glEnableVertexAttribArray(4);    glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(vec4Size));    glEnableVertexAttribArray(5);    glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(2 * vec4Size));    glEnableVertexAttribArray(6);    glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(3 * vec4Size));    glVertexAttribDivisor(3, 1);    glVertexAttribDivisor(4, 1);    glVertexAttribDivisor(5, 1);    glVertexAttribDivisor(6, 1);    glBindVertexArray(0);&#125;\r\n注意这里我们将 Mesh 的 VAO\r\n从私有变量改为了公有变量，让我们能够访问它的顶点数组对象。这并不是最好的解决方案，只是为了配合本小节的一个简单的改动。除此之外代码就应该很清楚了。我们告诉了\r\nOpenGL\r\n应该如何解释每个缓冲顶点属性的缓冲，并且告诉它这些顶点属性是实例化数组。\r\n接下来，我们再次使用网格的 VAO，这一次使用 glDrawElementsInstanced\r\n进行绘制：\r\n123456789// 绘制小行星instanceShader.use();for(unsigned int i = 0; i &lt; rock.meshes.size(); i++)&#123;    glBindVertexArray(rock.meshes[i].VAO);    glDrawElementsInstanced(        GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, 0, amount    );&#125;\r\n这里，我们绘制与之前相同数量 amount\r\n的小行星，但是使用的是实例渲染。结果应该是非常相似的，但如果你开始增加\r\namount\r\n变量，你就能看见实例化渲染的效果了。没有实例化渲染的时候，我们只能流畅渲染\r\n1000 到 1500 个小行星。而使用了实例化渲染之后，我们可以将这个值设置为\r\n100000，每个岩石模型有 576 个顶点，每帧加起来大概要绘制 5700\r\n万个顶点，但性能却没有受到任何影响！\r\n\r\n\r\nimg\r\n\r\n上面这幅图渲染了 10\r\n万个小行星，半径为150.0f，偏移量等于25.0f。在某些机器上，10\r\n万个小行星可能会太多了，所以尝试修改这个值，直到达到一个你能接受的帧率。\r\n可以看到，在合适的环境下，实例化渲染能够大大增加显卡的渲染能力。正是出于这个原因，实例化渲染通常会用于渲染草、植被、粒子，以及上面这样的场景，基本上只要场景中有很多重复的形状，都能够使用实例化渲染来提高性能。\r\n抗锯齿\r\n在学习渲染的旅途中，你可能会时不时遇到模型边缘有锯齿的情况。这些锯齿边缘(Jagged\r\nEdges)的产生和光栅器将顶点数据转化为片段的方式有关。在下面的例子中，你可以看到，我们只是绘制了一个简单的立方体，你就能注意到它存在锯齿边缘了：\r\n\r\n\r\nimg\r\n\r\n可能不是非常明显，但如果你离近仔细观察立方体的边缘，你就应该能够看到锯齿状的图案。如果放大的话，你会看到下面的图案：\r\n\r\n\r\nimg\r\n\r\n这很明显不是我们想要在最终程序中所实现的效果。你能够清楚看见形成边缘的像素。这种现象被称之为走样(Aliasing)。有很多种抗锯齿（Anti-aliasing，也被称为反走样）的技术能够帮助我们缓解这种现象，从而产生更平滑的边缘。\r\n最开始我们有一种叫做超采样抗锯齿(Super Sample Anti-aliasing,\r\nSSAA)的技术，它会使用比正常分辨率更高的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率。这些额外的分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的性能开销。所以这项技术只拥有了短暂的辉煌。\r\n然而，在这项技术的基础上也诞生了更为现代的技术，叫做多重采样抗锯齿(Multisample\r\nAnti-aliasing, MSAA)。它借鉴了 SSAA\r\n背后的理念，但却以更加高效的方式实现了抗锯齿。我们在这一节中会深度讨论\r\nOpenGL 中内建的 MSAA 技术。\r\n多重采样\r\n为了理解什么是多重采样(Multisampling)，以及它是如何解决锯齿问题的，我们有必要更加深入地了解\r\nOpenGL 光栅器的工作方式。\r\n光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。\r\n\r\n\r\nimg\r\n\r\n这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点(Sample\r\nPoint)，它会被用来决定这个三角形是否遮盖了某个像素。图中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所遮盖，所以它们不会受到片段着色器的影响。\r\n你现在可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的：\r\n\r\n\r\nimg\r\n\r\n由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致之前讨论到的锯齿边缘。\r\n多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的\r\n4\r\n个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。\r\n\r\n\r\nimg\r\n\r\n上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有\r\n4 个采样点。这里，只有两个采样点遮盖住了三角形。\r\n采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。\r\n从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了 2\r\n个子采样点，所以下一步是决定这个像素的颜色。你的猜想可能是，我们对每个被遮盖住的子采样点运行一次片段着色器，最后将每个像素所有子采样点的颜色平均一下。在这个例子中，我们需要在两个子采样点上对被插值的顶点数据运行两次片段着色器，并将结果的颜色储存在这些采样点中。（幸运的是）这并不是它工作的方式，因为这本质上说还是需要运行更多次的片段着色器，会显著地降低性能。\r\nMSAA\r\n真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的\r\n4 个采样点中只有 2\r\n个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。\r\n这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形。让我们来看看前面三角形的多重采样会是什么样子：\r\n\r\n\r\nimg\r\n\r\n这里，每个像素包含 4\r\n个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的\r\n4\r\n个子样本中。而在三角形的边缘，并不是所有的子采样点都被遮盖，所以片段着色器的结果将只会储存到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所储存的颜色来决定。\r\n简单来说，一个像素中如果有更多的采样点被三角形遮盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下的效果：\r\n\r\n\r\nimg\r\n\r\n对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。\r\n不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。\r\n我们到目前为止讨论的都是多重采样抗锯齿的背后原理，光栅器背后的实际逻辑比目前讨论的要复杂，但你现在应该已经可以理解多重采样抗锯齿的大体概念和逻辑了。\r\n(译者注： 如果看到这里还是对原理似懂非懂，可以简单看看知乎上@文刀秋二对抗锯齿技术的精彩介绍)\r\nOpenGL 中的 MSAA\r\n如果我们想要在 OpenGL 中使用\r\nMSAA，我们必须要使用一个能在每个像素中存储大于 1\r\n个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做多重采样缓冲(Multisample\r\nBuffer)。\r\n大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲。GLFW\r\n同样给了我们这个功能，我们所要做的只是提示(Hint)\r\nGLFW，我们希望使用一个包含 N\r\n个样本的多重采样缓冲。这可以在创建窗口之前调用\r\nglfwWindowHint 来完成。\r\n1glfwWindowHint(GLFW_SAMPLES, 4);\r\n现在再调用 glfwCreateWindow\r\n创建渲染窗口时，每个屏幕坐标就会使用一个包含 4\r\n个子采样点的颜色缓冲了。GLFW 会自动创建一个每像素 4\r\n个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了 4 倍。\r\n现在我们已经向 GLFW 请求了多重采样缓冲，我们还需要调用\r\nglEnable 并启用 GL_MULTISAMPLE，来启用多重采样。在大多数\r\nOpenGL\r\n的驱动上，多重采样都是默认启用的，所以这个调用可能会有点多余，但显式地调用一下会更保险一点。这样子不论是什么\r\nOpenGL 的实现都能够正常启用多重采样了。\r\n1glEnable(GL_MULTISAMPLE);\r\n只要默认的帧缓冲有了多重采样缓冲的附件，我们所要做的只是调用 glEnable\r\n来启用多重采样。因为多重采样的算法都在 OpenGL\r\n驱动的光栅器中实现了，我们不需要再多做什么。如果现在再来渲染本节一开始的那个绿色的立方体，我们应该能看到更平滑的边缘：\r\n\r\n\r\nimg\r\n\r\n这个箱子看起来的确要平滑多了，如果在场景中有其它的物体，它们也会看起来平滑很多。\r\n离屏 MSAA\r\n由于 GLFW 负责了创建多重采样缓冲，启用 MSAA\r\n非常简单。然而，如果我们想要使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己动手生成多重采样缓冲了。\r\n有两种方式可以创建多重采样缓冲，将其作为帧缓冲的附件：纹理附件和渲染缓冲附件，这和在帧缓冲教程中所讨论的普通附件很相似。\r\n多重采样纹理附件\r\n为了创建一个支持储存多个采样点的纹理，我们使用\r\nglTexImage2DMultisample 来替代\r\nglTexImage2D，它的纹理目标是 GL_TEXTURE_2D_MULTISAPLE。\r\n123glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);\r\n它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为\r\nGL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。\r\n我们使用 glFramebufferTexture2D\r\n将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是\r\nGL_TEXTURE_2D_MULTISAMPLE。\r\n1glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0);\r\n当前绑定的帧缓冲现在就有了一个纹理图像形式的多重采样颜色缓冲。\r\n多重采样渲染缓冲对象\r\n和纹理类似，创建一个多重采样渲染缓冲对象并不难。我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将\r\nglRenderbufferStorage\r\n的调用改为glRenderbufferStorageMultisample 就可以了。\r\n1glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height);\r\n函数中，渲染缓冲对象后的参数我们将设定为样本的数量，在当前的例子中是\r\n4。\r\n渲染到多重采样帧缓冲\r\n渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及/或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。\r\n一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。多重采样帧缓冲的还原通常是通过\r\nglBlitFramebuffer\r\n来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。\r\nglBlitFramebuffer 会将一个用 4\r\n个屏幕空间坐标所定义的源区域复制到一个同样用 4\r\n个屏幕空间坐标所定义的目标区域中。你可能记得在帧缓冲教程中，当我们绑定到\r\nGL_FRAMEBUFFER\r\n时，我们是同时绑定了读取和绘制的帧缓冲目标。我们也可以将帧缓冲分开绑定至\r\nGL_READ_FRAMEBUFFER 与\r\nGL_DRAW_FRAMEBUFFER。glBlitFramebuffer\r\n函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，我们可以将图像位块传送(Blit)到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。\r\n123glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO);glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);\r\n如果现在再来渲染这个程序，我们会得到与之前完全一样的结果：一个使用\r\nMSAA 显示出来的橄榄绿色的立方体，而且锯齿边缘明显减少了：\r\n\r\n\r\nimg\r\n\r\n但如果我们想要使用多重采样帧缓冲的纹理输出来做像是后期处理这样的事情呢？我们不能直接在片段着色器中使用多重采样的纹理。但我们能做的是将多重采样缓冲位块传送到一个没有使用多重采样纹理附件的\r\nFBO\r\n中。然后用这个普通的颜色附件来做后期处理，从而达到我们的目的。然而，这也意味着我们需要生成一个新的\r\nFBO，作为中介帧缓冲对象，将多重采样缓冲还原为一个能在着色器中使用的普通\r\n2D 纹理。这个过程的伪代码是这样的：\r\n123456789101112131415161718192021222324unsigned int msFBO = CreateFBOWithMultiSampledAttachments();// 使用普通的纹理颜色附件创建一个新的FBO...glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, 0);...while(!glfwWindowShouldClose(window))&#123;    ...    glBindFramebuffer(msFBO);    ClearFrameBuffer();    DrawScene();    // 将多重采样缓冲还原到中介FBO上    glBindFramebuffer(GL_READ_FRAMEBUFFER, msFBO);    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);    glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);    // 现在场景是一个2D纹理缓冲，可以将这个图像用来后期处理    glBindFramebuffer(GL_FRAMEBUFFER, 0);    ClearFramebuffer();    glBindTexture(GL_TEXTURE_2D, screenTexture);    DrawPostProcessingQuad();    ...&#125;\r\n如果现在再实现帧缓冲教程中的后期处理效果，我们就能够在一个几乎没有锯齿的场景纹理上进行后期处理了。如果施加模糊的核滤镜，看起来将会是这样：\r\n\r\n\r\nimg\r\n\r\n因为屏幕纹理又变回了一个只有单一采样点的普通纹理，像是边缘检测这样的后期处理滤镜会重新导致锯齿。为了补偿这一问题，你可以之后对纹理进行模糊处理，或者想出你自己的抗锯齿算法。\r\n你可以看到，如果将多重采样与离屏渲染结合起来，我们需要自己负责一些额外的细节。但所有的这些细节都是值得额外的努力的，因为多重采样能够显著提升场景的视觉质量。当然，要注意，如果使用的采样点非常多，启用多重采样会显著降低程序的性能。在本节写作时，通常采用的是\r\n4 采样点的 MSAA。\r\n自定义抗锯齿算法\r\n将一个多重采样的纹理图像不进行还原直接传入着色器也是可行的。GLSL\r\n提供了这样的选项，让我们能够对纹理图像的每个子样本进行采样，所以我们可以创建我们自己的抗锯齿算法。在大型的图形应用中通常都会这么做。\r\n要想获取每个子样本的颜色值，你需要将纹理 uniform 采样器设置为\r\nsampler2DMS，而不是平常使用的 sampler2D：\r\n1uniform sampler2DMS screenTextureMS;\r\n使用 texelFetch 函数就能够获取每个子样本的颜色值了：\r\n1vec4 colorSample = texelFetch(screenTextureMS, TexCoords, 3);  // 第4个子样本\r\n我们不会深入探究自定义抗锯齿技术的细节，这里仅仅是给你一点启发。\r\nReferences\r\n\r\nRendering\r\n学习：Early-Z 与 Z-PrePass - 技术专栏 - Unity 官方开发者社区\r\nUnity\r\nShader-渲染队列，ZTest，ZWrite，Early-Z-腾讯游戏学堂\r\n(tencent.com)\r\nUnity3D 研究院之\r\nURP 下 PrePassZ（一百一十九） | 雨松 MOMO 程序研究院\r\n(xuanyusong.com)\r\nRendering\r\n学习：Early-Z 与 Z-PrePass - 技术专栏 - Unity 官方开发者社区\r\nReversed-Z\r\n详解 - jackmaxwell - 博客园 (cnblogs.com)\r\n程序媛转 TA\r\n之面试篇二：z-fighting，以及 z 精度的最佳分辨率函数 - 知乎\r\n(zhihu.com)\r\nglBlendFuncSeparate\r\n- OpenGL 4 Reference Pages (khronos.org)\r\nAndroid\r\nOpenGLES2.0（十八）——轻松搞定 Blend 颜色混合_湖广午王的博客-CSDN\r\n博客\r\n彩色转灰度的公式\r\n- 野生特效测试员 - 博客园 (cnblogs.com)\r\n详解 Cubemap、IBL\r\n与球谐光照 - 知乎 (zhihu.com)\r\n\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/04Advanced OpenGL/General","date":"2023-03-08T02:33:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"38c975c13d700e0f4a358527ea875949","title":"learningOpenGl Chapter 2.5","content":"Light Casters - 投光物\r\n\r\nAll the lighting we've used so far came from a single source that is\r\na single point in space. It gives good results, but in the real world we\r\nhave several types of light that each act different. A light source that\r\ncasts light upon objects is called a light caster. In this\r\nchapter we'll discuss several different types of light casters. Learning\r\nto simulate different light sources is yet another tool in your toolbox\r\nto further enrich your environments.\r\nWe'll first discuss a directional light, then a point light which is\r\nan extension of what we had before, and lastly we'll discuss spotlights.\r\nIn the next chapter\r\nwe'll combine several of these different light types into one scene.\r\n\r\nDirectional Light\r\n\r\n示例：太阳光\r\n\r\n光源的作用效果只受光源摆放角度的影响，摆放的具体位置一般不会对Directional\r\nLight造成影响\r\n\r\n只有一个点的Directional Light和Point Light的区别：\r\nPoint Light的效果会随着距离而衰减，但Directional\r\nLight不会，这也是它们效果不同的直接成因\r\n\r\nPoint Lights\r\n\r\n示例：无罩电灯泡\r\n\r\n光源的作用效果同时受摆放的角度和位置的影响\r\nAttenuation\r\nChoosing the right values\r\nImplementing attenuation\r\nSpotlight\r\n\r\n示例：舞台聚光灯\r\n\r\n光源的作用效果同时受摆放的角度和位置的影响\r\nFlashlight\r\nSmooth/Soft edges\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/02Lighting/04.Light casters","date":"2023-03-08T02:32:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"ad9f08ec3444afaa1c2eddcf989f6462","title":"learningOpenGl Chapter 2.4","content":"使用：“光照贴图”\r\nProblem 4:\r\n\r\nAlso add something they call an emission map which is a texture that\r\nstores emission values per fragment. Emission values are colors an\r\nobject may emit as if it contains a light source itself; this\r\nway an object can glow regardless of the light conditions. Emission maps\r\nare often what you see when objects in a game glow (like eyes\r\nof a robot, or light\r\nstrips on a container). Add the following\r\ntexture (by creativesam) as an emission map onto the container as if the\r\nletters emit light: solution;\r\nresult:\r\n\r\n\r\nimg\r\n\r\n\r\n重点：Matrix贴图并没有出现在铁边上！也就是说，这并不是直接读入并应用一个贴图那么简单。\r\n为了实现这点，我们需要做“判断”。但是！在glsl中使用分支会直接导致极低的运行效率，而且if语句在早期GPU上是不受支持的——我们应当尽量避免使用if语句，此处我们将这个if语句变成了三个step和一次计算：\r\n1234567vec3 emission = texture(material.emission, Texcoord).rgb * diff * max(light.diffuse, vec3(0.7f));float temp = step(spec_tex.r, 0.0f);  // if spec_tex.r &gt; 0.0f, then return 0 else 1temp = min(step(spec_tex.g, 0.0f), temp);temp = min(step(spec_tex.b, 0.0f), temp); // temp == 0: spec_tex is not black; 1: black;// we complete the problem four without using if sentence.emission = emission * temp;\r\nstep\r\n- OpenGL 4 Reference Pages (khronos.org)\r\nOpenGL\r\nshader性能优化策略（一）：减少分支语句 - 腾讯云开发者社区-腾讯云\r\n(tencent.com)\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/02Lighting/03.Lighting maps","date":"2023-03-08T02:31:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"77ec7ccacfb72fa4bd2436c5873c81ff","title":"learningOpenGl Chapter 2.3","content":"一个场景中，我们可能同时使用多个物体，而这些物体对光的特性各不相同——我们需要建立“材质”属性，统一地管理物体的三种光照关系\r\n构建思路：\r\n我们利用struct来管理物体的对应情况下的“颜色“来代替笼统的”objectColor“\r\n1234567struct Material&#123;    vec3 ambient;    vec3 diffuse;    vec3 specular;    float shininess;&#125;uniform Material material;\r\n\r\n我们为每个冯氏光照模型的元素都定义一个颜色向量。\r\n\r\nambient材质向量定义了在环境光照下这个物体反射的是什么颜色；通常这是和物体颜色相同的颜色。\r\ndiffuse材质向量定义了在漫反射光照下物体的颜色。漫反射颜色被设置为(和环境光照一样)我们需要的物体颜色。\r\nspecular材质向量设置的是物体受到的镜面光照的影响的颜色(或者可能是反射一个物体特定的镜面高光颜色)。\r\nshininess则影响镜面高光的散射/半径。\r\n\r\n这四个元素定义了一个物体的材质，通过它们我们能够模拟很多真实世界的材质。\r\n\r\n定义了物体本身的材质的同时，我们还有一件事情要做：定义光源对物体材质的各个内容上的强度——光源对环境、漫反射和镜面元素，应该同时具有不同的强度：\r\n这样，我们还需要一个struct来管理光线强度，这样我们就可以在不改变物体材质(物体的真实颜色)的条件下，通过改变光源的颜色去改变物体各个元素的强度，来产生很多的效果\r\n12345678struct Light&#123;    vec3 position;    vec3 ambient;    vec3 diffuse;    vec3 specular;&#125;;uniform Light light;\r\n\r\n一个光源的ambient、diffuse和specular光都有不同的亮度。\r\n\r\n环境光通常设置为一个比较低的亮度，因为我们不希望环境色太过显眼。\r\n光源的diffuse元素通常设置为我们希望光所具有的颜色；经常是一个明亮的白色。\r\nspecular元素通常被设置为vec3(1.0f)类型的全强度发光。\r\n要记住的是我们同样把光的位置添加到结构体中。\r\n\r\n\r\n参考：\r\nhttp://devernay.free.fr/cours/opengl/materials.html\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/02Lighting/02.Materials","date":"2023-03-08T02:30:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"e4e32fc3ec80a57afe53517f515d2f2d","title":"learningOpenGl Chapter 2.2","content":"Phong lighting model\r\n裴祥风提出的标准光照模型背后的理念。\r\n\r\n把进入到摄像机内的光线分为4个部分：\r\n\r\nemissive -\r\n自发光部分，用于描述当给定一个方向时，一个表面本身回向该方向发射多少辐射量。\r\nspecular -\r\n高光反射部分，用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量\r\ndiffuse -\r\n漫反射部分，用于描述当光线从光环照射到模型表面时，该表面会向每个方向散射多少辐射量\r\nambient - 环境光部分，用于描述其他所有的间接光照\r\n\r\n\r\n\r\n值得注意的是，如果没有使用全局光照(global\r\nillumination)的话，自发光的表面并不会真的照亮周围物体，只是它本身看起来更亮了而已\r\n着色\r\n逐顶点光照 - Gouraud\r\nShading - 高洛德着色\r\n逐片元着色 - Phong\r\nShading - 冯氏着色\r\n兰伯特\r\n番外 1：Global Light -\r\n全局光照\r\n《Real-Time Rendering 3rd》 提炼总结 第九章\r\n全局光照:光线追踪、路径追踪与GI技术进化编年史 - 毛星云的文章 - 知乎\r\nhttps://zhuanlan.zhihu.com/p/29418992\r\n番外 2：Fresnel - 菲涅尔效应\r\n现象表述：\r\n当视线垂直于表面时，反射较弱，而当视线与表面呈一定夹角时，夹角越小，反射就越明显。\r\n\r\n\r\n同一个地方的湖面，在不同的位置去观察它，总能看到它在不同位置所呈现的效果是不一样的，近处看可以看到清澈见底的湖水，远处看却是波光粼粼的湖面。\r\n\r\n应用\r\n菲涅尔反射是什么？ - BurningMountion的回答 - 知乎\r\nhttps://www.zhihu.com/question/53022233/answer/399310332\r\nShader实验室:菲涅尔效应 - Shader实验室的文章 - 知乎\r\nhttps://zhuanlan.zhihu.com/p/151375798\r\n【Blender教程】刻晴丝袜效果案例_哔哩哔哩_bilibili\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/02Lighting/01.Basic Lighting","date":"2023-03-08T02:29:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"a30ae670e7580d885c145007ff8514b4","title":"learningOpenGl Chapter 2.1","content":"Define a rule\r\n如果我要使用向量A(1.0, 0.8, 0.6)来乘以B(0.8, 0.6, 0.4)，我定义：\r\n\r\n这与点积的区别在于：该运算的结果是向量，而点积的结果是一个具体数据。\r\n利用这个关系，我们可以计算光照关系： \r\nWhat we need to do in this\r\nsection\r\n在本节中，我们要实现一个光照场景来为后续步骤提供便利。这会用到我们定义的规则。\r\n此时，我们需要做的包括：\r\n\r\n制作一个light source(LS)\r\n制作一个object(OB)\r\n\r\n此时，为了方便以后的更多操作，我们需要区别LS和OB的Shader：\r\n分别为LS和OB搭起一套Shader程序，依次调用他们的shader.use并且投入相应的数据，最终确保：\r\n\r\nColor of LS hardly change\r\nColor of OB will changed because of our rules\r\n\r\nFinally, we can get a pic like:\r\n\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/02Lighting/00.Colors","date":"2023-03-08T02:28:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"09d4101db265eb203c19a059d113fd7c","title":"learningOpenGl Chapter 1.8","content":"1.8 Coordinate Systems\r\ncategories\r\n请主要注意这中间的MVP变换与最后的视口变换\r\n\r\n\r\ncoordinate_systems\r\n\r\n1234// final tranformation looks like:layout (location = 0) in vec3 Position;...gl_Position = Project * View * Model * Move * Rotate * Translate * vec4(Position, 1.0f);\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/07Coordinate Systems","date":"2023-03-08T02:27:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"59ead1496baa87513e343c88c9a506ed","title":"learningOpenGl Chapter 1.7","content":"1.7 Transform\r\n欢迎！\r\n欢迎来到这里，有关数学的一节。\r\n这里会结合Games 101与Unity Shader入门精要的相关内容进行。\r\n\r\nGames 101：Lecture\r\n03 Transformation\r\n\r\n1.7.1 GAMES 101\r\n1.7.1.1 GAMES 101 Lecture\r\n03 Transformation\r\n线性变换适用范围：缩放、旋转  但当加入平移变换时，线性变换就无能为力： \r\n为了能在一个矩阵中表示这些变换，我们选择引入齐次坐标(Homogeneous Coordinates)：\r\n &gt; 此时： \r\n\r\n为什么向量添置的是0而点是1？\r\n\r\n通过简单的运算我们可以发现，如果w分量是0，则平移变换对该对象不造成任何影响——我们对向量的w分量置0是为了保护向量的“不随“平移变换”的这种性质，而Point的w为1则正是为了采用这种性质\r\n\r\n基于w分量的原理，我们可以得到：\r\n\r\n\r\n\r\n当Point +\r\nPoint时，w分量为2了，这能代表什么？——我们人为地定义w用于均分： \r\n\r\n我们把形如上方的运算方式称为仿射变换，Affine Transformations，它采用齐次坐标\r\n此时，缩放、旋转和平移三种操作会变为：  但是，矩阵乘法中虽然没有交换律但是有结合律\r\n我们按照顺序： 平移矩阵旋转矩阵缩放矩阵\r\n进行运算时，我们是可以将前三个矩阵先计算然后集结合为一个矩阵再与目标左乘的\r\n当然，这个顺序并不是定死的，需要注意，我们只会关于原点的操作：关于原点的平移、旋转与缩放，如需必要，我们得把目标“先平移到原点上”\r\n1.7.1.2 GAMES 101\r\nLecture 04 Transformation Count.\r\n对于原Rotation矩阵： \r\n即对于旋转矩阵，有逆矩阵等于转置矩阵——这是一个正交矩阵\r\n\r\n正交矩阵定义：\r\n若一个矩阵满足：ATA = AAT =\r\nE，则A矩阵是正交矩阵\r\n此时A有如下性质：  正交矩阵有哪些性质？ -\r\n知乎 (zhihu.com)\r\n\r\n1.7.1.2.1 3D transformations\r\n类同1.7.1.1中的二维变换，只是我们需要将2D变换所用的三维齐次坐标改为四维齐次坐标：\r\n 此时的三种变换的矩阵会变为：  而旋转则分为三种，分别应用于绕x, y, z三轴旋转的情况： \r\n有了基础的绕三轴的旋转，我们可以通过组合，将物体旋转到任意方向上去：\r\n 例：飞机的运动：roll, yaw, pitch\r\n\r\n在三维空间中任意的旋转，我们都可以通过将它分解到三个轴上\r\n\r\n将旋转轴平移到经过原点\r\n分解该旋转过程\r\n\r\n公式：Rodrigues' Rotation Formula:\r\nRotation by angle α around axis n \r\n\r\n简明推导过程：\r\n\r\n罗德里格斯公式，给个轴和角度就能转\r\n向量叉乘与叉乘矩阵\r\n- neu博 - 博客园 (cnblogs.com)\r\n\r\n1.7.1.2.2 Viewing transformation\r\n\r\n以拍照片为例：\r\n\r\nFind a good place and arrange people (Model transformation)\r\nFind a good \"angle\" to put the camera (View transformation)\r\nCheese! (Projection transformation)\r\n\r\n即MVP变换——模型-视图-投影变换\r\n相应的，我们也有MVP矩阵。当然，这里是View transformation\r\n\r\n1.7.1.2.2.1 View/Camera\r\ntransformation\r\n目的：将摄像头移动至世界中心\r\n过程：做“将原点移动至当前摄像头位置的“的逆变换\r\n原因：我们很难直接求出从世界空间转换到摄像机空间的旋转矩阵，那么鉴于\r\n\r\n旋转矩阵本身的特殊性\r\n旋转后最终结果必定为 x: (1, 0, 0); y: (0, 1, 0); z: (0, 0,\r\n1)\r\n旋转前(世界空间下的)摄像机的x, y, z轴已知\r\n\r\n那么，我们可以利用以上信息构建出从摄像机空间变换到世界空间的旋转矩阵，再将该矩阵转置得到目标矩阵\r\n\r\n利用R_view.rotate，我们将世界空间变换到摄像机空间\r\n同时我们也可以相反地利用**R-1_view.rotate**矩阵实现从摄像机空间到世界空间的逆变换\r\n\r\n\r\n这样，便有完整的变换如下： \r\n1.7.1.2.2.2 Projection\r\ntransformation - 投影变换\r\n1.7.1.2.2.2.1 Orthographic\r\nprojection - 正交变换\r\nmap a cuboid: [l, r], [b, t], [f,\r\nn] to the \"canonical\" cube [-1, 1]3\r\n使用的手段包括：位移、缩放等 \r\n1.7.1.2.2.2.2 Perspective\r\nprojection - 透视变换\r\nGAMES101：\r\n\r\n将Perspective projection先挤压为Orthographic\r\nprojection，然后再依照正交变换的思路做projection\r\n\r\n\r\n1.7.2 利用GLM变换\r\nGLM版本：\r\n\r\n从0.9.9版本开始，GLM创建矩阵的默认值为零矩阵；在此之前的版本则是单位矩阵。使用语句初始化：\r\n1glm::mat4 mat = glm::mat4(1.0f);\r\n\r\n现在的情况：\r\n在CPU侧提前完成变换矩阵的计算，然后将该结果传递到shader处用于position的计算\r\n123456789// main.cpp处// 1. 计算好变换矩阵glm::mat4 trans = glm::mat4(1.0f);trans = glm::rorate(trans, glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));trans = glm::scale(trans, glm::vec3(0.5f, 0.5f, 0.5f));// 2. 传递值 - uniform手段Gluint transformLoc = glGetUniformLocation(...);glUniformMatrix4fv(transformLoc, 1, GL_FALSE, trans);\r\n12345// vertex shader处// 3. 实际使用uniform mat4 transform;...gl_Position = transform * vec4(position, 1.0f);\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/06Transform","date":"2023-03-08T02:26:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"59e0ee426fc499572e79ecdf9cee6601","title":"learningOpenGl Chapter 1.6","content":"1.6 Texture\r\n1.6.1 纹理坐标与纹理的应用\r\n1.6.1.1 定义纹理坐标\r\n\r\n我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。\r\n艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（不过也有1D&amp;3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。\r\n\r\n现在我们利用纹理，给三角形贴上一张砖墙图片。\r\n\r\n\r\nimg\r\n\r\n为了能够把纹理映射(Map)到该三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture\r\nCoordinate)，用来标明该从纹理图像的哪个部分采样。之后在图形的其它片段上进行片段插值(Fragment\r\nInterpolation)。\r\n纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0,\r\n0)，也就是纹理图片的左下角，终始于(1,\r\n1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。\r\n\r\n\r\nimg\r\n\r\n我们为三角形指定了3个纹理坐标点。如上图所示：\r\n\r\n我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0,\r\n0)；\r\n三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5,\r\n1.0)；\r\n同理右下方的顶点设置为(1, 0)。\r\n\r\n我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。\r\n纹理坐标看起来就像这样：\r\n12345GLfloat texCoords[] = &#123;    0.0f, 0.0f, // 左下角    1.0f, 0.0f, // 右下角    0.5f, 1.0f // 上中&#125;;\r\n1.6.1.2 使用纹理\r\n类似于Shader程序，使用纹理之前我们应该先把它们加载到我们的（main.c\r\nCPU部分）应用中。\r\n纹理图像可能被储存为各种各样的格式，每种都有自己特别的数据结构和排列，为了方便地将图像加载到应用中，一个可行的解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。这里又会涉及到很多问题，比如文件格式的选择甚至设计，图像加载器的性能？多格式支持？而且鉴于纹理使用的广泛程度，这些东西的设计和项目的成败都可以说是息息相关。\r\n不过，这里为避免麻烦，我们选择直接借用参考答案：使用一个支持多种流行格式的图像加载库来为我们解决这个问题。比如：\r\n1.6.1.2.1: Use\r\nstb_image.h to load image：\r\n\r\nstb_image.h is a very popular single header image\r\nloading library by Sean\r\nBarrett that is able to load most popular file formats and is easy\r\nto integrate in your project(s). stb_image.h can be\r\ndownloaded from here.\r\nSimply download the single header file, add it to your project as\r\nstb_image.h, and create an additional C++ file with the\r\nfollowing code:\r\n\r\n在stb_image.h中，可以发现使用该头文件所需要的引用与定义：\r\n12#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot;\r\nBy defining STB_IMAGE_IMPLEMENTATION the preprocessor modifies the\r\nheader file such that it only contains the relevant definition source\r\ncode, effectively turning the header file into a .cpp file,\r\nand that's about it. Now simply include stb_image.h\r\nsomewhere in your program and compile.\r\nFor the following texture sections we're going to use an image of a\r\nwooden\r\ncontainer. To load an image using stb_image.h we use\r\nits stbi_load function:\r\n12int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0); \r\nThe function first takes as input the location of an image file. It\r\nthen expects you to give three ints as its second, third\r\nand fourth argument that stb_image.h will fill with the\r\nresulting image's width, height and number of\r\ncolor channels. We need the image's width and height for generating\r\ntextures later on.\r\n1.6.1.2.2: Generate Texture\r\n在前面，我们已经完成了对图片数据的读取，此时就应该回到OpenGL上来——开始准备生成纹理了\r\n123456789101112131415GLuint texture; // IDglGenTexture(1, &amp;texture); // The glGenTextures function first takes as input how many textures we want to generate and stores them in a unsigned int array given as its second argument (in our case just a single unsigned int). // Just like other objects we need to bind it, so any subsequent texture commands will configure the currently bound texture:glBindTexture(GL_TEXTURE_2D, texture[0]);// 为当前绑定的纹理对象设置环绕、过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 生成纹理glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);glGenerateMipmap(GL_TEXTURE_2D); // 多层渐变纹理\r\nglTexImage2D参数不少：\r\n\r\n第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。\r\n第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。\r\n第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有RGB值，因此我们也把纹理储存为RGB值。\r\n第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。\r\n下个参数应该总是被设为0（历史遗留问题）。\r\n第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值。\r\n最后一个参数是真正的图像数据。\r\n\r\n当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。\r\nAfter we're done generating the texture and its corresponding\r\nmipmaps, it is good practice to free the image memory:\r\n12stbi_image_free(data);glBindTexture(GL_TEXTURE_2D, 0);\r\n1.6.2 纹理采样方式\r\n\r\n纹理坐标的范围通常是从(0, 0)到(1,\r\n1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n环绕方式(Wrapping)\r\n描述\r\n\r\n\r\n\r\n\r\nGL_REPEAT\r\n对纹理的默认行为。重复纹理图像。\r\n\r\n\r\nGL_MIRRORED_REPEAT\r\n和GL_REPEAT一样，但每次重复图片是镜像放置的。\r\n\r\n\r\nGL_CLAMP_TO_EDGE\r\n纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。\r\n\r\n\r\nGL_CLAMP_TO_BORDER\r\n超出的坐标为用户指定的边缘颜色。\r\n\r\n\r\n\r\n当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子：\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nglTexParameter\r\n- OpenGL 4 Reference Pages (khronos.org)\r\nopengl\r\n- What does changing GL_TEXTURE_WRAP)_(S/T) do? - Game Development Stack\r\nExchange\r\n\r\n前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）：\r\n12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);\r\n\r\n第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。\r\n第二个参数需要我们指定，设置的选项 与\r\n应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴。\r\n最后一个参数需要我们传递一个环绕方式，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。\r\n\r\n\r\n如果我们选择GL_CLAMP_TO_BORDER选项，我们需要执行的步骤是这些：指定一个边缘的颜色，使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项：\r\n12&gt;float borderColor[] = &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;&gt;glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);\r\n\r\n1.6.3 纹理过滤\r\n\r\n插值办法\r\n\r\nOpenGL需要知道怎样将纹理像素（Texture\r\nPixel、Texel、纹素）映射到纹理坐标。这在物体较大而纹理的分辨率较低时十分重要。\r\n\r\nTexture\r\nPixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。\r\n\r\nGL_NEAREST（也叫邻近过滤，Nearest Neighbor\r\nFiltering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：\r\n\r\n\r\nimg\r\n\r\nGL_LINEAR（也叫线性过滤，(Bi)linear\r\nFiltering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：\r\n\r\n\r\nimg\r\n\r\n那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：\r\n\r\n\r\nimg\r\n\r\nGL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。\r\n当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：\r\n12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n1.6.4 多级渐远纹理\r\n想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色，这在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。\r\nOpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：\r\n\r\n\r\nimg\r\n\r\n手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。\r\n在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n过滤方式\r\n描述\r\n\r\n\r\n\r\n\r\nGL_NEAREST_MIPMAP_NEAREST\r\n使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样\r\n\r\n\r\nGL_LINEAR_MIPMAP_NEAREST\r\n使用最邻近的多级渐远纹理级别，并使用线性插值进行采样\r\n\r\n\r\nGL_NEAREST_MIPMAP_LINEAR\r\n在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样\r\n\r\n\r\nGL_LINEAR_MIPMAP_LINEAR\r\n在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样\r\n\r\n\r\n\r\n就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：\r\n12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/05Texture","date":"2023-03-08T02:25:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"eb947faf7dc84fa49cb79bdd22ec183a","title":"learningOpenGl Chapter 1.5","content":"1.5 Shaders\r\n\r\n着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。\r\n从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。\r\n\r\n1.5.1 GLSL\r\nOpenGL中的Shader是用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。\r\n着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。一个典型的着色器有下面的结构：\r\n12345678910111213141516#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;int main()&#123;  // 处理输入并进行一些图形操作  ...  // 输出处理过的结果到输出变量  out_variable_name = weird_stuff_we_processed;&#125;\r\n特别的，当我们特别谈论到顶点着色器的时候，每个输入变量也叫顶点属性(Vertex\r\nAttribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限：\r\n123GLint nrAttributes;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);std::cout &lt;&lt; &quot;Maximum nr of vertex attributes supported: &quot; &lt;&lt; nrAttributes &lt;&lt; std::endl;\r\n通常情况下它至少会返回16个，大部分情况下是够用了。\r\n1.5.2 数据类型\r\nGLSL有数据类型可以来指定变量的种类。\r\nGLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。\r\nGLSL也有两种特殊的但是容器类型，分别是向量(Vector)和矩阵(Matrix)\r\n1.5.2.1 向量容器\r\n\r\n向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。\r\n\r\n1.5.2.1.1 向量容器的存在形式\r\n\r\nGLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。\r\n\r\n在GLSL中，向量容器中可以容纳的基本内容可以是：\r\n\r\n\r\n\r\n类型\r\n含义\r\n\r\n\r\n\r\n\r\nvecn\r\n包含n个float分量的默认向量\r\n\r\n\r\nbvecn\r\n包含n个bool分量的向量\r\n\r\n\r\nivecn\r\n包含n个int分量的向量\r\n\r\n\r\nuvecn\r\n包含n个unsigned int分量的向量\r\n\r\n\r\ndvecn\r\n包含n个double分量的向量\r\n\r\n\r\n\r\n1.5.2.1.2 向量容器内容获取\r\n以vec4类型的向量\"test\"为例，想要获取其中的各个分量，可以使用：\r\ntest.x; test.y; test.z;\r\ntest.w （位置坐标）\r\n这种分量的获取方式，完全等同于 rgba（颜色值） 与\r\nstpq（纹理坐标），但是为了维护程序良好的可读性，请务必根据具体数据类型选择分量的获取方式\r\n1.5.2.1.3 Swizzling:\r\n向量容器内容的“重组”\r\n向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法：\r\n1234vec2 someVec;vec4 differentVec = someVec.xyxx;vec3 anotherVec = differentVec.zyw;vec4 otherVec = someVec.xxxx + anotherVec.yxzy;\r\n你可以使用上面4个字母任意组合来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，你不允许在一个vec2向量中去获取.z元素。我们也可以把一个向量作为一个参数传给不同的向量构造函数，以减少需求参数的数量：\r\n123vec2 vect = vec2(0.5f, 0.7f);vec4 result = vec4(vect, 0.0f, 0.0f);vec4 otherResult = vec4(result.xyz, 1.0f);\r\n1.5.2.2 矩阵\r\n1.5.3 数据输入与输出\r\n\r\n虽然Shader是各自独立的小程序，但是它们都是渲染管线上的一小部分，出于这样的原因，我们希望每个Shader都有输入和输出，这样才能进行数据交流和传递。GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。\r\n\r\n顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，layout (location = 0)。顶点着色器需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据。\r\n\r\nVertex\r\nShader - OpenGL Wiki (khronos.org)\r\nFragment\r\nShader - OpenGL Wiki (khronos.org)\r\nopengl\r\n- How does the fragment shader know what variable to use for the color\r\nof a pixel? - Stack Overflow\r\n\r\n如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。\r\n示例如下：\r\n12345678910111213141516// 顶点着色器#version 330 corelayout (location = 0) in vec3 position; // position变量的属性位置值为0out vec4 vertexColor; // 为片段着色器指定一个颜色输出void main() &#123;    gl_Position = vec4(position, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数    vertexColor = vec4(0.5f, 0.0f, 0.0f, 1.0f); // 把输出变量设置为暗红色&#125;// 片段着色器#version 330 corein vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）out vec4 color; // 片段着色器输出的变量名可以任意命名，但类型必须是vec4void main() &#123;    color = vertexColor;&#125;\r\n1.5.4 Uniform\r\n\r\nUniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)，这意味着它可以被着色器程序的任意着色器在任意阶段访问。在完成一次设置（赋值）后，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。\r\n\r\n我们可以在一个着色器中添加uniform关键字至类型和变量名前来声明一个GLSL的uniform。\r\n示例如下：我在片段着色器中声明一个uniform\r\nvec4的变量，并把片段着色器的输出颜色设置为该变量的值。\r\n12345678#version 330 coreout vec4 color;uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量void main() &#123;    color = ourColor;&#125;  \r\n由于uniform变量是全局变量，因此我们可以在任何shader中定义它们，而无需像1.5.3那样用in\r\nout作为中介来传递到目标Shader中。因此，既然顶点着色器中不需要这个uniform，那我们便不在那里定义它。\r\n:warning:如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量\r\n而在shader中写下的ourColor，只是一个声明/定义，这个uniform现在还是空的，我们还没有给它添加任何数据。还记得吗：“Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式”，也就是说，Uniform的具体定义及实现应该在CPU也就是main.c里完成而不是Shader中\r\n我们可以这样：\r\n123456789101112...(game loop); // 做底色等等GLint vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;); // 在CPU阶段，查找对应Uniform定义// 拿到该Uniform变量后，我们就可以对其进行处理。GLfloat timeValue = glfwGetTime(); // 获取时间GLfloat greenValue = (sin(timeValue) / 2) + 0.5; // 对时间求sin，结果在(-1, 1)，值在(0, 1)波动glUseProgram(shaderProgram); // 先激活着色器(Use)，再更新UniformglUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);...(draw&amp;call); // draw call在这之后\r\n1.5.5 解决更多属性\r\n\r\n如有必要，请重新回看1.4部分\r\n\r\n在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：\r\n123456GLfloat vertices[] = &#123;    // 位置              // 颜色     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部&#125;;\r\n根据我们的数据，我们需要做的修改如下：\r\n\r\nVS，接收新的Color信息\r\nFS，接受该Color信息\r\nmain.c，对该数据进行解析，配置VAO指针等\r\n\r\n特别注意，glVertexAttribPointer函数有两处修改：\r\n1234glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));// 1. 修改了步长// 2. 修改了偏移量，注意偏移量的具体格式与计算思路（对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以偏移量就是3 * sizeof(GLfloat)，用字节来计算就是12字节）\r\n这个图片可能不是你所期望的\"只有3个颜色\"(因为我们只提供了3个颜色)，这是一个大调色板——这是在片段着色器中进行的所谓片段插值(Fragment\r\nInterpolation)的结果。\r\n\r\n当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。基于这些位置，它会插值(Interpolate)所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是30%蓝\r\n+ 70%绿。\r\n这正是在这个三角形中发生了什么。我们有3个顶点，和相应的3个颜色，从这个三角形的像素来看它可能包含50000左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。\r\n\r\n1.5.6 我们自己的着色器类\r\n\r\n编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。\r\n我们会把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。我们先来添加必要的include，并定义类结构：\r\n12345678910111213141516171819202122&gt;#ifndef SHADER_H&gt;#define SHADER_H&gt;#include &lt;string&gt;&gt;#include &lt;fstream&gt;&gt;#include &lt;sstream&gt;&gt;#include &lt;iostream&gt;&gt;#include &lt;GL/glew.h&gt;; // 包含glew来获取所有的必须OpenGL头文件&gt;class Shader&gt;&#123;&gt;public:   // 程序ID   GLuint Program;   // 构造器读取并构建着色器   Shader(const GLchar* vertexPath, const GLchar* fragmentPath);   // 使用程序   void Use();&gt;&#125;;&gt;#endif\r\n:warning:在上面，我们在头文件顶部使用了几个预处理指令(Preprocessor\r\nDirectives)。这些预处理指令会告知你的编译器只在它没被包含过的情况下才包含和编译这个头文件，即使多个文件都包含了这个着色器头文件。它是用来防止链接冲突的。\r\n着色器类储存了着色器程序的ID。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。我们还添加了一个Use函数，它其实不那么重要，但是能够显示这个自造类如何让我们的生活变得轻松（虽然只有一点）。\r\n从文件读取\r\n我们使用C++文件流读取着色器内容，储存到几个string对象里：\r\n123456789101112131415161718192021222324252627282930313233&gt;Shader(const GLchar* vertexPath, const GLchar* fragmentPath)&gt;&#123;   // 1. 从文件路径中获取顶点/片段着色器   std::string vertexCode;   std::string fragmentCode;   std::ifstream vShaderFile;   std::ifstream fShaderFile;   // 保证ifstream对象可以抛出异常：   vShaderFile.exceptions(std::ifstream::badbit);   fShaderFile.exceptions(std::ifstream::badbit);   try    &#123;       // 打开文件       vShaderFile.open(vertexPath);       fShaderFile.open(fragmentPath);       std::stringstream vShaderStream, fShaderStream;       // 读取文件的缓冲内容到流中       vShaderStream &lt;&lt; vShaderFile.rdbuf();       fShaderStream &lt;&lt; fShaderFile.rdbuf();              // 关闭文件       vShaderFile.close();       fShaderFile.close();       // 转换流至GLchar数组       vertexCode = vShaderStream.str();       fragmentCode = fShaderStream.str();        &#125;   catch(std::ifstream::failure e)   &#123;       std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot; &lt;&lt; std::endl;   &#125;   const GLchar* vShaderCode = vertexCode.c_str();   const GLchar* fShaderCode = fragmentCode.c_str();   [...]\r\n下一步，我们需要编译和链接着色器。注意，我们也将检查编译/链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）：\r\n123456789101112131415161718192021222324252627282930313233343536&gt;// 2. 编译着色器&gt;GLuint vertex, fragment;&gt;GLint success;&gt;GLchar infoLog[512];&gt;// 顶点着色器&gt;vertex = glCreateShader(GL_VERTEX_SHADER);&gt;glShaderSource(vertex, 1, &amp;vShaderCode, NULL);&gt;glCompileShader(vertex);&gt;// 打印编译错误（如果有的话）&gt;glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success);&gt;if(!success)&gt;&#123;   glGetShaderInfoLog(vertex, 512, NULL, infoLog);   std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&gt;&#125;;&gt;// 片段着色器也类似&gt;[...]&gt;// 着色器程序&gt;this-&gt;Program = glCreateProgram();&gt;glAttachShader(this-&gt;Program, vertex);&gt;glAttachShader(this-&gt;Program, fragment);&gt;glLinkProgram(this-&gt;Program);&gt;// 打印连接错误（如果有的话）&gt;glGetProgramiv(this-&gt;Program, GL_LINK_STATUS, &amp;success);&gt;if(!success)&gt;&#123;   glGetProgramInfoLog(this-&gt;Program, 512, NULL, infoLog);   std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&gt;&#125;&gt;// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了&gt;glDeleteShader(vertex);&gt;glDeleteShader(fragment);\r\n最后我们也会实现Use函数：\r\n1234&gt;void Use()&gt;&#123;   glUseProgram(this-&gt;Program);&gt;&#125;\r\n现在我们就写完了一个完整的着色器类。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了：\r\n12345678&gt;Shader ourShader(&quot;path/to/shaders/shader.vs&quot;, &quot;path/to/shaders/shader.frag&quot;);&gt;...&gt;while(...)&gt;&#123;   ourShader.Use();   glUniform1f(glGetUniformLocation(ourShader.Program, &quot;someUniform&quot;), 1.0f);   DrawStuff();&gt;&#125;\r\n我们把顶点和片段着色器储存为两个叫做shader.vs和shader.frag的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用.vs和.frag作为扩展名很直观。\r\n源码：使用新着色器类的程序，着色器类，顶点着色器，和片段着色器。\r\n\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/04Shaders","date":"2023-03-08T02:24:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"4fc32846a71333fda5c166e6a4c0c980","title":"learningOpenGl Chapter 1.4","content":"1.4 绘制三角形\r\n\r\n在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。\r\n\r\n\r\n3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics\r\nPipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。\r\n图形渲染管线可以被划分为两个主要部分：\r\n\r\n第一部分把你的3D坐标转换为2D坐标；\r\n第二部分是把2D坐标转变为实际的有颜色的像素。\r\n\r\n这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。\r\n\r\n\r\n\r\n注意：2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。\r\n\r\n\r\n1.4.1 浅谈图形渲染管线\r\n\r\n图形渲染管线接受一组3D坐标，然后把它们转变为屏幕上的有色2D像素输出。\r\n图形渲染管线可以分为多个阶段，每个阶段的输出都会用作下个阶段的输入\r\n管线的各个阶段很容易并行执行——这样能充分发挥GPU的效能。不同阶段有着不同的功能，这也意味着每个阶段所执行的程序都不同，这种在GPU的渲染管线上运行的程序即为Shader。\r\n并非是所有Shader都是可以配置的：\r\n\r\nVertex Shader\r\nTessellation Shader\r\nGeometry Shader\r\nFragment Shader\r\n\r\n\r\n1.4.2 实现基本的管线\r\n1.4.2.0 在管线处理之前\r\n\r\n标准化设备坐标\r\n\r\n在开始执行依次图形渲染管线之前，我们需要先向程序灌入可用的顶点\r\n12345GLfloat vertices[] = &#123;    -0.5f, -0.5f, 0.0f,     0.5f, -0.5f, 0.0f,     0.0f,  0.5f, 0.0f&#125;;\r\n这样的顶点数据会被直接发送给我们渲染管线的第一个阶段：Vertex\r\nShader——它会在GPU上创建内存用于储存我们的顶点数据。当然我们还需要还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。\r\n1.4.2.1 数据类型\r\n1.4.2.1.1 VBO创建\r\nVBO: Vertex Buffer Objects, VBO, 顶点缓冲对象\r\n我们利用VBO来存储我们发送到GPU的大量顶点。\r\n\r\n顶点从CPU发送到GPU相对较慢，所以我们应该一次性且大量地将顶点数据从CPU传送到GPU上\r\nVS可以很快速地访问显存中的顶点数据\r\n\r\n与OpenGL中的其它对象一样，VBO对象也有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个ID组合一个VBO对象：\r\n1234GLuint VBO[1]; //这个缓冲有一个独一无二的IDglGenBuffers(1, VBO);  //在对应位置上生成缓冲glBindBuffer(GL_ARRAY_BUFFER, VBO[0]); //给缓冲指定类型glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);//把已定义的顶点数据复制到VBO中\r\nOpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。\r\n我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标(上下文)上。之后我们使用的任何在GL_ARRAY_BUFFER上的缓冲调用都会用来配置当前绑定的VBO。\r\n然后我们就可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。\r\n\r\n它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。\r\n第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。\r\n第三个参数是我们希望发送的实际数据。\r\n第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：\r\n\r\nGL_STATIC_DRAW ：数据不会或几乎不会改变。\r\nGL_DYNAMIC_DRAW：数据会被改变很多。\r\nGL_STREAM_DRAW ：数据每次绘制时都会改变。\r\n\r\n三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。\r\n\r\n1.4.2.1.2 VBO调用\r\n顶点数据以VBO形式加载完成时，它是这样子的：\r\n\r\n\r\nimg\r\n\r\n\r\n位置数据被储存为32-bit（4字节）浮点值: 每个分量如\r\npoint1的x坐标：float类型，4Byte = 32bit;\r\n每个位置包含3个这样的值: 1个point共3个坐标值\r\n在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列:\r\n见数组，我们写下point1的坐标后立即跟上的是point2而不是point1的其他如颜色等信息\r\n数据中第一个值在缓冲开始的位置: 也就是没有偏移量。\r\n\r\n根据以上信息：我们便可以着手解析VBO数据以供OpenGL使用了\r\n12glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);glEnableVertexAttribArray(0); // 启用这个顶点属性\r\nglVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们：\r\n\r\n第一个参数指定我们要配置的顶点属性，这关系着我们将要在具体哪里(哪个顶点属性上)存储这份数据。这关系到我们在VS里调用该数据时所用的数据位置即layout位置：layout(location = 0)即代表该数据的顶点属性的位置值为0。\r\n第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。\r\n第三个参数指定数据类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。\r\n下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。\r\n第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个GLfloat之后，我们把步长设置为3 * sieof(GLfloat)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子(译注:\r\n这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节)。\r\n最后一个参数的类型是GLvoid*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。\r\n\r\n\r\n现在我们已经定义了OpenGL该如何解释顶点数据，并启用了对应的顶点属性（顶点属性默认是禁用的）。\r\n自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。在OpenGL中绘制一个物体，代码会像是这样：\r\n12345678910&gt;// 0. 复制顶点数组到缓冲中供OpenGL使用&gt;glBindBuffer(GL_ARRAY_BUFFER, VBO);&gt;glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&gt;// 1. 设置顶点属性指针&gt;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);&gt;glEnableVertexAttribArray(0);&gt;// 2. 当我们渲染一个物体时要使用着色器程序&gt;glUseProgram(shaderProgram);&gt;// 3. 绘制物体&gt;someOpenGLFunctionThatDrawsOurTriangle();\r\n每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？\r\n\r\n1.4.2.1.3 VAO\r\n\r\n顶点数组对象(Vertex Array Object,\r\nVAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中\r\n\r\nOpenGL的核心模式要求我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。\r\n\r\n\r\n一个顶点数组对象会储存以下这些内容：\r\n\r\nglEnableVertexAttribArray和glDisableVertexAttribArray的调用。\r\n通过glVertexAttribPointer调用设置的顶点属性配置。\r\n通过glVertexAttribPointer调用进行的顶点缓冲对象与顶点属性链接。\r\n\r\n\r\n\r\nimg\r\n\r\n创建一个VAO和创建一个VBO很类似：\r\n12GLuint VAO; // IDglGenVertexArrays(1, &amp;VAO); // 对象  \r\n要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：\r\n1234567891011121314151617181920// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..// 1. 绑定VAOglBindVertexArray(VAO);    // 2. 把顶点数组复制到缓冲中供OpenGL使用    glBindBuffer(GL_ARRAY_BUFFER, VBO);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    // 3. 设置顶点属性指针    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);    glEnableVertexAttribArray(0);//4. 解绑VAOglBindVertexArray(0);[...]// ..:: 绘制代（游戏循环中） :: ..// 5. 绘制物体glUseProgram(shaderProgram);glBindVertexArray(VAO);someOpenGLFunctionThatDrawsOurTriangle();glBindVertexArray(0);\r\n1.4.2.1.4 EBO\r\n在渲染顶点这一话题上我们还有最有一个需要讨论的东西——索引缓冲对象(Element\r\nBuffer Object，EBO，也叫Index Buffer\r\nObject，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：\r\n12345678910GLfloat vertices[] = &#123;    // 第一个三角形    0.5f, 0.5f, 0.0f,   // 右上角    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, 0.5f, 0.0f,  // 左上角    // 第二个三角形    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, -0.5f, 0.0f, // 左下角    -0.5f, 0.5f, 0.0f   // 左上角&#125;;\r\n可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？\r\n很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed\r\nDrawing)正是我们问题的解决方案。首先，我们先要定义（独一无二的）顶点，和绘制出矩形所需的索引：\r\n1234567891011GLfloat vertices[] = &#123;    0.5f, 0.5f, 0.0f,   // 右上角    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, -0.5f, 0.0f, // 左下角    -0.5f, 0.5f, 0.0f   // 左上角&#125;;GLuint indices[] = &#123; // 注意索引从0开始!     0, 1, 3, // 第一个三角形    1, 2, 3  // 第二个三角形&#125;;\r\n你可以看到，当时用索引的时候，我们只定义了4个顶点，而不是6个。下一步我们需要创建索引缓冲对象：\r\n12345// almost as same as VBO; notice third and forth lines that use different_缓冲目标: GL_ELEMENT_ARRAY_BUFFERGLuint EBO; glGenBuffers(1, &amp;EBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); \r\n最后，用glDrawElements函数绘图：\r\n1glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\r\n\r\n第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。\r\n第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。\r\n第三个参数是索引的类型，这里是GL_UNSIGNED_INT。\r\n最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。\r\n\r\nglDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。\r\n\r\n\r\nimg\r\n\r\n最后的初始化和绘制代码现在看起来像这样：\r\n1234567891011121314151617181920212223// ..:: 初始化代码 :: ..// 1. 绑定顶点数组对象glBindVertexArray(VAO);    // 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用    glBindBuffer(GL_ARRAY_BUFFER, VBO);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    // 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);    // 3. 设定顶点属性指针    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);    glEnableVertexAttribArray(0);// 4. 解绑VAO（不是EBO！）glBindVertexArray(0);[...]// ..:: 绘制代码（游戏循环中） :: ..glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);glBindVertexArray(0);\r\n1.4.2.2 Vertex Shader\r\n1.4.2.2.1 编写VS\r\n1234567891011121314#version 330 core //版本信息声明，每个着色器都起始于一个版本声明layout (location = 0) in vec3 position; //这里有两个要点// 1* layout 关键字：指定了输入变量所在的“位置”// 2* in 关键字 ：这声明了这是一个从app阶段传入的属性\t//我们应在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)，这里我们先只使用positionvoid main()&#123; // shader程序主函数    gl_Position = vec4(position.x, position.y, position.z, 1.0);    //将3维的position转为了一个4维向量以用于矩阵变换        // 我们并没有利用out关键字定义gl_Position就可以直接使用的原因是：这是一个predefined variable&#125;\r\n1.4.2.2.2 编译VS\r\n为了在我们的opengl程序中使用这个VS，我们需要在main.c内读取这个VS并且编译执行它：\r\n123456789GLuint vertexShader; //仍然优先创建IDvertexShader = glCreateShader(GL_VERTEX_SHADER); //在ID上创建一个Shader“对象”。由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER。glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); // “转移代码”，“转存”// 保存着色器源码的着色器对象作为第一个参数；Specifies the handle of the shader object whose source code is to be replaced// 第二参数指定了传递的源码字符串数量，这里只有一个// 第三个参数是顶点着色器真正的源码; Specifies an array of pointers to strings containing the source code to be loaded into the shader// 第四个参数我们先设置为NULLglCompileShader(vertexShader); // 最终编译\r\n1.4.2.2.3 检验编译成果\r\n\r\n你可能会希望检测在调用glCompileShader后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：\r\n123&gt;GLint success;&gt;GLchar infoLog[512];&gt;glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);\r\n首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用glGetShaderiv检查是否编译成功。如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。\r\n12345&gt;if(!success)&gt;&#123;   glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);   std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&gt;&#125;\r\n如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。\r\n\r\n1.4.2.3 Fragment Shader\r\n\r\n片段着色器(Fragment\r\nShader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器全是关于计算你的像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。\r\n\r\n在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！\r\n\r\n\r\n12345678#version 330 core // same as VSout vec4 color; // out，表示输出用向量；vec4，vec4类型void main()&#123;    color = vec4(1.0f, 0.5f, 0.2f, 1.0f); // 写死颜色；RGBA&#125;\r\n编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型：\r\n1234GLuint fragmentShader; // IDfragmentShader = glCreateShader(GL_FRAGMENT_SHADER); // 对象glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, null); // 转存glCompileShader(fragmentShader); // 编译\r\n1.4.2.4 着色器对象与连接\r\n着色器程序对象(Shader Program\r\nObject)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。\r\n当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。\r\n创建一个程序对象流程如下：\r\n12345GLuint shaderProgram; // IDshaderProgram = glCreateProgram(); // 对象glAttachShader(shaderProgram, vertexShader); // 装载VS；glAttachShader(shaderProgram, fragmentShader); // 装载FSglLinkProgram(shaderProgram); // 使用glLinkProgram来连接这个program对象，这会对已装载的shader做一些处理并解锁一些功能\r\n此时程序对象创建完毕，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：\r\n1glUseProgram(shaderProgram);\r\n在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。\r\n\r\n对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：\r\n12&gt;glDeleteShader(vertexShader);&gt;glDeleteShader(fragmentShader);\r\n现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。\r\n\r\n1.4.2.5 完成绘制\r\n要想绘制我们想要的物体，OpenGL给我们提供了glDrawArrays函数，它使用当前激活的着色器，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。\r\n1234glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 3);glBindVertexArray(0);  \r\n\r\nglDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。\r\n第二个参数指定了顶点数组的起始索引，我们这里填0。\r\n最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。\r\n\r\n完整的程序源码可以在这里找到。\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/03.Hello Triangle","date":"2023-03-08T02:23:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"fa3249ce619228ad8d74e7a819afc946","title":"Regex","content":"Regex\r\n正则运用\r\n当你使用多个捕获组时，请务必小心NULL！这是某个捕获组未能捕获任何内容的结果！\r\n验证：是否有bug\r\n在线正则表达式测试 中文\r\n(oschina.net)\r\n在线正则验证 英文 regex101: build,\r\ntest, and debug regex\r\n在线验证正则表达式结构：Regexper\r\nregex_match\r\n- C++ Reference (cplusplus.com)\r\n第\r\n6 章 正则表达式 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++\r\nTutorial: C++ 11/14/17/20 On the Fly (changkun.de)\r\nc++\r\n正则表达式 高性能 - Bing\r\nc++\r\nlocale - Bing\r\n1[‐\\-a-zA-Z0-9\\.]+\r\n正则提速\r\n\r\n让匹配更快失败，尤其是匹配很长的字符串时，匹配失败的位置要比成功的位置多得多。\r\n以简单、必须的字元开始，排除明显不匹配的位置，如锚点(^或$)，特殊字符(x或63A)字符类([a-z]或)，和单词边界(；尽量避免使用分组、选择、重复量词开头，如/one|two/、、等。\r\n使用量词模式时，尽量让重复部分具体化，让字元互斥，如用”[^\"\\r\\n]”代替”.?”（这个依赖回溯）。\r\n减少分支数量、缩小分支范围，用字符集和选项组件来减少分支的出现，或把分支在正则上出现的位置推后，把分支中最常出现的情况放在分支的最前面。\r\n123cat|bat -&gt; [cb]at;red|read -&gt; rea?d;red|raw -&gt; r(?:ed|aw); (.|\\r|\\n) -&gt; [\\s\\S]\r\n精确匹配需要的文本以减少后续的处理，如果需要引用匹配的一部分，可使用捕获，然后通过反向引用来处理。\r\n暴露必需的字元，用/^(ab|cd)/而不是/(^ab|^cd)/。\r\n使用合适的量词，基于预期的回溯数量，使用合适的量词类型。\r\n把正则表达式赋值给变量以便复用和提升提升性能，这样可以让正则减少不必要的编译过程。while\r\n(/regex1/.test(str1)) {/regex2/.exec(str2);…}用下面的代替上面的 var\r\nregex1 = /regex1/,regex2 = /regex2/;while (regex1.test(str1))\r\n{regex2.exec(str2);…}\r\n将复杂的正则表达式拆分成简单的片段，每个正则只在上一个成功的匹配中查找，更高效，而且可以减少回溯。\r\n使用非捕获组，因为捕获组需要消耗时间和内存来记录反向引用，并不断更新，如果不需要反向引用，可用非捕获组(?:…)代替捕获组(…)；当需要全文匹配的反向引用时，可用regex.exec()返回的结果或者在替换字符串是使用$&amp;。\r\n此优化在firefox中效果较小，但其他浏览器中处理长字符串时有较大影响\r\n\r\nAnd More？\r\n觉得正则表达式太慢？这里有一个提速100倍的方案！\r\n- 知乎 (zhihu.com)\r\n项目地址\r\nvi3k6i5/flashtext:\r\nExtract Keywords from sentence or Replace keywords in sentences.\r\n(github.com)\r\n","slug":"Algorithm/String Processing/Regex","date":"2023-03-08T02:22:54.000Z","categories_index":"Algorithm","tags_index":"Algorithm,String Processing,Regex","author_index":"JBR_Bunjie"},{"id":"840d5a833aff18f2fbd4e2e8f83d93a6","title":"learningOpenGl Chapter 1.3","content":"1.3 你好，窗口\r\n1.3.1 引入库，并作基本初始化\r\nLet's see if we can get GLFW up and running. First, create a\r\n.cpp file and add the following includes to the top of your\r\nnewly created file.\r\n12#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;\r\n\r\n请确认在包含GLFW的头文件之前包含了GLEW的头文件。在包含glew.h头文件时会引入许多OpenGL必要的头文件（例如GL/gl.h），所以你需要在包含其它依赖于OpenGL的头文件之前先包含GLEW\r\n\r\nNext, we create the main function where we will instantiate the GLFW\r\nwindow:\r\n123456789101112int main()&#123;    glfwInit();    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);      glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);        return 0;&#125;\r\nIn the main function\r\n\r\nwe first initialize GLFW with glfwInit,\r\nafter which we can configure GLFW using glfwWindowHint.\r\n\r\nThe first argument of glfwWindowHint tells us what option we want to\r\nconfigure, where we can select the option from a large enum of possible\r\noptions prefixed with GLFW_.\r\nThe second argument is an integer that sets the value of our option.\r\nA list of all the possible options and its corresponding values can be\r\nfound at GLFW's\r\nwindow handling documentation.\r\n\r\nIf you try to run the application now and it gives a lot of\r\nundefined reference errors it means you didn't successfully\r\nlink the GLFW library.\r\n\r\nSince the focus of this book is on OpenGL version 3.3 we'd like to\r\ntell GLFW that 3.3 is the OpenGL version we want to use. This way GLFW\r\ncan make the proper arrangements when creating the OpenGL context. This\r\nensures that when a user does not have the proper OpenGL version GLFW\r\nfails to run. We set the major and minor version both to 3.\r\nWe also tell GLFW we want to explicitly use the\r\ncore-profile, 并且不允许用户调整窗口的大小。Telling\r\nGLFW we want to use the core-profile means we'll get access to a smaller\r\nsubset of OpenGL features without backwards-compatible features we no\r\nlonger need.\r\n1.3.2\r\n创建窗口对象并设为进程的主要上下文\r\n接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到。\r\n12345678GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, nullptr, nullptr);if (window == nullptr)&#123;    std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;    glfwTerminate();    return -1;&#125;glfwMakeContextCurrent(window);\r\nThe glfwCreateWindow function requires\r\n\r\nthe window width and height as its first two arguments\r\nrespectively.\r\nThe third argument allows us to create a name for the window; for\r\nnow we call it \"LearnOpenGL\" but you're allowed to name it\r\nhowever you like.\r\nWe can ignore the last 2 parameters.\r\nThe function returns a GLFWwindow object that we'll later need for\r\nother GLFW operations. After that we tell GLFW to make the context of\r\nour window the main context on the current thread\r\n(glfwMakeContextCurrent()).\r\n\r\n1.3.3 初始化GLEW\r\n\r\n在之前的教程中已经提到过，GLEW是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLEW。\r\n\r\n123456glewExperimental = GL_TRUE;if (glewInit() != GLEW_OK)&#123;    std::cout &lt;&lt; &quot;Failed to initialize GLEW&quot; &lt;&lt; std::endl;    return -1;&#125;\r\n这样我们在后面就可以跳过对OpenGL的函数的查找过程快速调用了\r\n\r\n请注意，我们在初始化GLEW之前设置glewExperimental变量的值为GL_TRUE，这样做能让GLEW在管理OpenGL的函数指针时更多地使用现代化的技术，如果把它设置为GL_FALSE的话可能会在使用OpenGL的核心模式时出现一些问题。\r\n\r\n1.3.4 设置视口(Viewport)？\r\n你需要知道，在你已经创建好的窗口里，不是所有内容都是可以用来作画的，对于该window的实际可用来渲染的区域的大小，我们必须手动指定。\r\n注：视口的起点与窗口起点总是一致的。\r\n在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL渲染窗口的尺寸大小，这样OpenGL才只能知道怎样相对于窗口大小显示数据和坐标。我们可以通过调用glViewport函数来设置窗口的维度(Dimension)：\r\n1234int width, height;glfwGetFramebufferSize(window, &amp;width, &amp;height);glViewport(0, 0, width, height);\r\nglViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素），这里我们是直接从GLFW中获取的。我们从GLFW中获取视口的维度而不设置为800*600是为了让它在高DPI的屏幕上（比如说Apple的视网膜显示屏）也能正常工作。\r\n我们实际上也可以将视口的维度设置为比GLFW的维度小，这样子之后所有的OpenGL渲染将会在一个更小的窗口中显示，这样子的话我们也可以将一些其它元素显示在OpenGL视口之外。\r\n1.3.5 准备好你的引擎\r\n我们总是希望程序在明确地被关闭之前，能不断绘制图像并能够接受用户输入。因此我们需要一个while循环——让它在GLFW退出前一直保持运行，我们可以把它称之为游戏循环(Game\r\nLoop)。下面几行的代码就实现了一个简单的游戏循环：\r\n12345while(!glfwWindowShouldClose(window))&#123;    glfwPollEvents();    glfwSwapBuffers(window);&#125;\r\n\r\nglfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后游戏循环便结束了，之后为我们就可以关闭应用程序了。\r\nglfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等），然后调用对应的回调函数（可以通过回调方法手动设置）。我们一般在游戏循环的开始调用事件处理函数。\r\nglfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。\r\n\r\n1.3.6 最后一件事\r\n当游戏循环结束后我们需要正确释放/删除之前的分配的所有资源。我们可以在main函数的最后调用glfwTerminate函数来释放GLFW分配的内存。\r\n12glfwTerminate();return 0;\r\n这样便能清理所有的资源并正确地退出应用程序。这时运行这份代码，你可以看到一个黑窗口。\r\n1.3.7 输入\r\n通过GLFW的回调函数(Callback Function)，我们可以实现一些用户控制。\r\n回调函数事实上是一个函数指针，当我们设置好后，GLWF会在合适的时候调用它。其中，\r\n按键回调(KeyCallback)是众多回调函数中的一种。当我们设置了按键回调之后，GLFW会在用户有键盘交互时调用它。该回调函数的原型如下所示：\r\n1void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);\r\n按键回调函数接受\r\n\r\n一个GLFWwindow指针作为它的第一个参数；\r\n第二个整形参数用来表示按下的按键；\r\naction参数表示这个按键是被按下还是释放；\r\n最后一个整形参数表示是否有Ctrl、Shift、Alt、Super等按钮的操作。\r\n\r\nGLFW会在合适的时候调用它，并为各个参数传入适当的值。\r\n1234567void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)&#123;    // 当用户按下ESC键,我们设置window窗口的WindowShouldClose属性为true    // 关闭应用程序    if(key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)        glfwSetWindowShouldClose(window, GL_TRUE);&#125;\r\n在我们（新创建的）key_callback函数中，我们检测了键盘是否按下了Escape键。如果键的确按下了(不释放)，我们使用glfwSetwindowShouldClose函数设定WindowShouldClose属性为true从而关闭GLFW。main函数的while循环下一次的检测将为失败，程序就关闭了。\r\n最后一件事就是通过GLFW注册我们的函数至合适的回调，代码是这样的:\r\n1glfwSetKeyCallback(window, key_callback);  \r\n除了按键回调函数之外，我们还能我们自己的函数注册其它的回调。例如，我们可以注册一个回调函数来处理窗口尺寸变化、处理一些错误信息等。我们可以在创建窗口之后，开始游戏循环之前注册各种回调函数。\r\n1.3.8 渲染\r\n我们要把所有的渲染(Rendering)操作放到游戏循环中，因为我们想让这些渲染指令在每次游戏循环迭代的时候都能被执行。代码将会是这样的：\r\n123456789101112// 程序循环while(!glfwWindowShouldClose(window))&#123;    // 检查事件    glfwPollEvents();    // 渲染指令    ...    // 交换缓冲    glfwSwapBuffers(window);&#125;\r\n为了测试一切都正常工作，我们使用一个自定义的颜色清空屏幕。在每个新的渲染迭代开始的时候我们总是希望清屏，否则我们仍能看见上一次迭代的渲染结果（这可能是你想要的效果，但通常这不是）。我们可以通过调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer\r\nBit)来指定要清空的缓冲，可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。\r\n12glClearColor(0.2f, 0.3f, 0.3f, 1.0f);glClear(GL_COLOR_BUFFER_BIT);\r\n注意，除了glClear之外，我们还调用了glClearColor来设置清空屏幕所用的颜色。当调用glClear函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为glClearColor里所设置的颜色。在这里，我们将屏幕设置为了类似黑板的深蓝绿色。\r\n附录：完整代码：\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;// GLEW#define GLEW_STATIC#include &lt;GL/glew.h&gt;// GLFW#include &lt;GLFW/glfw3.h&gt;// Function prototypesvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);// Window dimensionsconst GLuint WIDTH = 800, HEIGHT = 600;// The MAIN function, from here we start the application and run the game loopint main()&#123;    std::cout &lt;&lt; &quot;Starting GLFW context, OpenGL 3.3&quot; &lt;&lt; std::endl;    // Init GLFW    glfwInit();    // Set all the required options for GLFW    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);    // Create a GLFWwindow object that we can use for GLFW&#x27;s functions    GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, &quot;LearnOpenGL&quot;, nullptr, nullptr);        if (window == nullptr)    &#123;        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();        return -1;    &#125;    glfwMakeContextCurrent(window);    // Set the required callback functions    glfwSetKeyCallback(window, key_callback);    // Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions    glewExperimental = GL_TRUE;    // Initialize GLEW to setup the OpenGL Function pointers    if (glewInit() != GLEW_OK)    &#123;        std::cout &lt;&lt; &quot;Failed to initialize GLEW&quot; &lt;&lt; std::endl;        return -1;    &#125;        // Define the viewport dimensions    int width, height;    glfwGetFramebufferSize(window, &amp;width, &amp;height);      glViewport(0, 0, width, height);    // Game loop    while (!glfwWindowShouldClose(window))    &#123;        // Check if any events have been activiated (key pressed, mouse moved etc.) and call corresponding response functions        glfwPollEvents();        // Render        // Clear the colorbuffer        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT);        // Swap the screen buffers        glfwSwapBuffers(window);    &#125;    // Terminate GLFW, clearing any resources allocated by GLFW.    glfwTerminate();    return 0;&#125;// Is called whenever a key is pressed/released via GLFWvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)&#123;    std::cout &lt;&lt; key &lt;&lt; std::endl;    if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)        glfwSetWindowShouldClose(window, GL_TRUE);&#125;\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/02.Hello Window","date":"2023-03-08T02:22:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"fc711215d7019d15e7fa23ec8cb6e4d7","title":"learningOpenGl Chapter 1.2","content":"1.2 Creating A Window\r\n\r\nThe first thing we need to do before we start creating stunning\r\ngraphics is to create an OpenGL context and an application window to\r\ndraw in. However, those operations are specific per operating system and\r\nOpenGL purposefully tries to abstract itself from these operations. This\r\nmeans we have to create a window, define a context, and handle user\r\ninput all by ourselves.\r\nLuckily, there are quite a few libraries out there that provide the\r\nfunctionality we seek, some specifically aimed at OpenGL. Those\r\nlibraries save us all the operation-system specific work and give us a\r\nwindow and an OpenGL context to render in. Some of the more popular\r\nlibraries are GLUT, SDL, SFML and GLFW. On LearnOpenGL we will be using\r\nGLFW. Feel free to use any of the other libraries, the\r\nsetup for most is similar to GLFW's setup.\r\n在我们画出出色的效果之前，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象(Abstract)出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。\r\n幸运的是，有一些库已经提供了我们所需的功能，其中一部分是特别针对OpenGL的。这些库节省了我们书写操作系统相关代码的时间，提供给我们一个窗口和上下文用来渲染。最流行的几个库有GLUT，SDL，SFML和GLFW。在教程里我们将使用GLFW。\r\n\r\n1.2.1 Using GLFW\r\n\r\nGLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。\r\n\r\n\r\n配置教程可以参考傅老师视频\r\n\r\n1.2.2 Using GLEW\r\n到这里，我们仍然有一件事要做。因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上会是类似这样：\r\n1234567// 定义函数原型typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);// 找到正确的函数并赋值给函数指针GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);// 现在函数可以被正常调用了GLuint buffer;glGenBuffers(1, &amp;buffer);\r\n你可以看到代码非常复杂，而且很繁琐，我们需要对每个可能使用的函数都要重复这个过程。幸运的是，有些库能简化此过程，其中GLEW是目前最新，也是最流行的库。\r\n编译和链接GLEW\r\nGLEW是OpenGL Extension Wrangler\r\nLibrary的缩写，它能解决我们上面提到的那个繁琐的问题。因为GLEW也是一个库，我们同样需要构建并将其链接进工程。GLEW可以从这里下载，你同样可以选择下载二进制版本，如果你的目标平台列在上面的话，或者下载源码编译，步骤和编译GLFW时差不多。记住，如果不确定的话，选择32位的二进制版本。\r\n我们使用GLEW的静态版本glew32s.lib（注意这里的“s”），将库文件添加到你的库目录，将include内容添加到你的include目录。接下来，在VS的链接器选项里加上glew32s.lib。注意GLFW3（默认）也是编译成了一个静态库。\r\n\r\n静态(Static)链接是指编译时就将库代码里的内容整合进你的二进制文件。优点就是你不需要管理额外的文件了，只需要发布你单独的一个二进制文件就行了。缺点就是你的可执行文件会变得更大，另外当库有升级版本时，你必须重新进行编译整个程序。\r\n动态(Dynamic)链接是指一个库通过.dll或.so的方式存在，它的代码与你的二进制文件的代码是分离的。优点是使你的二进制文件大小变小并且更容易升级，缺点是你最终发布程序时必须带上这些DLL。\r\n\r\n\r\n如果你希望静态链接GLEW，必须在包含GLEW头文件之前定义预处理器宏GLEW_STATIC：\r\n12&gt;#define GLEW_STATIC&gt;#include &lt;GL/glew.h&gt;\r\n如果你希望动态链接，那么你可以省略这个宏。但是记住使用动态链接的话你需要拷贝一份.DLL文件到你的应用程序目录。\r\n\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/01.CreateAWindow","date":"2023-03-08T02:21:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"84a91876a3b2e3a40cf47c0b0209858c","title":"learningOpenGl Chapter 1.1","content":"1.1 Getting Started - OpenGL\r\n1.1.1 OpenGL\r\n\r\n\r\n什么是opengl？\r\n\r\n\r\n是一个API(Application Programming Interface, 应用程序编程接口)\r\n包含了一系列可以操作图形、图像的函数\r\n然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范。也就是说，OpenGL并非是一个“唯一的”框架，它在不同系统、平台、设备上都可能有不同的表现——因为OpenGL规范并没有规定实现的细节。具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配。OpenGL规范只规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定。\r\n\r\n实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。\r\nSince most implementations are built by graphics card manufacturers,\r\nwhenever there is a bug in the implementation this is usually solved by\r\nupdating your video card drivers; those drivers include the newest\r\nversions of OpenGL that your card supports. This is one of the reasons\r\nwhy it's always advised to occasionally update your graphic drivers.\r\n\r\nKhronos publicly hosts all specification documents for all the OpenGL\r\nversions. The interested reader can find the OpenGL specification of\r\nversion 3.3 (which is what we'll be using) here\r\nwhich is a good read if you want to delve into the details of OpenGL\r\n(note how they mostly just describe results and not implementations).\r\nThe specifications also provide a great reference for finding the\r\nexact workings of its functions.\r\n\r\n\r\n有点c之于编译器的意思\r\n编程时主要按c标准编写，厂商提供编译器，等到实际在执行的时候，再考虑“实际内容”（如1.1.3\r\n拓展）\r\n\r\n\r\n1.1.2 Core-profile vs Immediate\r\nmode\r\n\r\n核心模式与立即渲染模式\r\n\r\n\r\nImmediate mode - 固定管线 - 早期\r\nCore-profile - 可编程管线 - 现代 - 灵活、高效、\r\n\r\n\r\n注意兼容性：\r\nWhen using functionality from the most recent version of OpenGL, only\r\nthe most modern graphics cards will be able to run your application.\r\nThis is often why most developers generally target lower versions of\r\nOpenGL and optionally enable higher version functionality.\r\n\r\n1.1.3 Extensions\r\nOpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。\r\nThe developer has to query whether any of these extensions are\r\navailable before using them (or use an OpenGL extension library). This\r\nallows the developer to do things better or more efficient, based on\r\nwhether an extension is available:\r\n12345if(GL_ARB_extension_name) &#123;    // Do cool new and modern stuff supported by hardware&#125; else &#123;    // Extension not supported: do it the old way&#125;\r\n1.1.4 State machine\r\nOpenGL自身是一个巨大的状态机：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。\r\nWhenever we tell OpenGL that we now want to draw lines instead of\r\ntriangles for example, we change the state of OpenGL by changing some\r\ncontext variable that sets how OpenGL should draw. As soon as we change\r\nthe context by telling OpenGL it should draw lines, the next drawing\r\ncommands will now draw lines instead of triangles.\r\nWhen working in OpenGL we will come across several state-changing\r\nfunctions that change the context and several state-using functions that\r\nperform some operations based on the current state of OpenGL. As long as\r\nyou keep in mind that OpenGL is basically one large state machine, most\r\nof its functionality will make more sense.\r\n1.1.5 Objects\r\nOpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。\r\nAn object in OpenGL is a collection of options that represents a\r\nsubset of OpenGL's state.\r\nFor example, we could have an object that represents the settings of\r\nthe drawing window; we could then\r\n\r\nset its size,\r\nhow many colors it supports\r\nand so on.\r\n\r\nOne could visualize an object as a C-like struct:\r\n12345struct object_name &#123;    float  option1;    int    option2;    char[] name;&#125;;\r\n\r\n基元类型(Primitive Type)\r\n使用OpenGL时，建议使用OpenGL定义的基元类型。比如使用float时我们加上前缀GL（因此写作GLfloat）。int、uint、char、bool等等也类似。OpenGL定义的这些GL基元类型的内存布局是与平台无关的，而int等基元类型在不同操作系统上可能有不同的内存布局。使用GL基元类型可以保证你的程序在不同的平台上工作一致。\r\n\r\n1.1.6 使用OpenGL的大致方法\r\n当我们使用一个对象时，通常看起来像如下一样（把OpenGL上下文看作一个大的结构体）：\r\n123456789101112131415161718// OpenGL的状态struct OpenGL_Context &#123;    ...    object* object_Window_Target;    ...     &#125;;// 创建对象GLuint objectId = 0;glGenObject(1, &amp;objectId);// 绑定对象至上下文glBindObject(GL_WINDOW_TARGET, objectId);// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);// 将上下文对象设回默认glBindObject(GL_WINDOW_TARGET, 0);\r\n这一小段代码展现了你以后使用OpenGL时常见的工作流。\r\n\r\n我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。\r\n然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。\r\n接下来我们设置窗口的选项。\r\n最后我们将目标位置的对象id设回0，解绑这个对象。\r\n\r\n设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。\r\n\r\n使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。\r\n\r\n1.1.7 epilogue - 尾声\r\n\r\n让我们开始吧\r\n你现在已经知道一些OpenGL的相关知识了，OpenGL规范和库，OpenGL幕后大致的运作流程，以及OpenGL使用的一些传统技巧。不要担心你还没有完全消化它们，后面的教程我们会仔细地讲解每一个步骤，你会通过足够的例子来真正掌握OpenGL。如果你已经做好了开始下一步的准备，我们可以在这里开始创建OpenGL上下文以及我们的第一个窗口了。\r\n附加资源\r\n\r\nopengl.org：OpenGL官方网站。\r\nOpenGL\r\nregistry：包含OpenGL各版本的规范和扩展。\r\n\r\n\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/01GettingStarted/00.OpenGL","date":"2023-03-08T02:20:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"d309579445aab8e475b1a200f76bbffc","title":"learningOpenGl 0","content":"OpenGL学习记录\r\n这份笔记对应的教程来自网站：LearnOpenGL-CN，是Learn OpenGL, extensive tutorial\r\nresource for learning Modern OpenGL的早期译文\r\n同时辅以视频教程：\r\n\r\n[傅老師/OpenGL教學\r\n第一章] OpenGL自製3D遊戲引擎 (已更畢)_哔哩哔哩_bilibili\r\n[傅老師/OpenGL教學\r\n第二章][10/16晚間更新] OpenGL自製3D遊戲引擎_哔哩哔哩_bilibili\r\n[傅老師/OpenGL教學\r\n第三章] [01/08晚間更新]\r\nOpenGL自製3D遊戲引擎(已更畢)_哔哩哔哩_bilibili\r\n\r\n当然，现在是21/12/2022，就现在而言，这份教程已经有些老了。\r\n该仓库已经停止维护，并且对应的英文站点已经更新了更多额外的内容，对于这些内容，有做一定的穿插。\r\n","slug":"Language Learning/Opengl/learnopengl-cn.readthedocs.io/ReadMe","date":"2023-03-08T02:18:08.000Z","categories_index":"Opengl,Shader","tags_index":"Shader,Opengl","author_index":"JBR_Bunjie"},{"id":"71fbc7ff44065d31551c0ea05fc7175a","title":"实现一个视差体积雾吧！","content":"实现一个视差体积雾吧！\r\n原理说明\r\n核心思路：基于一张噪点图，基于切线空间下的视线方向，不断偏移 uv\r\n来取样其中的内容，由于 Texture 下暗处的 rgb 三值都会急速下降并趋于\r\n0，因此让 uv\r\n偏移到暗处即可形成自然的颜色渐变——我们的视差体积雾即以该内容来伪装“高度”。在完成采样后，将最终采样与初始采样做合并来让暗部更暗以增强对比。\r\n实现思路\r\nVertex Shader\r\n构建 rotation 矩阵，并利用该矩阵将 ObjectSpace 下的\r\nviewDir 转换到 Tangent 空间下。在切线空间，顶点和像素成为原点，xy 轴与\r\nuv 同向——此时就可以利用 ViewDir 来代表了一种对 uv\r\n进行抽象的渐进取样方向与步长，当然，这里只有方向是可以直接使用的，对于具体的步长内容，我们应该将它们的控制变量利用属性以暴露出来。\r\nFragment Shader\r\n步长\r\n首先我们将 viewDir 分为 xy 和 z\r\n两个维度，分别利用外置暴露的属性来进行控制，这有两个目的：\r\n\r\nxy 控制了对 uv 的最大偏移量\r\n而对 z 进行控制，则是为了控制单次偏移的步长\r\n\r\n最终计算步长：\r\n1float3 minOffset = viewDir / (viewDir.z * _Layers)\r\n初始采样\r\n之后，我们先利用初始的 uv 来对 texture\r\n进行取样，这是可选的，但我们利用它来作为一个底层，并将之后的计算结果全部都叠加与这之上，这会：\r\n\r\n加快取样 uv 的偏移过程\r\n增加暗部与亮部的对比来增强立体感\r\n\r\nuv 偏移过程\r\nuv 偏移结束是基于两个内容的：finiNoise 的减小与 minOffset 上 z\r\n分量的逐步叠加，其中 finiNoise\r\n会减小是因为其数据的直接来源——Texture，在黑色上，其 rgb 值是趋于 0\r\n的——这会让 finiNoise 急速衰减，因此，我们实际使用的 Texture\r\n实际上是由要求的——它的黑色部分应该受到相当程度的限制，否则实际上的偏移量会过小导致视差的体积云失效。\r\n123456789float finiNoise = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv.xy).r * MainTex.r;  // 只作为加快偏移结束的变量float3 prev_uv = uv;while (finiNoise &gt; uv.z) &#123;    uv += minOffset;    finiNoise = SAMPLE_TEXTURE2D_LOD(_MainTex, sampler_MainTex, uv.xy, 0).r * MainTex.r;    // finiNoise = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv.xy).r * MainTex.r;    // 此处不能使用寻常的SAMPLE_TEXTURE2D函数，原因见`tex2Dlod` 与 `SAMPLE_TEXTURE2D_LOD`一节&#125;\r\n最终取样\r\n在初始 uv 和最终 uv\r\n间进行插值，这样使我们最终获得的结果更加平滑，减少画面的突变\r\n12345678// 可选float d1 = finiNoise - uv.z;float d2 = finiNoise - prev_uv.z;float w = d1 / (d1 - d2 + 0.0000001);uv = lerp(uv, prev_uv, w);// 利用最终完成变换的uv来进行取样half4 resultColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv.xy) * MainTex;\r\n返回结果\r\n暴露_Alpha 属性来控制云层密度\r\n1234567half rangeClt = MainTex.a * resultColor.r + _Alpha * 0.75;half Alpha = abs(smoothstep(rangeClt, _Alpha, 1.0));Alpha = pow(Alpha, 5);// Light light = GetMainLight();return half4(resultColor.rgb * _Color.rgb, Alpha); //* light.color.rgb\r\n代码讲解\r\n\r\n具体代码已在Reference中给出\r\n\r\ntex2Dlod 与\r\nSAMPLE_TEXTURE2D_LOD\r\ntex2Dlod 与 SAMPLE_TEXTURE2D_LOD\r\n是两个同能相同的取样函数，分别对应了 Built-in 和\r\nurp 两种渲染管线。不过，这并非意味着这两个函数分别对应了\r\nCG 与 HLSL\r\n中的不同的实现——事实上，CG 与 HLSL\r\n中所定义的都是 tex2Dlod，urp 中采用新的\r\nAPI，大概只是为了与原 Built-in 管线作出区分。\r\n那么，首先先来了解 tex2Dlod 函数：\r\n\r\nSamples a 2D texture with mipmaps. The mipmap LOD is specified in\r\nt.w. tex2Dlod\r\n- Win32 apps | Microsoft Learn\r\n\r\n着我我们平常见到的 tex2D\r\n函数是不同的——tex2D 仅采样当前纹理本身：\r\n\r\nSamples a 2D texture. tex2D\r\n(HLSL reference) - Win32 apps | Microsoft Learn\r\n\r\n当然，这也意味着我们使用该函数时，应确保加入的 texture 的\r\nGenerate Mip Maps\r\n选项是勾选上的(当我们加入一张图片时，Unity 会帮我们默认勾选该内容:)\r\n Generate Mip Maps 选项\r\n当做好准备后，我们就可以利用 tex2Dlod 来对预生成的\r\nMip Maps 进行采样了：\r\n\r\nret tex2Dlod(s, t)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nIn/Out\r\nTemplate\r\nType\r\nComponent\r\nType\r\nSize\r\n\r\n\r\n\r\n\r\ns\r\nin\r\nobject\r\nsampler2D\r\n1\r\n\r\n\r\nt\r\nin\r\nvector\r\nfloat\r\n4\r\n\r\n\r\nret\r\nout\r\nvector\r\nfloat\r\n4\r\n\r\n\r\n\r\ntex2Dlod\r\n- Win32 apps | Microsoft Learn\r\n\r\n可以发现，当前的 tex2Dlod 函数相较于\r\ntex2D，本来为 float2 类型的 UV 变为了\r\nfloat4 类型——新增加了 zw 两位，而其中的 w 位代表了当前 LOD\r\n值，而 z 没有实际意义，常保持为 0：\r\n\r\ntex2Dlod\r\n(nvidia.com)\r\n\r\n我们可以进行一些小小的实验，比和上方展示的结果做对比：\r\n t.z==5000,\r\nt.w==0，可以发现结果并没有任何变化\r\n t.z==5000,\r\nt.w==4，高度感仍然比较明显，同时锯齿的感觉也有所减缓\r\n t.z==5000,\r\nt.w==7，可以发现云层的高度起伏已经很不明显了\r\n t.z==5000,\r\nt.w==100，可以说，云层完全失去了高度起伏的感觉并且模糊不堪\r\n通过以上的对比我们可以发现：当我们不断的增大 LOD\r\n时，云层开始变得越来越模糊，并在 LOD\r\n过大时变得缺乏高度感——也就是说，我们。\r\n不过，tex2Dlod 这样的函数，其逻辑本确实特别直观——在 HLSL\r\n文档的最后，有这样的说明：\r\n\r\nStarting with Direct3D 10, you can use new HLSL syntax to access\r\ntextures and other resources. You can replace intrinsic-style texture\r\nlookup functions, such as tex2Dlod, with a more object-oriented style.\r\nIn this object-oriented style, textures are decoupled from samplers and\r\nhave methods for loading and sampling.\r\n\r\nHLSL 的解决方案是换用面向对象的 SampleLevel\r\n函数，而它的使用方法几乎和 URP 下的 SAMPLE_TEXTURE2D_LOD\r\n函数一致：\r\n1#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)\r\n其区别在于，HLSL 中的 SampleLevel 函数是\r\nTexture2D 类型变量的属性，而\r\nSAMPLER_TEXTURE2D_LOD 则更加类似于定义于\r\nD3D11.hlsl 中的 'static'\r\n类型的函数。而对于其中的参数，则可以理解为 tex2Dlod\r\n中对应的 float4 t 被拆分了，而 LOD\r\n作为独立的参数被写进了函数中。\r\n特别的，tex2Dlod 和 SAMPLER_TEXTURE2D_LOD\r\n会被专门用在循环当中，例如在本案例中，如果使用 tex2D 和\r\nSAMPLER_TEXTURE2D 则会报错：\r\n\r\n\r\nimage-20230331201010767\r\n\r\n\r\n该问题的出现原因可以参考该回答：unity3d\r\n- Why I can't use tex2D inside a loop in Unity ShaderLab? - Stack\r\nOverflow 不严谨地简化解释为：循环中的计算单元不能预测采样的 LOD\r\n值导致了单元间独立而庞大的计算，使循环不能及时地退出进而导致错误\r\n\r\n因此，我们需要使用 tex2Dlod 类函数来显式地对\r\nMip Maps 进行采样以解决此类问题。Unity Manual\r\n中也提及了这种因为导数计算而需要使用 tex2Dlod\r\n类函数的情况：Unity\r\n- Manual: Writing shaders for different graphics APIs\r\n(unity3d.com)\r\nReference\r\n\r\n缘起：【百人计划先行版】5\r\n分钟教你用视差搓体积云_哔哩哔哩_bilibili\r\n原理参考：视差贴图\r\n- LearnOpenGL CN (learnopengl-cn.github.io)\r\ntex2Dlod\r\n- Win32 apps | Microsoft Learn\r\nCode\r\n- VolumeCloud at URP_LearningPath\r\n\r\n","slug":"Rendering/ParallaxCloud","date":"2023-03-02T04:23:23.000Z","categories_index":"Unity,Shader","tags_index":"Unity,Shader","author_index":"JBR_Bunjie"},{"id":"bbf9542302ac0838c1965dd8fababb22","title":"主流 Anti-Aliasing 算法及原理概览","content":"主流 Anti-Aliasing\r\n算法及原理概览\r\n\r\nhttps://zhuanlan.zhihu.com/p/57503957\r\n\r\nSpatial Anti-Aliasing\r\nSSAA\r\nSSAA，即 Super sampling anti-aliasing，有时也称为 full-scene\r\nanti-aliasing (FSAA)，一般认为是性能消耗很大的一种抗锯齿方案。\r\n基本思路为：我们通过在更高的分辨率，使用更多的采样点来进行渲染，并在完成渲染后对结果进行混合以及下采样得到最终的结果\r\n\r\nColor samples are taken at several instances inside the pixel (not\r\njust at the center as normal), and an average color value is calculated.\r\nThis is achieved by rendering the image at a much higher resolution than\r\nthe one being displayed, then shrinking it to the desired size, using\r\nthe extra pixels for calculation. The result is a downsampled image with\r\nsmoother transitions from one line of pixels to another along the edges\r\nof objects. The number of samples determines the quality of the\r\noutput.\r\nhttps://en.wikipedia.org/wiki/Supersampling\r\n\r\n这里有一篇关于具体步骤的总结：https://zhuanlan.zhihu.com/p/484890144\r\n这个做法的核心思路就是面多加水水多加面：既然锯齿的直接原因是采样不足，那我就增加渲染过程中的采样，以得到更好的画面。但是\r\nSSAA\r\n的做法并不算好：这样做的计算量太大了——甚至是对显卡、显存、带宽全方位的压力。\r\nMSAA\r\n一般认为，MSAA 是唯一一个被硬件支持、有硬件实现的 AA\r\n算法，曾经业界普遍采用的方案之一。不过在延迟管线逐渐兴起、众多 AA\r\n方案如雨后春笋般冒出的当下，MSAA 的一些局限性也开始暴露出来。\r\n\r\nSuper sampling anti-aliasing (SSAA), also called full-scene\r\nanti-aliasing (FSAA), is used to avoid aliasing (or \"jaggies\") on\r\nfull-screen images. SSAA was the first type of anti-aliasing available\r\nwith early video cards. But due to its tremendous computational cost and\r\nthe advent of multisample anti-aliasing (MSAA) support on GPUs, it is no\r\nlonger widely used in real time applications. MSAA provides somewhat\r\nlower graphic quality, but also tremendous savings in computational\r\npower.\r\nhttps://en.wikipedia.org/wiki/Spatial_anti-aliasing\r\n\r\n对于 MSAA 的过程可作简述如下：我们保留 SSAA\r\n中的采样点，但我们将会提前——在光栅化阶段就进行覆盖判断。记录覆盖结果，并在之后的着色中，对存在通过判断的采样点的像素进行着色。分别对通过的采样点进行深度测试等，最后将通过这些测试的结果保存至对应缓冲的对应位置。在所有渲染工作完成时，我们会进行一步\"Resolve\"操作，它会合并所有的\r\nmulti-sampled textures 以得到最终结果。\r\n\r\nFor DirectX, resolving a texture means blending multi-sampled texture\r\ninto a non-multisampled one. For simple scenarios this is usually done\r\nautomatically by the output merger, but is often needed to be done\r\nexplicitly (e.g. ResolveSubresource) when using multi-sampled render\r\ntarget as an input for a next render pass (e.g. post-processing).\r\nReasons being both performance and lower complexity of the following\r\npass shaders.\r\nhttps://computergraphics.stackexchange.com/questions/9262/what-does-texture-resolve-mean\r\n\r\n下图是 DX11 的光栅化说明文档中的 MSAA 示意图，非常详细地展示了 MSAA\r\n的应用原理。\r\n\r\n\r\nimage-20231006191532143\r\n\r\n\r\n关于 MSAA，可以参考：https://zhuanlan.zhihu.com/p/415087003\r\n\r\n从以上的内容中，你大概可以看出：相对于\r\nSSAA，我们降低了显卡的计算量——一个像素块仍然只需要一次计算就足够了，但显存和带宽上的压力仍在——因为采样点依然存在。重要的是，这些带宽并没有得到有效利用——很多带宽被浪费了——这也就是为什么延迟管线不会采用\r\nMSAA 的原因。\r\nTAA\r\n接着看 TAA，Temporal Anti-Aliasing\r\n\r\nhttps://zhuanlan.zhihu.com/p/57503885\r\n\r\n和 SSAA 类似的是，TAA 的每个像素点同样有多个\"采样点\"。但是不同与 SSAA\r\n的是，TAA\r\n会综合历史帧的数据来实现抗锯齿，这样会将每个像素点的多次采样成本均摊到多个帧中，相对的开销要小得多，同时，由于\r\nTAA\r\n是从前后帧来获取，将每个像素的多次采样分摊到多个帧中来实现的，其实际的执行效率相较于\r\nMSAA\r\n会高上不少。不过，既然是综合历史帧的算法，其效果必然会因为物体运动而收到影响。\r\n\r\nSampling the pixels at a different position in each frame can be\r\nachieved by adding a per-frame \"jitter\" when rendering the frames. The\r\n\"jitter\" is a 2D offset that shifts the pixel grid, and its X and Y\r\nmagnitude are between 0 and 1.\r\nWhen combining pixels sampled in past frames with pixels sampled in\r\nthe current frame, care needs to be taken to avoid blending pixels that\r\ncontain different objects, which would produce ghosting or\r\nmotion-blurring artifacts. Different implementation of TAA have\r\ndifferent ways of achieving this. Possible methods include:\r\nUsing motion vectors from the game engine to perform motion\r\ncompensation before blending. Limiting (clamping) the final value of a\r\npixel by the values of pixels surrounding it.\r\nhttps://en.wikipedia.org/wiki/Temporal_anti-aliasing\r\n\r\n 一种可用的采样点序列实例：Halton 采样序列\r\nTAA 的具体流程可参考：https://zhuanlan.zhihu.com/p/425233743\r\nMorphological Anti-Aliasing\r\n除了增加采样点的数目，另一种常见的抗锯齿方案是通过后处理的方式来完成——例如\r\nFXAA 和 SMAA。\r\n它的思路也很简单：既然大多数锯齿都只出现在物体边缘或者高光变化的部分，那我们通过后处理的方式，检测出图像块之间的边缘，然后根据边缘信息对边缘两侧的图像进行混合处理，就可以达到抗锯齿的效果了。\r\n比如下图中的图像，左边是待处理的图像，中间是找到的边界，右侧是将边界两侧像素混合后得到的抗锯齿效果。\r\n\r\n\r\nimg\r\n\r\nFXAA\r\nFXAA，即 Fast approximate anti-aliasing：\r\n\r\nFast approximate anti-aliasing (FXAA) is a screen-space anti-aliasing\r\nalgorithm created by Timothy Lottes at Nvidia.\r\nFXAA 3 is released under a public domain license. A later version,\r\nFXAA 3.11, is released under a 3-clause BSD license.\r\nhttps://en.wikipedia.org/wiki/Fast_approximate_anti-aliasing\r\n\r\nFXAA3.11 有两个版本：注重抗锯齿质量的 Quality 版本和注重抗锯齿速度的\r\nConsole 版本。\r\n\r\n即使是 FXAA3.11，也已经是很有年头的东西了——这是出现于 2011 年，适用于\r\nGTX4 系的技术。\r\n\r\nFXAA 大致步骤如下：\r\n\r\n计算亮度与对比度：\r\n\r\n首先是求亮度，这可以使用常用的求亮度公式 L = 0.213 _ R + 0.715 _\r\nG + 0.072 * B，也可以直接使用 G\r\n分量的颜色值作为亮度值，因为绿色对整体亮度的贡献是最大的。当然，我们也可以直接从采样结果中获取——这需要我们提前将亮度保存在\r\nalpha 通道中\r\n采样亮度，计算对比度：\r\n采样的位置是下图所示的点，分别得到中间点 M 和周围四个点 N、E、W、S\r\n的亮度值。\r\n\r\n\r\nimg\r\n\r\n可以直接用最大亮度和最小亮度的差作为对比度：\r\n123456float MaxLuma = max(N, E, W, S, M);float MinLuma = min(N, E, W, S, M);float Contrast =  MaxLuma - MinLuma;if(Contrast &gt;= max(_MinThreshold, MaxLuma * _Threshold)) &#123;//    ...&#125;\r\n如果得到的对比度值比较小，可以认为当前的点，不需要进行锯齿处理。\r\n\r\n基于亮度的混合系数计算\r\n\r\n关于像素边缘采样：\r\nSMAA\r\nFSR\r\n\r\nhttps://zhuanlan.zhihu.com/p/532302889\r\n\r\nTSR\r\nDeep Learning Anti-Aliasing\r\nDLSS\r\nReferences\r\n\r\nhttps://zhuanlan.zhihu.com/p/57503957\r\n\r\n","slug":"Rendering/主流AA算法及原理","date":"2023-02-25T04:23:23.000Z","categories_index":"Algorithm,Rendering,AA","tags_index":"Algorithm,Rendering,AA","author_index":"JBR_Bunjie"},{"id":"d603f61c6dd6ebd8e3ed06a28bd85050","title":"设计模式在游戏编程中的实践","content":"设计模式在游戏编程中的实践\r\n设计模式\r\n命令模式\r\n\r\n将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；\r\n对请求排队或记录请求日志，以及支持可撤销的操作。\r\n\r\n命令模式至少包含这样几个部分：\r\n\r\n\r\nimg\r\n\r\n介绍\r\n意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\r\n主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\r\n何时使用：在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\r\n如何解决：通过调用者调用接受者执行命令，顺序：调用者\r\n→ 命令 → 接受者。\r\n关键代码：定义三个角色：1、received\r\n真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口\r\n应用实例：struts 1 中的 action 核心控制器\r\nActionServlet 只有一个，相当于\r\nInvoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的\r\nCommand。\r\n优点： 1、降低了系统耦合度。\r\n2、新的命令可以很容易添加到系统中去。\r\n缺点：使用命令模式可能会导致某些系统有过多的具体命令类。\r\n使用场景：认为是命令的地方都可以使用命令模式，比如：\r\n1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。\r\n注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\r\n使用命令模式之前...\r\n\r\n在每个游戏中都有一块代码读取用户的输入——按钮按下，键盘敲击，鼠标点击，诸如此类。\r\n这块代码会获取用户的输入，然后将其变为游戏中有意义的行为\r\n\r\n\r\n一个手柄,\r\nA键调用swapWeapon()，B键调用lurch()，X键调用jump()，Y键调用fireGun()。\r\n\r\n\r\n如果对这样一个功能作出实现的话，最简单的实现也许是如下所示的：\r\n123456void InputHandler::handleInput() &#123;  if (isPressed(BUTTON_X)) jump();  else if (isPressed(BUTTON_Y)) fireGun();  else if (isPressed(BUTTON_A)) swapWeapon();  else if (isPressed(BUTTON_B)) lurchIneffectively();&#125;\r\n它能实现我们的功能没错，但我们至少能发现这里的耦合度太高了，事实上，这里在实际游玩中，还不能允许玩家修改键位等等。要想实现更多的功能，我们就得将这里的代码解耦——这个时候命令模式就出场了。\r\n命令模式有好几种实现思路，但是它们都有一些共性\r\n命令基类 / 抽象命令类\r\n这一般是一个抽象类或接口，在其中声明了用于执行请求的\r\nexecute()等方法，通过这些方法可以调用请求接收者的相关操作。\r\n这部分的示例如下：\r\n12345class Command &#123;public:  virtual ~Command() &#123;&#125;  virtual void execute() = 0;&#125;;\r\n具体命令类\r\n我们根据实际需求，对基类进行实现\r\n123456789class JumpCommand : public Command &#123;public:  virtual void execute() &#123; jump(); &#125;&#125;;class FireCommand : public Command &#123;public:  virtual void execute() &#123; fireGun(); &#125;&#125;;z`\r\n这一部分往往是存在很多变化的：也许我们会设立\r\n调用部分 / 请求部分\r\n在代码的输入处理部分，为每个按键存储一个指向命令的指针。\r\n12345678910111213class InputHandler&#123;public:  void handleInput();  // 绑定命令的方法……private:  Command* buttonX_;  Command* buttonY_;  Command* buttonA_;  Command* buttonB_;&#125;;\r\n并对于这个接收输入的部分，我们将其修改为：\r\n123456void InputHandler::handleInput() &#123;  if (isPressed(BUTTON_X)) buttonX_-&gt;execute();  else if (isPressed(BUTTON_Y)) buttonY_-&gt;execute();  else if (isPressed(BUTTON_A)) buttonA_-&gt;execute();  else if (isPressed(BUTTON_B)) buttonB_-&gt;execute();&#125;\r\n到这里，我们已经实现了这个应用中的解耦了——我们不关心我们具体调用的是什么方法，我们只需要知道，这就是我们需要的方法就行。\r\n但是这里还可以有一个问题，之所以说“可以有”，是因为这里\r\n接收部分\r\n\r\n接收者执行与请求相关的操作，它具体实现对请求的业务处理。\r\n\r\n我们得根据实际情况判断我们是否真的需要这一部分：我们所谓的接收部分，往往就是我们实际的\r\nGameObject，也就是说，这一部分决定了我们到底想要我们的功能对于谁生效——譬如我们在上一部分中的第一个例子，我们可以发现这样一个问题：我们假设了顶层的jump(),\r\nfireGun()之类的函数是用于找到玩家角色的——这些假定同样产生了耦合，而这些耦合限制了这些命令的用处——JumpCommand只能让玩家的角色跳跃。\r\n让我们将这个接收命令的 GameObject\r\n暴露出来，将函数控制的角色对象传进去——这需要修改一下前面的代码：\r\n12345678910111213141516171819202122232425262728293031// 抽象类部分class Command &#123;public:  virtual ~Command() &#123;&#125;  virtual void execute(GameObject&amp; character) = 0;&#125;;// Jumpclass JumpCommand : public Command &#123;public:  virtual void execute(GameActor&amp; actor) &#123;    actor.jump();  &#125;&#125;;// handleCommand* InputHandler::handleInput() &#123;  if (isPressed(BUTTON_X)) return buttonX_;  if (isPressed(BUTTON_Y)) return buttonY_;  if (isPressed(BUTTON_A)) return buttonA_;  if (isPressed(BUTTON_B)) return buttonB_;  // 没有按下任何按键，就什么也不做  return NULL;&#125;// 接收部分Command* command = inputHandler.handleInput();if (command) &#123;  command-&gt;execute(actor);&#125;\r\n需要注意两点：\r\n\r\n不管我们有没有暴露作用对象，我们实际产生影响的\r\nCode，是存在于我们的接收部分中的\r\n在新的实例中，我们的功能不是立即执行的——我们会延迟到调用执行时再知道\r\n\r\n对于传入 GameObject\r\n的情况，我们成功扩大了这个模板的可用性：即使是对于\r\nAI，我们也只需编写适用于它们的Command对象，就可以复用它。\r\n\r\n把控制角色的命令变为第一公民对象，去除直接方法调用中严厉的束缚。\r\n将其视为命令队列，或者是命令流：\r\n\r\n\r\n一条连接AI到角色的管道。\r\n\r\n一些代码（输入控制器或者 AI）产生一系列命令放入流中。\r\n另一些代码（调度器或者角色自身）调用并消耗命令。\r\n通过在中间加入队列，我们解耦了消费者和生产者。\r\n\r\n撤销和重做\r\n我想，命令模式最广泛的用例应该是用于实现撤销和重做功能了。\r\n由于在本模式中，我们天然地将一个过程的进行拆分成了命令发出和命令执行两部分，那我们就可以很方便地记录命令的发出内容，并以此为作为回滚的依据。\r\n我们已经使用了命令来抽象输入控制，所以每个玩家的举动都已经被封装其中。\r\n举个例子，移动一个单位的代码可能如下：\r\n123456789101112131415161718// 注意这和前面的命令有些许不同：在前面的例子中，我们需要从修改的角色那里抽象命令; 在这个例子中，我们将命令绑定到要移动的单位上。// 这条命令的实例不是通用的“移动某物”命令；而是游戏回合中特殊的一次移动class MoveUnitCommand : public Command &#123;public:  MoveUnitCommand(Unit* unit, int x, int y)  : unit_(unit),    x_(x),    y_(y)  &#123;&#125;  virtual void execute() &#123;    unit_-&gt;moveTo(x_, y_);  &#125;private:  Unit* unit_;  int x_, y_;&#125;;\r\n这展现了命令模式应用时的一种情形。\r\n就像之前的例子，指令在某些情形中是可重用的对象，代表了可执行的事件。\r\n我们早期的输入控制器将其实现为一个命令对象，然后在按键按下时调用其execute()方法。\r\n这里的命令更加特殊。它们代表了特定时间点能做的特定事件。\r\n这意味着输入控制代码可以在玩家下决定时创造一个实例。就像这样：\r\n1234567891011121314151617181920Command* handleInput()&#123;  Unit* unit = getSelectedUnit();  if (isPressed(BUTTON_UP)) &#123;    // 向上移动单位    int destY = unit-&gt;y() - 1;    return new MoveUnitCommand(unit, unit-&gt;x(), destY);  &#125;  if (isPressed(BUTTON_DOWN)) &#123;    // 向下移动单位    int destY = unit-&gt;y() + 1;    return new MoveUnitCommand(unit, unit-&gt;x(), destY);  &#125;  // 其他的移动……  return NULL;&#125;\r\n命令的一次性为我们很快地赢得了一个优点。\r\n为了让指令可被取消，我们为每个类定义另一个需要实现的方法：\r\n1234567class Command&#123;public:  virtual ~Command() &#123;&#125;  virtual void execute() = 0;  virtual void undo() = 0;&#125;;\r\nundo()方法回滚了execute()方法造成的游戏状态改变。\r\n这里是添加了撤销功能后的移动命令：\r\n1234567891011121314151617181920212223242526272829303132class MoveUnitCommand : public Command&#123;public:  MoveUnitCommand(Unit* unit, int x, int y)  : unit_(unit),    xBefore_(0),    yBefore_(0),    x_(x),    y_(y)  &#123;&#125;  virtual void execute()  &#123;    // 保存移动之前的位置    // 这样之后可以复原。    xBefore_ = unit_-&gt;x();    yBefore_ = unit_-&gt;y();    unit_-&gt;moveTo(x_, y_);  &#125;  virtual void undo()  &#123;    unit_-&gt;moveTo(xBefore_, yBefore_);  &#125;private:  Unit* unit_;  int xBefore_, yBefore_;  int x_, y_;&#125;;\r\n注意我们为类添加了更多的状态。\r\n当单位移动时，它忘记了它之前是什么样的。\r\n如果我们想要撤销这个移动，我们需要记得单位之前的状态，也就是xBefore_和yBefore_的作用。\r\n由于命令趋向于修改对象状态的一小部分，对数据其他部分的快照就是浪费内存。手动内存管理的消耗更小。持久化数据结构是另一个选项。\r\n使用它，每次修改对象都返回一个新对象，保持原来的对象不变。巧妙的实现下，这些新对象与之前的对象共享数据，所以比克隆整个对象开销更小。使用持久化数据结构，每条命令都存储了命令执行之前对象的引用，而撤销只是切换回之前的对象。\r\n为了让玩家撤销移动，我们记录了执行的最后命令。当他们按下control+z时，我们调用命令的undo()方法。\r\n（如果他们已经撤销了，那么就变成了“重做”，我们会再一次执行命令。）\r\n支持多重的撤销也不太难。\r\n我们不单单记录最后一条指令，还要记录指令列表，然后用一个引用指向“当前”的那个。\r\n当玩家执行一条命令，我们将其添加到列表，然后将代表“当前”的指针指向它。\r\n\r\n\r\n从旧到新排列的命令栈。\r\n一个当前箭头指向一条命令，一个“撤销”箭头指向之前的命令，一个“重做”指向之后的命令\r\n\r\n当玩家选择“撤销”，我们撤销现在的命令，将代表当前的指针往后退。\r\n当他们选择“重做”，我们将代表当前的指针往前进，执行该指令。\r\n如果在撤销后选择了新命令，那么清除命令列表中当前的指针所指命令之后的全部命令。\r\n第一次在关卡编辑器中实现这点时，我觉得自己简直就是个天才。\r\n我惊讶于它如此的简明有效。\r\n你需要约束自己，保证每个数据修改都通过命令完成，一旦你做到了，余下的都很简单。\r\n享元模式\r\n享元模式最直接的影响就是数据复用：\r\n\r\n迷雾散尽，露出了古朴庄严的森林。古老的铁杉，在头顶编成绿色穹顶。\r\n阳光在树叶间破碎成金色顶棚。从树干间远眺，远处的森林渐渐隐去。\r\n这是我们游戏开发者梦想的超凡场景，这样的场景通常由一个模式支撑着，它的名字低调至极：享元模式。\r\n用几句话就能描述一片巨大的森林，但是在实时游戏中做这件事就完全是另外一件事了。\r\n当屏幕上需要显示一整个森林时，图形程序员看到的是每秒需要送到 GPU\r\n六十次的百万多边形——我们讨论的是成千上万的树，每棵都由上千的多边形组成。\r\n就算有足够的内存描述森林，渲染的过程中，CPU 到 GPU\r\n的部分也太过繁忙了。\r\n让我们仔细分析一下这个场景——每棵树都有：\r\n\r\n定义树干，树枝和树叶形状的多边形网格。\r\n树皮和树叶的纹理。\r\n在森林中树的位置和朝向。\r\n大小和色彩之类的调节参数，让每棵树都看起来与众不同。\r\n\r\n如果用代码表示，那么会得到这样的东西：\r\n1234567891011class Tree &#123;private:  Mesh mesh_;  Texture bark_;  Texture leaves_;  Vector position_;  double height_;  double thickness_;  Color barkTint_;  Color leafTint_;&#125;;\r\n这是一大堆数据，多边形网格和纹理体积非常大。\r\n描述整个森林的对象在一帧的时间就交给 GPU 实在是太过了。\r\n幸运的是，有一种老办法来处理它：关键点在于，哪怕森林里有千千万万的树，它们大多数长得一模一样。\r\n它们使用了相同的网格和纹理。\r\n这意味着这些树的实例的大部分字段是一样的。\r\n\r\n你要么是疯了，要么是亿万富翁，才能让美术给森林里每棵树建立独立模型。\r\n\r\n注意每一棵树的小盒子中的东西都是一样的。\r\n我们可以通过显式地将对象切为两部分来更加明确地模拟。\r\n第一，将树共有的数据拿出来分离到另一个类中：\r\n123456class TreeModel &#123;private:  Mesh mesh_;  Texture bark_;  Texture leaves_;&#125;;\r\n游戏只需要一个这种类，\r\n因为没有必要在内存中把相同的网格和纹理重复一千遍。\r\n游戏世界中每个树的实例只需有一个对这个共享TreeModel的引用。\r\n留在Tree中的是那些实例相关的数据：\r\n12345678910class Tree &#123;private:  TreeModel* model_;  Vector position_;  double height_;  double thickness_;  Color barkTint_;  Color leafTint_;&#125;;\r\n你可以将其想象成这样：\r\n\r\n\r\n一行树，每个都有自己的参数和位置朝向，指向另一个有网格、纹理、树叶的树模型。\r\n\r\n不过，虽然把所有的东西都存在主存里没什么问题，但是这对渲染也毫无帮助——在森林到屏幕上之前，它得先到\r\nGPU。我们需要用显卡可以识别的方式共享数据。\r\n为了减少需要推送到 GPU\r\n的数据量，我们想把共享的数据——TreeModel——只发送一次。\r\n然后再分别发送每个树独特的数据——位置，颜色，大小。 最后，我们告诉\r\nGPU，“使用同一模型渲染每个实例”。\r\n幸运的是，今日的图形接口和显卡正好支持这一点。\r\n这些细节很繁琐且超出了这部书的范围，但是 Direct3D 和 OpenGL 都可以做实例渲染。\r\n在这些 API 中，你需要提供两部分数据流。\r\n第一部分是一块需要渲染多次的共同数据——在例子中是树的网格和纹理。\r\n第二部分是实例的列表以及绘制第一部分时需要使用的参数。\r\n然后调用一次渲染，绘制整个森林。\r\n这个 API 是由显卡直接实现的，我们可以说，享元模式是唯一的有硬件支持的\r\nGoF 设计模式。\r\n\r\n介绍\r\n好了，我们已经看了一个具体的例子，下面我介绍模式的通用部分。\r\n享元，就像它的名字暗示的那样，\r\n当你需要共享类时使用，通常是因为你有太多这种类了。\r\n实例渲染时，每棵树通过总线送到 GPU\r\n消耗的更多是时间而非内存，但是基本要点是一样的。\r\n这个模式通过将对象的数据分为两种来解决这个问题。\r\n第一种数据没有特定指明是哪个对象的实例，因此可以在它们间分享。\r\nGof 称之为固有状态，但是我更喜欢将其视为“上下文无关”部分。\r\n在这里的例子中，是树的网格和纹理。\r\n数据的剩余部分是变化状态，那些每个实例独一无二的东西。\r\n在这个例子中，是每棵树的位置，拉伸和颜色。\r\n就像这里的示例代码块一样，这种模式通过在每个对象出现时共享一份固有状态来节约内存。\r\n就目前而言，这看上去像是基础的资源共享，很难被称为一种模式。\r\n部分原因是在这个例子中，我们可以为共享状态划出一个清晰的身份：TreeModel。\r\n我发现，当共享对象没有有效定义的实体时，使用这种模式就不那么明显（使用它也就越发显得精明）。\r\n在那些情况下，这看上去是一个对象被魔术般地同时分配到了多个地方。\r\n让我展示给你另外一个例子。\r\n合理示例\r\n这些树长出来的地方也需要在游戏中表示。\r\n这里可能有草，泥土，丘陵，湖泊，河流，以及其它任何你可以想到的地形。\r\n我们基于区块建立地表：世界的表面被划分为由微小区块组成的巨大网格。\r\n每个区块都由一种地形覆盖。\r\n每种地形类型都有一系列特性会影响游戏玩法：\r\n\r\n决定了玩家能够多快地穿过它的移动开销。\r\n表明能否用船穿过的水域标识。\r\n用来渲染它的纹理。\r\n\r\n基于前面的教训，我们不会在每个区块中保存这些状态。\r\n相反，一个通用的方式是为每种地形使用一个枚举。\r\n123456enum Terrain &#123;  TERRAIN_GRASS,  TERRAIN_HILL,  TERRAIN_RIVER  // 其他地形&#125;;\r\n然后，世界管理巨大的网格：\r\n1234class World &#123;private:  Terrain tiles_[WIDTH][HEIGHT];&#125;;\r\n\r\n这里我使用嵌套数组存储 2D 网格。 在\r\nC/C++中这样是很有效率的，因为它会将所有元素打包在一起。 在 Java\r\n或者其他内存管理语言中，那样做会实际给你一个数组，其中每个元素都是对数组的列的引用，那就不像你想要的那样内存友好了。\r\n反正，隐藏 2D 网格数据结构背后的实现细节，能使代码更好地工作。\r\n我这里这样做只是为了让其保持简单。\r\n\r\n为了获得区块的实际有用的数据，我们做了一些这样的事情：\r\n1234567891011121314151617int World::getMovementCost(int x, int y) &#123;  switch (tiles_[x][y]) &#123;    case TERRAIN_GRASS: return 1;    case TERRAIN_HILL:  return 3;    case TERRAIN_RIVER: return 2;      // 其他地形……  &#125;&#125;bool World::isWater(int x, int y) &#123;  switch (tiles_[x][y]) &#123;    case TERRAIN_GRASS: return false;    case TERRAIN_HILL:  return false;    case TERRAIN_RIVER: return true;      // 其他地形……  &#125;&#125;\r\n你知道我的意思了。这可行，但是我觉得很丑。\r\n移动开销和水域标识是区块的数据，但在这里它们散布在代码中。\r\n更糟的是，简单地形的数据被众多方法拆开了。\r\n如果能够将这些包裹起来就好了。毕竟，那是我们设计对象的目的。\r\n如果我们有实际的地形类就好了，像这样：\r\n12345678910111213141516171819class Terrain &#123;public:  Terrain(int movementCost,          bool isWater,          Texture texture)  : movementCost_(movementCost),    isWater_(isWater),    texture_(texture)  &#123;&#125;  int getMovementCost() const &#123; return movementCost_; &#125;  bool isWater() const &#123; return isWater_; &#125;  const Texture&amp; getTexture() const &#123; return texture_; &#125;private:  int movementCost_;  bool isWater_;  Texture texture_;&#125;;\r\n你会注意这里所有的方法都是const。这不是巧合。\r\n由于同一对象在多处引用，如果你修改了它， 改变会同时在多个地方出现。\r\n这也许不是你想要的。\r\n通过分享对象来节约内存的这种优化，不应该影响到应用的显性行为。\r\n因此，享元对象几乎总是不可变的。\r\n但是我们不想为每个区块都保存一个实例。\r\n如果你看看这个类内部，你会发现里面实际上什么也没有，\r\n唯一特别的是区块在哪里。\r\n用享元的术语讲，区块的所有状态都是“固有的”或者说“上下文无关的”。\r\n鉴于此，我们没有必要保存多个同种地形类型。 地面上的草区块两两无异。\r\n我们不用地形区块对象枚举构成世界网格，而是用Terrain对象指针组成网格：\r\n1234567class World&#123;private:  Terrain* tiles_[WIDTH][HEIGHT];  // 其他代码……&#125;;\r\n每个相同地形的区块会指向相同的地形实例。\r\n\r\n\r\n一行区块，每个区块指向共享的草、河、山丘对象。\r\n\r\n由于地形实例在很多地方使用，如果你想要动态分配，它们的生命周期会有点复杂。\r\n因此，我们直接在游戏世界中存储它们。\r\n12345678910111213141516class World&#123;public:  World()  : grassTerrain_(1, false, GRASS_TEXTURE),    hillTerrain_(3, false, HILL_TEXTURE),    riverTerrain_(2, true, RIVER_TEXTURE)  &#123;&#125;private:  Terrain grassTerrain_;  Terrain hillTerrain_;  Terrain riverTerrain_;  // 其他代码……&#125;;\r\n然后我们可以像这样来描绘地面：\r\n12345678910111213141516171819202122232425void World::generateTerrain()&#123;  // 将地面填满草皮.  for (int x = 0; x &lt; WIDTH; x++)  &#123;    for (int y = 0; y &lt; HEIGHT; y++)    &#123;      // 加入一些丘陵      if (random(10) == 0)      &#123;        tiles_[x][y] = &amp;hillTerrain_;      &#125;      else      &#123;        tiles_[x][y] = &amp;grassTerrain_;      &#125;    &#125;  &#125;  // 放置河流  int x = random(WIDTH);  for (int y = 0; y &lt; HEIGHT; y++) &#123;    tiles_[x][y] = &amp;riverTerrain_;  &#125;&#125;\r\n我承认这不是世界上最好的地形生成算法。\r\n现在不需要World中的方法来接触地形属性，我们可以直接暴露出Terrain对象。\r\n1234const Terrain&amp; World::getTile(int x, int y) const&#123;  return *tiles_[x][y];&#125;\r\n用这种方式，World不再与各种地形的细节耦合。\r\n如果你想要某一区块的属性，可直接从那个对象获得：\r\n1int cost = world.getTile(2, 3).getMovementCost();\r\n我们回到了操作实体对象的\r\nAPI，几乎没有额外开销——指针通常不比枚举大。\r\n观察者模式\r\n观察者模式是 C#中的一个基本模式，已经以 event\r\n语法的形式嵌入了整个语言中。\r\n引入\r\n\r\n假设我们向游戏中添加了成就系统。\r\n它存储了玩家可以完成的各种各样的成就，比如“杀死 1000\r\n只猴子恶魔”，“从桥上掉下去”，或者“一命通关”。\r\n 我发誓画的这个没有第二个意思，笑。\r\n要实现这样一个包含各种行为来解锁成就的系统是很有技巧的。\r\n如果我们不够小心，成就系统会缠绕在代码库的每个黑暗角落。\r\n当然，“从桥上掉落”和物理引擎相关，\r\n但我们并不想看到在处理撞击代码的线性代数时，\r\n有个对unlockFallOffBridge()的调用是不？\r\n我们喜欢的是，照旧，让关注游戏一部分的所有代码集成到一块。挑战在于，成就在游戏的不同层面被触发。怎么解耦成就系统和其他部分呢？\r\n这就是观察者模式出现的原因。这让代码宣称有趣的事情发生了，而不必关心到底是谁接受了通知。\r\n举个例子，有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。\r\n为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。\r\n相反，可以这样做：\r\n123456789void Physics::updateEntity(Entity&amp; entity) &#123;  bool wasOnSurface = entity.isOnSurface();  entity.accelerate(GRAVITY);  entity.update();  if (wasOnSurface &amp;&amp; !entity.isOnSurface()) &#123;    notify(entity, EVENT_START_FALL);  &#125;&#125;// 物理引擎确实决定了要发送什么通知，所以这并没有完全解耦。但在架构这个领域，通常只能让系统变得*更好*，而不是*完美*。\r\n它做的就是声称，“额，我不知道有谁感兴趣，但是这个东西刚刚掉下去了。做你想做的事吧。”\r\n成就系统注册它自己为观察者，这样无论何时物理代码发送通知，成就系统都能收到。\r\n它可以检查掉落的物体是不是我们的失足英雄，\r\n他之前有没有做过这种不愉快的与桥的经典力学遭遇。\r\n如果满足条件，就伴着礼花和炫光解锁合适的成就，而这些都无需牵扯到物理代码。\r\n事实上，我们可以改变成就的集合或者删除整个成就系统，而不必修改物理引擎。\r\n它仍然会发送它的通知，哪怕实际没有东西接收。\r\n\r\n介绍\r\n在观察者模式中，我们理所当然地存在两个主要对象：观察者和被观察者\r\n我们可以这样简单归纳这两者的关系：观察者订阅被观察者的状态，当被观察者状态改变时，被观察者主动通知所有订阅的观察者。\r\n观察者\r\n我们从那个需要知道别的对象做了什么事的类开始。\r\n这些好打听的对象用如下接口定义：\r\n123456class Observer&#123;public:  virtual ~Observer() &#123;&#125;  virtual void onNotify(const Entity&amp; entity, Event event) = 0;&#125;;\r\n任何实现了这个的具体类就成为了观察者。\r\n在我们的例子中，是成就系统，所以我们可以像这样实现：\r\n123456789101112131415161718192021class Achievements : public Observer &#123;public:  virtual void onNotify(const Entity&amp; entity, Event event) &#123;    switch (event) &#123;    case EVENT_ENTITY_FELL:      if (entity.isHero() &amp;&amp; heroIsOnBridge_) &#123;        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);      &#125;      break;      // 处理其他事件，更新heroIsOnBridge_变量……    &#125;  &#125;private:  void unlock(Achievement achievement) &#123;    // 如果还没有解锁，那就解锁成就……  &#125;  bool heroIsOnBridge_;&#125;;\r\n被观察者\r\n被观察的对象拥有通知的方法函数，用 GoF 的说法，那些对象被称为“主题”。\r\n它有两个任务。首先，它有一个列表，保存默默等它通知的观察者：\r\n123456class Subject&#123;private:  Observer* observers_[MAX_OBSERVERS];  int numObservers_;&#125;;\r\n重点是被观察者暴露了公开的API 来修改这个列表：\r\n123456789101112class Subject &#123;public:  void addObserver(Observer* observer) &#123;    // 添加到数组中……  &#125;  void removeObserver(Observer* observer) &#123;    // 从数组中移除……  &#125;  // 其他代码……&#125;;\r\n这就允许了外界代码控制谁接收通知。\r\n*被观察者与观察者交流，但是不与它们耦合*。\r\n在我们的例子中，没有一行物理代码会提及成就。\r\n但它仍然可以与成就系统交流。这就是这个模式的聪慧之处。\r\n被观察者有一列表观察者而不是单个观察者也是很重要的。\r\n这保证了观察者不会相互干扰。\r\n举个例子，假设音频引擎也需要观察坠落事件来播放合适的音乐。\r\n如果客体只支持单个观察者，当音频引擎注册时，就会取消成就系统的注册。这意味着这两个系统需要相互交互——而且是用一种极其糟糕的方式，\r\n第二个注册时会使第一个的注册失效。\r\n支持一列表的观察者保证了每个观察者都是被独立处理的。\r\n就它们各自的视角来看，自己是这世界上唯一看着被观察者的。\r\n被观察者的剩余任务就是发送通知：\r\n12345678910class Subject &#123;protected:  void notify(const Entity&amp; entity, Event event) &#123;    for (int i = 0; i &lt; numObservers_; i++) &#123;      observers_[i]-&gt;onNotify(entity, event);    &#125;  &#125;  // 其他代码…………&#125;;\r\n现在，我们只需要给物理引擎和这些挂钩，这样它可以发送消息，\r\n成就系统可以和引擎连线来接受消息。\r\n我们按照传统的设计模式方法实现，继承Subject：\r\n1234class Physics : public Subject &#123;public:  void updateEntity(Entity&amp; entity);&#125;;\r\n这让我们将notify()实现为了Subject内的保护方法。\r\n这样派生的物理引擎类可以调用并发送通知，但是外部的代码不行。\r\n同时，addObserver()和removeObserver()是公开的，\r\n所以任何可以接触物理引擎的东西都可以观察它。\r\n在真实代码中，我会避免使用这里的继承。\r\n相反，我会让Physics 有\r\n一个Subject的实例。\r\n不再是观察物理引擎本身，被观察的会是独立的“下落事件”对象。\r\n观察者可以用像这样注册它们自己：\r\n12physics.entityFell()  .addObserver(this);\r\n对我而言，这是“观察者”系统与“事件”系统的不同之处。\r\n使用前者，你观察做了有趣事情的事物。\r\n使用后者，你观察的对象代表了发生的有趣事情。\r\n现在，当物理引擎做了些值得关注的事情，它调用notify()，就像之前的例子。\r\n它遍历了观察者列表，通知所有观察者。\r\n\r\n\r\n被观察者包含一列表观察者的指针。前两个指向成就和音频系统。\r\n\r\n很简单，对吧？只要一个类管理一列表指向接口实例的指针。\r\n难以置信的是，如此直观的东西是无数程序和应用框架交流的主心骨。\r\n观察者模式不是完美无缺的。当我问其他程序员怎么看，他们提出了一些抱怨。\r\n让我们看看可以做些什么来处理这些抱怨。\r\n观察者模式的一般实现\r\n创建 Subject 类：\r\n1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;public class Subject &#123;   private List&lt;Observer&gt; observers  = new ArrayList&lt;Observer&gt;();   private int state;   public int getState() &#123;      return state;   &#125;   public void setState(int state) &#123;      this.state = state;      notifyAllObservers();   &#125;   public void attach(Observer observer)&#123;      observers.add(observer);   &#125;   public void notifyAllObservers()&#123;      for (Observer observer : observers) &#123;         observer.update();      &#125;   &#125;&#125;\r\n创建 Observer 类：\r\n1234public abstract class Observer &#123;   protected Subject subject;   public abstract void update();&#125;\r\n创建实体观察者类：\r\n1234567891011121314151617181920212223242526272829303132public class BinaryObserver extends Observer&#123;   public BinaryObserver(Subject subject)&#123;      this.subject = subject;      this.subject.attach(this);   &#125;   @Override   public void update() &#123;      System.out.println( &quot;Binary String: &quot; + Integer.toBinaryString( subject.getState() ) );   &#125;&#125;public class OctalObserver extends Observer&#123;   public OctalObserver(Subject subject)&#123;      this.subject = subject;      this.subject.attach(this);   &#125;   @Override   public void update() &#123;     System.out.println( &quot;Octal String: &quot; + Integer.toOctalString( subject.getState() ) );   &#125;&#125;public class HexaObserver extends Observer&#123;   public HexaObserver(Subject subject)&#123;      this.subject = subject;      this.subject.attach(this);   &#125;   @Override   public void update() &#123;      System.out.println( &quot;Hex String: &quot; + Integer.toHexString( subject.getState() ).toUpperCase() );   &#125;&#125;\r\n使用 Subject 和实体观察者对象：\r\n1234567891011121314public class ObserverPatternDemo &#123;   public static void main(String[] args) &#123;      Subject subject = new Subject();      new HexaObserver(subject);      new OctalObserver(subject);      new BinaryObserver(subject);      System.out.println(&quot;First state change: 15&quot;);      subject.setState(15);      System.out.println(&quot;Second state change: 10&quot;);      subject.setState(10);   &#125;&#125;\r\n执行程序，输出结果：\r\n12345678First state change: 15Hex String: FOctal String: 17Binary String: 1111Second state change: 10Hex String: AOctal String: 12Binary String: 1010\r\n原型模式\r\n\r\n原型模式（Prototype\r\nPattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。这种模式实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。\r\n\r\n正式采用原型设计模式\r\n原型模式的关键思路是一个对象可以产出与它自己相近的对象。\r\n如果你有一个恶灵，你可以制造更多恶灵。\r\n如果你有一个恶魔，你可以制造其他恶魔。\r\n任何怪物都可以被视为原型怪物，产出其他版本的自己。\r\n为了实现这个功能，我们给基类Monster添加一个抽象方法clone()：\r\n创建一个顶级的基类\r\n12345678class Monster&#123;public:  virtual ~Monster() &#123;&#125;  virtual Monster* clone() = 0;  // 其他代码……&#125;;\r\n每个怪兽子类提供一个特定实现，返回与它自己的类和状态都完全一样的新对象。举个例子：\r\n123456789101112131415class Ghost : public Monster &#123;public:  Ghost(int health, int speed)  : health_(health),    speed_(speed)  &#123;&#125;  // 关键在于特定实现中覆写的clone方法  virtual Monster* clone() &#123;    return new Ghost(health_, speed_);  &#125;private:  int health_;  int speed_;&#125;;\r\n一旦我们所有的怪物都支持这个，\r\n我们不再需要为每个怪物类创建生产者类。我们只需定义一个类：\r\n123456789101112131415class Spawner&#123;public:  Spawner(Monster* prototype)  : prototype_(prototype)  &#123;&#125;  Monster* spawnMonster()  &#123;    return prototype_-&gt;clone();  &#125;private:  Monster* prototype_;&#125;;\r\n它内部存有一个怪物，一个隐藏的怪物，\r\n它唯一的任务就是被生产者当做模板，去产生更多一样的怪物，\r\n有点像一个从来不离开巢穴的蜂后。\r\n\r\n\r\n一个生产者包含一个对怪物应用的原型字段。\r\n他调用原型的clone()方法来产生新的怪物。\r\n\r\n为了得到恶灵生产者，我们创建一个恶灵的原型实例，然后创建拥有这个实例的生产者：\r\n12Monster* ghostPrototype = new Ghost(15, 3);Spawner* ghostSpawner = new Spawner(ghostPrototype);\r\n这个模式的灵巧之处在于它不但拷贝原型的类，也拷贝它的状态。\r\n这就意味着我们可以创建一个生产者，生产快速鬼魂，虚弱鬼魂，慢速鬼魂，而只需创建一个合适的原型鬼魂。\r\n我在这个模式中找到了一些既优雅又令人惊叹的东西。\r\n我无法想象自己是如何创造出它们的，但我更无法想象不知道这些东西的自己该如何是好。\r\n\r\n效果如何?\r\n好吧，我们不需要为每个怪物创建单独的生产者类，那很好。\r\n但我们确实需要在每个怪物类中实现clone()。\r\n这和使用生产者方法比起来也没节约多少代码量。\r\n当你坐下来试着写一个正确的clone()，会遇见令人不快的语义漏洞。\r\n做深层拷贝还是浅层拷贝呢？换言之，如果恶魔拿着叉子，克隆恶魔也要克隆叉子吗？\r\n同时，这看上去没减少已存问题上的代码，\r\n事实上还增添了些人为的问题。\r\n我们需要将每个怪物有独立的类作为前提条件。\r\n这绝对不是当今大多数游戏引擎运作的方法。\r\n我们中大部分痛苦地学到，这样庞杂的类层次管理起来很痛苦，\r\n那就是我们为什么用组件模式和类型对象为不同的实体建模，这样无需一一建构自己的类。\r\n\r\n用原型模式来优化数据结构\r\n随着编程的进行，如果你比较程序与数据的字节数，\r\n那么你会发现数据的占比稳定地增长。\r\n早期的游戏在程序中生成几乎所有东西，这样程序可以塞进磁盘和老式游戏卡带。\r\n在今日的游戏中，代码只是驱动游戏的“引擎”，游戏是完全由数据定义的。\r\n这很好，但是将内容推到数据文件中并不能魔术般地解决组织大项目的挑战。\r\n它只能把这挑战变得更难。\r\n我们使用高级编程语言就因为它们有办法管理复杂性：不再是将一堆代码拷来拷去，我们将其移入函数中，通过名字调用。\r\n不再是在一堆类之间复制方法，我们将其放入单独的类中，让其他类可以继承或者组合。\r\n让我们在游戏中考虑考虑：使用原型和委托来重用数据。\r\n游戏中的哥布林也许被定义为像这样的东西：\r\n1234567&#123;  &quot;name&quot;: &quot;goblin grunt&quot;,  &quot;minHealth&quot;: 20,  &quot;maxHealth&quot;: 30,  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]&#125;\r\n这看上去很易懂，哪怕是最讨厌文本的设计者也能使用它。\r\n所以，你可以给哥布林大家族添加几个兄弟分支：\r\n1234567891011121314151617&#123;  &quot;name&quot;: &quot;goblin wizard&quot;,  &quot;minHealth&quot;: 20,  &quot;maxHealth&quot;: 30,  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;],  &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]&#125;&#123;  &quot;name&quot;: &quot;goblin archer&quot;,  &quot;minHealth&quot;: 20,  &quot;maxHealth&quot;: 30,  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;],  &quot;attacks&quot;: [&quot;short bow&quot;]&#125;\r\n现在，如果这是代码，我们会闻到了臭味。\r\n在实体间有很多的重复，训练优良的程序员讨厌重复。\r\n它浪费了空间，消耗了作者更多时间。\r\n你需要仔细阅读代码才知道这些数据是不是相同的。 这难以维护。\r\n如果我们决定让所有哥布林变强，需要记得将三个哥布林都更新一遍。糟糕糟糕糟糕。\r\n如果这是代码，我们会为“哥布林”构建抽象，并在三个哥布林类型中重用。\r\n但是无能的 JSON 没法这么做。所以让我们把它做得更加巧妙些。\r\n我们可以为对象添加\"prototype\"字段，记录委托对象的名字。\r\n如果在此对象内没找到一个字段，那就去委托对象中查找。\r\n这样，我们可以简化我们的哥布林 JSON 内容：\r\n12345678910111213141516171819&#123;  &quot;name&quot;: &quot;goblin grunt&quot;,  &quot;minHealth&quot;: 20,  &quot;maxHealth&quot;: 30,  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]&#125;&#123;  &quot;name&quot;: &quot;goblin wizard&quot;,  &quot;prototype&quot;: &quot;goblin grunt&quot;,  &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]&#125;&#123;  &quot;name&quot;: &quot;goblin archer&quot;,  &quot;prototype&quot;: &quot;goblin grunt&quot;,  &quot;attacks&quot;: [&quot;short bow&quot;]&#125;\r\n由于弓箭手和术士都将 grunt 作为\r\n原型，我们就不需要在它们中重复血量，防御和弱点。\r\n我们为数据模型增加的逻辑超级简单——基本的单一委托——但已经成功摆脱了一堆冗余。\r\n有趣的事情是，我们没有更进一步，把哥布林委托的抽象原型设置成“基本哥布林”。\r\n相反，我们选择了最简单的哥布林，然后委托给它。\r\n在基于原型的系统中，对象可以克隆产生新对象是很自然的，\r\n我认为在这里也一样自然。这特别适合记录那些只有一处不同的实体的数据。\r\n想想 Boss 和其他独特的事物，它们通常是更加常见事物的重新定义，\r\n原型委托是定义它们的好方法。\r\n断头魔剑，就是一把拥有加成的长剑，可以像下面这样表示：\r\n12345&#123;  &quot;name&quot;: &quot;Sword of Head-Detaching&quot;,  &quot;prototype&quot;: &quot;longsword&quot;,  &quot;damageBonus&quot;: &quot;20&quot;&#125;\r\n只需在游戏引擎上多花点时间，你就能让设计者更加方便地添加不同的武器和怪物，而增加的这些丰富度能够取悦玩家。\r\n单例模式\r\n设计模式 像这样描述单例模式：\r\n\r\n保证一个类只有一个实例，并且提供了访问该实例的全局访问点。\r\n\r\n我们从“并且”那里将句子分为两部分，分别进行考虑。\r\n保证一个类只有一个实例\r\n有时候，如果类存在多个实例就不能正确的运行。\r\n通常发生在类与保存全局状态的外部系统互动时。\r\n考虑封装文件系统的 API 类。\r\n因为文件操作需要一段时间完成，所以类使用异步操作。\r\n这就意味着可以同时运行多个操作，必须让它们相互协调。\r\n如果一个操作创建文件，另一个操作删除同一文件，封装器类需要同时考虑，保证它们没有相互妨碍。\r\n为了实现这点，对我们封装器类的调用必须接触之前的每个操作。\r\n如果用户可以自由地创建类的实例，这个实例就无法知道另一实例之前的操作。\r\n而单例模式提供的构建类的方式，在编译时保证类只有单一实例。\r\n提供了访问该实例的全局访问点\r\n游戏中的不同系统都会使用文件系统封装类：日志，内容加载，游戏状态保存，等等。\r\n如果这些系统不能创建文件系统封装类的实例，它们如何访问该实例呢？\r\n单例为这点也提供了解决方案。\r\n除了创建单一实例以外，它也提供了一种获得它的全局方法。\r\n使用这种范式，无论何处何人都可以访问实例。\r\n综合起来，经典的实现方案如下：\r\n12345678910111213class FileSystem &#123;public:  static FileSystem&amp; instance() &#123;    // 惰性初始化    if (instance_ == NULL) instance_ = new FileSystem();    return *instance_;  &#125;private:  FileSystem() &#123;&#125;  static FileSystem* instance_;&#125;;\r\n静态的instance_成员保存了一个类的实例，\r\n私有的构造器保证了它是唯一的。\r\n公开的静态方法instance()让任何地方的代码都能访问实例。\r\n在首次被请求时，它同样负责惰性实例化该单例。\r\n现代的实现方案看起来是这样的：\r\n12345678910class FileSystem &#123;public:  static FileSystem&amp; instance() &#123;    static FileSystem *instance = new FileSystem();    return *instance;  &#125;private:  FileSystem() &#123;&#125;&#125;;\r\n哪怕是在多线程情况下，C++11 标准也保证了本地静态变量只会初始化一次，\r\n因此，假设你有一个现代\r\nC++编译器，这段代码是线程安全的，而前面的那个例子不是。\r\nC\r\nDouble Check 的懒汉模式\r\n123456789101112131415public sealed class Singleton &#123;    private static volatile Singleton _instance;    private static readonly object _lockObject = new Object();    public static Singleton Instance &#123;        get &#123;            if (_instance == null) &#123;                lock (_lockObject) &#123;                    if (_instance == null) &#123; _instance = new Singleton(); &#125;                &#125;            &#125;            return _instance;        &#125;    &#125;&#125;\r\nLazy&lt;T&gt;的懒汉模式\r\n123456789public class LazySingleton &#123;    private static readonly Lazy&lt;LazySingleton&gt; _instance = new Lazy&lt;LazySingleton&gt;(() =&gt; new LazySingleton());    public static LazySingleton Instance &#123;        get &#123; return _instance.Value; &#125;    &#125;    private LazySingleton() &#123; &#125;&#125;\r\nLazy\r\nthread-safe Singleton using LazyT (programming-books.io)\r\n\r\n.Net 4.0 type Lazy guarantees thread-safe object initialization, so\r\nthis type could be used to make Singletons.\r\nUsing Lazy&lt;T&gt; will make sure that the object is\r\nonly instantiated when it is used somewhere in the calling code.\r\n\r\n单例模式的弊端\r\n状态模式\r\n我们用状态模式来解决繁复状态切换的代码，这种模式与状态机的构造紧密相连。\r\nReference\r\n\r\n游戏编程模式 (tkchu.me)\r\n设计模式\r\n| 菜鸟教程 (runoob.com)\r\n\r\n","slug":"Dev/Theory/设计模式在游戏中的实践","date":"2023-02-02T04:23:23.000Z","categories_index":"Theroy","tags_index":"Theroy","author_index":"JBR_Bunjie"},{"id":"bde1cebd8cf0309ead488efbe937c7e3","title":"龙书 Chapter0. 序章项目的运行","content":"龙书 Chapter0.\r\n序章项目的运行\r\nIntroduction\r\nto 3D Game Programming with DirectX 12\r\n一书学习记录(第一个例子编译错误)_direct3d'&amp;' 需要左值_whoispo\r\n的博客-CSDN 博客\r\nDX12\r\n龙书之旅（一、前言） - 知乎 (zhihu.com)\r\n","slug":"Language Learning/HLSL/龙书Chapter0","date":"2023-01-02T04:23:23.000Z","categories_index":"Language Learning,HLSL","tags_index":"Language Learning,HLSL","author_index":"JBR_Bunjie"},{"id":"bcde879fe9c2f7bb644082a93fd7a2fd","title":"Vim 9. The Rest","content":"Vim 9. The Rest\r\n比较文件差异——Show difference\r\n本质是在 vim 中新开一个窗口，\r\nTo show differences between files execute below command −\r\n123$ vimdiff &lt;file&gt; &lt;file&gt;OR$ vim –d &lt;file&gt; &lt;file&gt;\r\nvim 内比较\r\n12:diffsplit filename # 横向窗口:vert :diffsplit filename # 纵向窗口\r\n相同的部分无颜色表示，不同的部分会进行高亮\r\n修改处跳转——Jump to previous\r\nchange\r\nIn diff window, execute following command to jump to previous change\r\n−\r\n1[c\r\nJump to next change\r\nIn diff window, execute following command to jump to next change\r\n−\r\n1]c\r\nvim 内进行文件浏览\r\n:Ex 开启目录浏览器，可以浏览当前目录下的所有文件，并可以选择 :Sex\r\n水平分割当前窗口，并在一个窗口中开启目录浏览器\r\nvim 与 shell 切换\r\n:shell 可以在不关闭 vi 的情况下切换到 shell 命令行 exit 从 shell 回到\r\nvi\r\n","slug":"Deploy/vim/09.rest","date":"2022-12-23T04:23:27.000Z","categories_index":"Vim,Linux","tags_index":"Linux,Vim","author_index":"JBR_Bunjie"},{"id":"38657bb576422385082819b144ae3e3f","title":"Vim 8. Working With Multiple Things","content":"Vim 8. Working With\r\nMultiple Things\r\n打开新文件——Multiple files\r\nLet us suppose you are editing a file and you want to open another\r\nfile in same Vim session.\r\nIn that case, you can use Vim’s edit command. Below table shows these\r\ncommands\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n:e\r\nLoad new file in buffer for editing\r\n\r\n\r\n:edit\r\nSame as :e\r\n\r\n\r\n:e \r\nList the files for editing from current directory\r\n\r\n\r\n:edit \r\nSame as :e \r\n\r\n\r\n\r\n打开新文件并保持旧文件——Multiple\r\nbuffers\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n:badd \r\nAdd file into new buffer\r\n\r\n\r\n:bN\r\nSwitch to Nth buffer. For instance to switch to 3rd buffer use\r\n:b3\r\n\r\n\r\n:bnext\r\nMove to the next buffer in buffer list\r\n\r\n\r\n:bprevious\r\nMove to the previous buffer in buffer list\r\n\r\n\r\n:buffers\r\nList all buffers\r\n\r\n\r\n:bfirst\r\nMove to the first buffer\r\n\r\n\r\n:blast\r\nMove to the last buffer\r\n\r\n\r\n:ball\r\nLoad all buffers\r\n\r\n\r\n\r\n在我们可以使用\r\n1:buffers 或 :ls\r\n来查看我们所打开的全部文件\r\n多标签页——Multiple tabs\r\nLike other editors we can also open multiple tabs in Vim. Below table\r\ndescribes tab related commands −\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n:tabnew\r\nOpen new tab\r\n\r\n\r\n:tabnew \r\nOpen new file in tab\r\n\r\n\r\n:tabclose(acronym: :tabc)\r\nClose current tab\r\n\r\n\r\n:tabo\r\nclose all the tabs except the first one\r\n\r\n\r\n:tabnext\r\nMove to the next tab\r\n\r\n\r\n:tabprevious\r\nMove to the previous tab\r\n\r\n\r\n:tabfirst\r\nMove to the first tab\r\n\r\n\r\n:tablast\r\nMove to the last tab\r\n\r\n\r\n\r\n多窗口：Multiple windows\r\nIn Vim we can create new window using following commands −\r\n开启多窗\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n:new \r\nOpen file in new window(横向)\r\n\r\n\r\n:split+窗口名(acronym:sp+窗口名)\r\n横向切割窗口\r\n\r\n\r\n:vsplit+窗口名(acronym:vsp+窗口名)\r\n纵向切割窗口\r\n\r\n\r\n\r\n窗口切换\r\n\r\n:ctrl+w+h/j/k/l 左下上右切换窗口\r\n快速双击 ctrl+w 依次切换窗口\r\n\r\n窗口大小调整\r\n纵向调整\r\n\r\n\r\n\r\ncommand\r\ndescription\r\n\r\n\r\n\r\n\r\n:ctrl+w +\r\n纵向扩大（行数增加）\r\n\r\n\r\n:ctrl+w -\r\n纵向缩小 （行数减少）\r\n\r\n\r\n:res(ize) num\r\n把当前窗口显示行数调整为 num 行\r\n\r\n\r\n:res(ize)+num\r\n把当前窗口高度增加 num 行\r\n\r\n\r\n:res(ize)-num\r\n把当前窗口高度减少 num 行\r\n\r\n\r\n\r\n横向调整\r\n\r\n\r\n\r\ncommand\r\ndescription\r\n\r\n\r\n\r\n\r\n:vertical res(ize) num\r\n指定当前窗口为 num 列\r\n\r\n\r\n:vertical res(ize)+num\r\n把当前窗口增加 num 列\r\n\r\n\r\n:vertical res(ize)-num\r\n把当前窗口减少 num 列\r\n\r\n\r\n\r\n关闭多窗\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n:close/:q!\r\n关闭多窗口使用 close\r\n只是暂时关闭窗口，其内容还在缓存中，只有使用 q!等才能真正退出。\r\n\r\n\r\n\r\n","slug":"Deploy/vim/08.multiplefiles","date":"2022-12-23T04:23:26.000Z","categories_index":"Vim,Linux","tags_index":"Linux,Vim","author_index":"JBR_Bunjie"},{"id":"2e0713a54a3b57174efc77b214714bd2","title":"Vim 7. Search","content":"Vim 7. Search\r\n进行相关设置——Search\r\nrelated settings\r\n启用增量搜索——To perform incremental search execute following command\r\n−\r\n1:set incsearch\r\n启用内容高亮——To highlight search execute following command −\r\n1:set hlsearch\r\nThis command will automatically highlight current matches. For\r\ninstance in below image fox word is highlighted −\r\nTo disable incremental and highlighted search execute following\r\ncommands −\r\n12:set noincsearch:set nohlsearch\r\n当前文件搜索——Search in\r\ncurrent file\r\n向后搜索——Search in forward\r\ndirection\r\nUse following commands to perform search in forward direction −\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n/\r\nSearch expression in forward direction\r\n\r\n\r\nn\r\nFind next occurrence. This is same and find next\r\n\r\n\r\nN\r\nFind previous occurrence. This is same as find previous\r\n\r\n\r\n//\r\nRepeat previous forward search\r\n\r\n\r\n\r\n向前搜索——Search in\r\nbackward direction\r\nUse following commands to perform search in backward direction\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n?\r\nSearch expression in backward direction\r\n\r\n\r\nn\r\nFind previous occurrence. This is same and find previous\r\n\r\n\r\nN\r\nFind next occurrence. This is same as find next\r\n\r\n\r\n??\r\nRepeat previous backward search\r\n\r\n\r\n\r\n指针后搜索——Search word\r\nunder cursor\r\nPlace cursor under any word and execute following commands to perform\r\nsearch operation −\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n*\r\nSearch next occurrence of current word\r\n\r\n\r\n#\r\nSearch previous occurrence of current word\r\n\r\n\r\n\r\n多文件搜索——Search in\r\nmultiple files\r\nUsing vimgrep command we can search  in multiple files.\r\nFor instance below command searches string - Jarvis in\r\nall text files.\r\n1:vimgrep Jarvis *.txt\r\nNote that to go to next and previous occurrence we have to use\r\nfollowing commands −\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n:cn\r\nGo to next occurrence of expression\r\n\r\n\r\n:cN\r\nGo to previous occurrence of expression\r\n\r\n\r\n\r\n","slug":"Deploy/vim/07.Search","date":"2022-12-23T04:23:25.000Z","categories_index":"Vim,Linux","tags_index":"Linux,Vim","author_index":"JBR_Bunjie"},{"id":"d0f573d5ece004aa9f60d986d26310d5","title":"WSA Install third-party apps!","content":"WSA Install third-party apps\r\n第 0\r\n步：确保已正确将 adb 命令加入到系统的环境变量\r\n执行下面的命令能看到 adb 版本号则表示 ok\r\n如有错误，请检查环境变量是否配置正确\r\n1adb version\r\n第 1 步：连接 WSA\r\n1adb connect 127.0.0.1:58526\r\n其中 127.0.0.1:58526 是刚才在 WSA 设置项中看到的 IP\r\n第 2 步：安装 APK\r\n连接成功之后，就能用下面命令来安装 APK 了\r\n123456789adb install &#123;你的APK文件完整路径&#125;# 注意 .apk 的路径最好无中文且无空格，否则需要用英文双引号包裹。# 可在资源管理器上右键点击 apk 文件选「复制文件地址」获取完整路径adb install d:\\download\\apk\\weixin.apk#下面是例子：adb install &quot;d:\\下载\\异次元 iPlaySoft.com\\qq.apk&quot;\r\n安装完成后，在 Windows 开始菜单的“所有应用”里就能找到你安装的 Android\r\n应用\r\n","slug":"Deploy/Windows/WSA install third party apk","date":"2022-12-23T04:23:24.000Z","categories_index":"Delopy and Installation","tags_index":"Windows,WSA,Android","author_index":"JBR_Bunjie"},{"id":"8a564cf263c32b7750d24416c76931ac","title":"Vim 6. Navigation","content":"Vim 6. Navigation\r\n移动光标\r\n\r\n\r\n\r\n具体按键\r\n描述 Description\r\n\r\n\r\n\r\n\r\nh\r\n左移 Move cursor to left by one position\r\n\r\n\r\nj\r\n下移 Move cursor to downward by one position\r\n\r\n\r\nk\r\n上移 Move cursor to upward direction by one line\r\n\r\n\r\nl\r\n右移 Move cursor to right direction by one line\r\n\r\n\r\n\r\n可以通过数字键+移动键实现快速移动，如向下移动十行：\r\nTo perform multi-position navigation use number with these commands.\r\nFor instance to navigate cursor 10 line below from current line, execute\r\nfollowing command −\r\n110j # 先按数字键1 0 后按 j\r\n有一些特殊\"数字\"： | command | Description | | ---- |\r\n------------------------------------------------- | | 0\r\n| Move cursor to the beginning of current line | | $ |\r\nMove cursor to the end of current line | | Ctrl + f |\r\nScroll down entire page | | Ctrl + b | Scroll up entire\r\npage |\r\nNavigate to lines\r\nBelow command can be used to navigate to specific line −\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\n:[lineNumber]\r\nJump to the certain line\r\n\r\n\r\n:0\r\nJump to the start of file\r\n\r\n\r\n:$\r\nJump to the end of file\r\n\r\n\r\n\r\nWord navigation\r\nWe can use following commands for word navigation −\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\nw\r\nMove cursor to the beginning of the next word\r\n\r\n\r\ne\r\nMove cursor to the end of the current word\r\n\r\n\r\nb\r\nMove cursor to the beginning of the previous word\r\n\r\n\r\n\r\nUsing jumps\r\nVim keeps track of your navigation using a jump list. You can go\r\nbackward and forward through that list.\r\nThe jump list keeps tracks of all the places you’ve been to by\r\ntracking file name, line number and column number.\r\nTo view jump list execute following command −\r\n1:jumps\r\nFollowing command are based on jump list −\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\nCtrl + o\r\nJump back to the previous position\r\n\r\n\r\nCtrl + i\r\nJump to the next position\r\n\r\n\r\n\r\n退出:jumps\r\n一般不要使用:q 作退出！很可能直接关闭文件！\r\n","slug":"Deploy/vim/06.navigation","date":"2022-12-23T04:23:24.000Z","categories_index":"Vim,Linux","tags_index":"Linux,Vim","author_index":"JBR_Bunjie"},{"id":"05224746dee6fcc8d8927349a6fd8d76","title":"To Finish List","content":"DTD\r\nDTD 简介 |\r\n菜鸟教程 (runoob.com)\r\nXML\r\nXML 简介 – 什么是\r\nXML？ | 菜鸟教程 (runoob.com)\r\nUptimebot\r\n网页监管工具：UptimeRobot: Free\r\nWebsite Monitoring Service\r\nAlgorithm\r\n模拟退火\r\n浅谈玄学算法——模拟退火 -\r\nM_sea 的博客 - 洛谷博客 (luogu.org)\r\n","slug":"TODOLIST","date":"2022-12-23T04:23:23.000Z","categories_index":"To Finish List","tags_index":"To Finish List","author_index":"JBR_Bunjie"},{"id":"2e7a3ae4090ee29ca9a2e76805bad9b3","title":"CRC Algorithm","content":"\r\n那简而言之就是 取首位 异或(首位为0 除数为0) 左移 上述三个步骤循环呗\r\n当左移后余数长度小于被除数时则取余 也可以这么理解吧\r\n当余数开头出现n个0的时候就可以全部消掉直到首位是1\r\n商补上n-1个0和一个1就可以了 继续异或运算嘛 我是看到有好几题余数开头俩0的\r\n分析看看\r\n\r\n模2除法(CRC校验码计算)\r\n鉴于网上的讲解自己好不容易才看懂…所以整理了一下,\r\n也方便大家能够理解\r\n模2加减法\r\n模2除法需要用到模2加减法,关于模2加减法,其实就是异或操作,规则如下:\r\n123456789101112//不需要考虑进位和借位0 ± 0 = 01 ± 1 = 00 ± 1 = 11 ± 0 = 1例: 1101 ± 1001 = 0100计算如下:\t\t  1 1 0 1 \t\t± 1 0 0 1 \t\t-----------\t\t  0 1 0 01234\r\n简记:同为0,异为1\r\n\r\n模2除法:\r\n规则:假设被除数X,和除数P,余数R\r\n\r\nX除以P(对X和P做模2加减法),当前X首位为1时,商1,为0时商0\r\n所得余数R去除首位(即左移一位):\r\n\r\n若R第一位为0,将其作为新的被除数,除以0,此时其首位为0,商即为0\r\n若R第一位为1,将其作为新的被除数,除以P,此时其首位为1,商即为1\r\n\r\n重复第2步直到R位数少于P位数\r\n\r\n\r\n例:1111000对除数1101做模2除法:\r\n先说结果:\r\n商1011余111\r\n整体运算\r\n12345678910111213141516      1 0 1 1     //商---------------1 1 1 1 0 0 0     //被除数,注意首位为11 1 0 1\t          //被除数首位为1,除以除数---------------  0 1 0 0 0 0     //余数去除首位,作为新的被除数  0 0 0 0         //被除数首位为0,除以0---------------    1 0 0 0 0     //余数去除首位,作为新的被除数    1 1 0 1       //被除数首位为1,除以除数  ---------------      1 0 1 0     //余数去除首位,作为新的被除数      1 1 0 1     //被除数首位为1,除以除数---------------        1 1 1     //余数,此时余数位数少于除数,不能继续除了123456789101112131415\r\n分步分析\r\n第一步(每一步其实都是模2加减法运算):\r\n1234567      1         //商-------------1 1 1 1 0 0 0   //被除数,注意首位为11 1 0 1\t        //除数-------------0 0 1 0 0 0 0   //余数,模2运算后结果123456\r\n\r\n商的第一位:被除数首位为1,商为1(只要被除数首位非0,商就是1)\r\n\r\n第二步:余数去除首位(左移一位),当第一位为0时,除以0;为1时,除以除数。\r\n1234567      1 0        //商---------------  0 1 0 0 0 0    //余数去除首位,作为新的被除数  0 0 0 0        //被除数首位为0,除以0---------------  0 1 0 0 0 0    //余数,模2运算后结果123456\r\n\r\n商的第二位:被除数首位为0,商为0(只要被除数首位是0商就是0)\r\n\r\n第三步\r\n1234567      1 0 1      //商----------------    1 0 0 0 0    //余数去除首位,作为新的被除数    1 1 0 1      //被除数首位为1,除以除数----------------    0 1 0 1 0    //余数,模2运算后结果123456\r\n\r\n商的第三位:被除数首位为1,商为1\r\n\r\n第四步\r\n12345678      1 0 1 1     //商----------------      1 0 1 0     //余数去除首位,作为新的被除数      1 1 0 1     //被除数首位为1,除以除数----------------      0 1 1 1     //余数,此时余数位数(这里的0要忽略掉,不参与下一轮,因为最上面的被除数后面      \t\t\t  //没有数可以给这里往后补一位了)少于除数位数,不能继续除了1234567\r\n\r\n商的第四位:被除数首位为1,商为1 此时不能继续做除法,计算结束\r\n\r\n得到最终结果:\r\n商1011余111\r\n\r\n前言\r\nCRC算法简介\r\nCRC计算\r\nCRC校验\r\nCRC计算的C语言实现\r\nCRC计算工具\r\n总结\r\n\r\n前言\r\n最近的工作中，要实现对通信数据的CRC计算，所以花了两天的时间好好研究了一下，周末有时间整理了一下笔记。\r\n一个完整的数据帧通常由以下部分构成：\r\n\r\n\r\nimg\r\n\r\n校验位是为了保证数据在传输过程中的完整性，采用一种指定的算法对原始数据进行计算，得出的一个校验值。接收方接收到数据时，采用同样的校验算法对原始数据进行计算，如果计算结果和接收到的校验值一致，说明数据校验正确，这一帧数据可以使用，如果不一致，说明传输过程中出现了差错，这一帧数据丢弃，请求重发。\r\n常用的校验算法有奇偶校验、校验和、CRC，还有LRC、BCC等不常用的校验算法。\r\n以串口通讯中的奇校验为例，如果数据中1的个数为奇数，则奇校验位0，否则为1。\r\n例如原始数据为：0001\r\n0011，数据中1的个数（或各位相加）为3，所以奇校验位为0。这种校验方法很简单，但这种校验方法有很大的误码率。假设由于传输过程中的干扰，接收端接收到的数据是0010\r\n0011，通过奇校验运算，得到奇校验位的值为0，虽然校验通过，但是数据已经发生了错误。\r\n\r\n\r\nimg\r\n\r\n校验和同理也会有类似的错误：\r\n\r\n\r\nimg\r\n\r\n一个好的校验校验方法，配合数字信号编码方式，如(差分)曼彻斯特编码，(不)归零码等对数据进行编码，可大大提高通信的健壮性和稳定性。例如以太网中使用的是CRC-32校验，曼彻斯特编码方式。本篇文章介绍CRC校验的原理和实现方法。\r\nCRC算法简介\r\n\r\n循环冗余校验（Cyclic Redundancy Check，\r\nCRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。\r\n\r\nCRC校验计算速度快，检错能力强，易于用编码器等硬件电路实现。从检错的正确率与速度、成本等方面，都比奇偶校验等校验方式具有优势。因而，CRC\r\n成为计算机信息通信领域最为普遍的校验方式。常见应用有以太网/USB通信，压缩解压，视频编码，图像存储，磁盘读写等。\r\nCRC参数模型\r\n不知道你是否遇到过这种情况，同样的CRC多项式，调用不同的CRC计算函数，得到的结果却不一样，而且和手算的结果也不一样，这就涉及到CRC的参数模型了。计算一个正确的CRC值，需要知道CRC的参数模型。\r\n一个完整的CRC参数模型应该包含以下信息：WIDTH，POLY，INIT，REFIN，REFOUT，XOROUT。\r\n\r\nNAME：参数模型名称。\r\nWIDTH：宽度，即生成的CRC数据位宽，如CRC-8，生成的CRC为8位\r\nPOLY：十六进制多项式，省略最高位1，如 x8 + x2 + x + 1，二进制为1\r\n0000 0111，省略最高位1，转换为十六进制为0x07。\r\nINIT：CRC初始值，和WIDTH位宽一致。\r\nREFIN：true或false，在进行计算之前，原始数据是否翻转，如原始数据：0x34\r\n= 0011 0100，如果REFIN为true，进行翻转之后为0010 1100 = 0x2c\r\nREFOUT：true或false，运算完成之后，得到的CRC值是否进行翻转，如计算得到的CRC值：0x97\r\n= 1001 0111，如果REFOUT为true，进行翻转之后为11101001 = 0xE9。\r\nXOROUT：计算结果与此参数进行异或运算后得到最终的CRC值，和WIDTH位宽一致。\r\n\r\n通常如果只给了一个多项式，其他的没有说明则：INIT=0x00，REFIN=false，REFOUT=false，XOROUT=0x00。\r\n常用的21个标准CRC参数模型：\r\n\r\n\r\nimg\r\n\r\nCRC校验在电子通信领域非常常用，可以说有通信存在的地方，就有CRC校验：\r\n\r\n美信(MAXIM)的芯片DS2401/DS18B20，都是使用的CRC-8/MAXIM模型\r\nSD卡或MMC使用的是CRC-7/MMC模型\r\nModbus通信使用的是CRC-16/MODBUS参数模型\r\nUSB协议中使用的CRC-5/USB和CRC-16/USB模型\r\nSTM32自带的硬件CRC计算模块使用的是CRC-32模型\r\n\r\n至于多项式的选择，初始值和异或值的选择，输入输出是否翻转，这就涉及到一定的编码和数学知识了。感兴趣的朋友，可以了解一下每个CRC模型各个参数的来源。至于每种参数模型的检错能力、重复率，需要专业的数学计算了，不在本文讨论的范畴内。\r\nCRC计算\r\n好了，了解了CRC参数模型知识，下面手算一个CRC值，来了解CRC计算的原理。\r\n问：原始数据：0x34，使用CRC-8/MAXIN参数模型，求CRC值？\r\n答：根据CRC参数模型表，得到CRC-8/MAXIN的参数如下：\r\n12345POLY = 0x31 = 0011 0001(最高位1已经省略)INIT = 0x00XOROUT = 0x00REFIN = TRUEREFOUT = TRUE\r\n有了上面的参数，这样计算条件才算完整，下面来实际计算：\r\n12345678910110.原始数据 = 0x34 = 0011 0100，多项式 = 0x31 = 1 0011 00011.INIT = 00，原始数据高8位和初始值进行异或运算保持不变。2.REFIN为TRUE，需要先对原始数据进行翻转：0011 0100 &gt; 0010 11003.原始数据左移8位，即后面补8个0：0010 1100 0000 00004.把处理之后的数据和多项式进行模2除法，求得余数：原始数据：0010 1100 0000 0000 = 10 1100 0000 0000多项式：1 0011 0001模2除法取余数低8位：1111 10115.与XOROUT进行异或，1111 1011 xor 0000 0000 = 1111 1011 6.因为REFOUT为TRUE，对结果进行翻转得到最终的CRC-8值：1101 1111 = 0xDF7.数据+CRC：0011 0100 1101 1111 = 34DF，相当于原始数据左移8位+余数。\r\n模2除法求余数：\r\n\r\n\r\nimg\r\n\r\n验证手算结果：\r\n\r\n\r\nimg\r\n\r\n可以看出是一致的，当你手算的结果和工具计算结果不一致时，可以看看INIT，XOROUT，REFINT，REFOUT这些参数是否一致，有1个参数不对，计算出的CRC结果都不一样。\r\nCRC校验\r\n上面通过笔算的方式，讲解了CRC计算的原理，下面来介绍一下如何进行校验。\r\n按照上面CRC计算的结果，最终的数据帧：0011 0100 1101 1111 =\r\n34DF，前8位0011 0100是原始数据，后8位1101 1111 是 CRC结果。\r\n接收端的校验有两种方式，一种是和CRC计算一样，在本地把接收到的数据和CRC分离，然后在本地对数据进行CRC运算，得到的CRC值和接收到的CRC进行比较，如果一致，说明数据接收正确，如果不一致，说明数据有错误。\r\n另一种方法是把整个数据帧进行CRC运算，因为是数据帧相当于把原始数据左移8位，然后加上余数，如果直接对整个数据帧进行CRC运算（除以多项式），那么余数应该为0，如果不为0说明数据出错。\r\n\r\n\r\nimg\r\n\r\n而且，不同位出错，余数也不同，可以证明，余数与出错位数的对应关系只与CRC参数模型有关，而与原始数据无关。\r\nCRC计算的C语言实现\r\n无论是用C还是其他语言，实现方法网上很多，这里我找了一个基于C语言的CRC计算库，里面包含了常用的21个CRC参数模型计算函数，可以直接使用，只有crcLib.c和crcLib.h两个文件。\r\nGitHub地址：https://github.com/whik/crc-lib-c\r\n使用方法非常简单：\r\n12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;crcLib.h&quot;int main()&#123;    uint8_t LENGTH = 10;    uint8_t data[LENGTH];    uint8_t crc;    for(int i = 0; i &lt; LENGTH; i++)    &#123;        data[i] = i*5;        printf(&quot;%02x &quot;, data[i]);    &#125;    printf(&quot;\\n&quot;);    crc = crc8_maxim(data, LENGTH);    printf(&quot;CRC-8/MAXIM:%02x\\n&quot;, crc);    return 0;&#125;\r\n计算结果：\r\n\r\n\r\nimg\r\n\r\nCRC计算工具\r\n下面这几款工具都可以自定义CRC算法模型，而且都有标准CRC模型可供选择。如果自己用C语言或者Verilog实现校验算法时，非常适合作为标准答案进行验证。\r\n\r\n在线计算：http://www.ip33.com/crc.html\r\n离线计算工具：CRC_Calc v0.1.exe或者GCRC.exe\r\n\r\n格西CRC计算器：\r\n\r\n\r\nimg\r\n\r\n总结\r\nCRC校验并不能100%的检查出数据的错误，非常低的概率会出现CRC校验正确但数据中有错误位的情况。这和CRC的位数，多项式的选择等等有很大的关系，所以在实际使用中尽量选择标准CRC参数模型，这些多项式参数都是经过理论计算得出的，可以提高CRC的检错能力。CRC校验可以检错，也可以纠正单一比特的错误，你知道纠错的原理吗？\r\n参考资料\r\n\r\nhttps://www.cnblogs.com/liushui-sky/p/9962123.html\r\nhttps://segmentfault.com/a/1190000018094567!\r\n\r\n","slug":"Algorithm/CRC、LRC、BCC校验与模二运算","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"CRC,Algorithm","author_index":"JBR_Bunjie"},{"id":"413173748dc9f0bf852352ce35bf92b1","title":"Catalan Number","content":"wikipedia-en: Catalan\r\nnumber - Wikipedia\r\nwikipedia-cn:卡塔兰数 -\r\n维基百科，自由的百科全书 (wikipedia.org)\r\n强烈推荐这篇博客：卡特兰(Catalan)数入门详解\r\n- Morning_Glory - 博客园 (cnblogs.com)\r\n\r\nCatalan Number\r\n\r\nIn combinatorial\r\nmathematics, the Catalan numbers are a sequence of natural numbers\r\nthat occur in various counting problems,\r\noften involving recursively defined\r\nobjects. They are named after the French-Belgian mathematician Eugène\r\nCharles Catalan (1814–1894).\r\nThe first Catalan numbers for n = 0, 1, 2, 3, ... are\r\n​ 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, ...\r\n(sequence A000108 in the OEIS).\r\n\r\n意义？\r\n\r\n卡特兰数是一个在组合数学里经常出现的一个数列，它并没有一个具体的意义，却是一个十分常见的数学规律\r\n\r\n也就是说：只要我们能在实际解决问题的过程中，发现当前问题符合Catalan\r\nNumber的定义(公式)，就可以直接利用Cantanlan的相关公式来解决\r\n定义：\r\n设h(n)为catalan数的第n项，令h(0)=1,h(1)=1，catalan数满足递推式：\r\nh(n) = h(0) * h(n-1) + h(1) * h(n-2) + ... + h(n-1) * h(0) (n≥2)\r\n容易计算的推导公式：\r\n可以看英文维基的推导过程\r\nThe nth Catalan number can be expressed directly in terms of\r\nbinomial\r\ncoefficients by\r\n\r\n(公式中的括号表达式请勿用组合的方式来计算)\r\nAn alternative expression for Cn is\r\n\r\nusage\r\n例题1：\r\n题目：2N个人排队买电影票，N个人持5元买票，N个人持10元买票。售票处在售票前只有票没有钱，票价5元，问有多少种排队方式能让2N个人顺利买票，并且输出所有排队队列（不会因为找钱问题）\r\n题解：设x为当前已购票人群中持五元的人数，设y为当前已购票人群中持十元的人数\r\n则易知，任何时候都应有x &gt;= y\r\n将本题转换为坐标系上的问题\r\n则有：\r\n\r\n\r\nimage-20220126215930311\r\n\r\n易知，所有在直线y = x之下的路径都是合法路径，而所有与y = x +\r\n1有交集的路径都是非法路径\r\n我们所需要做的，只是从所有的可能路径——C(2n,\r\nn)中，取出非法路径即可\r\n将所有经过y = x + 1的非法路径(因为所有路径仍然都是要到达(n,n)的)\r\n对直线y = x + 1进行对称\r\n此时所有路径都会到达点 (n - 1, n + 1)\r\n故易知，所有非法路径总数：C(2n, n-1)\r\n故最终结果为：C(2n, n) - C(2n, n-1)\r\n由此题我们可以看出Catalan\r\nNumber类题目的相关特征——使用高度相关的两种数据进行先后排序\r\n例题2：\r\n题目：电影院卖电影票，但是没有零钱找，票价一张 5 元，买票的人为 n\r\n个持有 5 元，m个持 有 10\r\n元，求解出可能的买票序列的个数，使得电影院能够将票卖完。\r\n测试数据：\r\n\r\n\r\nn=3, m=3\r\n\r\n输出：180\r\n\r\nn=5, m=3\r\n\r\n输出：20160\r\n\r\nn=100, m=100\r\n输出：7808493736285054490617457563685000616783524531556170923710322111330291583796072702181230534772124989150269427118016226042154879111313238663979471534186434961519434230403597200370267217266558867539125388517366666256080507202260345081955685568391820824161596607976035333269564672318518060023284166918774048734879105185187102720000000000000000000000000000000000000000000000000\r\n\r\n\r\n解法：和例题一几乎一致，但是具体公式不再能直接套用\r\n我们仍有相同含义的x(x - n - 5元)与y(y - m -\r\n10元)，但是具体公式开始不同\r\n其中，所有可能的顺序为：C(m+n, n)\r\n不合法的路径仍与y = x + 1有关，但是最终的非法内容有：C(m + n,\r\nm-1)\r\n故最终有：C(m + n, n) - C(m + n, m - 1)\r\n是不是有点疑惑？怎么算出来和结果不一样，好像多除以了(m! * n!)？\r\n若是将每个人视为相同的人，是无序的话，结果解释上述表达式，但是实际上每个人都不尽相同，为了保证顺序，还需要乘以(m!\r\n* n!)\r\n(组合方式已定，每组内自由排列)，最终可得到答案(m\r\n+ n)! * (n - m + 1)/(n +\r\n1)，事实上，上一题也应该作这样子的额外处理才对\r\n更多典例\r\n1. 出栈次序\r\n一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?\r\n2. 01序列\r\n给出一个n，要求一个长度为2n的01序列，使得序列的任意前缀中1的个数不少于0的个数，\r\n有多少个不同的01序列? 以下为长度为6的序列: 111000 101100 101010 110010\r\n110100\r\n3. ‘+1’ ‘-1’序列\r\nn个+1和n个-1构成的2n项\r\na1,a2,⋅⋅⋅,a2na1,a2,⋅⋅⋅,a2n，其部分和满足非负性质，即a1+a2+⋅⋅⋅+ak&gt;=0a1+a2+⋅⋅⋅+ak&gt;=0，(k=1,2,···,2n)\r\n，有多少个不同的此序列?\r\n4. 括号序列\r\nn对括号有多少种匹配方式？\r\n5. 找零问题\r\n2n个人要买票价为五元的电影票，每人只买一张，但是售票员没有钱找零。其中，n个人持有五元，另外n个人持有十元，问在不发生找零困难的情况下，有多少种排队方法？\r\n6. 矩阵链乘\r\nP=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？\r\n7. 二叉树计数\r\n有n个节点构成的二叉树（非叶子节点都有2个儿子），共有多少种情形？\r\n有n+1个叶子的二叉树的个数？\r\n8. 凸多边形划分\r\n在一个n边形中，通过不相交于n边形内部的对角线，把n边形拆分为若干个三角形，问有多少种拆分方案？\r\n9. 圆上n条线段\r\n在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线段不相交的方法数？\r\n10. 单调路径\r\n一位大城市的律师在他住所以北n个街区和以东n个街区处工作，每天他走2n个街区去上班。如果他从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？\r\n11. 填充阶梯图形\r\n用n个长方形填充一个高度为n的阶梯状图形的方法个数？\r\n12. 摞碗问题\r\n饭后，姐姐洗碗，妹妹把姐姐洗过的碗一个一个放进碗橱摞成一摞。一共有n个不同的碗，洗前也是摞成一摞的，也许因为小妹贪玩而使碗拿进碗橱不及时，姐姐则把洗过的碗摞在旁边，问：小妹摞起的碗有多少种可能的方式？\r\n13. 汽车胡同加油问题\r\n一个汽车队在狭窄的路面上行驶，不得超车，但可以进入一个死胡同去加油，然后再插队行驶，共有n辆汽车，问共有多少种不同的方式使得车队开出城去？\r\n14. 还书借书问题\r\n在图书馆一共2n个人在排队，n个还《面试宝典》一书，n个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数\r\n15. 高矮排队问题\r\n2n个高矮不同的人,排成两排,每排必须是从矮到高排列,而且第二排比对应的第一排的人高,问排列方式有多少种?\r\n","slug":"Algorithm/Catalan number","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,String Processing","author_index":"JBR_Bunjie"},{"id":"4bbde60d3dafb255adad1c9293392efa","title":"全排列","content":"Permutations - 全排列\r\n顾名思义，就是找出当前元素所有可行的序列\r\n一个朴素的思想是递归，这种方式简单但并不高效快捷\r\n以两个示例来进行算法说明：\r\nExample1:\r\n\r\n实验五 数据输出\r\n实验准备 理解数据输入、输出的技巧。\r\n实验目的 理解算法设计的数学基本思想，理解算法程序化实现的技巧。\r\n实验过程 输出1,2,3,4,5,6这六个元素的所有全排列。\r\n\r\n12345678910111213141516def permutations(arr: list, position: int, end: int):    if position == end:        # 完成一次排列，输出结果，返回上层        print(arr)    else:        # 采用递归解决问题        for index in range(position, end):            # 每进入一次函数，都会在当前位置山建立循环，这个循环会将所有的锁具都和当前数进行一次交换            # 由于每单次循环都会将数据列表重置还原，所以不会对下一次交换产生影响导致重复            # 故从当前的position开始，与end之前的所有数据交换次序，就可以得到所有内容            arr[index], arr[position] = arr[position], arr[index]            permutations(arr, position + 1, end)            arr[index], arr[position] = arr[position], arr[index]  # 还原到交换前的状态，为了进行下一次交换permutations(arr, 0, len(arr))print(&quot;共720条数据&quot;)  # 6*5*4*3*2*1 == 720\r\nExample2: 46. 全排列 -\r\n力扣（LeetCode） (leetcode-cn.com)\r\n12345678910111213141516class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        self.result = []        self.generatation(nums, 0, len(nums))        return self.result    def generatation(self,nums, start, end):        if start == end:            # print(nums)            self.result.append([t for t in nums])            return                for i in range(start, end):            nums[i], nums[start] = nums[start], nums[i]            self.generatation(nums, start+1,end)            nums[start], nums[i] = nums[i], nums[start]\r\n1.6\r\n字符串的全排列 | 编程之法：面试和算法心得 (gitbooks.io)\r\n","slug":"Algorithm/Permutations","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"d42b57b5bace0bb67392a01a7601ad24","title":"Dijkstra Algorithm","content":"Dijkstra 算法详解\r\n概述\r\nDijkstra 算法是求一个图中一个点到其他所有点的最短路径的算法\r\nDijkstra\r\n算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度\r\nO(n2)\r\n\r\n主要行为\r\n每次从「未求出最短路径的点」中 取出 距离距离起点\r\n最小路径的点，以这个点为桥梁 刷新「未求出最短路径的点」的距离\r\n图解案例分析\r\n题要\r\n以 A 点为顶点，求到其他点的最短路径。\r\n\r\n\r\nimg\r\n\r\n邻接矩阵图\r\n12345int[][] graph = new int[][]{{0 , 2, ∞, 6}{2 , 0, 3, 2}{∞ , 3, 0, 2}{6 , 2, 2, 0}};\r\n算法过程\r\nresult：已求出 最小路径的顶点 notFound：未求出\r\n最小路径的顶点，里面的值是 到起点的距离 每次从 「未求出最短路径的点」中\r\n取出 距离距离起点 最近的点，以这个点为桥梁\r\n刷新「未求出最短路径的点」的距离\r\n初始，result={A(0)} 中只有起点 A，notFound={B(2),C(∞),D(6)} 中是除了\r\nA 点的其他点，里面的值是到起点的距离（例如 B(2) 代表 B点到起点的距离为\r\n2）\r\n\r\n\r\nimg\r\n\r\n然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 B(2)\r\n，然后通过 B(2) 为桥梁 刷新「未求出最短路径的点」的距离\r\n取出 最短路径的点： 从「未求出最短路径的点」notFound 中取出\r\n最短路径的点 B(2)，放入结果 result 中，结果如下：\r\n「未求出最短路径点」 notFound={C(∞),D(6)}，「已求出最短路径的点\r\n」result={A(0),B(2)}\r\n刷新距离： 通过 B(2) 为桥梁，刷新距离。\r\n例如 AD = 6 &lt; AB + BD = 4 以 B(2)\r\n为桥梁的距离更短，就刷新「未求出最短路径点」D(6) 的距离为 D(4)\r\nnotFound={C(∞),D(4)}\r\n同理刷新 C(∞) 的距离为 C(5) ，最后结果如下：\r\n「未求出最短路径点」 notFound={C(5),D(4)}\r\n，「已求出最短路径的点」result={A(0),B(2)}\r\n\r\n\r\nimg\r\n\r\n然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 D(4)\r\n，然后通过 D(4) 为桥梁 刷新「未求出最短路径的点」的距离\r\n同理，最后结果如下：\r\n「未求出最短路径点」 notFound={C(5)}\r\n，「已求出最短路径的点」result={A(0),B(2),D(4)}\r\n\r\n\r\nimg\r\n\r\n然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 C(5)\r\n，算法结束\r\nresult={A(0),B(2),D(4),C(5)} 就是最终所求的 最短距离\r\n\r\n\r\nimg\r\n\r\n\r\n代码\r\n\r\n这里使用 -1 表无穷大，下面是 Java 代码和测试案例\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Dijkstra {    public static int[] dijkstra(int[][] graph,int startVertex){        //初始化 以求出最短路径的点 result[]        int length = graph.length;        int[] result = new int[length];        for (int i = 0; i &lt; length; i++) {            result[i] = -1;        }        result[startVertex] = 0 ;                // 初始化 未求出最短路径的点 notFound[]        int[] notFound = new int[length];        for (int i = 0; i &lt; length; i++) {            notFound[i] = graph[startVertex][i];        }        notFound[startVertex] = -1;                // 开始 Dijkstra 算法        for (int i = 1; i &lt; length; i++) {            //1. 从「未求出最短路径的点」notFound 中取出 最短路径的点            //1.1 找到最短距离的点            int min = Integer.MAX_VALUE;            int minIndex = 0;            for (int j = 0; j &lt; length; j++) {                if (notFound[j] &gt; 0 &amp;&amp; notFound[j] &lt; min){                    min = notFound[j];                    minIndex = j;                }            }            //1.2 将最短距离的点 取出 放入结果中            result[minIndex] = min;            notFound[minIndex] = -1;                        //2. 刷新 「未求出最短距离的点」 notFound[] 中的距离            //2.1 遍历刚刚找到最短距离的点 (B) 的出度 (BA、BB、BC、BD)            for (int j = 0; j &lt; length; j++) {                // 出度可通行(例如 BD:graph[1][3]  &gt; 0)                // 出度点不能已经在结果集 result中(例如 D: result[3] == -1)                if (graph[minIndex][j] &gt; 0                &amp;&amp; result[j] == -1){                    int newDistance = result[minIndex] + graph[minIndex][j];                    //通过 B 为桥梁，刷新距离                    //（比如`AD = 6 &lt; AB + BD = 4` 就刷新距离）（ -1 代表无限大）                    if (newDistance &lt; notFound[j] || notFound[j]==-1){                        notFound[j] = newDistance;                    }                }            }        }        return result;    }    /** 测试案例 */    public static void main(String[] args) {        char[] vertices = new char[]{'A','B','C','D'};        int[][] graph = new int[][]{            {0, 2, -1, 6},             {2, 0, 3, 2},             {-1, 3, 0, 2},             {6, 2, 2, 0}        };        int[] dijkstra = dijkstra(graph, 0);        for (int i : dijkstra) {            System.out.println(i);        }    }}\r\n测试结果 12340254 Dijkstra算法详解 通俗易懂\r\n- 知乎 (zhihu.com)\r\n另题：\r\n\r\n\r\nimg\r\n\r\n","slug":"Algorithm/Dijkstra","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Shortest Path Algorithm","author_index":"JBR_Bunjie"},{"id":"7dbcf1e35df66bdccacdaed2ecd943d3","title":"利用递归、无循环地打印数组","content":"Reverse Output Without Cycle\r\n描述：不用循环，不逐一赋值地把一个数组逆序输出\r\n循环 -&gt; 递归；即用递归去承担原本循环的工作\r\n即：\r\n123456void Print(int[] arr, int len) &#123;    if (len &gt; 0) &#123;        Console.printline(arr[len-1] + &quot;\\n&quot;);        Print(arr, len - 1);    &#125;&#125;\r\n","slug":"Algorithm/ReverseOutputWithoutCycle","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"9fd0e4d3dba46b1add7af94a3f9b782a","title":"Sugiyama Algorithm","content":"划时代的自动布局算法：sugiyama算法\r\nsugiyama algorithm steps\r\nof the framework is to divide the task of drawing a graph into\r\nseveral subproblems, most of which closely resemble other well known\r\nproblems within computer science. That way one can use algorithms for\r\nthe similar problems to solve the Sugiyama subproblems and thereby\r\nsimplify the graph layout process. The different steps of the method are\r\nillustrated in figure 2. They are the following:\r\n\r\nCycle removal\r\n\r\nFirst the possibly cyclic graph must be made acyclic by removing\r\ncycles, done by reversing some edges.\r\n\r\nLayer assignment\r\n\r\nSecond, the vertices are assigned to layers and dummy vertices and\r\ndummy edges are introduced for every edge that spans over more than two\r\nlayers so as to create a proper layering [2], i.e. one where every edge\r\nhas its endpoints in adjacent layers.\r\n\r\nVertex ordering\r\n\r\nThird, the vertices are ordered within their layers to minimise edge\r\ncrossings.\r\n\r\nCoordinate assignment\r\n\r\nFourth and last, the vertices are assigned coordinates to create a\r\nbalanced graph.\r\nsugiyama barycenter算法内容\r\n两层间的情况：\r\nn层间的情况：\r\n纯python实现：\r\n1\r\n原论文地址：\r\nMethods for\r\nVisual Understanding of Hierarchical System Structures | IEEE Journals\r\n&amp; Magazine | IEEE Xplore\r\n所实现算法的仓库：\r\n视频教程：\r\n(40)\r\nHierarchical Drawings: Sugiyama Framework | Visualization of Graphs -\r\nLecture 8 - YouTube\r\nMore Resource:\r\n161388.pdf\r\n(chalmers.se)\r\n","slug":"Algorithm/Sugiyama","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Auto Layout","author_index":"JBR_Bunjie"},{"id":"991c84bc86acdc32c9243fba302e2655","title":"Hash Function","content":"\r\n序列化及其逆过程要解决的核心问题是\r\n实现相同的数据在不同格式间的转化；\r\n持久化要解决的则是内存中数据结构到硬盘上数据的转化\r\n，比如比特流或者xml格式的文件；分布式系统数据层都需要做持久化的工作，要么存到数据库中、要么直接以文件形式保存到硬盘上；\r\nmarshalling要解决的问题和serialization类似，但它更加关注网络间数据传输、另有种说法认为marshalling包括跟数据转化有关的codebase;\r\n\r\nFirst，What is Serialization\r\n引用C#文档中对serialization的定义：\r\n\r\nSerialization is the process of converting an object into a\r\nstream of bytes to store the object or transmit it to memory, a\r\ndatabase, or a file. Its main purpose is to save the state\r\nof an object in order to be able to recreate it when needed.\r\nThe reverse process is called deserialization.\r\nHow serialization works\r\nThis illustration shows the overall process of serialization:\r\n\r\n\r\nSerialization graphic\r\n\r\nThe object is serialized to a stream that carries the data. The\r\nstream may also have information about the object's type, such as its\r\nversion, culture, and assembly name. From that stream, the object can be\r\nstored in a database, a file, or memory.\r\nUses for serialization\r\nSerialization allows the developer to save the state of an object and\r\nre-create it as needed, providing storage of objects as well as data\r\nexchange. Through serialization, a developer can perform actions such\r\nas:\r\n\r\nSending the object to a remote application by using a web\r\nservice\r\nPassing an object from one domain to another\r\nPassing an object through a firewall as a JSON or XML string\r\nMaintaining security or user-specific information across\r\napplications\r\n\r\n\r\nSerialization\r\n(C#) | Microsoft Docs\r\n序列化(serialization)过程就是复杂数据在空间上的降维，最终结果是将一个数据结构或者包含对象状态的数据转换为一种可以在计算机文件系统或者内存缓存中被存储或者在计算机网络上被传输的数据格式，当它根据序列化格式被解析时，计算机就能生成一个语义上与原始数据相同的克隆。\r\n数据序列化不是数据持久化！数据序列化只是\r\n“可以作为数据持久化的中间过程” 而已\r\n数据复杂度的降维\r\n几个数据序列化标准介绍与比较\r\n【Netty入门】几种序列化协议的介绍_白夜行-CSDN博客_netty序列化协议\r\nMarshalling\r\nThe\r\ndifference between Serialization and Marshalling\r\nterminology\r\n- What is the difference between Serialization and Marshaling? - Stack\r\nOverflow\r\n补充材料\r\nhttps://en.wikipedia.org/wiki/Marshalling_(computer_science)\r\nhttps://zh.wikipedia.org/wiki/Marshalling_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\r\nrfc2713\r\n(ietf.org)\r\n序列化理解起来很简单\r\n- 知乎 (zhihu.com)\r\n","slug":"Algorithm/Serialization、Persistence and Marshalling","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Serialization","author_index":"JBR_Bunjie"},{"id":"08152463b75b8ab3478d28a28a35a8b9","title":"中国邮递员问题","content":"The Route of the Postman\r\nReference\r\n\r\nThe\r\nChinese-Postman-Method (tum.de)\r\n邮递员问题 -\r\n维基百科，自由的百科全书 (wikipedia.org)\r\n中国邮递员问题\r\n| Junnor.G (cfonheart.github.io)\r\n\r\nDetails\r\n\r\n邮递员问题（也称邮路问题，Route\r\nInspection Problem，或中国邮路问题,China Route\r\nInspection Problem，或中国邮递员问题Chinese Postman\r\nProblem）是一个图论问题。此问题为在一个连通的无向图中找到一最短的封闭路径，且此路径需通过所有边至少一次。\r\n简单来说，邮递员问题就是在一个已知的地区，邮差要设法找到一条最短路径，可以走过此地区所有的街道，且最后要回到出发点。\r\n\r\n一笔画问题 -\r\n维基百科，自由的百科全书 (wikipedia.org)\r\n问题解决\r\n\r\n\r\n图本身就是一个欧拉回路图，那么直接走一个欧拉回路就访问了所有路径并回到了起点\r\n\r\n（欧拉回路图的前提条件是每个点的度数都是偶数）\r\n\r\n图不是一个欧拉回路图，需要对某些边重复走多次回到起点，等价于添加了一些已经存在的重边，构建了欧拉回路。\r\n\r\n不是欧拉回路需要通过增加一些边使得图变成一个欧拉回路，并能保证问题的最优解，添加的边权值和一定是尽可能短的。\r\n\r\n计算度数为奇数的点\r\n算出所有点之间的最短路径\r\n奇度数的点一定为偶数，点与点之间构建二分图，权值为两点之间的最短路，找到一个最小权值匹配集\r\n对于匹配集，找到每一个匹配集两点之间形成的最短路径，那么这条最短路径就需要加入到额外的边中，且一定能保证这条路径上除了这两个匹配的奇度数点度数加了1变成了偶数，其他所有中间点都是加了2，不影奇偶性。\r\n所有边都添加好后，就是一个欧拉回路了，计算从起点开始的欧拉回路路径\r\n\r\n\r\n","slug":"Algorithm/The Chinese Postman Problem","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Shortest Route","author_index":"JBR_Bunjie"},{"id":"224d76f53823245ff06db9fdf896bcc4","title":"三角形面积计算","content":"求面积\r\n1.底高求面积\r\n已知三角形底a，高h，则 \r\n2.海伦公式\r\n已知三角形三边a,b,c，则 \r\n3.边角公式\r\n已知三角形两边a,b,这两边夹角，则有：  即两夹边之积乘夹角正弦值的一半。\r\n4.内切圆面积公式\r\n设三角形三边分别为a、b、c，内切圆半径为r\r\n则三角形面积 \r\n5.外接圆面积公式\r\n设三角形三边分别为a、b、c，外接圆半径为R\r\n则三角形面积 \r\n6.行列式形式\r\n\r\n为三阶行列式，此三角形在平面直角坐标系内，这里选取最好按逆时针顺序从右上角开始取，因为这样取得出的结果一般都为正值，如果不按这个规则取，可能会得到负值，但不要紧，只要取绝对值就可以了，不会影响三角形面积的大小。\r\n7.中线面积公式\r\nMa,Mb,Mc为三角形的中线长. \r\n单色三角形\r\nDescription\r\n在空间中给出了n个点。这些点任三点不共线，并且每两个点之间都有一条线相连，每一条线不是红的就是黑的。在这些点和线组成的三角形中，如果一个三角形的三条边的颜色都相同，那么我们就称这个三角形为单色三角形。现给出所有涂红色的线，试求出单色三角形的数目。\r\nmathematics side\r\nQuestion:\r\n给定空间里n(n&lt;=1000)个点，假设任意三个点都不共线。\r\n将任意两点之间的连线涂上红色或者黑色。\r\n问3条边同色的三角形个数。\r\n\r\nAnswer:\r\n由于三角形总数C(n,3)，所以求出异色三角形个数就求出了同色三角形个数。\r\n值得注意的是，当我们比较一个三角形是否是单色三角形时，我们实际比较的是三角形中的任意两条边，而不是比较一个“三角形”\r\n利用这样的比较关系，我们比较的对象是单个顶点而不是每个三角形，易知：一个异色三角形存在两个顶点，该三角形中与它们相邻的两边是不同色的；而对从一个顶点出发的两条异色边都属于一个异色三角形。这是个一对二的关系。\r\n已知第i个点会连接总共n-1条边。设第i个点连接了a条红边、n-1-a条黑边，由于边之间的组合关系，这些边一定属于a(n-1-a)个不同的异色三角形。由于异色三角形都会被考虑两次，所以最终的答案为C(n,\r\n3) - sigmaΣ(i from 1 to n)a(n-1-a)/2\r\n请注意，每个i下的a都是不同的，为了彰显这之中的关联，可以改设为ai，故得答案：\r\nC(n, 3) - Σ(i from 1 to n) ai * (n - 1 - ai) / 2\r\n\r\nprogramming side\r\nQuestion:\r\n任务：\r\n请写一个程序：\r\n从文本文件中读入点数和对红色连线的描述；\r\n找出该图中红色三角形的数目；\r\n把结果输出到文件TRO.OUT中。\r\n输入格式：\r\n在文本文件TRO.IN的第一行包括一个整数n，3 &lt;= n &lt;=\r\n1000，为空间中的点数。\r\n该文件的第二行为一个整数m，0 &lt;= m &lt;=\r\n250000，为红色连线的数目。\r\n以下的m行中每行为两个用空格分开的整数p和k，1 &lt;= p &lt; k &lt;=\r\nn，表示第p点和第k号点之间的连线为红色。\r\n输出格式：\r\n你应该在文本文件TRO.OUT输出唯一的一个整数——同色三角形的数目。\r\n样例：\r\n输入\r\n\r\n6 9 1 2 2 3 2 5 1 4 1 6 3 4 4 5 5 6 3 6\r\n\r\n输出\r\n\r\n2\r\n\r\nAnswer:\r\n按照在mathematics\r\nside中的思路，我们可以发现，单个点的比较中，是不存在“方向”的，或者说，所比较的每条线都是双向的。而同时也不在意当前点对点的具体内容，我们只在意当前点下，具体\r\n有 多少“红线”与“黑线”\r\n故我们用一个字典来记录各个顶点下的线数即可\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt; using namespace std; const int maxn = 200010;typedef long long LL; int a[maxn];int cnt[maxn];int n,num;int ele[100]; void fen(int x)//素因子分解{    num=0;    for(int i=2;i*i&lt;=x;i++){        if(x%i==0){            ele[num++]=i;            while(x%i==0)                x/=i;        }    }    if(x&gt;1) ele[num++]=x;} void init()//预处理与a[i]不互质的数的个数{    memset(cnt,0,sizeof(cnt));    scanf(\"%d\",&amp;n);    for(int i=0;i&lt;n;i++){        scanf(\"%d\",&amp;a[i]);        fen(a[i]);        for(int j=1;j&lt;(1&lt;&lt;num);j++){            int tmp=1;            for(int k=0;k&lt;num;k++)                if((1&lt;&lt;k)&amp;j) tmp*=ele[k];            cnt[tmp]++;        }    }} LL solve(){    LL ans=n;    ans=ans*(n-1)*(n-2)/6;//防止爆int    LL sum=0;    for(int i=0;i&lt;n;i++){//容斥原理求与a[i]不互质的数的个数        fen(a[i]);        LL tmp=0;        for(int j=1;j&lt;(1&lt;&lt;num);j++){            LL ret = 1;            int t=0;            for(int k=0;k&lt;num;k++){                if((1&lt;&lt;k)&amp;j){                    ret*=ele[k];                    t++;                }            }            if(t&amp;1) tmp+=cnt[ret];            else tmp-=cnt[ret];        }        if(tmp==0) continue;        else sum+=(n-tmp)*(tmp-1);        //cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;tmp&lt;&lt;\" \"&lt;&lt;(n-tmp)*(tmp-1)/2&lt;&lt;endl;    }    return ans-sum/2;}int main(){    int t;    scanf(\"%d\",&amp;t);    while(t--){        init();        LL ans=solve();        printf(\"%I64d\\n\",ans);    }    return 0;}\r\n","slug":"Algorithm/三角形面积计算","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,triangle area","author_index":"JBR_Bunjie"},{"id":"88fe004551a3de4348d535f91c34c293","title":"字符画","content":"字符画\r\n另类应用\r\n当你需要在shell里查看图片时\r\n现有框架\r\nascii-image-converter TheZoraiz/ascii-image-converter:\r\nA cross-platform command-line tool to convert images into ascii art and\r\nprint them on the console. Now supports braille art!\r\n(github.com)\r\n原理\r\n字符画是一系列字符的组合，我们可以把字符看作是比较大块的像素，一个字符能表现一种颜色，字符的种类越多，可以表现的颜色也越多，图片也会更有层次感。\r\n最终显示的是黑白色的字符画，那么彩色的图\r\n片怎么转换成黑白的呢？这里就需要了解灰度值的概念了。\r\n灰度值：指黑白图像中点的颜色深度，范围一般从0到255，白色为255，黑色为0，故黑白图片也称灰度图像。\r\n我们利用下面的公式将像素的RGB值转换成灰度值：\r\ngray ＝ 0.2126 * r + 0.7152 * g + 0.0722\r\n* b\r\n用不同的字符代表不同的灰度值，字符的种类和数量可以根据自己需要的效果进行调整，最好从前往后可以看到明显的变化，最后一个字符为空格符最佳：\r\n1ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\\&quot;^`&#x27;. &quot;)\r\n图片转字符画的关键思想是将图片的灰度值与你自己设定的字符集之间建立映射关系，不同区间的灰度值对应不同的字符，之后将图片每一个像素对应的字符打印出来就是我们要的字符画啦~\r\n这里提供两种方法：\r\n\r\n获取图片的RGB值，利用公式： Gray = R0.299 + G0.587 + B*0.114\r\n计算可得每个像素点的灰度值，之后再建立映射即可。\r\n先将彩色图片转换为黑白图片，然后直接将每个像素点的灰度值与字符集建立映射。\r\n\r\n实现思路？\r\n思路也很简单，通过像素的灰度来映射出ASCII字符。灰度值越大，所映射的ASCII字符占的单位面积越大，也就是看起来越黑。\r\n（例如某点的灰度是0，那么对应的字符就是空格；类似的，灰度为255时，对应的字符就是“$”）\r\n实际操作起来会遇到的问题就是：\r\n图片太大，输出后的文本即使使用最小字体也看不全\r\nASCII字符不是方形像素（长宽比不是1:1）\r\n处理方法就是对图片的大小数据进行处理（而不是原图修改）然后映射。\r\n总体上来说制作字符画还是比较简单的，需要处理的情况没有那么多。\r\n黑白字符画\r\n黑白字符画应该是难度最低的了。大致思路是这样的：\r\n\r\n设计一个从深到浅（0~255，黑~白）的字符列表；\r\n将原图转为黑白，并量化（quantization，如从 0~255 量化为\r\n0~16）从而匹配字符列表的长度；\r\n将图片缩放为一个很小的图（如宽度 100）；\r\n将每一个像素点的亮度转为对应字符；\r\n输出为 .txt 文件。\r\n\r\n彩色字符画\r\n\r\n将原图缩放为一个很小的缩略图（如宽度 100）；\r\n新建一个大的白色或黑色画布；\r\n计算好每个字符在画布上的位置，将缩略图中每一个像素点转为颜色相同的字符，并打印在画布指定位置上；\r\n将画布输出为图像（如 .png）文件。\r\n\r\nReference：\r\n字符画——从入门到不屑 - 知乎\r\n(zhihu.com)\r\n","slug":"Algorithm/字符画","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"920b0f28d25f5984040e129525c64cc1","title":"Floor method","content":"Floor Number\r\n以python为例：\r\n\r\nint()进行强制类型转化\r\nround()函数\r\nformat()函数\r\n两个连续的数学计算\r\n\r\n12345a = 60.89564a//1a-(a+1)%1(a+B-1)//B # 向上取整\r\n","slug":"Algorithm/小数取整","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Number Processing","author_index":"JBR_Bunjie"},{"id":"61e7c8da8f21c01a5499770adb3ae992","title":"平面分割问题","content":"直线切割平面问题\r\nReference：\r\n\r\n平面分割_xzx9的博客-CSDN博客_平面分割空间\r\n平面分割类问题总结\r\n- Yeader - 博客园 (cnblogs.com)\r\n\r\nDetail：\r\n【题型一】直线分割平面\r\n\r\n在一个平面上有一个圆和n条直线，这些直线中每一条在圆内同其他直线相交，假设没有3条直线相交于一点，试问这些直线将圆分成多少区域。\r\n\r\n分析： \r\n当添加第N条，为了使平面最多，\r\n则第N条直线要与前面的N-1条直线都相交，且没有任何三条直线相交一个点。\r\n则添加第N条直线会多N-1个交点。同时：由于每增加N个交点，就增加N+1个平面，所以添加的第N条直线来会在之前的基础上增加N个平面。\r\n若用F[i]表示i条直线能把平面切分成的个数。 \r\n可得递推结果： \r\n【题型二】平面分割空间（HDU\r\n1290）\r\n\r\n全面考虑，注意平面是可以倾斜的！\r\n还有更多？\r\n【题型三】折线分割平面（HDU 2050）\r\n【题型四】圆形划分区域\r\n","slug":"Algorithm/平面切割","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"c7cd6315021c2b49c9efb80c79e420a8","title":"大数运算","content":"前言：\r\n在计算机中数字表示的范围是有限制的，比如我们熟知的 int、float、double\r\n等数据类型所能表示的范围都是有限的，如果我们要对位数达到几十位、几百位、上千位的大整数进行计算，这些数据类型显然不能满足我们的要求，因此我们需要通过算法来实现这些功能。\r\n1、大数加法\r\n两个大数我们可以用数组来保存，然后在数组中逐位进行相加，再判断该位相加后是否需要进位，为了方便计算，我们将数字的低位放在数组的前面，高位放在后面。\r\n下面是两个正的大整数相加算法的C语言参考代码：\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAX 1000    // 大数的最大位数/*  大数加法  参数：  num1为第一个大数，用字符数组保存  num2为第二个大数  sum数组保存相加的结果  即：num1+num2=sum  返回值：返回数组sum的有效长度，即计算结果的位数 */int Addition(char num1[], char num2[], int sum[])&#123;    int i, j, len;    int n2[MAX] = &#123;0&#125;;    int len1 = strlen (num1); // 计算数组num1的长度，即大数的位数    int len2 = strlen (num2); // 计算数组num2的长度，即大数的位数    len = len1&gt;len2 ? len1 : len2; // 获取较大的位数    //将num1字符数组的数字字符转换为整型数字，且逆向保存在整型数组sum中，即低位在前，高位在后    for (i = len1-1, j = 0; i &gt;= 0; i--, j++)        sum[j] = num1[i] - &#x27;0&#x27;;    // 转换第二个数    for (i = len2-1, j = 0; i &gt;= 0; i--, j++)        n2[j] = num2[i] - &#x27;0&#x27;;    // 将两个大数相加    for (i = 0; i &lt;= len; i++)    &#123;        sum[i] += n2[i];  // 两个数从低位开始相加        if (sum[i] &gt; 9)   // 判断是否有进位        &#123;   // 进位            sum[i] -= 10;            sum[i+1]++;        &#125;    &#125;    if(sum[len] != 0)  // 判断最高位是否有进位        len++;    return len;   // 返回和的位数&#125;int main()&#123;    int i, len;    int sum[MAX] = &#123;0&#125;; // 存放计算的结果，低位在前，高位在后，即sum[0]是低位    char num1[] = &quot;1234567891234567891234&quot;; // 第一个大数    char num2[] = &quot;2345678912345678913345&quot;; // 第二个大数    len = Addition(num1, num2, sum);    // 两数相加    printf(&quot;%s\\n  +\\n%s\\n  =\\n&quot;, num1, num2);    // 反向输出求和结果    for (i = len-1; i &gt;= 0; i--)        printf(&quot;%d&quot;, sum[i]);    printf(&quot;\\n&quot;);    return 0;&#125;\r\n2、大数减法\r\n相减算法也是从低位开始减的。先要判断被减数和减数哪一个位数长，若被减数位数长是正常的减法；若减数位数长，则用被减数减去减数，最后还要加上负号；当两数位数长度相等时，最好比较哪一个数字大，否则负号处理会很繁琐；处理每一项时要，如果前一位相减有借位，就先减去上一位的借位，无则不减，再去判断是否能够减开被减数，如果减不开，就要借位后再去减，同时置借位为1，否则置借位为0。\r\n下面是C语言参考代码：\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAX 1000    // 大数的最大位数/*  大数减法  参数：  num1为被减数，用字符数组保存  num2为减数  sum数组保存相减的结果   即：num1-num2=sum  返回值：返回数组sum的有效长度，即计算结果的位数 */int Subtraction(char num1[], char num2[], int sum[])&#123;    int i, j, len, blag;    char *temp;    int n2[MAX] = &#123;0&#125;;    int len1 = strlen(num1); // 计算数组num1的长度，即大数的位数    int len2 = strlen(num2); // 计算数组num2的长度，即大数的位数    // 在进行减法之前要进行一些预处理    blag = 0; // 为0表示结果是正整数，为1表示结果是负整数    if(len1 &lt; len2) // 如果被减数位数小于减数    &#123;        blag = 1; // 标记结果为负数        // 交换两个数，便于计算        temp = num1;        num1 = num2;        num2 = temp;        len = len1;        len1 = len2;        len2 = len;    &#125;    else if(len1 ==len2) // 如果被减数的位数等于减数的位数    &#123;        // 判断哪个数大        for(i = 0; i &lt; len1; i++)        &#123;            if(num1[i] == num2[i])                continue;            if(num1[i] &gt; num2[i])            &#123;                blag = 0; // 标记结果为正数                break;            &#125;            else            &#123;                blag = 1; // 标记结果为负数                // 交换两个数，便于计算                temp = num1;                num1 = num2;                num2 = temp;                break;            &#125;        &#125;    &#125;    len = len1&gt;len2 ? len1 : len2; // 获取较大的位数    //将num1字符数组的数字转换为整型数且逆向保存在整型数组sum中，即低位在前，高位在后    for (i = len1-1, j = 0; i &gt;= 0; i--, j++)        sum[j] = num1[i] - &#x27;0&#x27;;    // 转换第二个数    for (i = len2-1, j = 0; i &gt;= 0; i--, j++)        n2[j] = num2[i] - &#x27;0&#x27;;    // 将两个大数相减    for (i = 0; i &lt;= len; i++)    &#123;        sum[i] = sum[i] - n2[i]; // 两个数从低位开始相减        if (sum[i] &lt; 0)   // 判断是否有借位        &#123;    // 借位            sum[i] += 10;            sum[i+1]--;        &#125;    &#125;    // 计算结果长度    for (i = len1-1; i&gt;=0 &amp;&amp; sum[i] == 0; i--)        ;    len = i+1;    if(blag==1)    &#123;        sum[len] = -1;  // 在高位添加一个-1表示负数        len++;    &#125;    return len;   // 返回结果的位数&#125;int main()&#123;    int i, len;    int sum[MAX] = &#123;0&#125;; // 存放计算的结果，低位在前，高位在后，即sum[0]是低位    char num1[] = &quot;987654321987654321&quot;; // 第一个大数    char num2[] = &quot;123456789123456789&quot;; // 第二个大数    len = Subtraction(num1, num2, sum);    // 两数相减    // 输出结果    printf(&quot;%s\\n  -\\n%s\\n  =\\n&quot;, num1, num2);    if(sum[i=len-1] &lt; 0) // 根据高位是否是-1判断是否是负数    &#123;        printf(&quot;-&quot;); // 输出负号        i--;    &#125;    for (; i &gt;= 0; i--)        printf(&quot;%d&quot;, sum[i]);    printf(&quot;\\n&quot;);    return 0;&#125;\r\n3、大数乘法\r\n首先说一下乘法计算的算法，从低位向高位乘，在竖式计算中，我们是将乘数第一位与被乘数的每一位相乘，记录结果，之后，用第二位相乘，记录结果并且左移一位，以此类推，直到计算完最后一位，再将各项结果相加，得出最后结果。\r\n计算的过程基本上和小学生列竖式做乘法相同。为了编程方便，并不急于处理进位，而是将进位问题留待最后统一处理。\r\n总结一个规律: 即一个数的第i 位和另一个数的第j\r\n位相乘所得的数，一定是要累加到结果的第i+j 位上。这里i, j\r\n都是从右往左，从0 开始数。ans[i+j] = a[i]*b[j];\r\n另外注意进位时要处理，当前的值加上进位的值再看本位数字是否又有进位；前导清零。\r\n下面是C语言的两个正大数相乘的参考代码：\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAX 1000    // 大数的最大位数/*  大数乘法  参数：  num1为第一个因数，用字符数组保存  num2为第二个因数  sum数组保存相乘的结果  即：num1*num2=sum  返回值：返回数组sum的有效长度，即计算结果的位数 */int Multiplication(char num1[],char num2[], int sum[])&#123;    int i, j, len, len1, len2;    int a[MAX+10] = &#123;0&#125;;    int b[MAX+10] = &#123;0&#125;;    int c[MAX*2+10] = &#123;0&#125;;    len1 = strlen(num1);    for(j = 0, i = len1-1; i &gt;= 0; i--) //把数字字符转换为整型数        a[j++] = num1[i]-&#x27;0&#x27;;    len2 = strlen(num2);    for(j = 0, i = len2-1; i &gt;= 0; i--)        b[j++] = num2[i]-&#x27;0&#x27;;    for(i = 0; i &lt; len2; i++)//用第二个数乘以第一个数,每次一位    &#123;        for(j = 0; j &lt; len1; j++)        &#123;            c[i+j] += b[i] * a[j]; //先乘起来,后面统一进位        &#125;    &#125;    for(i=0; i&lt;MAX*2; i++) //循环统一处理进位问题    &#123;        if(c[i]&gt;=10)        &#123;            c[i+1]+=c[i]/10;            c[i]%=10;        &#125;    &#125;    for(i = MAX*2; c[i]==0 &amp;&amp; i&gt;=0; i--); //跳过高位的0    len = i+1; // 记录结果的长度    for(; i&gt;=0; i--)        sum[i]=c[i];    return len;&#125;int main()&#123;    int i, len;    int sum[MAX*2+10] = &#123;0&#125;; // 存放计算的结果，低位在前，高位在后，即sum[0]是低位    char num1[] = &quot;123456789123456789&quot;; // 第一个大数    char num2[] = &quot;123456789123456789&quot;; // 第二个大数    len = Multiplication(num1, num2, sum);    // 输出结果    printf(&quot;%s\\n  *\\n%s\\n  =\\n&quot;, num1, num2);    for(i = len-1; i&gt;=0; i--)        printf(&quot;%d&quot;, sum[i]);    printf(&quot;\\n&quot;);    return 0;&#125;\r\n4、大数除法\r\n大数除法是四则运算里面最难的一种。不同于一般的模拟，除法操作不是模仿手工除法，而是利用减法操作来实现的。其基本思想是反复做除法，看从被除数里面最多能减去多少个除数，商就是多少。逐个减显然太慢，要判断一次最多能减少多少个整数(除数)的10的n次方。\r\n以7546除以23为例：\r\n先用7546减去23的100倍，即减去2300，可以减3次，余下646，此时商就是300\r\n(300=100*3)；\r\n然后646减去23的10倍，即减去230，可以减2次，余下186，此时商就是320\r\n(320=300+10*2)；\r\n然后186减去23，可以减8次，余下2，此时商就是328 (328=320+1*8)；\r\n因为2除以23的结果小于1，而我们又不用计算小数点位，所以不必再继续算下去了。\r\n下面是C语言的两个正大数相除的参考代码，计算结果中没有小数：\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAX 1000    // 大数的最大位数// 注：// 本代码在以下博客代码中进行修改：// http://www.cnblogs.com/javawebsoa/archive/2013/08/01/3231078.html///*  函数SubStract功能：  用长度为len1的大整数p1减去长度为len2的大整数p2  结果存在p1中，返回值代表结果的长度  不够减：返回-1 ， 正好够：返回0*/int SubStract(int *p1, int len1, int *p2, int len2)&#123;    int i;    if(len1 &lt; len2)        return -1;    if(len1 == len2 )    &#123;                        // 判断p1 &gt; p2        for(i = len1-1; i &gt;= 0; i--)        &#123;            if(p1[i] &gt; p2[i])   // 若大，则满足条件，可做减法                break;            else if(p1[i] &lt; p2[i]) // 否则返回-1                return -1;        &#125;    &#125;    for(i = 0; i &lt;= len1-1; i++)  // 从低位开始做减法    &#123;        p1[i] -= p2[i];         // 相减        if(p1[i] &lt; 0)           // 若是否需要借位        &#123;   // 借位            p1[i] += 10;            p1[i+1]--;        &#125;    &#125;    for(i = len1-1; i &gt;= 0; i--)  // 查找结果的最高位    &#123;        if( p1[i] )             //最高位第一个不为0            return (i+1);       //得到位数并返回    &#125;    return 0;                   //两数相等的时候返回0&#125;/*  大数除法---结果不包括小数点  num1 被除数  num2 除数  sum  商，存放计算的结果，即：num1/num2=sum  返回数组sum的有效长度，即商的位数*/int Division(char num1[], char num2[], char sum[])&#123;    int k, i, j;    int len1, len2, len=0;     //大数位数    int dValue;                //两大数相差位数    int nTemp;                 //Subtract函数返回值    int num_a[MAX] = &#123;0&#125;;      //被除数    int num_b[MAX] = &#123;0&#125;;      //除数    int num_c[MAX] = &#123;0&#125;;      //商    len1 = strlen(num1);       //获得大数的位数    len2 = strlen(num2);    //将数字字符转换成整型数，且翻转保存在整型数组中    for( j = 0, i = len1-1; i &gt;= 0; j++, i-- )        num_a[j] = num1[i] - &#x27;0&#x27;;    for( j = 0, i = len2-1; i &gt;= 0; j++, i-- )        num_b[j] = num2[i] - &#x27;0&#x27;;    if( len1 &lt; len2 )          //如果被除数小于除数，直接返回-1，表示结果为0    &#123;        return -1;    &#125;    dValue = len1 - len2;      //相差位数    for (i = len1-1; i &gt;= 0; i--)    //将除数扩大，使得除数和被除数位数相等    &#123;        if (i &gt;= dValue)            num_b[i] = num_b[i-dValue];        else                         //低位置0            num_b[i] = 0;    &#125;    len2 = len1;    for(j = 0; j &lt;= dValue; j++ )    //重复调用，同时记录减成功的次数，即为商    &#123;        while((nTemp = SubStract(num_a, len1, num_b+j, len2-j)) &gt;= 0)        &#123;            len1 = nTemp;            //结果长度            num_c[dValue-j]++;       //每成功减一次，将商的相应位加1        &#125;    &#125;    // 计算商的位数，并将商放在sum字符数组中    for(i = MAX-1; num_c[i] == 0 &amp;&amp; i &gt;= 0; i-- );  //跳过高位0，获取商的位数    if(i &gt;= 0)        len = i + 1; // 保存位数    for(j = 0; i &gt;= 0; i--, j++)     // 将结果复制到sum数组中        sum[j] = num_c[i] + &#x27;0&#x27;;    sum[j] = &#x27;\\0&#x27;;   // sum字符数组结尾置0    return len;      // 返回商的位数&#125;int main()&#123;    int i;    int len;                // 商的位数    char num1[MAX] = &quot;1234567899876543210&quot;;   // 第一个大数    char num2[MAX] = &quot;20160415123025&quot;;              // 第二个大数    char sum[MAX] = &#123;0&#125;;    // 计算结果    //scanf(&quot;%s&quot;, num1);      //以字符串形式读入大数    //scanf(&quot;%s&quot;, num2);    len = Division(num1, num2, sum);    //输出结果    printf(&quot;%s\\n  ÷\\n%s\\n  =\\n&quot;, num1, num2);    if( len&gt;=0 )    &#123;        for(i = 0; i &lt; len; i++ )            printf(&quot;%c&quot;, sum[i]);    &#125;    else    &#123;        printf(&quot;0&quot;);    &#125;    printf(&quot;\\n&quot;);    return 0;&#125;\r\n","slug":"Algorithm/大数四则运算","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"7c79e745614c96c9bf175ffbbcfcb82c","title":"卡拉彼丘游戏设计的一点思考","content":"卡拉彼丘的独特战术动作、射击体验与新人劝退的结果\r\n独特的战术动作：弦化\r\n机动性、\r\n拉人、回复与局内突破的天然矛盾\r\n长时间的 ttk\r\n","slug":"游戏设计分析/卡拉彼丘的游戏设计分析","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"0b5bad59d6c75a685d314a2ae8f6dd4e","title":"Git Command","content":"git 分区\r\ngit 一共有三个分区：\r\n工作区、暂存区和版本库\r\ngit 的初始化（自报家门）\r\n\r\ngit config --global user.name \"YOUR NAME\"\r\ngit config --global user.email \"email@example.com\"\r\n\r\n用 git 创建仓库(repository)\r\n\r\nmkdir repositoryExample（这只是生成了一个文件夹）\r\n\r\n进入仓库（文件夹）\r\n\r\ncd repositoryExample\r\n\r\n初始化仓库（仓库的正式建立）\r\n\r\ngit init\r\n\r\n注意：此举会在当前目录下生成一个.git\r\n文件夹，但是这是一个以.开头的隐藏文件夹，所以使用 ls\r\n命令无法直接看到，你可以使用 ls -a 命令来查看这类隐藏的文件夹\r\n用 git 来记录变化\r\n\r\ngit add fileName\r\n*可以使用 git status -s 来查看更改***\r\n\r\n-A, --all add changes from all tracked and untracked files\r\n-u, --update update tracked files\r\n\r\ngit diff\r\n使用 diff 来查看已经做出的变化\r\n用 git diff HEAD -- filename\r\n来比较远程仓库和本地的文件的区别\r\ngit commit -m \"本次提交的说明\"\r\n\r\n\r\n\r\n\r\n**或者使用 git commit -a 命令来跳过 add 直接提交所有变动\r\n关于历史提交\r\n\r\n使用 git log 或者 git log --pretty=oneline 来查看\r\n使用 git reset + log 中的每行前的如 d5d7e...版本号 来还原\r\ngit 中，有 git reflog 命令来记录用户的每一次操作\r\ngit 管理的是修改而不是文件！\r\n\r\n关于文件更改\r\n\r\ngit checkout -- filename //舍弃工作区的所有更改\r\n关于这个命令\r\n如果 filename 文件还没有被提交到暂存区（仍然停留在工作区），则 git\r\n会立即撤销所有更改——即使已经在文件中保存\r\n如果 filename 文件已经用 add 命令提交过一次了，则 git\r\n会将它重置为刚刚提交到缓存区中的状态\r\ngit reset HEAD filename\r\n通过这个命令，我们可以将已经提交到暂存区的 filename\r\n文件回退到工作区\r\n\r\n文件删除\r\n\r\ngit rm filename\r\n注意: 删除文件也是一个修改，必须要提交才会被记录，但这里没有必要\r\nadd，可以直接 commit\r\ngit checkout -- filename\r\n又见面了，再次用此命令来恢复文件，因为它的作用其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\r\n\r\ngit\r\nrm - How do I delete a file from a Git repository? - Stack\r\nOverflow\r\n远程管理\r\n\r\n显示所有远程仓库：git remote -v\r\n添加远程版本库：git remote add [name] [url]\r\n删除远程仓库：git remote remove origin\r\n修改仓库名：git remove rename old_name new_name\r\n\r\n向远程库提交\r\n\r\ngit push -u [推送的主机] [推送的分支] ——例：origin main\r\n删除主机的分支：git push origin --delete master\r\n\r\n从远程库克隆\r\n\r\ngit clone git@项目仓库地址\r\n从远程获取代码并合并本地版本：\r\n规范：git pull  :\r\n示例：git pull origin master:brantest\r\n——将远程主机 origin 的 master 分支拉取过来，与本地的 brantest\r\n分支合并\r\n\r\n分支\r\n\r\n创建并切换到新分支：git checkout -b dev 或 git switch -c dev\r\n切换分支：git checkout dev 或 git switch master\r\n查看分支：git branch\r\n把分支合并到 main 上：git merge dev\r\n删除分支：git branch -d dev\r\n将分支推送到远程仓库：git push origin bunjie（同理呀！）\r\n\r\ngit push --set-upstream origin master\r\nssh-keygen -t rsa\r\nSet Proxy\r\n一文让你了解如何为\r\nGit 设置代理 - Eric (ericclose.github.io)\r\n","slug":"Deploy/GitAndGithub/Git Commmand","date":"2022-12-23T04:23:23.000Z","categories_index":"Git","tags_index":"Git","author_index":"JBR_Bunjie"},{"id":"743056c4369a9fa1f8f105370c847ec2","title":"日志格式","content":"日志格式\r\n通用前缀 class.method LEVEL | KEY | SUB_KEY | param1=x;param2=x;... |\r\nrs=JSON | traceId=xxx[ | 其它自定义日志]\r\nKEY：标示业务领域，如“领券”\r\nSUBKEY：标示业务领域中具体的逻辑，如“策略决策”、“权益决策”、“调用\r\nUMP”等\r\nLEVEL：DEBUG / TRACE / MONITOR / WARN\r\n要求：\r\n查找日志时，再一次查询中可以顺利通过一个或多个关键字的组合，找到一条完整的业务处理链路。\r\n如通过一个 userId 和 KEY，可以完整的找到这个用户的领券全过程。\r\n调试日志\r\n仅在调试阶段需要输出，线上一般不输出。\r\n日志可以包括每次请求的详细出入参等信息。\r\n线上必须有开关可以控制这类日志的打印。\r\nlevel=DEBUG\r\n普通日志\r\n用户追踪必要的代码执行记录，线上一般打印出来，大促时可以降级。\r\n日志可以包括每次外部请求的详细出入参，以及内部请求的关键参数。\r\n请求出入参较长时，可考虑只打印关键参数。\r\nlevel=TRACE\r\n业务指标项日志\r\n记录必要的业务活动，通过 sls 或 sunfire 产出业务大盘\r\nlevel=MONITOR\r\n监控报警项日志\r\n通过 sunfire 产出报警\r\nlevel=WARN\r\n自定义日志\r\n不做格式要求，自行打印，注意避免过量日志造成线上磁盘资源紧张\r\n","slug":"Dev/Theory/日志规范","date":"2022-12-23T04:23:23.000Z","categories_index":"Theroy","tags_index":"Theroy","author_index":"JBR_Bunjie"},{"id":"708e72f78c0920c292ea7dfe7d2abfd7","title":"一些PowerShell, CMD命令","content":"一些PowerShell, CMD命令\r\nWindows\r\n命令 | Microsoft Docs\r\n搜索文件中文本的模式\r\n12| findstr# https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/findstr\r\n搜索文件中的文本字符串，并显示包含指定字符串的文本行\r\n12| find# https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/find\r\n显示当前进程\r\n1tasklist\r\n杀死某个进程\r\n1taskkill &lt;exe程序名/PID&gt;\r\n历史命令记录\r\n123456789101112# PowerShell获取当前会话中输入的命令historyget-history# PowerShell获取当前会话中输入的命令的全部信息Get-History | Format-List -Property *# CMD获取当前会话中输入的命令doskey /h# 查阅总的命令历史记录：cat %USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt# https://docs.microsoft.com/zh-cn/powershell/module/Microsoft.PowerShell.Core/about/about_history?view=powershell-7.2\r\n实例\r\n生成随机数\r\n12345678910111213141516# cmd窗口直接输入：set /a %random%%10+1# bat文件：set /a rnd=%random%%%10+1echo %rnd%# PowerShell# 使用内置函数：Get-RandomGet-Random# This command gets a random integer between 0 (zero) and Int32.MaxValue.Get-Random -Maximum 100# This command gets a random integer between 0 (zero) and 99.Get-Random -Minimum 10.7 -Maximum 20.93# This command gets a random floating-point number greater than or equal to 10.7 and less than 20.92.Get-Random -InputObject 1, 2, 3, 5, 8, 13 -Count 3# This command gets three randomly selected numbers in random order from the array.\r\n1arp -\r\n","slug":"Deploy/Windows/一些PowerShell·CMD命令","date":"2022-12-23T04:23:23.000Z","categories_index":"Windows","tags_index":"Windows,Powershell,CMD","author_index":"JBR_Bunjie"},{"id":"6447ce34572a48189d0a25e47120ad48","title":"Vim 5. EDIT","content":"Vim 5. edit 综述\r\n总览：\r\nVim provides many commands which make editing functionality really\r\npowerful. In this chapter, we will discuss following items −\r\n\r\nInsert\r\nAppend\r\nOpen new line\r\nSubstitute\r\nChange\r\nReplace\r\nJoin\r\n\r\n插入——i：Insert text before\r\ncursor\r\nTo insert text before cursor perform following steps −\r\n\r\nTo insert text before cursor perform following steps\r\nSwitch to insert mode\r\n\r\n1i\r\n追加——a：Append text after\r\ncursor\r\nTo append text after cursor perform following steps\r\n\r\nSwitch to command mode and move cursor to appropriate position\r\n\r\n1Esc\r\n\r\nSwitch to insert mode\r\n\r\n1a\r\n头插——I：Insert text\r\nat the beginning of line\r\nLet us suppose you are in the middle of line and you want to insert\r\ntext at the beginning of current line then perform following steps −\r\n\r\nSwitch to command mode\r\n\r\n1Esc\r\n\r\nActivate insert mode\r\n\r\n1I\r\nThis action will move cursor to the beginning of current line and\r\nswitch Vim in insert mode\r\n尾插——A：Append text at the\r\nend of line\r\nLet us suppose you are in the middle of line and you want to append\r\ntext at the end of current line then perform following steps −\r\n\r\nSwitch to command mode\r\n\r\n1Esc\r\n\r\nSwitch to insert mode\r\n\r\n1A\r\nThis action will move cursor to the end of line and switch Vim in\r\ninsert mode\r\n另起行——在光标当前行下新起一行并进入\r\ninsert 模式——o：Open new line below cursor\r\nLet us suppose you are in the middle of line and you want to open new\r\nline below current line then perform following steps −\r\n\r\nSwitch to command mode\r\n\r\n1Esc\r\n\r\nSwitch to insert mode\r\n\r\n1o\r\nThis action will insert blank line below current line and switch Vim\r\nin insert mode\r\n另起行——将当前行下移一行并进入\r\ninsert 模式——O：Open new line above cursor\r\nLet us suppose you are in the middle of line and you want to open new\r\nline above current line then perform following steps −\r\n\r\nSwitch to command mode\r\n\r\n1Esc\r\n\r\nSwitch to insert mode\r\n\r\n1o\r\nThis action will insert blank line above current line and switch Vim\r\nin insert mode\r\n替换——替换(删)当前字插入——s：Substitute\r\none character\r\nLet us suppose you want to substitute single character then perform\r\nfollowing steps −\r\n\r\nSwitch to command mode\r\n\r\n1Esc\r\n\r\nSwitch to insert mode\r\n\r\n1s\r\nThis action will delete character under cursor and switch Vim in\r\ninsert mode To substitute entire line use −\r\n替换——替换(删)当前行插入——S：Substitute\r\nentire line\r\nor you want to substitute entire line -\r\n\r\nSwitch to command mode\r\n\r\n1Esc\r\n\r\nSwitch to insert mode\r\n\r\n1S\r\nThis action will delete entire line and switch Vim in insert\r\nmode.\r\n修改——改变文字(删)——cc：Change\r\nentire line\r\nLet us suppose you want to change text in current line then perform\r\nfollowing steps −\r\n\r\nSwitch to command mode\r\n\r\n1Esc\r\n\r\nExecute following command −\r\n\r\n1cc\r\nThis is similar to substitute action using S\r\n修改——从当前位置起改变文字(删)——C：change\r\ntext from current cursor position\r\nexecute following command -\r\n1C\r\nThis action will delete text after current cursor position and switch\r\nVim in insert mode.\r\n替换——代替当前光标所指字符——r：\r\nTo replace single character perform following steps −\r\n\r\nSwitch to command mode\r\n\r\n1Esc\r\n\r\nMove cursor to appropriate position\r\nExecute following command −\r\n\r\n1r\r\n\r\nEnter character to be substituted.\r\n\r\nNote that this command will not switch Vim in insert\r\nmode\r\n替换——直接进入替换编辑模式——R/hit\r\ninsert button twice：\r\nTo replace entire line execute −\r\n1R\r\nIt will switch Vim in replace mode as shown in below image −\r\n合并——合并当前行与下一行——J：Join\r\ntext\r\nTo join two lines perform following steps −\r\n\r\nSwitch to command mode\r\n\r\n1Esc\r\n\r\nMove cursor to appropriate line\r\nExecute following command −\r\n\r\n1J\r\n编辑进化——重新审视编辑——Revisiting\r\nEditing：\r\nBuffer\r\nBuffer is temporary memory used by Vim. When we open a file\r\nin editor, Vim loads its contents from disk drive. These\r\ncontents are stored in memory (RAM) whenever we edit a file we are\r\nactually editing file from buffer. Once we finish editing and save file\r\nthat time only buffer contents are transferred to appropriate file.\r\nSwap\r\nSwap area is a file created by Vim to store buffer contents\r\nperiodically. While editing file our changes may be lost because of any\r\nreasons and Vim provides swap files to provide data recovery.\r\nTo get actual name of swap file execute following command −\r\n1:swapname\r\nCut, Copy and paste actions\r\nWe often perform cut, copy and paste actions on text. Vim provides\r\nfollowing commands to perform these actions (y stands for yank and p\r\nstands for paste action) −\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\nx\r\nDelete character from cursor position\r\n\r\n\r\nX\r\nDelete previous character from cursor position\r\n\r\n\r\ny\r\nCopy single character from cursor position\r\n\r\n\r\np\r\nPaste character after cursor position\r\n\r\n\r\nP\r\nPaste character before cursor position\r\n\r\n\r\nd\r\ncut\r\n\r\n\r\n\r\nMulti-position command\r\nWe can use cut, copy and paste commands with words and sentences as\r\nwell. Below table shows this −\r\n\r\n\r\n\r\nCommand\r\nDescription\r\n\r\n\r\n\r\n\r\ndw\r\nDelete word from cursor position\r\n\r\n\r\nD\r\nDelete entire line from cursor position\r\n\r\n\r\ndd\r\nDelete entire line\r\n\r\n\r\nY\r\nCopies entire line\r\n\r\n\r\nyy\r\nCopies entire line\r\n\r\n\r\n\r\nTo perform multi-line/multi-word actions just use numbers with\r\ncommand. You can use this syntax with other commands as well. For\r\ninstance, to delete 3 words use −\r\n13dw\r\nUndo\r\nWe can undo single or multiple actions. To perform one time undo\r\naction execute −\r\n1u\r\nTo perform multiple undo action, use number with same command. For\r\ninstance, below command will undo last 3 actions −\r\n13u\r\nIn addition to this, to undo all execute following command −\r\n1U\r\nRedo\r\nRedo is apposite action of undo. Execute any of the command to\r\nperform redo action.\r\n123Ctrl + r# OR:red\r\n","slug":"Deploy/vim/05.editing","date":"2022-12-23T04:23:23.000Z","categories_index":"Vim,Linux","tags_index":"Linux,Vim","author_index":"JBR_Bunjie"},{"id":"b0298187d3b43e42af9c0e2b93f65724","title":"Birthday Paradox","content":"生日悖论-birthday paradox\r\n一个很简单的概率关系，由于其反直觉而称为“悖论”：\r\n一个房间要多少人，则两个人的生日相同的概率\r\n\r\n\r\n\r\n对应情况\r\n所需人数\r\n\r\n\r\n\r\n\r\n大于50%？\r\n23人\r\n\r\n\r\n大于70%？\r\n30人\r\n\r\n\r\n大于97%？\r\n50人\r\n\r\n\r\n大于99%？\r\n57人\r\n\r\n\r\n\r\n可以发现，概率大于99%所需的人数 只是总数的1 / 6不到而已！\r\n每个人生日 都不同 的 阶乘\r\n形式为：\r\n\r\n\r\nimg\r\n\r\n故至少有两个人生日相同的概率就是上述结果的补，即：\r\n生日悖论 - 知乎\r\n(zhihu.com)\r\n鸽笼理论-pigeonhole\r\nprinciple\r\n又叫抽屉原理\r\n如果有n种n+1个物品，那么至少有一种有两个物品\r\n这种基本概念也没什么太多好阐释的，主要是鸽笼定理在思维上可能会造成一些奇怪的突破口\r\n有几个衍生的阐述形式：\r\n形式一：如果把n+1(n是正整数)个对象放入n个盒子里，那么至少有一个盒子中放入两个或者两个以上的对象。证明：假设每个盒子中都少于两个对象，那么总数不可能为n+1个对象，与前提矛盾。\r\n形式二：如果把m个对象放到n个盒子里（m,n都是正整数），那么至少有一个盒子中放入[m-1/n]+1个的对象。注：[m-1/n]中的[]代表着m-1/n的整数部分。证明：假设每个盒子中都少于或者等于[m-1/n]对象，那么对象的总数将不会多于n*[m-1/n]个，从而少于或者等于m-1个，与前提矛盾。\r\n应用——生日攻击\r\n生日悖论与鸽笼理论组合的可被应用于设计密码学攻击方法——生日攻击。\r\n即 N 位长度的哈希表可能发生碰撞测试次数不是 2^N 次而是只有 2^(N/2) +\r\n1 次\r\n\r\n如果输出是256位，我们随机地选择输入，并计算哈希值，在检验第2^256 +\r\n1个输入之前便很可能找到碰撞。\r\n实际上，如果我们随机选择2^128 +\r\n1个输入，找到至少两个相同哈希值的概率为99%，而2 ^ 130 + 1 则高达\r\n99.8%。\r\n\r\n具体场景可以看：密码学：生日攻击_Linuxest-CSDN博客_生日攻击\r\n算法题\r\n鸽笼原理&amp;容斥原理_LazyCrazyCat的博客-CSDN博客_鸽笼定理\r\n","slug":"Algorithm/BirthdayParadox/生日悖论&鸽笼理论-birthday paradox&pigeonhole principle","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"2ae8bf5d7ed3f9dc8f4a04292dc96322","title":"Python 深浅拷贝概念与使用","content":"深浅拷贝概念与使用\r\nReference：\r\n\r\n彻底理解\r\nPython 中的\"指针\"_杰克小麻雀的博客-CSDN 博客_python 有指针吗\r\n\r\ndeep copy and shallow copy\r\n浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用\r\n深拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中\r\nexamples\r\nshallow copy\r\ncode\r\n1234567891011121314list1 = [[1, 2], (30, 40)]list2 = list(list1)list1.append(100)print(&quot;list1:&quot;,list1)  # [[1, 2], (30, 40), 100]print(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]list1[0].append(3)print(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40), 100]print(&quot;list2:&quot;,list2)  # [[1, 2, 3], (30, 40)]list1[1] += (50, 60)print(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40, 50, 60), 100]print(&quot;list2:&quot;,list2)  # [[1, 2, 3], (30, 40)]\r\nexplanations\r\nin this program, we initial a list: list1 first which\r\ncontains two elements: a list and a tuple.然后对 list1 执行浅拷贝，赋予\r\nlist2。因为浅拷贝里的元素是对原对象元素的引用，因此 list2 中的元素和\r\nlist1 指向同一个列表和元组对象。\r\nnext，list1.append(100). 表示对 list1 的列表新增元素\r\n100。这个操作不会对 list2 产生任何影响，因为 list2 和 list1\r\n作为整体是两个不同的对象，并不共享内存地址。操作过后 list2 不变，list1\r\n会发生改变。\r\nthen，list1[0].append(3) 表示对 list1\r\n中的第一个列表新增元素 3。因为 list2 是 list1 的浅拷贝，list2\r\n中的第一个元素和 list1 中的第一个元素，共同指向同一个列表，因此 list2\r\n中的第一个列表也会相对应的新增元素 3。\r\nat last,\r\nlist1[1] += (50, 60)，因为元组是不可变的，这里表示对 list1\r\n中的第二个元组拼接，然后重新创建了一个新元组作为 list1\r\n中的第二个元素，而 list2 中没有引用新元组，因此 list2 并不受影响。\r\ndeep copy\r\ncode\r\n123456789101112131415import copylist1 = [[1, 2], (30, 40)]list2 = copy.deepcopy(list1)list1.append(100)print(&quot;list1:&quot;,list1)  # [[1, 2], (30, 40), 100]print(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]list1[0].append(3)print(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40), 100]print(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]list1[1] += (50, 60)print(&quot;list1:&quot;,list1)  # [[1, 2, 3], (30, 40, 50, 60), 100]print(&quot;list2:&quot;,list2)  # [[1, 2], (30, 40)]\r\nexplanation\r\njust as the example code above, no matter how the list1 changes,\r\nlist2 remains itself. 因为此时的 list1 和 list2\r\n完全独立，没有任何联系。\r\n特例\r\n如果被深拷贝对象中存在指向自身的引用会怎么样？\r\n1234567import copylist1 = [1]list1.append(list1)print(list1)  # [1, [...]]list2 = copy.deepcopy(list1)print(list2)  # [1, [...]]\r\n此例子中，列表 list1 中有指向自身的引用，因此 list1\r\n是一个无限嵌套的列表。但是当深度拷贝 list1 到 list2\r\n后，程序并没有出现栈溢出的现象。这是为什么呢？\r\n-&gt;因为 deepcopy 会自动维护一个字典，记录已经拷贝的对象与其\r\nID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回。通过查看\r\ndeepcopy 函数实现的源码就会明白：\r\n赋值与拷贝的关系\r\n赋值\r\n只是复制了新对象的引用，不会开辟新的内存空间。\r\n拷贝\r\n创建新对象，具体内容视拷贝类型而定（深浅拷贝）\r\n所以赋值并不会产生一个独立的对象单独存在，只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。\r\n请注意区分浅拷贝与赋值——关键在是否有新对象被创建\r\n示例\r\n赋值操作：\r\n12345a = [1, 2, 3]b = a# a.append(4)# print(b) # [1, 2, 3, 4]\r\n三种浅拷贝操作：\r\n切片操作：\r\n1lst1 = lst[:] 或者 lst1 = [each for each in lst]\r\n工厂函数：\r\n1lst1 = list(lst)\r\ncopy 函数：\r\n1lst1 = copy.copy(lst)\r\n三种，都是浅拷贝\r\n连续赋值\r\n在 python\r\n中是可以使用连续赋值的方式来一次为多个变量进行赋值的(请注意，仍然是“赋值”！)，比如：\r\n12a = b = c = 1a, b, c = 1, 1, 1\r\n这些都可以完成变量的赋值，但是就有一个问题了，比如：\r\n12a = 3a, b = 1, a  # a = 1, b = 3\r\n如果按照正常的思维逻辑，先进行 a = 1，在进行 b = a，最后 b 应该等于\r\n1，但是这里 b 应该等于\r\n3，因为在连续赋值语句中等式右边其实都是局部变量，而不是真正的变量值本身，因此，上面例子中右边的\r\na，在 python 解析的时候，只是把变量 a 的指向的变量 3 赋给 b，而不是 a=1\r\n之后 a 的结果。这里有一个 Leetcode 里链表的例子：\r\n\r\n假如要对一个链表进行翻转，就比如把 1—&gt;2-&gt;3-&gt;4 转化为\r\n4-&gt;3-&gt;2-&gt;1\r\n\r\n对于这个问题很简单，只要反转指针就可以了，假如链表结构为：\r\n1234class ListNode:    def __init__(self, x):        self.val = x        self.next = None1234\r\n我们可以用很简单的三行代码完成这个过程：\r\n12345def reverseList(self, head):        L = ListNode(float(&quot;-inf&quot;))        while head:            L.next, head.next, head = head, L.next, head.next        return L.next12345\r\n这里的 L 是指向一个新建的结点，因为 python\r\n没有指针的概念，所以用一个额外的结点来代替头指针，这里的核心代码就是中间那一行三个变量的连续赋值，如果单独一句句来理解的话，最后肯定是想不通的，在这里，假设\r\nhead 结点是链表串’1-&gt;2-&gt;3-&gt;4’的头结点，先用新的 L 结点的 next\r\n指针指向 head 的第一个结点‘1’，之后将 L.next(第一次也就是空)赋给了 head\r\n的 next 指针，之后再把 head 的 next 指针（注意，这里的 next\r\n指针还是指向‘2’的，而不是空）赋给 head，相当于 next\r\n向前移一位，这一步相当于一个串变成了两个：\r\n\r\nL：‘-inf’-&gt;‘1’\r\nhead：‘2’-&gt;‘3’-&gt;‘4’-&gt;‘5’\r\n\r\n","slug":"Language Learning/Python/Python拷贝与赋值","date":"2022-12-23T04:23:23.000Z","categories_index":"Python,Language Learning","tags_index":"Language Learning,Python","author_index":"JBR_Bunjie"},{"id":"9f9ee0afa6efd648aa340428f380e2d6","title":"requirements.txt in Python project","content":"requirements.txt in Python\r\nproject\r\n写 python\r\n程序的时候，我们经常的会下载很多外部模块，当我们编写完成后，准备在其他设备上部署的时候，那么新设备上需要安装我当前环境下的所有包——非常麻烦\r\n我们可以利用 pip 来生成一个 requirements.txt\r\n的文件，在新环境中通过读取这个文件中的模块名称进行环境的安装\r\n生成 requirements.txt\r\n在项目根目录打开 cmd/powershell\r\n执行\r\n1pip freeze &gt; requirements.txt\r\n例如：\r\n\r\n\r\nimg\r\n\r\n这时候项目根目录就会多一个requirements.txt文件，里面会记录我们项目需要的所以模块信息。具体说明可见：pip freeze - pip\r\ndocumentation v22.0.3 (pypa.io)\r\n\r\n请注意区分当前 terminal 中的 pip 是否和项目所使用的 pip\r\n所一致，terminal 生成的 txt 是根据系统变量中 pip 的所有依赖包来生成 txt\r\n的，可能跟项目实际所使用的有所不同\r\n如果在创建项目都是包全局继承就比较悲剧，但鉴于 requirements.txt\r\n的格式较为简单，在了解后可以尝试手动创建\r\n\r\n使用 requirements.txt\r\n新环境中通过此文件可以直接安装模块（注:需要先切换到\r\nrequirements.txt的上级目录，也就是项目根目录）\r\n在项目根目录下执行\r\n1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt\r\n安装至虚拟环境中命令\r\n进入到了虚拟环境中：切到虚拟环境目录的 Script 文件下\r\n1pip install -r D:\\odoo13\\odoo\\requirements.txt\r\n两个备用镜像源：\r\n阿里 https://mirrors.aliyun.com/pypi/simple\r\n清华 https://pypi.tuna.tsinghua.edu.cn/simple\r\n","slug":"Language Learning/Python/Requirements.txt","date":"2022-12-23T04:23:23.000Z","categories_index":"Python,Language Learning","tags_index":"Language Learning,Python","author_index":"JBR_Bunjie"},{"id":"46c2c3df1cbb91d145ce37d8e3350c78","title":"selenium自动化爬虫","content":"目标：使用\r\nselenium 来解决网页中的大量同质化人工操作内容\r\n零：想好该怎么做：\r\n关于指定网站：\r\n网站是网盘网站，其文件有密码保护，即每个文件都有不同且无规律的受保护地址；同时，这些网页的操作完全重复。\r\n我们可以使用 selenium 来完成自动化代替重复劳动。\r\n关于 selenium\r\n\r\n需要使用浏览器的自动化 driver\r\n需要使用键盘输入模拟模块\r\n需要使用鼠标输入模拟模块\r\n需要事先了解需要操作的网页元素对象的路径\r\n\r\n一、准备工作：将所有需要爬取的地址整合到一个列表里：\r\n12345678910111213141516171819202122import ospath = r&quot;D:\\Project\\Code Trainning\\Learning\\PythonDemo&quot;filename = r&quot;addresslist.txt&quot; # 存储所有网址的文件code = &quot;849227&quot; # 网站文件的密码os.chdir(path)os.getcwd()f = open(file=filename, mode=&#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)FileContent = f.readlines()f.close()AddressList = []t = 1for i in FileContent:    if t % 2 == 0 and t % 4 != 0:        AddressList.append(i)    t = t + 1# for i in AddressList:#     print(i)\r\n二、用 selenium\r\n来打开这些网页并模拟操作：\r\n打开网页：\r\n12345678910111213141516171819from selenium import webdriver # selenium.webdriver模块提供了所有WebDriver的实现from selenium.webdriver.common.keys import Keys # Keys类提供了键盘的代码，用来输入特殊的键盘符（如：回车,ALT,F1等等）\t# 比如，在上条语句输入之后，可以使用Keys.ENTER来模拟输入回车符import timewd = webdriver.Edge(r&quot;D:\\language\\EdgeDriver\\msedgedriver.exe&quot;) # 创建一个Edge浏览器的实例try:    for i in AddressList:        wd.get(i)        …… # 接第二步        time.sleep(60)except Exception as e:    print(e)    # driver.get方法会导向给定的URL的页面，WebDriver会等待页面完全加载完(就是onload函数被触发了)，才把程序的控制权交给你的测试或者脚本。    # 但是！如果 你的页面用了太多的AJAX，那么这个机制将会失效，因为原本完整的页面只占用很小一部分时间，而ajax是“页面完成之后的操作”，selenium根本不知道页面到底是什么时候加载完。就像是requests面对众多ajax存在的网页一样\r\n对网页进行操作\r\n12345678910111213141516171819202122232425262728time.sleep(5) # 最差的实现方式，最好使用隐式等待input_box1 = wd.find_element_by_id(&#x27;passcode&#x27;) # 找到输入boxinput_box1.send_keys(code) # 输入验证码，send_keys函数能模拟大部分的键盘输入，其他的需要Keys类来实现confirm_button1 = wd.find_element_by_xpath(r&quot;/html/body/main/div/div[1]/div/div/div/div[2]/div[2]/button&quot;)confirm_button1.click() # 模拟鼠标电机time.sleep(5) # 如上confirm_button2 = wd.find_element_by_xpath(r&quot;/html/body/main/div/div/div[4]/div[1]/div[2]/button&quot;)confirm_button2.click()time.sleep(180)wd.find_element_by_tag_name(&#x27;body&#x27;).send_keys(Keys.Control + &#x27;t&#x27;) # 模拟组合键&quot;&quot;&quot;显式Waits\t+ 用WebDriverWait结合ExpectedCondition来实现：\t\telement = selenium.webdriver.support.ui.WebDriverWait(wd, 10).unitl(\t\t\tselenium.webdriver.support.expected_conditions.presence_of_located(By.ID, &quot;anyIDisOK&quot;)\t\t)\t\t# 这段代码将会等待10秒，并在等待过程中，每0.5s就调用一下ExpectedCondition，如果成功则立即返回，否则持续重试直到超时报错，报出错误TimeoutException\t+ 显示Wait中有许多预期条件，这样子就无需自己编写expected_condition（见文档隐式Waitsplease forget that，but when I understand，I will c&quot;&quot;&quot;\r\n结束\r\n1wd.close() # 或者 wb.quit()\r\n","slug":"Language Learning/Python/selenium自动化","date":"2022-12-23T04:23:23.000Z","categories_index":"Python,Language Learning","tags_index":"Language Learning,Python","author_index":"JBR_Bunjie"},{"id":"d2b3e77ca5e5c321ffd72dd8a363d797","title":"基本的Python爬虫","content":"基本的Python爬虫\r\n第一步：引入包并准备临时存储数据的列表\r\n12345678910111213141516171819import urllib.requestimport urllib.parseimport requestsfrom bs4 import BeautifulSoupimport reimport random, time # 设置每个网页之间的爬取间隔，防止被ban# import xlwt, xlwings, sqlite3# import selenium# 1.设定爬取网页对象url = &quot;&quot;# 2 准备临时保存数据的列表A = []B = []...# 3 文件保存路径saveAddress = &quot;D:\\\\project\\\\code\\\\python\\\\&quot;# 4 设立序号numnum = 0\r\n第二步：获取网页内容（源代码）\r\n采用urllib\r\n\r\n使用手册：\r\nPython\r\nurllib | 菜鸟教程 (runoob.com)\r\nurllib.request\r\n— Extensible library for opening URLs — Python 3.9.6\r\ndocumentation\r\n简明教程：\r\n\r\n\r\nurllib包内文件设计：\r\n\r\nurllib.request - 打开和读取 URL。它定义了一些打开\r\nURL\r\n的函数和类，包含授权验证、重定向、浏览器\r\ncookies等。\r\nurllib.error - 包含 urllib.request\r\n抛出的异常。\r\nurllib.parse - 解析 URL。\r\nurllib.robotparser - 解析 robots.txt 文件。\r\n\r\n打开一个 URL：\r\nurllib.request.urlopen(url, data=None, [timeout, ], cafile=None,\r\ncapath=None, cadefault=False, context=None)\r\n注意返回值：This function always returns an object which can work as\r\na context\r\nmanager and has the properties url,\r\nheaders, and status.\r\n注意 url 对象：Open the URL url, which can be either a\r\nstring or a Request\r\nobject.\r\n解析 urlopen()的返回值：（注意还要 decode()）\r\nread( [length = number] )\r\nreadline( )\r\nreadlines( [ ] )：返回列表\r\n模拟头部信息（身份伪装）：\r\nurllib.request.Request(url, data=None, headers={},\r\norigin_req_host=None, unverifiable=False, method=None)\r\n如果用到了 Request 对象，自然是直接将 data 放在这里面而不是在\r\nurlopen 里\r\n\r\n\r\n\r\n12345678910111213141516def ask_html(i):\t# 对基础url做处理，拿到新的、需要爬取的实际目标网页url，并在接下来对这个网址做处理\ttempUrl = url + str(i * 25)\t# 伪装user-agent\theaders = &#123;\t\t&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) ......&quot;\t&#125;\t\t# # 用户表单信息\t\t# data = bytes(urllib.parse.urlencode(&#123;&#x27;user_name&#x27;: &#x27;bunjie&#x27;&#125;), encoding=&#x27;utf-8&#x27;)，是urlopen中的data参数，用来发送post请求，否则是get请求\t# 对爬虫身份做封装\tresponse = urllib.request.Request(url=url_now, headers=headers, method=&quot;GET&quot;) # 要发送表单信息的话，请使用POST\t# 进行网页爬取并解码\treq = urllib.request.urlopen(response, timeout=30)\thtml = req.read().decode(&#x27;utf-8&#x27;)\t# 返回目标网页对应的html代码内容\treturn html\r\n采用 requests\r\n\r\n\r\n官方示例：\r\n\r\n\r\n1234567891011&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/user&#x27;, auth=(&#x27;user&#x27;, &#x27;pass&#x27;))&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.headers[&#x27;content-type&#x27;]&#x27;application/json; charset=utf8&#x27;&gt;&gt;&gt; r.encoding&#x27;utf-8&#x27;&gt;&gt;&gt; r.text&#x27;&#123;&quot;type&quot;:&quot;User&quot;...&#x27;&gt;&gt;&gt; r.json()&#123;&#x27;private_gists&#x27;: 419, &#x27;total_private_repos&#x27;: 77, ...&#125;\r\n\r\n\r\n文档：\r\nRequests: HTTP\r\nfor Humans™ — Requests 2.26.0 documentation\r\n(python-requests.org)\r\nRequests: 让\r\nHTTP 服务人类 — Requests 2.18.1 文档 (python-requests.org)\r\n简明教程：\r\n\r\nAPI Reference:\r\n\r\nrequests.get(url,\r\nparams=None, **kwargs)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nParameters:\r\nurl – URL for the new Request\r\nobject.params – (optional) Dictionary, list of\r\ntuples or bytes to send in the query string for the Request.**kwargs\r\n– Optional arguments that request takes.\r\n\r\n\r\n\r\n\r\nReturns:\r\nResponse\r\nobject\r\n\r\n\r\n\r\n\r\n\r\nrequests.post(url,\r\ndata=None, json=None, **kwargs)\r\nSends a POST request.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nParameters:\r\nurl – URL for the new Request\r\nobject.data – (optional) Dictionary, list of\r\ntuples, bytes, or file-like object to send in the body of the Request.json\r\n– (optional) json data to send in the body of the Request.**kwargs\r\n– Optional arguments that request takes.\r\n\r\n\r\n\r\n\r\nReturns:\r\nResponse\r\nobject\r\n\r\n\r\n\r\n\r\n\r\n**kwargs 参数列表:\r\n\r\nparams – (optional) Dictionary, list of tuples or\r\nbytes to send in the query string for the Request.\r\ndata – (optional) Dictionary, list of tuples,\r\nbytes, or file-like object to send in the body of the Request.\r\njson – (optional) A JSON serializable Python object\r\nto send in the body of the Request.\r\nheaders – (optional) Dictionary of HTTP Headers to\r\nsend with the Request.\r\ncookies – (optional) Dict or CookieJar object to\r\nsend with the Request.\r\nfiles – (optional) Dictionary of\r\n'name': file-like-objects (or\r\n&#123;'name': file-tuple&#125;) for multipart encoding upload.\r\nfile-tuple can be a 2-tuple\r\n('filename', fileobj), 3-tuple\r\n('filename', fileobj, 'content_type') or a 4-tuple\r\n('filename', fileobj, 'content_type', custom_headers),\r\nwhere 'content-type' is a string defining the content type\r\nof the given file and custom_headers a dict-like object\r\ncontaining additional headers to add for the file.\r\nauth – (optional) Auth tuple to enable\r\nBasic/Digest/Custom HTTP Auth.\r\ntimeout (float\r\nor tuple)\r\n– (optional) How many seconds to wait for the server to send data before\r\ngiving up, as a float, or a (connect\r\ntimeout, read timeout) tuple.\r\nallow_redirects (bool)\r\n– (optional) Boolean. Enable/disable\r\nGET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to\r\nTrue.\r\nproxies – (optional) Dictionary mapping protocol to\r\nthe URL of the proxy.\r\nverify – (optional) Either a boolean, in which case\r\nit controls whether we verify the server’s TLS certificate, or a string,\r\nin which case it must be a path to a CA bundle to use. Defaults to\r\nTrue.\r\nstream – (optional) if False, the\r\nresponse content will be immediately downloaded.\r\ncert – (optional) if String, path to ssl client\r\ncert file (.pem). If Tuple, (‘cert’, ‘key’) pair.\r\n\r\n\r\n\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637&gt; *class* **`requests`.`Response`**&gt;&gt; The [`Response`](https://docs.python-requests.org/en/latest/api/#requests.Response) object, which contains a server’s response to an HTTP request.&gt;&gt; 1. **content**&gt;&gt; ​\t\tContent of the response, in bytes.&gt;&gt; 2. **text**&gt;&gt;    Content of the response, in unicode.&gt;&gt;    If Response.encoding is None, encoding will be guessed using `charset_normalizer` or `chardet`.&gt;&gt;    The encoding of the response content is determined based solely on HTTP headers, following RFC 2616 to the letter. If you can take advantage of non-HTTP knowledge to make a better guess at the encoding, you should set `r.encoding` appropriately before accessing this property.&gt;&gt; 3. **`url` *= None***&gt;&gt;    Final URL location of Response.&gt;&gt; 4. **`status_code` *= None***&gt;&gt;    Integer Code of responded HTTP Status, e.g. 404 or 200.&gt;&gt; 5. **`request` *= None***&gt;&gt;    The [`PreparedRequest`](https://docs.python-requests.org/en/latest/api/#requests.PreparedRequest) object to which this is a response.&gt;&gt;    You can **check the response** header through this method!&gt;&gt; &gt; When you make a request, Requests makes educated guesses about the encoding of the response based on the HTTP headers. The text encoding guessed by Requests is used when you access **`r.text`**. You can find out what encoding Requests is using, and change it, using the **`r.encoding`** property:&gt; &gt;&gt; &gt; ```python&gt; &gt; &gt;&gt;&gt; r.encoding&gt; &gt; &#x27;utf-8&#x27;&gt; &gt; &gt;&gt;&gt; r.encoding = &#x27;ISO-8859-1&#x27;&gt; &gt; ```\r\n\r\nMake a Request\r\n\r\n\r\n123&gt;&gt;&gt; import requests # first import the module&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/events&#x27;) # get a webpage. In GET requests mode\r\nNow, we have a Response object called r. We can get all the\r\ninformation we need from this object.\r\nmeanwhile, requests’ simple API means that all forms of HTTP request\r\nare as obvious. For example, this is how you make an HTTP POST\r\nrequest:\r\n12&gt;&gt;&gt; r = requests.post(&#x27;https://httpbin.org/post&#x27;, data = &#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)# 我们当热可以在之前就将要发送的数据包data封装好，在post中就可以直接调用了\r\nNice, rights? What about the other HTTP request types: PUT, DELETE,\r\nHEAD and OPTIONS? These are all just as simple:\r\n1234&gt;&gt;&gt; r = requests.put(&#x27;https://httpbin.org/put&#x27;, data = &#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)&gt;&gt;&gt; r = requests.delete(&#x27;https://httpbin.org/delete&#x27;)&gt;&gt;&gt; r = requests.head(&#x27;https://httpbin.org/get&#x27;)&gt;&gt;&gt; r = requests.options(&#x27;https://httpbin.org/get&#x27;)\r\n\r\n\r\nPassing Parameters In\r\nURLs\r\n\r\n\r\nYou often want to send some sort of data in the URL’s query string.\r\nIf you were constructing the URL by hand, this data would be given as\r\nkey/value pairs in the URL after a question mark, e.g.\r\nhttpbin.org/get?key=val. Requests allows you to provide\r\nthese arguments as a dictionary of strings, using the\r\nparams keyword argument. As an example, if you wanted to\r\npass key1=value1 and key2=value2 to\r\nhttpbin.org/get, you would use the following code:\r\n12&gt;&gt;&gt; payload = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;&#125;&gt;&gt;&gt; r = requests.get(&#x27;https://httpbin.org/get&#x27;, params=payload)\r\nYou can see that the URL has been correctly encoded by printing the\r\nURL:\r\n12&gt;&gt;&gt; print(r.url)https://httpbin.org/get?key2=value2&amp;key1=value1\r\nNote that any dictionary key whose value is None will\r\nnot be added to the URL’s query string.\r\n\r\n\r\n第三步：利用 bs 和 re\r\n来对爬取内容做处理\r\nbs4：一级处理（可跳过）\r\n\r\n使用手册：\r\nBeautiful Soup\r\n4.4.0 文档 — Beautiful Soup 4.2.0 中文 文档\r\n简明教程：\r\n\r\n\r\n创建 BeautifulSoup 对象：\r\n将一段文档传入 BeautifulSoup 的构造方法,就能得到一个文档的对象,\r\n可以传入一段字符串或一个文件句柄.\r\n123soup = BeautifulSoup(open(&quot;index.html&quot;)) # 方法一：读取文件soup = BeautifulSoup(&quot;&lt;html&gt;data&lt;/html&gt;&quot;) # 方法二：读取现成、字符串形式的html代码片段\r\n首先,文档被转换成 Unicode,并且 HTML 的实例都被转换成 Unicode 编码\r\n12BeautifulSoup(&quot;Sacr&amp;eacute; bleu!&quot;)&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacré bleu!&lt;/body&gt;&lt;/html&gt;\r\n然后,Beautiful Soup\r\n选择最合适的解析器来解析这段文档,如果手动指定解析器那么 Beautiful Soup\r\n会选择指定的解析器来解析文档.(参考 解析成\r\nXML ).\r\n对文档进行处理：\r\nBeautiful Soup 将复杂 HTML 文档转换成一个复杂的树形结构,每个节点都是\r\nPython 对象,所有对象可以归纳为 4 种: Tag ,\r\nNavigableString , BeautifulSoup ,\r\nComment .\r\nTag：即原文档中的标签，可以通过name和attrs来直接调用对应的名称和属性，请务必注意属性的返回值！我们还可以通过string来调用内容，但是内容不能被直接修改\r\n如果只想得到 tag 中包含的文本内容,那么可以嗲用\r\nget_text() 方法,这个方法获取到 tag\r\n中包含的所有文版内容包括子孙 tag 中的内容,并将结果作为 Unicode\r\n字符串返回\r\nNavigableString：字符串常被包含在 tag\r\n内.Beautiful Soup 用 NavigableString 类来包装 tag\r\n中的字符串，tag 中包含的字符串不能编辑,但是可以被替换成其它的字符串,用\r\nreplace_with()\r\n方法:\r\n\r\n进行文档遍历：低效\r\n文档搜索（√）：\r\n\r\nselect()css 选择器，支持 id(#)，class(.)，tag，父子选择等 css\r\n匹配规则\r\nexample: bs.select(a[class = 'hello!' ])\r\nfind_all()几乎同 select，但是支持了正则表达式\r\nexample: bs.findall('div', class='item') /\r\nbs.find_all(re.compile(\"a\"))\r\n\r\n\r\n\r\n\r\n\r\nre：二级处理（从根本解决问题）\r\n\r\n正则表达式使用手册：\r\n正则表达式\r\n(Web\r\n视图)\r\nre 模块使用手册：\r\nre\r\n模块 (Web\r\n视图)\r\n\r\n1234567891011121314151617181920212223242526272829303132# 全部html代码已经在前面的url处理中完全取得def get_information(html):\tglobal num\tbs = BeautifulSoup(html, &#x27;lxml&#x27;) # 推荐使用lxml作为解析器,因为效率更高.\tfind_movie_address = re.compile(r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;, re.S)\tfind_title = re.compile(r&#x27;&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;&#x27;, re.S)\tfind_more_title = re.compile(r&#x27;&lt;span class=&quot;other&quot;&gt;(.*?)&lt;/span&gt;&#x27;, re.S)\tfor item in bs.find_all(&#x27;div&#x27;, class_=&#x27;item&#x27;):\t\tprint(&#x27;-&#x27;*30)\t\tprint(num + 1)\t\titem = str(item)\t\tmovie_address_data.append(re.findall(find_movie_address, item)[0])\t\tif len(re.findall(find_title, item)) == 2:   # 不是所有影片都有“两个title”的class\t\t\tmovie_title_data.append(re.findall(find_title, item)[0])\t\t\tmovie_traditional_title_data.append(re.findall(find_title, item)[1])\t\telse:\t\t\tmovie_title_data.append(re.findall(find_title, item)[0])\t\t\tmovie_traditional_title_data.append(&#x27; &#x27;)  # 用空格&#x27; &#x27;来代表该电影是中文电影，没有外文“原名”\t\tmovie_more_title_data.append(re.findall(find_more_title, item)[0])\t\ttemp = movie_title_data[num] + movie_traditional_title_data[num] + movie_more_title_data[num]\t\tmovie_title_collection.append(temp)\t\tprint(movie_address_data[num])\t\tprint(movie_title_collection[num])\t\tnum = num + 1\t# 模拟正常浏览网页的停留时间\ttime.sleep(random.random() * 100)\r\n第四步：保存数据\r\n\r\nexcel 表：Python Resources\r\nfor working with Excel - Working with Excel Files in Python\r\n(python-excel.org)\r\nxlwings：Automate Excel with\r\nPython (Open Source and Free) (xlwings.org)\r\n123456789101112# xlwings示例代码：import xlwings as xw#连接到excelworkbook = xw.Book(r&#x27;path/myexcel.xlsx&#x27;)#连接excel文件#连接到指定单元格data_range = workbook.sheets(&#x27;Sheet1&#x27;).range(&#x27;A1&#x27;)#写入数据data_range.value = [1,2,3]#保存workbook.save()\r\n\r\n以上步骤综合即是一个完整的 python 爬虫程序\r\n","slug":"Language Learning/Python/python爬虫","date":"2022-12-23T04:23:23.000Z","categories_index":"Python,Language Learning","tags_index":"Language Learning,Python","author_index":"JBR_Bunjie"},{"id":"54ad4410b8e441eafc3ef2cc6f0cea8f","title":"使用python自动化处理的文件及zipfile模块的介绍","content":"使用python自动化处理的文件及zipfile模块的介绍\r\n使用 Python\r\n解决文件自动化改名和命名\r\n原因：获取压缩文件的实际名称：\r\n压缩文件名称使用了随机字符，而原文件夹作为压缩文件的根目录来保存，为了避免打开压缩文件才能知道打开的到底是哪个文件，需要将压缩文件内的文件夹名复制出来为外部压缩文件改名\r\n采用方案：\r\n解压缩模块：zipfile\r\nofficial site zipfile — Work\r\nwith ZIP archives — Python 3.9.6 documentation\r\n\r\n提取所有压缩文件的实际名称\r\n\r\n文件处理模块：os\r\n\r\n确定实际工作目录\r\n找到所有需要改名的文件并存储\r\n在压缩文件中提取完实际名称后对源文件进行改名\r\n\r\n文字提取模块（正则表达式）：re\r\n\r\n对路径使用正则表达式来处理文件\r\n\r\n程序实例：\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import osimport zipfileimport reos.getcwd()\t\t\t# 等待结果path = r&quot;&quot;\t\t\t# 输入要处理文件的路径os.chdir(path)\t\t# 进入目标目录A = []for i in os.walk(path):    A.append(i)B = A[0][2] # B按顺序存储了需要修改的所有文件，注意A[0][2]的真正含义！# 注意，B可能包含已经修改了的文件，这时有两个方案\t# 1. （通过操作）规避这些文件，单独处理（费时费力，但是可以在一个文件夹下完成所有操作，也符合我个人直觉，毕竟是存在某些文件没有\t# 2. 将这些文件全部复制到新文件夹下保持文件纯净# 采用方案2C = [] # 存储真实名称for i in B:    with zipfile.ZipFile(i, &#x27;r&#x27;) as z:        for i in z.namelist():            C.append(i)        z.close() # 可能会有几百行？_(:з」∠)_，总之，拿下了就行get_name_rule = re.compile(r&quot; &quot;, re.S) # 正则表达式的筛选规则D = []for i in C:\tif re.findall(get_name_rule, i) != []:        D.append(re.findall(get_name_rule, i)[0])&#x27;&#x27;&#x27;E = []rule_extended = re.compile(r&quot; &quot;, re.S)for i in D:    if re.findall(rule_extended, i) != []:    \tE.append(re.findall(rule_extended, i)[0])    else:    \tE.append(i)补充提取，将所有违规字符如&#x27;/&#x27;，&#x27;*&#x27;等全部剔除&#x27;&#x27;&#x27;count = 0for i in B:    temp = E[count] + &quot;.zip&quot; \t# 注意后缀！    os.rename(i, temp)    count = count + 1\r\n有关zipfile的常用方法：\r\n\r\n一看就懂：\r\n123456789import zipfilef = zipfile.ZipFile(&#x27;filename.zip&#x27;, &#x27;w&#x27; ,zipfile.ZIP_DEFLATED)f.write(&#x27;file1.txt&#x27;)f.write(&#x27;file2.doc&#x27;)f.write(&#x27;file3.rar&#x27;)f.close()f = zipfile.ZipFile(&#x27;filename&#x27;)f.extractall()f.close()\r\n1.1 zipfile.ZipFile(file,\r\nmode='r', compression=ZIP_STORED,\r\nallowZip64=True, compresslevel=None, **,\r\nstrict_timestamps=True*)\r\nOpen a ZIP file, where file can be a path to a file (a\r\nstring), a file-like object or a path-like\r\nobject.\r\n\r\nfileName 是没有什么疑问的了。\r\nmode 和一般的文件操作一样,'r'表示打开一个存在的只读 ZIP\r\n文件；'w'表示清空并打开一个只写的 ZIP 文件，或创建一个只写的 ZIP\r\n文件；'a'表示打开一个 ZIP 文件，并添加内容。\r\n\r\n\r\n\r\n\r\nThe mode parameter should be 'r' to read an\r\nexisting file,\r\n'w' to truncate and write a new file,\r\n'x' to exclusively create and write a new file.\r\n\r\nIf mode is 'x' and file refers to an\r\nexisting file, a FileExistsError\r\nwill be raised.\r\n\r\n'a' to append to an existing file,\r\n\r\nIf mode is 'a' and file refers to an\r\nexisting ZIP file, then additional files are added to it.\r\nIf file does not refer to a ZIP file, then a new ZIP archive\r\nis appended to the file. This is meant for adding a ZIP archive to\r\nanother file (such as python.exe).\r\n12345#比如：我有一个new.txt文件a = zipfile.ZipFile(&#x27;new.txt&#x27;, &#x27;a&#x27;) # 此时new.txt文件会被归档，new.txt会被改写为zip文件a.write(&#x27;new.txt&#x27;)a.close()# 并在外侧改写new.txt的后缀为.zip，发现存在是一个正式的.zip文件且存在一个new.txt\r\nIf mode is 'a' and the file does not exist at\r\nall, it is created.\r\n\r\nIf mode is 'r' or 'a', the file\r\nshould be seekable.\r\n\r\n\r\n\r\ncompression 表示压缩格式，可选的压缩格式只有 2\r\n个：ZIP_STORE;ZIP_DEFLATED。ZIP_STORE 是默认的，表示不压缩；ZIP_DEFLATED\r\n表示压缩。\r\nallowZip64 为 True 时，表示支持 64\r\n位的压缩，一般而言，在所压缩的文件大于 2G\r\n时，会用到这个选项；默认情况下，该值为 False，因为 Unix 系统不支持。\r\n\r\n1.2 zipfile.close()\r\n\r\n你写入的任何文件在关闭之前不会真正写入磁盘。\r\n\r\n1.3 zipfile.write(filename[, arcname[,\r\ncompress_type]])\r\n\r\nacrname 是压缩文件中该文件的名字，默认情况下和 filename 一样\r\ncompress_type 的存在是因为 zip\r\n文件允许被压缩的文件可以有不同的压缩类型。\r\n\r\n1.4 zipfile.extractall([path[, member[,\r\npassword]]])\r\n\r\npath 解压缩目录\r\nmember 需要解压缩的文件名儿列表\r\npassword 当 zip 文件有密码时需要该选项\r\n\r\nExtract all members from the archive to the current working\r\ndirectory.\r\npath specifies a different directory to extract to.\r\nmembers is optional and must be a subset of the list returned\r\nby namelist().\r\npwd is the password used for encrypted files.\r\n\r\n\r\n\r\nZipFile.namelist()\r\n\r\n","slug":"Language Learning/Python/使用python解决文件自动化处理的方案及zipfile模块的介绍","date":"2022-12-23T04:23:23.000Z","categories_index":"Python,Language Learning","tags_index":"Language Learning,Python","author_index":"JBR_Bunjie"},{"id":"ab5351d849d735008d49a961e1e5262a","title":"售货员问题","content":"一、题目\r\n\r\n一个售货员必须访问n个城市，恰好访问每个城市一次，并最终回到出发城市。\r\n售货员从城市i到城市j的旅行费用是一个整数，旅行所需的全部费用是他旅行经过的的各边费用之和，而售货员希望使整个旅行费用最低。\r\n（等价于求图的最短哈密尔顿回路问题）令G=(V,\r\nE)是一个带权重的有向图，顶点集V=(v0, v1, ...,\r\nvn-1)。从图中任一顶点vi出发，经图中所有其他顶点一次且只有一次，最后回到同一顶点vi的最短路径。\r\n\r\n二、测试用例\r\n\r\n\r\nimg\r\n\r\n其中1,2,3,4,5代表五个城市。此模型可抽象为图，可用邻接矩阵c表示，如下图所示：\r\n\r\n\r\nimg\r\n\r\n三、动态规划方程\r\n假设从顶点s出发，令d(i,\r\nV)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。\r\n​ 推导：(分情况来讨论)\r\n​ ①当V为空集，那么d()，表示直接从i回到s了，此时\r\n且 \r\n​\r\n②如果V不为空，那么就是对子问题的最优求解。你必须在V这个城市集合中，尝试每一个，并求出最优解。\r\n​ \r\n​ 注：表示选择的城市和城市i的距离，是一个子问题。\r\n​ 综上所述，TSP问题的动态规划方程就出来了：\r\n\r\n\r\nimg\r\n\r\n四、用例分析\r\n现在对问题定义中的例子来说明TSP的求解过程。(假设出发城市是 0城市)\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n这里只画出了d(1,{2,3,4}),由于篇幅有限这里就不画了。\r\n①我们要求的最终结果是d(0,{1,2,3,4}),它表示，从城市0开始，经过{1,2,3,4}之中的城市并且只有一次，求出最短路径.。\r\n②d(0,{1,2,3,4})是不能一下子求出来的，那么他的值是怎么得出的呢？看上图的第二层，第二层表明了d(0,{1,2,3,4})所需依赖的值。那么得出：\r\n\r\n③d(1,{2,3,4})，d(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样也不是一步就能求出来的，它们的解一样需要有依赖，就比如说d(1,{2,3,4})\r\n\r\nd(2,{1,3,4})，d(3,{1,2,4})，d(4,{1,2,3})同样需要这么求。\r\n④按照上面的思路，只有最后一层的，当V为空集时，就可以满足\r\n且 该条件，直接求出dp数组部分的值。\r\n五、数据结构\r\n由上述动态规划公式d(i,V)表示从顶点i出发经过V(是一个点的集合)中各个顶点一次且仅一次，最后回到出发点s的最短路径长度。根据上述给的测试用例有5个城市编号0,1,2,3,4。那么访问n个城市，恰好访问每个城市一次，并最终回到出发城市的嘴短距离可表示为d(0,{1,2,3,4}),那么问题来了我们用什么数据结构表示d(i,V)，这里我们就可二维数据dp[N][M]来表示，N表示城市的个数，M表示集合的数量，即,之所以这么表示因为集合V有个子集。根据测试用例可得出如下dp数组表格：\r\n\r\n\r\nimg\r\n\r\n那么你们可能就有疑问了，为什么这么表示？这里说明一下比如集合{1,2,3,4}为什么用15表示，我们可以把集合中元素看成二进制1的位置（二进制从右开始看），1表示从右开始第一位为1,2表示从又开始第二位为1，所以集合{1,2,3,4}可表示二进制（1111）转化为十进制为15。再举个例子比如集合{1,3}表示为二进制为0101，十进制为5。所以我们求出dp[0][15]（通用表示dp[0][]）就是本题的最终解。\r\n注意：\r\n\r\n对于第y个城市，他的二进制表达为，1&lt;&lt;(y-1)。\r\n对于数字x，要看它的第i位是不是1，那么可以通过判断布尔表达式 (((x\r\n&gt;&gt; (i - 1) ) &amp; 1) == 1或者（x &amp; (1&lt;&lt;(i-1))）!=\r\n0的真值来实现。\r\n由动态规划公式可知，需要从集合中剔除元素。假如集合用索引x表示，要剔除元素标号为i,我们异或运算实现减法，其运算表示为：\r\nx = x ^ (1&lt;&lt;(i - 1))。\r\n\r\n六、最短路径顶点的计算\r\n我们先计算dp[N][M]数组之后，我可以用dp数组来反向推出其路径。其算法思想如下：\r\n比如在第一步时，我们就知道那个值最小，如下图所示：\r\n\r\n\r\nimg\r\n\r\n因为dp[][]数组我们已经计算出来了，由计算可知C01+d(1,{2,3,4})最小，所以一开始从起始点0出发，经过1。接下来同样计算d(1,{2,3,4})\r\n\r\n\r\nimg\r\n\r\n由计算可知C14+d(4,{2,3})所以0---&gt;1----&gt;4，接下来同理求d(4,{2,3})，这里就省略，读者可以自行计算。最终计算出来的路径为：0---&gt;1---&gt;4---&gt;2---&gt;3---&gt;0\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;vector&gt; using namespace std; #define N 5#define INF 10e7#define min(a,b) ((a&gt;b)?b:a) static const int M = 1 &lt;&lt; (N-1);//存储城市之间的距离int g[N][N] = &#123;&#123;0,3,INF,8,9&#125;,               &#123;3,0,3,10,5&#125;,               &#123;INF,3,0,4,3&#125;,               &#123;8,10,4,0,20&#125;,               &#123;9,5,3,20,0&#125;&#125;;//保存顶点i到状态s最后回到起始点的最小距离int dp[N][M];//保存路径vector&lt;int&gt; path; //核心函数，求出动态规划dp数组void TSP()&#123;    //初始化dp[i][0]    for(int i = 0; i &lt; N; i++)        dp[i][0] = g[i][0];        //求解dp[i][j]    for(int j = 1; j &lt; M; j++ ) &#123;        for(int i = 0; i &lt; N; i++ ) &#123;            dp[i][j] = INF;            //如果集和j(或状态j)中包含结点i,则不符合条件退出            if( ((j &gt;&gt; (i-1)) &amp; 1) == 1)                continue;                        for(int k = 1; k &lt; N; k++) &#123;                if( ((j &gt;&gt; (k-1)) &amp; 1) == 0)                    continue;                                if( dp[i][j] &gt; g[i][k] + dp[k][j^(1&lt;&lt;(k-1))] )                    dp[i][j] = g[i][k] + dp[k][j^(1&lt;&lt;(k-1))] ;            &#125;        &#125;    &#125;&#125;//判断结点是否都以访问,不包括0号结点bool isVisited(bool visited[])&#123;    for(int i = 1 ; i&lt;N ;i++)        if(visited[i] == false)            return false;    return true;&#125;//获取最优路径，保存在path中,根据动态规划公式反向找出最短路径结点void getPath()&#123;    //标记访问数组    bool visited[N] = &#123;false&#125;;    //前驱节点编号    int pioneer = 0 ,min = INF, S = M - 1,temp ;    //把起点结点编号加入容器    path.push_back(0);     while(!isVisited(visited))&#123;        for(int i=1; i&lt;N;i++)            if(visited[i] == false &amp;&amp; (S&amp;(1&lt;&lt;(i-1))) != 0)                if(min &gt; g[i][pioneer] + dp[i][(S^(1&lt;&lt;(i-1)))])                    min = g[i][pioneer] + dp[i][(S^(1&lt;&lt;(i-1)))] ;                    temp = i;                    pioneer = temp;        path.push_back(pioneer);        visited[pioneer] = true;        S = S ^ (1&lt;&lt;(pioneer - 1));        min = INF;    &#125;&#125;//输出路径void printPath()&#123;    cout&lt;&lt;&quot;最小路径为：&quot;;    vector&lt;int&gt;::iterator  it = path.begin();    for(it ; it != path.end();it++)        cout&lt;&lt;*it&lt;&lt;&quot;---&gt;&quot;;    //单独输出起点编号    cout&lt;&lt;0;&#125; int main()&#123;    TSP();    cout&lt;&lt;&quot;最小值为：&quot;&lt;&lt;dp[0][M-1]&lt;&lt;endl;    getPath();    printPath();    return 0;&#125;\r\n八、测试结果及性能分析\r\n\r\n\r\nimg\r\n\r\n时间复杂度：\r\n空间复杂度：\r\n旅行商问题（动态规划方法，超级详细的）_仁者乐山智者乐水的博客-CSDN博客_旅行商问题\r\n","slug":"Algorithm/DP/Traveling Salesman Problem","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,DP","author_index":"JBR_Bunjie"},{"id":"991c84bc86acdc32c9243fba302e2655","title":"Hash Function","content":"简明Hash function教程\r\n\r\n请注意！这篇文档是关于散列函数Hash function的，如果需要了解Hash\r\ntable相关内容请查阅“简明Hash table教程”等相关文章\r\n\r\n引子\r\n在各种下载站的资源页面下方，经常会有如下以SHA开头的特殊字段\r\n\r\nSHA1：9B71AD5604B3816BCC7E9AFA3052AE7D823163E8\r\n\r\n或者是或MD5开头的特殊字段\r\n\r\nMD5：124756ef340daf80196b4124686d651c\r\n\r\n这些特殊字段既非下载链接，也特定网址。那么这些特殊的字段都有什么用？\r\n想要解决这个问题，我们需要先了解一下什么是Hash算法\r\nHash算法\r\n什么是Hash？\r\n先简单介绍一下Hash算法\r\n\r\n散列函数（Hash\r\nfunction）又称散列算法、哈希函数，是一种从任何一种数据中创建数字“指纹”的方法。\r\n\r\n\r\n请注意！Hash算法并非特指某一种算法，而是所有满足Hash算法的一整类算法的统称\r\n\r\nHash算法的实际效果为：对任意一组输入数据进行计算处理，并最终得到一个固定长度的输出摘要。\r\n经典的比如经MD5算法运算后的结果只有16位或者32位16进制字符，而SHA-1的结果为40位16进制字符\r\n试着去生成一串Hash Code吧\r\n现在打开你的任何一款ide，通过MD5方法来对你好啊这串字符进行处理，如下是Python对之进行处理的例子\r\n12345678import hashlibstr1 = &quot;你好呀&quot; # 准备Hash算法需要处理的数据块m = hashlib.md5() # 确定特定的Hash算法m.update(str1.encode(&quot;utf8&quot;)) # 执行该算法print(m.hexdigest(), type(m.hexdigest())) # 查验输出结果# python提供了一个build-in function：hash，但是它有点特殊，具体了解可以参照下文：# https://blog.csdn.net/cunchi4221/article/details/107474126\r\n检查一下结果：4f65fdb33e0f2bd0de6bd1b41fdea968 &lt;class 'str'&gt;——一个32个字符，32Byte，128bit大小的字符串，和MD5算法规定的长度完全一致。同时，当我们重复执行这个程序时，我们发现程序最终得到的结果和第一次的结果不变！\r\n是的！更进一步地，当我们的数据和Hash算法确定以后，不管是在本地，还是在别的任何设备上再次执行这串代码，它的结果是不会发生变化的。也就是说，一个既定的输入在既定的Hash算法中只会对应一个特定的输出\r\n根据这个特点，我们可以用某种特定的Hash算法来检验资源的完整性：当用户完成资源的下载后，如果本地资源使用对应的Hash算法得到的Hash\r\ncode与下载网站上给出的Hash\r\ncode不相符的话，就意味着你的本地资源有问题，需要进行修复或者重新下载\r\nHash算法还能干什么？\r\n事实上，Hash\r\nCode被大量使用于网站的密码加密中：当用户注册的时候，用户的密码通过某种Hash算法加密后得到一串Hash\r\nCode，服务器就将Hash\r\nCode代替明文密码存储到服务器的数据库中，用户登陆时输入的密码经过加密会再次得到相同的结果，这当然与数据库中存储的内容一致，这样子就完成了用户的验证。\r\n由于Hash算法是一种有损的压缩运算，即在实时的运算中损失了大部分原始数据，这并不是加密而是摘要，同时也导致得到原数据最直接的方式只有再次输入，想要破解一般只能够依靠穷举。故一般认为Hash算法是不可逆运算，所以即便是服务器数据库泄露也不必担心账号被别人盗取\r\n尝试使用Hash算法，并研究它的输出规律\r\n为了研究Hash算法的输出结果的规律，我们需要几个实例\r\n1234567891011121314151617181920212223242526272829303132333435public class HelloWorld &#123;    public static void main(String []args) &#123;\t\tSystem.out.println(&quot;hello, java&quot;.hashCode());\t\tSystem.out.println(&quot;hello, java&quot;.hashCode()); //相同数据输入，查看结果                System.out.println(&quot;---------------------------&quot;);\t\t\t\tSystem.out.println(&quot;hello, jav&quot;.hashCode());\t\tSystem.out.println(&quot;hello, java&quot;.hashCode());\t\tSystem.out.println(&quot;hello, javav&quot;.hashCode());\t\tSystem.out.println(&quot;AaAaA&quot;.hashCode());  \t\tSystem.out.println(&quot;AaAaAa&quot;.hashCode());\t\tSystem.out.println(&quot;AaAaAaA&quot;.hashCode()); // 不同数据输入，查看结果\t\t        System.out.println(&quot;---------------------------&quot;);\t\t\t\tSystem.out.println(&quot;AaAaAa&quot;.hashCode());\t\tSystem.out.println(&quot;BBAaBB&quot;.hashCode()); // 仍然是不同数据输入，再次查看结果    &#125;&#125;/* outputs：20571445522057144552 // 相同的输入经过散列表算法运算后得到了相同的输出----------------------------15962084872057144552-653028210629841291952508096398208897 // 不同的输入“理所当然”地得到了完全不同的输出---------------------------19525080961952508096 // 不同的输入居然得到了相同的输出！*/\r\n从以上实例中我们可以发现虽然一般的不同字符经过运算后输出的结果是不同的，但是也存在不同字符串在经过运算后得到了相同的输出\r\n特别地，我们将这种两个不同的输入值经过运算后得到了相同的输入值的情况称作是“Hash\r\ncollision”\r\n需要指出的是，发生collision并不可怕，当一个更大的数据集被映射到一个更小的数据集或容器时，一定会出现多对一的情况，这是一件不可避免的事，而算法的优劣只取决于出现collision的频率如何。如果collision出现频次过高，那么就意味着这个Hash算法生成的Hash\r\nCode可以在较短时间内被别人使用穷举等办法来破解其内容——也就是说，它不安全，所以用户需要设置更长更复杂组合的密码，而服务器则需要使用更不容易被破解的Hash算法。\r\n一般来讲输出大小越长的算法，安全性也就越高。只有安全度足够高的Hash算法，即没有任何人能够成功实现碰撞的哈希，才有资格被考虑用在加密场合\r\n\r\n\r\nimage-20210916211845148\r\n\r\n在极限情况下，传统的MD5算法可以保证最多340282366920938463463374607431768211456个数据与结果的一一对应，而SHA-1算法甚至可以保证最多1461501637330902918203684832716283019655932542976个数据，但是由于计算机算力的进步，算法自身的缺陷，现呈的彩虹表等的诸多原因存在，它们已经可以在短时间内被破解，为了保证数据的安全，我们需要使用更安全的Hash算法如SHA-2系列的Hash算法来做数据加密\r\n小结\r\n\r\n什么是Hash算法？\r\n\r\nHash算法，一般译为哈希算法，摘要算法或者散列算法，它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。\r\n\r\n哈希算法的特点？\r\n\r\n相同的输入一定得到相同的输出；\r\n不同的输入大概率得到不同的输出。\r\n\r\n哈希加密的作用：\r\n\r\n完整性校验：MD5，SHA-1\r\n数据加密：SHA-2系列等\r\n\r\n\r\nHash算法是怎么实现的？——以MD5为例\r\nHash算法原理大同小异，大体上的流程包括对原数据块进行切片，再对切片进行细分，并利用每一细分小组的内容按预设算法进行破坏式压缩处理来得到最终的结果，下面以MD5算法为例介绍Hash算法流程\r\n原理概述：\r\nMD5算法先对数据块填充，将不合规的数据标准化。然后进行分组，标准是每512bit为大小分一组。在每一个分组中又进一步划分出16个32位的子分组。设立四个标准幻数，定义四个非线性函数，一个大小为64的常数数组，一个大小为64的位移常量数组。\r\n在计算过程中，根据512位分组的数据进行外循环，在这之中利用每个细分小组进行一轮16次循环一共4轮合64次的内循环。\r\n在单次内部循环中，根据正在进行的轮次运用四个非线性函数中的一个对子分组进行的数据进行处理，将处理的结果与标准幻数相加，并进行下一次循环。当主循环完成时，原标准幻数就与数据紧密联系起来，把所有标准幻数组合到一起，这就是一个基于MD5算法的Hash\r\nCode\r\n\r\n什么是幻数？\r\n不同领域对于幻数这一名称有不同的定义，而MD5中的幻数其实就是在算法中被预设的4个32位的整数，对于一个128位的MD5\r\nHash\r\nCode来说，由4个32位的整数结果彼此组和来得到最终结果貌似是一个不错的选择，而这4个结果就是由这4个标准幻数A,B,C,D根据数据块的内容按照预定算法经过不断演变得到的\r\n\r\n实际使用的标准幻数：\r\n1234A = 0x67452301B = 0xEFCDAB89C = 0x98BADCFED = 0x10325476 \r\n注意，其实这四个标准幻数和ABCD四个字母全无关系，实际生效的只是他们后面的变量值，而这四个值只是被算法规定如此而已也许这也算是一种另类的私货？\r\n详细流程介绍：\r\n填充\r\n首先将原数据进行补长（长度的度量是bits）到一个对512取模的结果为448的数在补长的过程中，我们先在原数据末尾append\r\n\"1\" bit to message，然后再append \"0\" bits until message length in bits ≡\r\n448 (mod 512)\r\n完成了补长之后，利用最后的64位（512-448=64）来记录填充前的长度(append\r\noriginal length in bits mod 264 to message)\r\n当上述两个操作都完成以后，数据的总长度就是512的倍数了\r\n一定要补长(64+1~512)，内容为100…0（如若消息长448，则填充512+64）\r\n计算\r\n首先把结果分割为N个512位的块：Y0，Y1，…（每一个512位块再细分为16个32比特子组）\r\n每个块都进行一次循环，在当前循环中，我们将整个块再次细分为16个32位的子块\r\n在正式开始循环之前，我们还需要这些东西：\r\n\r\n设立四个标准幻数\r\n\r\n\r\n\r\nimage-20210917110650229\r\n\r\n我们无需考究这四个数字的16进制内容有什么含义，但是规律明显得让人不禁发笑\r\n我们分别以ABCD为名设立四个32位的整数变量，A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476，这就是实际使用到的标准幻数\r\n\r\n定义四个非线性函数：\r\n\r\n\r\nimage-20210917103252897\r\n\r\n定义常量数组(正弦函数表)：\r\n12345678910111213for i in range(0, 64)    k[i] = math.floor(math.fabs(math.sin(i + 1)) * (2 ** 32))# 或者直接赋值：k = [     0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,      0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,      0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,      0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,      0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,      0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,      0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,      0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391]\r\n\r\n\r\n和为什么标准幻数被定义成那样子一样，解释为什么常量数组是这些东西的理由也只有“它是被定义成这样子的”。不过常量数组有一个优势：我们可以了解这些数字具体是怎么来的：\r\n你应该已经看见了定义常量数组的第一种（即利用正弦函数实时生成的）办法，这就是这些数据产生的来源。\r\n\r\n\r\n定义位移常量:\r\n1234567# md5转换用到的常量，数据都是算法本身规定的r = [    7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\t5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\t4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\t6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21]\r\n\r\n\r\n事实上：所有常量都是经由算法规定的，毕竟只有经过被“规定”的步骤才能保证结果的一致性\r\n\r\n循环计算\r\n循环分为内层和外层，外层是对512块进行循环，内层则对32位子块进行循环\r\n每次外层循环中，我们共会进行四轮内层循环，每次内层循环我们都会按顺序对单个32位子块进行处理\r\n123456789101112131415161718192021222324for i in outside: # 外层循环    for t in range(0, 64): # 内层总循环        if 0 ≤ i ≤ 15:            f = (b &amp; c) | (~b &amp; d) # 临时变量f，实际上是存储了当前轮次的非线性函数的结果            g = i # 存储当前轮次下的第几次        else if 16 ≤ i ≤ 31:            f = (d &amp; b) | ((~d) &amp; c)            g = (5×i + 1) % 16        else if 32 ≤ i ≤ 47:            f = b ^ c ^ d            g = (3×i + 5) % 16        else if 48 ≤ i ≤ 63:            f = c ^ (b | (~ d))            g = (7×i) % 16        temp = d        d = c        c = b        b = ((a + f + k[i] + w[g]) &lt;&lt; r[i]) + b        # w[g]是当前顺序下的32位数据子块,k[i]是我们已经生成好的常量数组,r[i]则是当前轮次所使用到的左移量        a = temp    A = A + a    B = B + b     C = C + c    D = D + d\r\n每次：一个输入128位，另一个输入512位，结果输出128位，用于下一轮输入\r\n\r\n结果\r\n\r\n1digest = str(A) + str(B) + str(C) + str(D)\r\n//最后一步的输出即为散列结果，共128位。\r\n又如SHA-1等算法原理与MD5大同小异，主要的变化之处在于：增加初始的标准幻数个数，增加循环轮数与参与范围，改变变换的非线性函数等\r\n怎么改进Hash算法？\r\n虽然我们认为哈希算法是一种“有损的压缩运算”，但是其攻击手段并不少，而当今Hash解密网站更是不胜枚举\r\nmd5在线解密破解,md5解密加密\r\n(cmd5.com)\r\n彩虹表\r\nRainbow table -\r\nWikipedia\r\n（总结）密码破解之王：Ophcrack彩虹表(Rainbow\r\nTables)原理详解（附：120G彩虹表下载） (ha97.com)\r\n什么是彩虹表？ - 知乎用户的回答 - 知乎\r\nhttps://www.zhihu.com/question/19790488/answer/19290308\r\n“加盐”(salting)\r\n\r\n给密码加一个随即的前缀或者后缀，然后再进行hash。这个随即的后缀或者前缀成为“盐”。通过加盐，相同的密码经过hash后就可以得到不一样的字符串了。检查用户输入的密码是否正确的时候，我们也还需要这个盐，所以盐一般都是跟hash一起保存在数据库里，或者作为hash字符串的一部分。\r\n盐不需要保密，只要盐是随机的话，查表，彩虹表都会失效。因为攻击者无法事先知道盐是什么，也就没有办法预先计算出查询表和彩虹表。如果每个用户都是使用了不同的盐，那么反向查表攻击也没法成功。\r\n\r\n因为能取得的“最好的结果”，也就是取得加盐后的密码，那究竟哪部分是我们添加的“盐”呢，黑客不知道\r\n下面是另一角度的思考：\r\n\r\n为什么加盐哈希可以抵御彩虹表\r\n彩虹表在生成的过程中，针对的是特定的函数H，H如果发生了改变，则已有的彩虹表数据就完全无法使用。\r\n生成彩虹表需要先预先选定一些口令，再一步步生成。然而如果加盐的话，会导致之前生成的那些口令都没有用了。（正确的口令需要有加了盐的格式），因此可以抵御彩虹表攻击。\r\n\r\n详见：\r\n加盐hash保存密码的正确方式\r\n- D＆G (wooyun.js.org)\r\n彩虹表攻击\r\n- 莫须有- - 博客园 (cnblogs.com)\r\n","slug":"Algorithm/HashFunction/HashFunction","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Hash","author_index":"JBR_Bunjie"},{"id":"e93f281683f5f1e8c6e0ab2a6dab5abb","title":"Noise Generate","content":"噪声 - Noise\r\n\r\nRandomness is needed to make things unpredictable, varied, and appear\r\nnatural. ——catlike coding\r\n\r\n在任何游戏中，噪声都是不可缺少的存在。因此，了解这些噪声的特点、用途以及生成算法都显得十分重要\r\n本文从基于 shader graph 中内置的三种程序化噪声，记录了以下噪声：\r\n\r\nSimple Noise\r\nGradient Noise(Perlin Noise)\r\nVoronoi Noise\r\nValue Noise\r\n\r\n The built-in noise in unity\r\nShaderGraph.\r\n下面，我们试着自己去实现这些噪点算法\r\nHashing\r\n\r\nwe have a process that for any specific input yields a unique and\r\nfixed apparently random output. This is what hash functions are for.\r\n——catlike coding\r\n\r\nHashing Space\r\nValue Noise\r\nPerlin / Gradient Noise\r\nNoise Variants\r\nVoronoi Noise\r\nSimplex Noise\r\n\r\nSimplex noise is a type of gradient noise, but we can also create\r\nvalue noise variants of it. We start with those because they are simpler\r\nand easier to analyze than the gradient variants.\r\n\r\nReference\r\n\r\nUnity\r\nPseudorandom Noise Tutorials (catlikecoding.com)\r\n游戏开发技术杂谈\r\n4：柏林噪声 1 - 知乎 (zhihu.com)\r\n\r\n","slug":"Algorithm/NOISE/Noise","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Noise","author_index":"JBR_Bunjie"},{"id":"120c49bf67650504f15740668777cd42","title":"Heap Sort - 堆排序","content":"Heap Sort - 堆排序\r\nReference：\r\n\r\nRecommend：堆排序之JAVA实现月光下一只赏月的猪的博客-CSDN博客java\r\n堆排序\r\n（高效率排序算法三）堆排序_送人玫瑰手留余香的博客-CSDN博客_堆排序效率\r\n1.7 堆排序 |\r\n菜鸟教程 (runoob.com)\r\n\r\nDetail：\r\n\r\n两个定义：\r\n\r\n\r\n大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；\r\n小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；\r\n\r\n\r\n步骤描述：\r\n\r\n\r\n\r\n创建一个堆 H[0……n-1]；\r\n把堆首（最大值）和堆尾互换；\r\n把堆的尺寸缩小 1，并调用\r\nshift_down(0)，目的是把新的数组顶端数据调整到相应位置；\r\n重复步骤 2，直到堆的尺寸为 1。\r\n\r\n\r\n\r\n分析：\r\n\r\n堆排序的平均时间复杂度为 Ο(nlogn)。\r\nCode：\r\nCode - JavaScript\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123;   // 建立大顶堆    len = arr.length;    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;        heapify(arr, i);    &#125;&#125;function heapify(arr, i) &#123;     // 堆调整    var left = 2 * i + 1,        right = 2 * i + 2,        largest = i;    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;        largest = left;    &#125;    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;        largest = right;    &#125;    if (largest != i) &#123;        swap(arr, i, largest);        heapify(arr, largest);    &#125;&#125;function swap(arr, i, j) &#123;    var temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;function heapSort(arr) &#123;    buildMaxHeap(arr);    for (var i = arr.length-1; i &gt; 0; i--) &#123;        swap(arr, 0, i);        len--;        heapify(arr, 0);    &#125;    return arr;&#125;\r\nCode - Python\r\n123456789101112131415161718192021222324252627282930def buildMaxHeap(arr):    import math    for i in range(math.floor(len(arr)/2),-1,-1):        heapify(arr,i)def heapify(arr, i):    left = 2*i+1    right = 2*i+2    largest = i    if left &lt; arrLen and arr[left] &gt; arr[largest]:        largest = left    if right &lt; arrLen and arr[right] &gt; arr[largest]:        largest = right    if largest != i:        swap(arr, i, largest)        heapify(arr, largest)def swap(arr, i, j):    arr[i], arr[j] = arr[j], arr[i]def heapSort(arr):    global arrLen    arrLen = len(arr)    buildMaxHeap(arr)    for i in range(len(arr)-1,0,-1):        swap(arr,0,i)        arrLen -=1        heapify(arr, 0)    return arr\r\n","slug":"Algorithm/SORT/Heap Sort","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Sort","author_index":"JBR_Bunjie"},{"id":"0d08c32366a524bf34b2dc2c2fb0333a","title":"Boyer Moore Algorithm","content":"Boyer Moore Algorithm\r\nGeneral\r\n高效，可靠，应用广泛：各种文本编辑器的\"查找\"功能（Ctrl+F），大多采用Boyer-Moore算法\r\n1977年，德克萨斯大学的Robert S. Boyer教授和J Strother\r\nMoore教授发明了这种算法。\r\nDetail\r\n\"坏字符规则\"\r\n\r\n后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置\r\n\r\n如果\"坏字符\"不包含在搜索词之中，则上一次出现位置为 -1。\r\n\"好后缀规则\"\r\n\r\n后移位数 = 好后缀的(最后)位置 - 后缀(在搜索词中)的上一次出现位置\r\n\r\n注意点：\r\n\r\n\"好后缀\"的位置以最后一个字符为准。假定\"ABCDEF\"的\"EF\"是好后缀，则它的位置以\"F\"为准，即5（从0开始计算）\r\n如果\"好后缀\"在搜索词中只出现一次，则它的上一次出现位置为\r\n-1。比如，\"EF\"在\"ABCDEF\"之中只出现一次，则它的上一次出现位置为-1（即未出现）\r\n如果\"好后缀\"有多个，则除了最长的那个\"好后缀\"，其他\"好后缀\"的上一次出现位置必须在头部。比如，假定\"BABCDAB\"的\"好后缀\"是\"DAB\"、\"AB\"、\"B\"，请问这时\"好后缀\"的上一次出现位置是什么？回答是，此时采用的好后缀是\"B\"，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个\"好后缀\"只出现一次，则可以把搜索词改写成如下形式进行位置计算\"(DA)BABCDAB\"，即虚拟加入最前面的\"DA\"\r\n\r\nCode\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public static int pattern(String pattern, String target) &#123;    int tLen = target.length();//主串的长度    int pLen = pattern.length();//模式串的长度\t//如果模式串比主串长，没有可比性，直接返回-1    if (pLen &gt; tLen) &#123;        return -1;    &#125;    int[] bad_table = build_bad_table(pattern);// 获得坏字符数值的数组，实现看下面    int[] good_table = build_good_table(pattern);// 获得好后缀数值的数组，实现看下面    for (int i = pLen - 1, j; i &lt; tLen;) &#123;        System.out.println(&quot;跳跃位置：&quot; + i);        //这里和上面实现坏字符的时候不一样的地方，我们之前提前求出坏字符以及好后缀        //对应的数值数组，所以，我们只要在一边循环中进行比较。还要说明的一点是，这里        //没有使用skip记录跳过的位置，直接针对主串中移动的指针i进行移动        for (j = pLen - 1; target.charAt(i) == pattern.charAt(j); i--, j--) &#123;            if (j == 0) &#123;//指向模式串的首字符，说明匹配成功，直接返回就可以了                System.out.println(&quot;匹配成功，位置：&quot; + i);                //如果你还要匹配不止一个模式串，那么这里直接跳出这个循环，并且让i++                //因为不能直接跳过整个已经匹配的字符串，这样的话可能会丢失匹配。//\t\t\t\t\ti++;   // 多次匹配//\t\t\t\t\tbreak;                return i;            &#125;        &#125;        //如果出现坏字符，那么这个时候比较坏字符以及好后缀的数组，哪个大用哪个        i += Math.max(good_table[pLen - j - 1], bad_table[target.charAt(i)]);    &#125;    return -1;&#125;//字符信息表public static int[] build_bad_table(String pattern) &#123;    final int table_size = 256;//上面已经解释过了，字符的种类    int[] bad_table = new int[table_size];//创建一个数组，用来记录坏字符出现时，应该跳过的字符数    int pLen = pattern.length();//模式串的长度    for (int i = 0; i &lt; bad_table.length; i++) &#123;        bad_table[i] = pLen;          //默认初始化全部为匹配字符串长度,因为当主串中的坏字符在模式串中没有出        //现时，直接跳过整个模式串的长度就可以了    &#125;    for (int i = 0; i &lt; pLen - 1; i++) &#123;        int k = pattern.charAt(i);//记录下当前的字符ASCII码值        //这里其实很值得思考一下，bad_table就不多说了，是根据字符的ASCII值存储        //坏字符出现最右的位置，这在上面实现坏字符的时候也说过了。不过你仔细思考        //一下，为什么这里存的坏字符数值，是最右的那个坏字符相对于模式串最后一个        //字符的位置？为什么？首先你要理解i的含义，这个i不是在这里的i，而是在上面        //那个pattern函数的循环的那个i，为了方便我们称呼为I，这个I很神奇，虽然I是        //在主串上的指针，但是由于在循环中没有使用skip来记录，直接使用I随着j匹配        //进行移动，也就意味着，在某种意义上，I也可以直接定位到模式串的相对位置，        //理解了这一点，就好理解在本循环中，i的行为了。\t\t//其实仔细去想一想，我们分情况来思考，如果模式串的最        //后一个字符，也就是匹配开始的第一个字符，出现了坏字符，那么这个时候，直        //接移动这个数值，那么正好能让最右的那个字符正对坏字符。那么如果不是第一个        //字符出现坏字符呢？这种情况你仔细想一想，这种情况也就意味着出现了好后缀的        //情况，假设我们将最右的字符正对坏字符        bad_table[k] = pLen - 1 - i;    &#125;    return bad_table;&#125;//匹配偏移表public static int[] build_good_table(String pattern) &#123;    int pLen = pattern.length();//模式串长度    int[] good_table = new int[pLen];//创建一个数组，存好后缀数值    //用于记录最新前缀的相对位置，初始化为模式串长度，因为意思就是当前后缀字符串为空    //要明白lastPrefixPosition 的含义    int lastPrefixPosition = pLen;    for (int i = pLen - 1; i &gt;= 0; --i) &#123;        if (isPrefix(pattern, i + 1)) &#123;        //如果当前的位置存在前缀匹配，那么记录当前位置            lastPrefixPosition = i + 1;        &#125;        good_table[pLen - 1 - i] = lastPrefixPosition - i + pLen - 1;    &#125;    for (int i = 0; i &lt; pLen - 1; ++i) &#123;    //计算出指定位置匹配的后缀的字符串长度        int slen = suffixLength(pattern, i);        good_table[slen] = pLen - 1 - i + slen;    &#125;    return good_table;&#125;//前缀匹配private static boolean isPrefix(String pattern, int p) &#123;    int patternLength = pattern.length();//模式串长度    //这里j从模式串第一个字符开始，i从指定的字符位置开始，通过循环判断当前指定的位置p    //之后的字符串是否匹配模式串前缀    for (int i = p, j = 0; i &lt; patternLength; ++i, ++j) &#123;        if (pattern.charAt(i) != pattern.charAt(j)) &#123;            return false;        &#125;    &#125;    return true;&#125;//后缀匹配private static int suffixLength(String pattern, int p) &#123;    int pLen = pattern.length();    int len = 0;    for (int i = p, j = pLen - 1; i &gt;= 0 &amp;&amp; pattern.charAt(i) == pattern.charAt(j); i--, j--) &#123;        len += 1;    &#125;    return len;&#125;\r\nReference\r\n\r\n字符串匹配的Boyer-Moore算法\r\n- 阮一峰的网络日志 (ruanyifeng.com)\r\n不用找了，学习BM算法，这篇就够了（思路+详注代码）_BoCong-Deng的博客-CSDN博客_bm算法\r\n\r\n","slug":"Algorithm/String Processing/Boyer Moore Algorithm","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,String Processing","author_index":"JBR_Bunjie"},{"id":"3300e6e8edea21eb33ad89b2150bf9cc","title":"R&K Algorithm","content":"Rabin–Karp algorithm -\r\n拉宾-卡普算法\r\n拉宾-卡普算法（英語：Rabin–Karp\r\nalgorithm）或卡普-拉宾算法（Karp–Rabin algorithm）\r\nGeneral\r\nRabin-Karp\r\n算法是由 Richard M.\r\nKarp和 Michael O.\r\nRabin创建的字符串搜索算法\r\nKR Algorithm使用散列来查找文本中的一组模式字符串中的任何一个。\r\nDetail\r\n假设我们有一个文本： yeminsajid\r\n，我们想知道文本中是否存在模式 nsa\r\n。要计算散列和滚动散列，我们需要使用素数。这可以是任何素数。让我们在这个例子中使用\r\nprime = 11\r\n。我们将使用以下公式确定哈希值：\r\n1(1st letter) X (prime) + (2nd letter) X (prime)¹ + (3rd letter) X (prime)² X + ......\r\n我们将表示：\r\n123456a -&gt; 1    g -&gt; 7    m -&gt; 13   s -&gt; 19   y -&gt; 25b -&gt; 2    h -&gt; 8    n -&gt; 14   t -&gt; 20   z -&gt; 26c -&gt; 3    i -&gt; 9    o -&gt; 15   u -&gt; 21d -&gt; 4    j -&gt; 10   p -&gt; 16   v -&gt; 22e -&gt; 5    k -&gt; 11   q -&gt; 17   w -&gt; 23f -&gt; 6    l -&gt; 12   r -&gt; 18   x -&gt; 24\r\nnsa 的哈希值为 ： \r\n现在我们找到文本的滚动哈希值。如果滚动哈希与模式的哈希值匹配，我们将检查字符串是否匹配。因为我们的模式有\r\n3 个字母，我们将采取 1 日 3 封\r\nYEM 从我们的文本，并计算哈希值。我们得到： \r\n此值与我们的模式的哈希值不匹配。所以字符串在这里不存在。现在我们需要考虑下一步。计算下一个字符串\r\nemi\r\n的哈希值。我们当然可以直接重新从。但这将是相当微不足道的，并且会花费更多。相反，我们使用另一种技术。\r\n\r\n我们从当前哈希值中减去 Previous String 中的\r\n第一个字母的 即 y\r\n的值。即：1653 - 25 = 1628。\r\n再次除以设定的素数 prime——11，可得：1628 / 11 =\r\n148`。\r\n最后加上新的字母 *（素数）^ m -\r\n1，可得：148 + 9 X 11² = 1237。\r\n\r\n新的哈希值不等于我们的模式哈希值。继续前进直到 a\r\n(nsa)，有：\r\n12345678Previous String: insFirst Letter of Previous String: i(9)New Letter: a(1)New String: \"nsa\"------------------------------2462 - 9 = 24532453 / 11 = 223223 + 1 X 11² = 344\r\n这是一个匹配！\r\n现由于两个字符串都匹配，因此匹配字符串存在于目标字符串中，现在我们只需要返回目标字符串匹配字段的起始位置即可。\r\nCode\r\nKR - JS\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @param {string} haystack * @param {string} needle * @return {number} *//**//** * @param {string} haystack * @param {string} needle * @return {number} */var strStr = function(haystack, needle){    if(needle.length == 0) return 0;    let n = haystack.length;    let m = needle.length;    let s = ' '+haystack;    let t = ' '+needle;        //String添加一个重新确定字符值得方法    String.prototype.newCode = function(){        return this.charCodeAt()-97+1;    }    //确定模数 尽量避免冲突    let p = 999991, d = 131;    //计算thash    let tHash = 0;    for(let i=1; i&lt;=m; i++){        tHash = (tHash*d + t[i].newCode()) % p;    }    //计算sHash子串的值    let sHash = new Array(n+1);    sHash[0] = 0;    for(let i=1; i&lt;=n; i++){        sHash[i] = (sHash[i-1]*d + s[i].newCode()) % p;    }       //hello ll    for(let i=m; i&lt;=n; i++){        if(calcHash(i-m, i, m) == tHash){            return i-m;        }    }    return -1;    function calcHash(l, r, len){        //_hello  求ll的hash        //先求_hell的hash, 再求_he的hash进行补位        //_hell - _he00 就是ll        //注意相减的时候为避免负数，可以先加上模数。再取模        return (sHash[r] - (sHash[l]*myPow(d, len, p))%p + p) % p;    }}function myPow(x,n, m){    function helper(x,n){        if(n==0) return 1.0;        let y = helper(x, n/2 | 0);        return n%2 ==0 ? (y*y)%m: (y*y*x)%m;    }    return n&gt;=0? helper(x, n) : 1.0/helper(x, n);}\r\nReference\r\n\r\nRabin-Karp\r\n算法简介 | 他山教程，只选择最优质的自学材料 (tastones.com)\r\n28.\r\n实现 strStr() 题解 - 力扣（LeetCode） (leetcode-cn.com)\r\n\r\n","slug":"Algorithm/String Processing/KR&RK","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,String Processing","author_index":"JBR_Bunjie"},{"id":"53896b079468d4c41963b2300dea196e","title":"KMP","content":"KMP算法\r\nKMP算法作用简介：\r\n在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。\r\nKMP算法原理：\r\n1.前缀与后缀\r\n\r\n几个必须明确的概念：前缀、后缀、相同前缀后缀的最大长度（为表述方便，下文均用公共最大长指代）\r\n\r\nabcdef的前缀：a、ab、abc、abcd、abcde（注意：abcdef不是前缀）\r\nabcdef的后缀：f、ef、def、cdef、bcdef（注意：abcdef不是后缀）\r\nabcdef的公共最大长：0（因为其前缀与后缀没有相同的）\r\nababa的前缀：a、ab、aba、abab\r\nababa的后缀：a、ba、aba、baba\r\nababa的公共最大长：3（因为他们的公共前缀后缀中最长的为aba，长度3）\r\n\r\n\r\n2.确定PMT (Partial Match\r\nTable)\r\n\r\n\"部分匹配值\"就是\"前缀\"和\"后缀\"的最长的共有元素的长度。以\"ABCDABD\"为例，\r\n\r\n\"A\"的前缀和后缀都为空集，共有元素的长度为0；其value为\r\n\"AB\"的前缀为[A]，后缀为[B]，共有元素的长度为0；　　\r\n\"ABC\"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；　　\r\n\"ABCD\"的前缀为[A, AB, ABC]，后缀为[BCD, CD,\r\nD]，共有元素的长度为0；　　\r\n\"ABCDA\"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA,\r\nA]，共有元素为\"A\"，长度为1；　　\r\n\"ABCDAB\"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB,\r\nAB, B]，共有元素为\"AB\"，长度为2；　　\r\n\"ABCDABD\"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD,\r\nCDABD, DABD, ABD, BD, D]，共有元素的长度为0。\r\n\r\n\r\n得表：\r\n\r\n\r\nimg\r\n\r\nKMP算法的Python实现：\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        def KMP(s, p):            &quot;&quot;&quot;            s 为主串            p 为模式串            如果 t 里有 p，返回打头下标            &quot;&quot;&quot;            nex = getNext(p)            i = 0            j = 0   # 分别是 s 和 p 的指针            while i &lt; len(s) and j &lt; len(p):                if j == -1 or s[i] == p[j]: # j == -1 是由于 j = next[j]产生                    i += 1                    j += 1                else:                    j = nex[j]            if j == len(p): # j 走到了末尾，说明匹配到了                return i - j            else:                return -1        def getNext(p):            &quot;&quot;&quot;            p 为模式串            返回 next 数组，即部分匹配表            &quot;&quot;&quot;            nex = [0] * (len(p) + 1)            nex[0] = -1            i = 0            j = -1            while i &lt; len(p):                if j == -1 or p[i] == p[j]:                    i += 1                    j += 1                    nex[i] = j     # 这是最大的不同：记录next[i]                else:                    j = nex[j]            return nex                return KMP(haystack, needle)\r\nReference\r\n\r\n字符串匹配的KMP算法\r\n- 阮一峰的网络日志 (ruanyifeng.com)\r\n如何更好地理解和掌握 KMP 算法? - 白鱼咸蛋笨大的回答 - 知乎\r\nhttps://www.zhihu.com/question/21923021/answer/642165149\r\n如何更好地理解和掌握 KMP 算法? - 海纳的回答 - 知乎\r\nhttps://www.zhihu.com/question/21923021/answer/281346746\r\n(第一个示例比较特殊)\r\n\r\n","slug":"Algorithm/String Processing/KMP","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,String Processing","author_index":"JBR_Bunjie"},{"id":"4bbde60d3dafb255adad1c9293392efa","title":"全排列","content":"光照模型特点概括：\r\n首先，分析一下所谓的 日式卡通渲染 都有些什么特点：\r\n\r\n硬过渡亮暗面\r\n描边\r\n\r\n\r\n因此，其可采用的具体的表现形式有：\r\n\r\n裁边漫反射 - StepDiffuse\r\n裁边高光\r\n裁边边缘光\r\n裁边视角光\r\n裁边光源光\r\n\r\n裁边漫反射\r\n卡通渲染里希望存在明快的色调对比，而不希望存在额外的过渡光照信息：\r\n在实际执行中，我们使用：\r\n12345678910float NL = dot(N, L);// 传统Lambert漫反射// traditionalDiffuse = _ObjectColor.rgb * _ColorTint_rgb * max(0, NL);// 进行映射以增大光照区域，当然也会方便后续可能的RampTexture取样float NL01 = NL * 0.5 + 0.5;float Threshold = step(_LightThreshold, NL01);diffuse = lerp(DarkSide, BrightSide, Threshold);\r\n来改写传统的漫反射光照，这样我们就能得到如下效果：\r\n 裁边漫反射结果示意\r\n当然，我们也可以尝试在明暗交界线上做出特殊效果：\r\n12345NL01 = smoothstep(0, _Smooth, NL01 - _SmoothRange);// 我们也可以用Step的结果加上traditional diffuse的结果来做出类似smooth step的效果，但是这样就达不到可控交界线位置的效果了// https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-smoothstepfloat Threshold = step(_LightThreshold, NL01);\r\n裁边高光\r\n在传统的 BlinPhong 高光中，我们的光照计算公式为：\r\n\\[\r\nresult = pow(NH, \\_Exp) * SpecularScale\r\n\\]\r\n而为了裁边，我们会改用这样的计算：\r\n\\[\r\nNH = pow(NH, \\_Exp)\\\\\\\\\r\nresult = step(1 - \\_StepSpecularWidth * 0.01, NH)*SpecularIntensity;\r\n\\]\r\n改写的基本思路为：使用额外的宽度控制参数的情况下，利用 step\r\n函数对整个结果进行裁剪。在完成裁剪后，最后使用一个 Intensity\r\n参数来控制最终 specular\r\n呈现的值，这个值不会改变高光的范围，只会改变高光的具体数值，这会对我们的后续处理(如果存在的话)产生影响。\r\n后面的大多数裁边算法的思路与裁剪高光的思路大体相同。\r\n裁边边缘光\r\n传统边缘光使用下方的计算方法，这会存在一个明显的明暗过渡：\r\n\\[\r\nfloat3\\space Rim = pow(1-NV,RimExp)*RimIntensity;\r\n\\]\r\n因此我们使用一种和裁边高光相似的算法来改写这个过程：\r\n\\[\r\nRim = step(1 - \\_RimWidth * 0.01, 1 - NV) * RimIntensity;\r\n\\]\r\n当然，我们可能还会对边缘光做很多额外的处理，比如在某种情况下，我们只希望物体上存在亮部相关的边缘光，那么我们可以：\r\n\\[\r\ndiffuse = dot(N, L)\\\\\\\\\r\nRim = step(1 - \\_RimWidth * 0.01, 1 - NV) * RimIntensity;\\\\\\\\\r\nBrightSideRim = lerp(0, Rim, diffuse)\r\n\\]\r\n这种实现所得到的结果类似于菲涅尔效果，这里也给出菲涅尔的实现（可参考入门精要\r\n10.1.5 节）：\r\nSchlick 菲涅尔近似等式：\r\n\\[\r\nF_{Schlick}(\\overrightarrow v,\\space \\overrightarrow n) = F_0 + (1 -\r\nF_0)(1 - \\overrightarrow v \\cdot \\overrightarrow n)\r\n\\]\r\n其中，F0是一个反射系数，这回是一个常数，一般我们会将它暴露出来以方便调整；v是视角方向；n是表面法线\r\nEmpricial 菲涅尔近似等式：\r\n\\[\r\nF_{Empricial}(\\overrightarrow v,\\space \\overrightarrow n) = max(0,\r\nmin(1,\\space bias + scale \\times (1- \\overrightarrow v \\cdot\r\n\\overrightarrow n)^{power}))\r\n\\]\r\nbias，scale，power 都是控制项\r\n从以上不难看出，菲涅尔其实也可以被归为一种边缘光，而边缘光的核心就是：1\r\n- NV\r\n裁边视角光\r\n为了使眼睛看到的部分更亮而被运用的光。传统的视角光的计算是：\r\n\\[\r\nViewLight = pow(NV,\\space ViewLightExp)*ViewLightIntensity;\r\n\\]\r\n我们仍然采用雷同高光的做法：\r\n\\[\r\nViewLight = step(1 - \\_ViewLightWidth,\\space NV)*ViewLightIntensity;\r\n\\]\r\n裁边光源光\r\n裁边光源光对 NL 做\r\nStep，这意味着其结果与视角无关，仅与法线与光方向相关。这种\r\n光源光 可以算作 视角光\r\n的一种，只是光源方向和视角方向重合了\r\n\\[\r\nStepLight = step(1-StepLightWidth,\\space NL);\r\n\\]\r\n关于裁光边缘的锯齿，我们也需要作出处理：涂月观 (tuyg.top)\r\nOutline\r\nOutline 的实现方式\r\nOutline 有多种实现方式，入门精要中提到过这么几种：\r\n\r\n基于观察角度和表面法线的轮廓线渲染：使用视角方向和表面法线的点乘结果来得到轮廓信息\r\n过程式几何轮廓线渲染：使用两个 Pass 来进行构建：第一个 Pass\r\n用来渲染背面的面片，并利用诸如顶点扩张等手法来使这些面片可见；第二个面片则用来渲染正面。这是大多数情况下的做法\r\n基于图像处理的轮廓线渲染：直接利用后处理来完成\r\n基于轮廓检测的轮廓线渲染：专用于需要精确检测出边缘并直接渲染它们以达到强烈的风格化效果的情况。利用一些特殊的判别式来确定轮廓线\r\n\r\n第二类中，我们一般采用背面法线外扩的方式，这是基于模型的：我们一般先沿法线方向挤出顶点。但是这个方法有较大的限制，如果盲目地进行，可能会出现各种问题，比如：转折处大的或者硬表面会经常发生断裂，内凹的模型在描边后正面的面片被背面的面片遮挡等问题。\r\n\r\n需要明确的是，平滑与平整是完全不同的\r\n\r\n还是入门精要，书中共用到了两种描边方式：一种是后处理时，通过边缘检测来描边，另一种是背部法线扩张。事实上，单是这两种方法就能实现很不错的效果。我们逐个开始：\r\n后处理边缘检测\r\n\r\n核心内容基本对应入门精要 12.3 节\r\n\r\n利用基于卷积的边缘检测，可以实现对剧烈变化的图像区块进行描边\r\n\r\n\"入门精要：...如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，我们就会认为他们之间应该有一条边界，这样的相邻像素之间的差值可以用梯度(Gradient)来表示...\"\r\n\r\n\r\n什么是卷积？\r\n\r\n3blue1brown: 【官方双语】那么……什么是卷积？_哔哩哔哩_bilibili\r\n\r\n\r\n入门精要：\r\n卷积操作是指，使用一个卷积核，对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形网络结构，该区域对每个方格都有一个权重值，当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置在像素上，并在翻转核之后再依次计算核中每个元素的每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。\r\n\r\n\r\n边缘检测的卷积核被称为边缘检测算子，常用的边缘检测算子有：\r\n$$ Roberts: Gx =\r\n\\[\\begin{bmatrix}\r\n-1 &amp; 0\\\\\r\n0 &amp; 1\r\n\\end{bmatrix}\\]\r\n; Gy=\r\n\\[\\begin{bmatrix}\r\n-1 &amp; 0\\\\\r\n0 &amp; 1\r\n\\end{bmatrix}\\]\r\n\\\\\r\nPrewitt: Gx =\r\n\\[\\begin{bmatrix}\r\n-1 &amp; 0 &amp; 1\\\\\r\n-1 &amp; 0 &amp; 1\\\\\r\n-1 &amp; 0 &amp; 1\r\n\\end{bmatrix}\\]\r\n\\[\\begin{bmatrix}\r\n-1 &amp; -1 &amp; -1\\\\\r\n0 &amp; 0 &amp; 0\\\\\r\n1 &amp; 1 &amp; 1\r\n\\end{bmatrix}\\]\r\n\\\\\r\nSobel: Gx =\r\n\\[\\begin{bmatrix}\r\n-1 &amp; 0 &amp; 1\\\\\r\n-2 &amp; 0 &amp; 2\\\\\r\n-1 &amp; 0 &amp; 1\r\n\\end{bmatrix}\\]\r\n\\[\\begin{bmatrix}\r\n-1 &amp; -2 &amp; -1\\\\\r\n0 &amp; 0 &amp; 0\\\\\r\n1 &amp; 2 &amp; 1\r\n\\end{bmatrix}\\]\r\n$$\r\n当我们进行卷积运算时，我们需要对每个像素分别使用 Gx 和 Gy\r\n两个卷积核，进行两次卷积操作。之后我们会得到两个方向上的梯度值。再整合这两者就可以得到整体的梯度值：\r\n$$ G=\r\n$$\r\n这个梯度值越大，说明当前位置像素周围的颜色变化越剧烈，就越有可能是图像的边缘。\r\n在 Built-in\r\n管线中，我们可以直接通过向场景中的摄像机挂载脚本，通过调用OnRenderImage方法来实现后处理系统，但是\r\nURP 中，我们则需要使用系统提供的 Render Feature\r\n来完成这件事。具体实现可参考：unity urp 14\r\nrender feature 实现简单后处理系统 - 知乎 (zhihu.com)\r\n对新手而言，在 Render Feature 下有几个要点需要指明：\r\n脚本结构：\r\n\r\n快速创建 Render Feature\r\n的脚本模板：Asserts-&gt;Create-&gt;Rendering-&gt;Universal Render\r\nPipeline-&gt;Renderer Feature\r\nUnity\r\n中 URP 管线实现后处理的几种方式 (068089dy.github.io)\r\n\r\n具体流程为，构造一个继承ScriptableRendererFeature的主类，并在这之中或者引用别处的自定义ScriptableRenderPass，实现其中的部分方法。\r\n12345678910111213141516class custom : ScriptableRendererFeature &#123;    ...    public override void Create() &#123;        throw new System.NotImplementedException();    &#125;    ...    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) &#123;        throw new System.NotImplementedException();    &#125;    class RenderOutlinePass : ScriptableRenderPass &#123;    \tpublic override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) &#123;            throw new System.NotImplementedException();        &#125;    &#125;&#125;\r\n脚本一般流程：\r\n在当前的 Universal Renderer Data\r\n下挂载好了对应的脚本后，我们的脚本就会开始生效。\r\nCreate\r\n函数会最先执行，我们在这里初始化我们会用到的全部数据及内容，包括ScriptableRenderPass的初始化等\r\n然后会转到 AddRenderPasses\r\n的执行阶段，这里的标准流程是获取某个阶段的摄像机内容，传入ScriptableRenderPass实例中并将它重新压入这一帧的渲染队列\r\n等到了ScriptableRenderPass执行时，便会按照我们在ScriptableRenderPass类中定义的\r\nExecute 方法执行，这一方法的具体内容和 OnRenderImage 函数很像\r\n脚本核心内容：\r\n外部参数\r\n对于一个后处理描边，我们会有如下的控制需求：\r\n\r\n实际使用的材质（也可以只汇入 Shader，然后再临时创建专用的\r\nMaterial，但终究是需要一个所专用的 Material 用于最后的函数调用）\r\n描边的颜色、描边的程度等\r\n用于指定 Render Feature 生效阶段的renderPassEvent\r\n\r\nScriptableRenderPass\r\n\r\n\r\nhttps://docs.unity3d.com/Manual/render-pipelines-feature-comparison.html\r\nScriptableRenderPass implements a logical rendering pass that can be\r\nused to extend Universal RP renderer.\r\n\r\n\r\n在由 AddRenderPasses\r\n压入栈之后，我们所定义的ScriptableRenderPass就会在对应的阶段被执行，为此，我们需要至少在ScriptableRenderPass中，实现这些内容：\r\n\r\n接收在 Create 函数中汇入的外部参数，包括指定\r\nrenderPassEvent、Material 等\r\n编写实际执行调用 Material 去渲染的函数 Execute，这会包括：\r\n\r\n申请 Command Buffer\r\n获取当前阶段的摄像机内结果\r\n（如有多步的 Blit（如高斯模糊）调用）申请临时 RT 作缓冲区\r\n调用执行 Command Buffer\r\n释放所有资源\r\n\r\n特别的，我们会遇到这些特殊内容：\r\n\r\nCommandBuffer:\r\nhttps://docs.unity3d.com/2021.3/Documentation/ScriptReference/Rendering.CommandBuffer.html\r\n\r\nCommandBuffer.GetTemporaryRT:\r\nhttps://docs.unity3d.com/2021.3/Documentation/ScriptReference/Rendering.CommandBuffer.GetTemporaryRT.html\r\n\r\nRenderTargetIdentifier:\r\nhttps://docs.unity3d.com/2021.3/Documentation/ScriptReference/Rendering.RenderTargetIdentifier.html，我们用此对象来接收从Camera传入的Src\r\nRT\r\nRenderTargetHandle: RenderTargetHandle.cs，于 namespace\r\nUnityEngine.Rendering.Universal 中\r\n获取摄像机输入的 RT：\r\n123456789101112131415/// &lt;summary&gt;/// Returns the camera color target for this renderer./// It&#x27;s only valid to call cameraColorTarget in the scope of &lt;c&gt;ScriptableRenderPass&lt;/c&gt;./// &lt;seealso cref=&quot;ScriptableRenderPass&quot;/&gt;./// &lt;/summary&gt;public RenderTargetIdentifier cameraColorTarget &#123;    get&#123;        if (!(m_IsPipelineExecuting || isCameraColorTargetValid)) &#123;            Debug.LogWarning(&quot;You can only call cameraColorTarget inside the scope of a ScriptableRenderPass. Otherwise the pipeline camera target texture might have not been created or might have already been disposed.&quot;);            // TODO: Ideally we should return an error texture (BuiltinRenderTextureType.None?)            // but this might break some existing content, so we return the pipeline texture in the hope it gives a &quot;soft&quot; upgrade to users.        &#125;        return m_CameraColorTarget;    &#125;&#125;\r\n\r\nRenderTextureDescriptor:\r\nhttps://docs.unity3d.com/2021.3/Documentation/ScriptReference/RenderTextureDescriptor.html\r\n\r\n更进一步：在后处理的边缘检测中加入深度与法线纹理\r\n\r\n核心内容基本对应入门精要 13.4 节\r\n\r\n\r\n在 urp 中快速获取深度图：【转载】Unity URP\r\n获取深度图 - 掘金 (juejin.cn)\r\n在 urp 中自己生成特定情况下的深度图：Unity3D:URP\r\n下输出深度图以及自定义 ScriptableRenderer - 知乎 (zhihu.com)\r\n基于深度与法线贴图的屏幕后处理——Unity\r\nURP“_CameraDepthTexture”和“_CameraNormalsTexture”使用讲解 - 知乎\r\n(zhihu.com)\r\n\r\n\r\n练习项目(八)：在 URP\r\n中显示法线图 - CodeAntenna\r\n\r\n需要说明的是，我们使用了一种特殊的技巧：我们将 Shader 中的 Lightmode\r\n的值，设为了 URP 中不存在的值，这样这个 Pass 一开始不会执行，而我们在\r\nRender Feature 中捕获这个值，并去替换这个\r\nPass，就可以拿到深度与法线纹理。\r\n\r\nURP\r\nShaderLab Pass tags | Universal RP | 11.0.0 (unity3d.com)\r\nUnity\r\n- Manual: ShaderLab: Predefined Pass tags in the Built-in Render\r\nPipeline (unity3d.com)\r\n\r\n\r\nUnity -\r\nManual: ShaderLab: assigning tags to a Pass (unity3d.com) \"Using\r\nPass tags with C# scripts\" Part\r\n\r\n更多办法？\r\n很显然，基于后处理的边缘检测所得到的结果不够精确：不只是人物，场景中的所有内容都被一视同仁地进行处理，使结果包含了大量的不必要的描边。\r\n而对于基于深度与法线后处理检测，虽然它能得到比较准确的效果，但是并非是完全适用于人物的描边.\r\n在入门精要中，对这种基于图像处理的轮廓线渲染的优缺点的描述为：\r\n\r\n这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。\r\n\r\n\r\n在米哈游 2017 年的分享中，有这样两张 PPT：\r\n\r\n\r\nimage-20230729213125901\r\n\r\n\r\n\r\nimage-20230729213257293\r\n\r\n即，这种 Image Space 的 Outline\r\n更加适用于对场景进行描边，而对于人物，我们会使用基于 Backface\r\n的描边。这些内容与 2019 年的分享内容没有太大变化。\r\n\r\n为了得到更加精确的描边，我们可以采用一种基于法线扩张的描边办法：\r\nBackFacing 描边\r\nBackFacing 有很多优点，首先就是实现简单，特别是在 Unity Shader\r\n中，我们只需要新开一个 Pass，然后沿法线方向延展顶点就可以了。\r\n另外，由于我们的描边是模型渲染的一个内容，我们可以很方便地控制很多细节，比如描边颜色与描边粗细等。\r\n在入门精要中，给出的描边 Pass 是在 View Space\r\n中进行的，这样子有一个问题：描边的粗细是固定的，这意味着它会受透视效果而改变，即：当摄像机靠近角色时，描边会变得很粗。因此，我们应该在透视变换后再进行顶点扩张。我们需要将法线转换到\r\nNDC Space，并在该空间下进行运算。\r\n\r\n【01】从零开始的卡通渲染-描边篇\r\n- 知乎 (zhihu.com)\r\n\r\n在 NDC\r\n下变换后，我们可以发现现在描边粗细已经是摄像机无关的了——无论摄像机远近，我们都能保证描边粗细一致。但是还有一个问题：描边会在某些边缘断裂，准确的说：当模型上出现弯折较大的部位的情况下，其对应位置的法线变化会过大，导致的结果就是最终的描边就会像这样裂开。\r\n为了解决这个问题，我们需要进行法线平滑。最简单的是平均法线，我们在脚本中检测每个顶点上的法线、相加，最后求平均。这样得到的结果基本上可以保证法线不会断裂，但是又另一个问题，就是如果直接使用平均法线，可能并不能完全保证法线的原始效果，我们可能需要对着个平滑过程进行加权：\r\n\r\nTech-Artist\r\n学习笔记：Smooth Shade 平均法线与加权法线 - 知乎 (zhihu.com)\r\n\r\n最后，当我们计算完平滑的法线后，我们需要将它存储到模型中，如果是使用模型的\r\nTangent 空间的话，我们可以直接将当前 Object Space 下的计算结果直接覆写\r\nTangent 中的数据，可是如果我们需要使用原始的 Tangent\r\n数据，那我们就要考虑别的存储位置例如\r\nUV，此时我们需要多做一件事：将法线转换到切线空间再存储：\r\n\r\nUnity\r\n平滑法线用于卡渲描边 - 知乎 (zhihu.com)\r\n\r\n值得一提的是，这里的加权方式是角度变量加权。不同的平滑思路会造成不同的结果，这种不同甚至可能出现在模型的不同分件中，我们需要在不同的部位，采用不同的平滑方案。\r\n这样子，我们就基本上构建了一个完善的法线平滑脚本了。这是在模型导入后的二次处理，那么可不可以在模型导入时，就直接对其进行操作呢？\r\n\r\n【Job/Toon Shading\r\nWorkflow】自动生成硬表面模型 Outline Normal - 知乎 (zhihu.com)\r\n\r\n一些补充\r\n至此，我们常用的描边办法就全部介绍完了，不过除此之外，还有几个可以补充的要点：\r\n\r\n入门精要中还提到过一种可用的轮廓线渲染办法：基于轮廓边检测的轮廓线渲染：Mesh\r\n上的每一条边一定被两个三角形共用，检测 Mesh\r\n上所有像这样相邻的三角面片是否符合：\r\n\\[\r\n(\\vec{n_0} * \\vec{v} &gt; 0) \\ne (\\vec{n_1} * \\vec{v} &gt; 0)\\\\\\\\\r\n其中，n_0和n_1分别代表了两个相邻三角面片的法向，v是从视角到该边上任意顶点的方向\r\n\\]\r\n渲染管线中的法线变换矩阵 -\r\n知乎 (zhihu.com)\r\n\r\n高光形变\r\nHair\r\nRendering and Shading (oregonstate.edu)\r\n我们并不希望高光总是⼀个圆形的光斑，因此我们需要对高光的形状也进行风格化处理：对高光点进行形变\r\n\r\nKajiya Kay 模型：\r\n需要注意的是，这里的 T\r\n并非是切线，它代表的是当前模型的副切线\r\n\r\n\\[\r\nSpecular = L_i * k_s * \\sqrt{ \\overrightarrow T \\cdot \\overrightarrow H\r\n} ^ {strength}\r\n\\]\r\n 用 Kajiya Kay\r\n模型实现的环形高光，Strength == 64，没有使用 Shift\r\nMap，没有使用衰减。（计算 W 型高光需要使用 Shift\r\nMap，可用的处理办法可参考：基于 Kajiya-Kay\r\n模型的毛发渲染 - 知乎 (zhihu.com))\r\n\r\nMarschner 模型：hair-sg03final.pdf\r\n(stanford.edu)\r\n就 Marschner 模型本身而言，这是一个基于物理的模型。Marschner Hair Model\r\n论文细读与推导 - 知乎 (zhihu.com)\r\n\r\n\r\n\r\nimg\r\n\r\nR：反射光线，T：透射光线。R，TT 和 TRT\r\n是三个对毛发反射率产生明显影响部分。 R：\r\n从头发纤维表面向观察者反弹的光。TT：\r\n折射到头发中并再次向观察者折射的光。TRT：光线折射到头发纤维中，从内表面反射，然后再次向观察者折射。\r\n\\[\r\nS=S_R+S_{TT}+S_{TRT} \\\\\r\nSP=MP⋅NP\\\\\r\nfor \\space P = R, TT, TRT\\\\\r\n\\]\r\n剖析 Unreal\r\nEngine 超真实人类的渲染技术 Part 3 - 毛发渲染及其它 - 0 向往 0 - 博客园\r\n(cnblogs.com)\r\nMarschner Hair Model\r\n论文细读与推导 - 知乎 (zhihu.com)\r\n\r\nKajiya-Kay\r\n模型是一种基于经验的头发渲染模型，它使用头发的切线来模拟平面法线的效果，能够近似地表现出高光的效果，并使用漫反射项来近似头发间的相互散射情况。然而，Kajiya-Kay\r\n模型不是基于物理的，它将头发建模成不透明的圆柱体，因此不能模拟光线可能穿过头发或者在头发中传播的情况，这就导致了其不能模拟出背光以及二次高光等效果\r\nMarschner 模型是一种基于物理的头发渲染模型，它在 Kajiya-Kay\r\n模型的基础上对单根头发的散射情况进行了实验和理论分析，然后建立了一个实用且基于物理的着色模型。Marschner\r\n模型将光照在毛发上的作用分为三个部分：R、TT 和\r\nTRT。这三个部分对毛发反射率产生明显影响\r\n\r\n\r\n近似的 Marschner Model？\r\n【UE4】材质藏宝阁\r\n01_头发 Kajiya-Kay Shading - 知乎 (zhihu.com)，即 Kajiya Kay + Shift\r\nMap + 第二层 Base Color 高光\r\n\r\n可参考的各向异性高光示例：\r\nUnity3D\r\nShaderLab 各向异性高光 - 川北 - 博客园 (cnblogs.com)\r\n一个风格高光实现：\r\n涂月观 (tuyg.top)\r\nATI 示例代码：\r\n\r\n\r\nimage-20230501191639629\r\n\r\n小结：\r\n卡通渲染中，最重要的就是：使用 Step 的、强烈的明暗分割\r\nPBR 下的材质表达\r\nPBR 材质分析\r\n ASE 在 URP 管线下的默认 PBR\r\n材质输出节点\r\n对于 PBR 预制节点所不能表达的效果，我们有两种解决思路：\r\n\r\n每种特性单独做一个 Shader。这种方案的优点是 Shader\r\n功能相对确定，GPU 计算效率快，缺点是会增加 DrawCall\r\n使用 UberShader 以包含所有特性，然后再通过 Mask\r\n进行材质分层。这种方案的优点是 DrawCall 少，基本上⼀个通⽤的 Shader\r\n可以满足大多数功能，同时可以减少贴图数量，缺点是会产生许多无用的 GPU\r\n计算。\r\n产生无用计算的原因：\r\n If\r\n语句会先计算出括号里面的内容，再根据条件值判断是否接受这个值。这种运行方式与\r\nCPU 不同，CPU\r\n是先根据条件值是否为真，再去判断是否要执行括号内的内容。\r\n\r\n和大多数最终的解决方案类似的——⼀种成熟的解决方案是 1 与 2\r\n的结合，即在通用的 Shader\r\n中做出通用特性，每个特性不能消耗太多的计算，而特殊的特性用单独的\r\nShader。\r\nTexture 介绍\r\nBase Map：基础色\r\nShadow Map：暗部衰减色，我们\r\n具体案例分析\r\n罪恶装备 Strive\r\n的渲染分析与复现\r\n部分引用\r\n【翻译】西川善司「实验做出的游戏图形」「GUILTY\r\nGEAR Xrd -SIGN-」中实现的「纯卡通动画的实时 3D 图形」的秘密，前篇（1） -\r\nTrace0429 - 博客园 (cnblogs.com)\r\n【翻译】西川善司「实验做出的游戏图形」「GUILTY\r\nGEAR Xrd -SIGN-」中实现的「纯卡通动画的实时 3D 图形」的秘密，前篇（2） -\r\nTrace0429 - 博客园 (cnblogs.com)\r\nShader 编写\r\n数据使用：\r\n\r\nBaseMap：基础⾊\r\nShadowMap：暗部衰减色，与 BaseMap 相乘构成暗部\r\nDetailTex：磨损线条\r\nLightMap.r：高光类型\r\nLightMap.g：Ramp 偏移值\r\nLightMap.b：高光强度 mask\r\nLightMap.a：内勾线的 Mask\r\nVertexColor.r：AO，常暗部分\r\nVertexColor.g：用来区分身体的部位\r\nVertexColor.b：描边遮罩\r\nVertexColor.a：渲染无用\r\n\r\n1\r\n碧蓝幻想\r\n原神\r\n破晓传说\r\n战双\r\nReference\r\n\r\n\r\n【01】从零开始的卡通渲染-描边篇\r\n- 知乎 (zhihu.com)\r\nUnity\r\n描边法线平滑工具 x 踩坑记录 - 知乎 (zhihu.com)\r\n渲染管线中的法线变换矩阵 -\r\n知乎 (zhihu.com)\r\nMenuItem\r\nis not working properly - Unity Forum\r\nURP\r\nShaderLab Pass 标签 | Universal RP | 12.1.1 (unity3d.com)\r\n【02】卡通渲染基本光照模型的实现\r\n- 知乎 (zhihu.com)\r\nGuilty\r\nGear Strive - Sol Badguy XPS (Updated) by o-DV89-o on\r\nDeviantArt\r\nChiliMilk/URP_Toon:\r\nA Toon Shader in Unity Universal Render Pipeline. (github.com)\r\n[卡通渲染]一、罪恶装备角色渲染还原\r\n- 知乎 (zhihu.com)\r\n基于 Kajiya-Kay\r\n模型的毛发渲染 - 知乎 (zhihu.com)\r\n【UE4】材质藏宝阁\r\n01_头发 Kajiya-Kay Shading - 知乎 (zhihu.com)\r\n涂月观-吹灯窗更明，月照一天雪\r\n(tuyg.top)\r\nHair\r\nRendering and Shading (oregonstate.edu)\r\nYoolie on\r\nTwitter: \"Tutorial on adjusting vertex normals for that 3D Anime look!\r\nsince a couple of people were asking for it, I decided to make it!\r\nHopefully it's useful to someone! It's the first tutorial I've ever\r\nmade, so I apologize if it's kind of unclear ;-; #blender #bnpr #3D\r\n#BlenderNPR https://t.co/3cctLK8tFD\" / Twitter\r\nTA\r\n技术美术-罪恶装备角色还原 - 知乎 (zhihu.com)\r\n灯光技法-伦勃朗光（2） -\r\n知乎 (zhihu.com)\r\n【02】卡通渲染基本光照模型的实现\r\n- 知乎 (zhihu.com)\r\n\r\n既有渲染思路分析\r\n\r\nChiliMilk/URP_Toon: A\r\nToon Shader in Unity Universal Render Pipeline. (github.com)\r\n\r\n项目结构分析\r\n该项目有三个\r\n共有\r\n核心代码分析\r\n\r\n分析的文件包括：\r\n\r\nToonShaderGUI.cs\r\nToon.shader\r\n\r\n\r\n\r\nToon.shader 文件的布局仍然遵循我们所提到的 shaderlab 基本结构：\r\n\r\nProperties：作者在这里声明了所有可用的属性\r\nSubShader\r\nCustomEditor：作者的确在项目中定义一个简单的\r\nGUI，虽然没有以窗口的形式呈现，但是材质的面板上确实变得不同了\r\nFallBack：FallBack 到 Error\r\n\r\nProperties 部分\r\nProperties 部分存在于 3 ~ 101 行.\r\n其中定义的大部分属性都直接用\r\n定义输入结构\r\n第一个 Pass 位于 109 ~ 130\r\n行。它通过引入了两个外部文件来实现主要功能，它们分别是：ToonInput.hlsl，ToonHairShadowMaskPass.hlsl\r\n12345678910111213141516171819202122Pass&#123;    Name &quot;HairShadowMask&quot; //    ZTest Less    Tags&#123;&quot;LightMode&quot;=&quot;HairShadowMask&quot;&#125;    ZWrite Off    Cull Back    HLSLPROGRAM    #pragma exclude_renderers gles gles3 glcore    #pragma target 4.5    #pragma multi_compile_instancing    #pragma multi_compile_fog    #pragma vertex Vertex    #pragma fragment Fragment    #include &quot;../Include/ToonInput.hlsl&quot;    #include &quot;../Include/ToonHairShadowMaskPass.hlsl&quot;    ENDHLSL&#125;\r\n显而易见的，这两个引入文件分别实现了输入结构的定义与 ShadowMap\r\n的计算\r\n我们先从 ToonInput.hlsl 开始：\r\n","slug":"Rendering/NPR/General","date":"2022-12-23T04:23:23.000Z","categories_index":"Rendering","tags_index":"Rendering","author_index":"JBR_Bunjie"},{"id":"4bbde60d3dafb255adad1c9293392efa","title":"全排列","content":"什么是 UST？\r\nUST，即 Unity Toon Shader，截至成文时，UST 的版本为\r\n0.9.4-preivew。对应：\r\n\r\nUnity\r\nToon Shader overview | Unity Toon Shader | 0.9.4-preview\r\n(unity3d.com)\r\nunity3d-jp/UnityChanToonShaderVer2_Project:\r\nUnityChanToonShaderVer2 Project / v.2.0.9 Release (github.com)\r\n\r\n其手册下的介绍为：\r\n\r\nThe Unity Toon Shader (UTS3) is a set of toon\r\nshaders designed to meet the needs of creators working on cel-shaded\r\n3D-CG animations.\r\n\r\n","slug":"Rendering/NPR/UST","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm","author_index":"JBR_Bunjie"},{"id":"b3bedba617b3d9cc8e9599d09276fd70","title":"CatlikeCoding - Chapter01. Basics","content":"Chapter01：Basics\r\n\r\n对于基础部分，除了这些内容外，仅记录了有用的 QA 内容：\r\n\r\nGame Objects and Scripts\r\n\r\n1. Which Unity versions are appropriate?\r\n...A further f1 suffix indicates an official final release...\r\n说明：因为 Unity 同时维护了多个版本，只有发行版会有 f1\r\n后缀，测试版分别为 b-beta、a-alpha，如：Beta 通道的 2023.1.0b20 和 Alpha\r\n通道的 2023.2.0a19\r\n2. What is albedo?\r\nAlbedo is a Latin word which means whiteness. It's the color of\r\nsomething when illuminated by white light.\r\n3. What is the default access modifier for\r\nclasses?\r\nWithout the access modifier, it would be as if we had written\r\ninternal class Clock. That would restrict access to\r\ncode from the same assembly, which becomes relevant when you use code\r\npackaged in separate assemblies. To make sure it always works, make\r\nclasses public by default.\r\n4. What does mono-behavior mean?\r\nThe idea is that we can program our own components to add\r\ncustom behavior to game objects. That's what the behavior part refers\r\nto. It just happens to use the British spelling, which is an\r\noddity. The mono part refers to the way in which support for\r\ncustom code was added to Unity. It used the Mono project, which\r\nis a multi-platform implementation of the .NET framework. Hence,\r\nMonoBehaviour. It's an old name that we're stuck with due\r\nto backwards-compatibility.\r\n5. Doesn't Awake have to be\r\npublic?\r\nAwake and a collection of other methods are considered\r\nspecial Unity event methods. The Unity engine will find them and invoke\r\nthem when appropriate, no matter how we declare them. This happens from\r\noutside the managed .NET environment.\r\n6. What's the difference between localRotation\r\nand rotation?\r\nThe localRotation property represents the rotation\r\ndescribed by the Transform component in isolation, thus it\r\nis a rotation relative to its parent. It's the rotation that you see in\r\nits inspector. In contrast, the rotation property\r\nrepresents the final rotation in world space, taking the entire object\r\nhierarchy into account. Setting that property would produce weird\r\nresults if we rotate the clock as a whole, because the arm would ignore\r\nthat as the property compensates for the rotation of the clock.\r\n7. Shouldn't there be a warning that hoursPivot\r\nis never initialized?\r\nThe compiler can detect that no code assigns anything to the field\r\nand could indeed issue such a warning, because it is unaware that we set\r\nit up via Unity's inspector. However, this warning is suppressed by\r\ndefault. The suppression can be controlled via the project settings.\r\nThere's a Suppress Common Warnings toggle under Player /\r\nOther Settings / Script Compilation. It suppresses warnings about\r\nboth uninitialized and unused private fields.\r\n8. What's special about const\r\nvalues?\r\nThe const keyword indicates that a\r\nvalue will never change and doesn't need to be a field. Instead, its\r\nvalue will be computed during compilation and is substituted for all\r\nusage of the constant. This is only possible for primitive types like\r\nnumbers.\r\n9. What's a variable?\r\nA variable acts like a field, except that it exists only while a\r\nmethod is being executed. It belongs to the method, not the class.\r\nFields、Properties、Variables\r\n\r\nBuilding A Graph\r\n\r\n1. A good understanding of mathematics is essential when\r\nprogramming.\r\n2. It is a pre-fabricated game object that exists in the\r\nproject, not in a scene.\r\n3. Why is the background of the prefab scene uniform dark\r\nblue?\r\nIf you open a prefab instance that's part of a scene then the scene\r\nwindow will display its surroundings depending on the Context\r\nsettings shown at the top of the window. If you open the prefab asset\r\nthen there is no context. In the case of assets the skybox is disabled\r\nby default in the prefab scene, along with some other things. You can\r\nconfigure this via the scene window's toolbar, just like you can for the\r\nregular scene window. The skybox can be toggled via the dropdown menu\r\nthat looks like a stack with a star on top of it. Notice how the scene\r\ntoolbar settings change when you jump in and out of prefab asset\r\nmode.\r\n4. What is the full inheritance chain of\r\nMonoBehaviour?\r\nMonoBehaviour extends Behaviour, which\r\nextends Component, which extends Object.\r\n\r\nMathematical Surface\r\n\r\n关于 Delegate，可用的拓展内容：(82) What are\r\nDelegates? (C# Basics, Lambda, Action, Func) - YouTube\r\n\r\nMeasuring Performance\r\n\r\n1. Whether a target frame rate can be achieved depends on how\r\nlong it takes to process individual frames. To reach 60FPS we must\r\nupdate and render each frame in less than 16.67 milliseconds. The time\r\nbudget for 30FPS is double that, thus 33.33ms per frame.\r\n\r\nThe statistics show a frame during which the CPU main thread took\r\n31.7ms and the render thread took 29.2ms. You'll likely get different\r\nresults, depending on your hardware and the game window screen size. In\r\nmy case it suggests that the entire frame took 60.9ms to render, but the\r\nstatistics panel reported 31.5FPS, matching the CPU time. The\r\nFPS indicator seems to takes the worst time and assumes that matches the\r\nframe rate. This is an oversimplification that only takes the CPU side\r\ninto account, ignoring the GPU and display. The real frame rate is\r\nlikely lower.\r\n\r\n2. \r\nPart1:Text strings are objects. When we create a new one via SetText\r\nthis produces a new string object, which is responsible for the\r\nallocation of 106 bytes. Unity's UI refresh then increases this to 4.5\r\nkilobytes. While this isn't much it will accumulate,\r\ntriggering a memory garbage collection process at some point\r\nwhich will result in an undesired frame duration spike.\r\nPart2: It is important to be aware of memory allocation for\r\ntemporary objects and eliminate recurring ones as much as possible.\r\nFortunately SetText and Unity's UI update only perform these memory\r\nallocations in the editor, for various reasons, like updating the text\r\ninput field. If we profile a build then we will find some initial\r\nallocations but then no more. So it is essential to profile\r\nbuilds. Profiling editor play mode is only good for a first\r\nimpression.\r\n\r\nGame Window Statistics\r\n\r\nGPU Instancing, SRP Batching and Dynamic\r\nBatching\r\nAnother way to improve rendering performance is by enabling GPU\r\ninstancing. This makes it possible to use a single draw command to tell\r\nthe GPU to draw many instances of one mesh with the same material,\r\nproviding an array of transformation matrices and optionally other\r\ninstance data. In this case we have to enable it per material. Ours have\r\nan Enable GPU Instancing toggle for it.\r\n\r\nDifference between Lerp\r\nand SmoothStep\r\nLerp is shorthand for linear interpolation.\r\nIt will produce a straight constant-speed transition between the\r\nfunctions. We can make it look a bit smoother by slowing down the\r\nprogress near the start and end. This is done by replacing the raw\r\nprogress with an invocation of Mathf.Smoothstep with zero,\r\none, and the progress as arguments. It applies the\r\n3x2−2x3 function, commonly known as\r\nsmoothstep. The first two parameter of Smoothstep\r\nare an offset and scale for this function, which we don't need so use 0\r\nand 1. Unity\r\n- Scripting API: Mathf.SmoothStep (unity3d.com)\r\n 0–1 Smoothstep and linear.\r\nMore: The Lerp method clamps its third\r\nargument so it falls in the 0–1 range. The Smoothstep\r\nmethod does this as well. We configured the latter to output a 0–1\r\nvalue, so the extra clamp of Lerp is not needed. For cases\r\nlike this there is an alternative LerpUnclamped method, so\r\nlet's use that one instead.\r\nCompute Shaders\r\n\r\n1. What's a MiB?\r\nBecause computer hardware uses binary numbers to address memory it's\r\npartitioned in powers of two, not powers of ten. MiB is the suffix for\r\nmebibyte, which is 220 = 1,0242 = 1,048,576 bytes.\r\nThis was originally known as a megabyte—indicated with MB—but that's now\r\nsupposed to indicate 106 bytes, matching the official\r\ndefinition of a million. However, MB, GB, etc. are often still used\r\ninstead of MiB, GiB, etc. 关于 MiB 与 MB：Mebibyte -\r\n维基百科，自由的百科全书 (wikipedia.org)\r\n\r\nReferences\r\n\r\nhttps://catlikecoding.com/unity/tutorials/basics/\r\n\r\n\r\n","slug":"Rendering/CatLikePrograming/Chapter01","date":"2022-12-23T04:23:23.000Z","categories_index":"CatlikeCoding,Rendering","tags_index":"Rendering,CatlikeCoding","author_index":"JBR_Bunjie"},{"id":"f8c8a85b34fcac6d0fefec2d2d2d9cd5","title":"Merge Sort - 归并排序","content":"Merge Sort 归并排序\r\nReference：\r\n1.5 归并排序\r\n| 菜鸟教程 (runoob.com)\r\n算法步骤：\r\n\r\n概述：\r\n\r\n\r\n\r\n申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\r\n设定两个指针，最初位置分别为两个已经排序序列的起始位置；\r\n比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\r\n重复步骤 3 直到某一指针达到序列尾；\r\n将另一序列剩下的所有元素直接复制到合并序列尾。\r\n\r\n\r\n\r\n图示：\r\n\r\n1:\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n2:\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n实现-迭代法：\r\n12345678910111213141516171819202122232425262728293031function mergeSort(arr) &#123;  // 采用自上而下的递归方法    var len = arr.length;    if(len &lt; 2) &#123;        return arr;    &#125;    var middle = Math.floor(len / 2),        left = arr.slice(0, middle),        right = arr.slice(middle);    return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123;    var result = [];    while (left.length &amp;&amp; right.length) &#123;        if (left[0] &lt;= right[0]) &#123;            result.push(left.shift());        &#125; else &#123;            result.push(right.shift());        &#125;    &#125;    while (left.length)        result.push(left.shift());    while (right.length)        result.push(right.shift());    return result;&#125;\r\n实现-递归法：\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;/** * Created by chengxiao on 2016/12/8. */public class MergeSort &#123;    public static void main(String []args)&#123;        int []arr = &#123;9,8,7,6,5,4,3,2,1&#125;;        sort(arr);        System.out.println(Arrays.toString(arr));    &#125;    public static void sort(int []arr)&#123;        int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间        sort(arr,0,arr.length-1,temp);    &#125;    private static void sort(int[] arr,int left,int right,int []temp)&#123;        if(left&lt;right)&#123;            int mid = (left+right)/2;            sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序            sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序            merge(arr,left,mid,right,temp);//将两个有序子数组合并操作        &#125;    &#125;    private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123;        int i = left;//左序列指针        int j = mid+1;//右序列指针        int t = 0;//临时数组指针        while (i&lt;=mid &amp;&amp; j&lt;=right)&#123;            if(arr[i]&lt;=arr[j])&#123;                temp[t++] = arr[i++];            &#125;else &#123;                temp[t++] = arr[j++];            &#125;        &#125;        while(i&lt;=mid)&#123;//将左边剩余元素填充进temp中            temp[t++] = arr[i++];        &#125;        while(j&lt;=right)&#123;//将右序列剩余元素填充进temp中            temp[t++] = arr[j++];        &#125;        t = 0;        //将temp中的元素全部拷贝到原数组中        while(left &lt;= right)&#123;            arr[left++] = temp[t++];        &#125;    &#125;&#125;\r\n用例1：\r\n计算二分图（bipartite\r\ngraph）交叉点（crossing）的数量_imred的博客-CSDN博客_bipartite\r\ngraph\r\n","slug":"Algorithm/SORT/MergeSort/Merge Sort","date":"2022-12-23T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Sort","author_index":"JBR_Bunjie"},{"id":"b14408b92d0c8809e1d3bbbaabf2879c","title":"Prim’s Minimum Spanning Tree","content":"\r\nPrim\r\n算法(Python 实现)_JohnJim 的博客-CSDN 博客_prim 算法 python\r\n","slug":"Algorithm/Prim/Prim","date":"2022-12-22T04:23:23.000Z","categories_index":"Algorithm","tags_index":"Algorithm,MST","author_index":"JBR_Bunjie"},{"id":"0eaa98b93346230bf7294e2b64167feb","title":"Vim start","content":"Vim Start\r\nVim 1. Start\r\n可参考Vim教程\r\nVim Tutorial\r\n(tutorialspoint.com)\r\nVim is acronym for Vi IMproved.\r\nVim 官网：\r\nwelcome home : vim online\r\n一个 Vim 相关的小游戏： https://vim-adventures.com/\r\n一个配置文件： https://github.com/MarsWang42/My-Vim-Conf\r\nVimAwesome 网站： https://vimawesome.com/\r\nVim Plug Github 页面： https://github.com/junegunn/vim-plug\r\nVim 2. installation\r\n确保 vim 安装：\r\n1which vim\r\n在当前用户根目录下的.vimrc\r\n文件中存储它的具体配置文件，我们可以进行手动配置\r\n12345678#没有.vimrc文件，手动进行创建touch .vimrc #vim .vimrc#写入命令：set nu#这个配置会使令vim编辑器在每行开头都显示行号\r\n若没有安装：\r\n123456#redhatyum install vim#debianapt updateapt install vim\r\nVim 3. modes\r\nvim 一共有 6 中模式\r\n\r\n\r\n\r\n进入方式\r\n对应模式\r\n\r\n\r\n\r\n\r\nn\r\nNormal mode\r\n\r\n\r\nv\r\nVisual mode\r\n\r\n\r\ni\r\nInsert mode\r\n\r\n\r\nc\r\nCommand-line mode\r\n\r\n\r\nh\r\nall previous modes when in a help file\r\n\r\n\r\na\r\nall previous modes\r\n\r\n\r\nr\r\nfor hit-enter prompt\r\n\r\n\r\n\r\n其中，normal mode，insert mode，command-line mode\r\n是我们的常用模式\r\nnormal mode\r\n这是进入 vim 后的默认模式\r\n我们可以在这个模式下执行复制，粘贴，删除，替换等许多操作\r\nInsert mode\r\n在 command mode\r\n下按i或功能键insert后进入的模式\r\n通过Esc退回到 command mode\r\nCommand line mode\r\n执行具体命令的模式，在 command mode\r\n下按下:来输入命令\r\n例如，我们可以通过:edit message.txt来对当前目录下的\r\nmessage.txt 文件进行编辑，若不存在此文件则先进行创建\r\n12:edit message.txt # 运行vim命令时的目录下的message.txt:edit /root/message.txt # 指定位置的message.txt\r\nVisual mode\r\n在 command mode 下按下v可进入\r\nreadonly mode\r\n123vim -R message.txt# orview message.txt\r\nVim 4. help\r\n当你没有任何头绪的时候，不妨输入\r\n1:help &lt;topic-name&gt;\r\n试试\r\nIn above command replace  with topic in which you are\r\ninterested. Forinstance to access help about vim mode, execute following\r\ncommand\r\n1:help modes\r\nSearch help phrase in manual\r\n如果你知道对应主题的名字的话，直接搜索对应内容当然是最好的\r\n但是当我们不知道我们所需要信息的准确名称时，我们就需要对 topic\r\n进行检索\r\n我们可以使用下面的命令：\r\nYou can search specific topic only if you know its name. But what if,\r\nyou don’t know the exact name of help topic. In that case you can use\r\nbelow command −\r\n1:helpgrep &lt;phrase&gt;\r\nFor instance, to access help about navigation in Vim execute below\r\ncommand\r\n1:helpgrep navigation\r\n退出 help:\r\n1:helpclose 或者直接 :q\r\n","slug":"Deploy/vim/01.start","date":"2022-11-11T03:23:22.000Z","categories_index":"Vim,Linux","tags_index":"Linux,Vim","author_index":"JBR_Bunjie"},{"id":"ef22db5291aa54808e48f608e26f7f4f","title":"Vim 0. Before We Start","content":"Vim 0. Before We Start\r\n其他的字符终端文本编辑器 -\r\nnano\r\n是一个字符终端的文本编辑器，但它比 vi/vim 要简单得多，比较适合 Linux\r\n初学者使用。某些 Linux 发行版的默认编辑器就是 nano。\r\n移动\r\n\r\n移动光标：使用用方向键移动。\r\n选择文字：按住鼠标左键拖到。\r\n\r\n复制粘贴\r\n\r\n复制一整行：Alt+6\r\n剪贴一整行：Ctrl+K\r\n粘贴：Ctrl+U\r\n\r\n如果需要复制／剪贴多行或者一行中的一部分，先将光标移动到需要复制／剪贴的文本的开头，按\r\nCtrl+6（或者 Alt+A）做标记，然后移动光标到\r\n待复制／剪贴的文本末尾。这时选定的文本会反白，用 Alt+6 来复制，Ctrl+K\r\n来剪贴。若在选择文本过程中要取消，只需要再按一次 Ctrl+6。\r\n搜索\r\n按\r\nCtrl+W，然后输入你要搜索的关键字，回车确定。这将会定位到第一个匹配的文本，接着可以用\r\nAlt+W 来定位到下一个匹配的文本。\r\n翻页\r\n\r\nCtrl+Y 到上一页\r\nCtrl+V 到下一页\r\n\r\n保存\r\n使用 Ctrl+O 来保存所做的修改\r\n退出\r\n按 Ctrl+X\r\n如果你修改了文件，下面会询问你是否需要保存修改。输入 Y 确认保存，输入\r\nN 不保存，按 Ctrl+C 取消返回。如果输入了\r\nY，下一步会让你输入想要保存的文件名。如果不需要修改文件名直接回车就行；若想要保存成别的名字（也就是另存为）则输入新名称然后确\r\n定。这个时候也可用 Ctrl+C 来取消返回。\r\nVim键盘图概览\r\nvi/vim 命令：\r\n\r\n经典版：\r\n\r\n编辑模式\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","slug":"Deploy/vim/00.beforeStart","date":"2022-11-11T03:23:21.000Z","categories_index":"Vim,Linux","tags_index":"Linux,Vim","author_index":"JBR_Bunjie"},{"id":"5380672006be2cb0abc462cb608a9c74","title":"Python相等判断","content":"python 的 is 和==，java\r\n的==和 equal（相等判断）\r\nPython 判断对象是否相等（== 和\r\nis）\r\nPython 中的对象包含三个基本要素，分别是：\r\n\r\nid：用来唯一标识一个对象，可以理解为内存地址；\r\ntype：标识对象的类型；\r\nvalue：对象的值；\r\n\r\n== ：比较两个对象的内容是否\r\n相等，即两个对象的 value 是否相等，无论 id\r\n是否相等，默认会调用对象的 __eq__()方法\r\nis： 比较的是两个对象是不是完全\r\n相同，即他们的 id 要相等。\r\n也就是说：如果 a is b 为 True，那么 a == b 也为 True\r\n字符串比较\r\n123456789a = &#x27;hello&#x27;b = &#x27;hello&#x27;print(a is b)print(id(a))print(id(b))# 执行结果：True18308264961761830826496176\r\n数字比较\r\n先看一个有趣的现象\r\n12345678910111213141516In[43]: a = 256In[44]: b = 256In[45]: a is bOut[45]: TrueIn[46]: id(a)Out[46]: 140711685177712In[47]: id(b)Out[47]: 140711685177712In[48]: a = 257In[49]: b = 257In[50]: a is bOut[50]: FalseIn[51]: id(a)Out[51]: 2097451837488In[52]: id(b)Out[52]: 2097451837648\r\n为什么当 a,b 为 257 的时候 a is b 为 False 呢？\r\nPython\r\n为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。\r\n而 Python 对小整数的定义是 [-5, 256)，只有数字在-5 到 256 之间它们的\r\nid\r\n才会相等，超过了这个范围就不行了，同样的道理，字符串对象也有一个类似的缓冲池，超过区间范围内自然不会相等了。\r\n需要注意的是这仅仅是在命令行中执行时才会有小整数缓存，而在文件中执行时，结果是不一样的，这是因为解释器做了一部分优化，如下：\r\n123456789x = 257y = 257print(id(x))print(id(y))print(x is y)# 执行结果：21773304110242177330411024True\r\n元组比较\r\n123456789x = (1, 2, 3)y = (1, 2, 3)print(x is y)print(id(x))print(id(y))# 执行结果：True30148303760243014830376024\r\n列表比较\r\n1234567891011x = [1, 2, 3]y = [1, 2, 3]print(x == y)print(x is y)print(id(x))print(id(y))# 执行结果：TrueFalse29689916502482968991650760\r\n列表赋值比较\r\n123456789x = [1, 2, 3]y = xprint(x is y)print(id(x))print(id(y))# 执行结果：True22949717815762294971781576\r\n字典比较\r\n1234567891011x = &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;b&quot;: 3&#125;y = &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;b&quot;: 3&#125;print(x == y)print(x is y)print(id(x))print(id(y))# 执行结果：TrueFalse25229085275762522908269848\r\n集合比较\r\n1234567891011x = set([1, 2, 3])y = set([1, 2, 3])print(x == y)print(x is y)print(id(x))print(id(y))# 执行结果：TrueFalse20803959557842080414590120\r\n小结：\r\n可以看到，当 x, y 为字符串、整数，元组（都是不可变类型）的时候，如果\r\nx 和 y 的值一样的话，x is y 则为 True；\r\n然而为列表，字典，集合（都是可变类型）的时候，x is y 为\r\nFalse，列表赋值的时候为 True；\r\n与 == 相比，is\r\n的计算速度快——因为它不能重载，不用进行特殊的函数调用，少了函数调用的开销而直接比较两个整数\r\nid。而 a == b\r\n则是等同于a.eq(b)。继承自 object 的\r\n__**eq__** 方法比较两个对象的 id，结果与 is\r\n一样。但是多数 Python 的对象会覆盖 object 的\r\n**__eq__**方法，而定义内容的相关比较，所以比较的是对象属性的值。\r\n在变量和单例值之间比较时，应该使用 is。目前，最常使用 is\r\n的地方是判断对象是不是 None\r\n关于 python\r\n的可变类型不可变类型可参考：https://www.runoob.com/python/python-variable-types.html\r\npython\r\n的赋值、浅拷贝和深拷贝可参考：https://blog.csdn.net/bufengzj/article/details/90486991\r\nJava 判断对象是否相等（== 和\r\nequal）\r\njava 中没有 is ,有 == 和 equal。。\r\n==：比较两个变量本身的值，即两个对象在内存中的首地址（类似也就是和\r\npython 的 is ）；\r\nequals：比较变量所包含的内容是否相同（类似也就是和\r\npython 的 == ）；\r\njava 具体参考：https://www.cnblogs.com/weibanggang/p/9457757.html\r\n","slug":"Language Learning/Python/相等判断","date":"2022-11-11T03:23:21.000Z","categories_index":"Python,Language Learning","tags_index":"Language Learning,Python","author_index":"JBR_Bunjie"},{"id":"1cdbf5ea28f06f2e781b02c473f83271","title":"Java 后端路径","content":"Java 后端路径\r\n教程网站：\r\nOracle Official Site：The Java™\r\nTutorials (oracle.com)\r\nRunoob：Java\r\n教程 | 菜鸟教程 (runoob.com)\r\nw3school：Java\r\nTutorial (w3schools.com)\r\nJava语言：\r\n集合，并发，JVM\r\nLinux：\r\n具备相当程度的 Linux\r\n基础。包括基础命令和设计模式\r\n数据库：\r\nMySql，Redis，HBase，MangoDB，ES\r\n框架：\r\nSpring，SpringMVC，SpringBoot，MyBatis，Tomcat，Dubbo\r\nMQ：\r\nRocketMQ，RabbitMQ，Kafka，ActiveMQ\r\n分布式：\r\nZooKeeper，分布式协议，如何保持一致性？RPC\r\n计算机：\r\n计算机网络，OS，算法\r\n系统设计：\r\nDDD（领域设计），系统分层（横向纵向）\r\n其他：\r\n缓存，网络安全\r\n","slug":"Language Learning/Java/Java后端学习路径","date":"2022-10-15T04:23:23.000Z","categories_index":"Language Learning,Java","tags_index":"Language Learning,Java","author_index":"JBR_Bunjie"},{"id":"c1ecb9ea74ed4a19b9e82231ff3ff600","title":"Complexity Has to Live Somewhere","content":"Complexity Has to Live\r\nSomewhere\r\nOriginal Post: Complexity\r\nHas to Live Somewhere (ferd.ca)\r\nChinese Version:\r\nComplexity\r\nHas to Live Somewhere - Google 文档\r\n架构设计-复杂度是不灭的 -\r\n知乎 (zhihu.com)\r\nSome Related Posts: 复杂度是不灭的，只会转移，难道一切都是徒劳的吗？\r\n- 知乎 (zhihu.com)\r\n\r\nComplexity has to live somewhere. If you embrace it, give it the\r\nplace it deserves, design your system and organisation knowing it\r\nexists, and focus on adapting, it might just become a strength.\r\n\r\n\r\n很多架构/系统一开始是简单的，这一点都没错，因为他们开始只处理简单问题，只处理几个点，这是正确的。随着系统的不断升级迭代，他们开始把复杂的事情往简单里入侵，于是系统边界开始变得模糊不清，最后崩塌。\r\n千里之堤毁于蚁穴。\r\n\r\n\r\n\r\nif you make the build tool simple, it won't handle all the weird\r\nedge cases that exist out there\r\nif you want to handle the weird edge cases, you need to deviate from\r\nwhatever norm you wanted to establish\r\nif you want ease of use for common defaults, the rules for common\r\ndefaults must be shared between the tool and the users, who shape their\r\nsystems to fit the tool's expectations\r\nif you allow configuration or scripting, you give the users a way to\r\nspecify the rules that must be shared, so the tool fits their\r\nsystems\r\nif you want to keep the tool simple, you have to force your users to\r\nonly play within the parameters that fit this simplicity\r\nif your users' use cases don't map well to your simplicity, they\r\nwill build shims around your tool to attain their objectives\r\n\r\n\r\n所以怎么解决复杂？要把复杂交给谁？\r\n是希望用户自定义？还是一站式打包，全部总揽？是只针对小问题破局？还是囊括一切？\r\n层层交叉，复杂自然分散。但是这些分散的复杂是否都经过了稳妥的处理？它们是不是被随意地丢弃在各个角落？\r\n最后：复杂度不会解决，但你所能做的一切都可以促成一个更完善的垃圾堆放处的实现\r\n","slug":"Dev/Theory/Complexity Has to Live Somewhere","date":"2022-07-03T04:23:23.000Z","categories_index":"Theroy","tags_index":"Theroy","author_index":"JBR_Bunjie"},{"id":"b0ae4fbedb34b36c8057186eece784bd","title":"Download SVG Element As A Pic","content":"Download SVG Element As A\r\nPic\r\nTHE\r\nDEFFERENCE BETWEEN SVG ELEMENT(CODE) AND SVG FILE\r\n\r\nreference:\r\n\r\nHow\r\ncan I save svg code as a .svg image? - Stack Overflow\r\n\r\nconclusions:\r\n\r\n\"Just had to make sure it has attribute: xmlns and versions, and then\r\nsave it in a text file and give it a .svg extension. Also make sure to\r\nadd xml tag a the top of the svg file just before pasting the svg tag\r\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\"\r\nSAVE (RATHER: DOWNLOAD)\r\nTHE SVG ELEMENT:\r\n\r\nrefenece: javascript\r\n- How do I save/export an SVG file after creating an SVG with D3.js (IE,\r\nsafari and chrome)? - Stack Overflow\r\ncode (which was used in NeatSankey) :\r\n\r\n1234567891011121314function save_as_svg() &#123;  var svg_data = document.getElementById(&quot;svg&quot;).innerHTML; //put id of your svg element here  var head =    &#x27;&lt;svg title=&quot;graph&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&#x27;;  //if you have some additional styling like graph edges put them inside &lt;style&gt; tag  var style = &quot;&lt;style&gt;&lt;/style&gt;&quot;;  var full_svg = head + style + svg_data + &quot;&lt;/svg&gt;&quot;;  var blob = new Blob([full_svg], &#123; type: &quot;image/svg+xml&quot; &#125;);  saveAs(blob, &quot;graph.svg&quot;);&#125;\r\nMETHOD NOT EXAMINED:\r\n\r\nreference: URL.createObjectURL()\r\n- Web API 接口参考 | MDN (mozilla.org)\r\ncode:\r\n\r\n12345678910var svgData = $(&quot;#figureSvg&quot;)[0].outerHTML;var svgBlob = new Blob([svgData], &#123; type: &quot;image/svg+xml;charset=utf-8&quot; &#125;);var svgUrl = URL.createObjectURL(svgBlob);var downloadLink = document.createElement(&quot;a&quot;);downloadLink.href = svgUrl;downloadLink.download = &quot;newesttree.svg&quot;;document.body.appendChild(downloadLink);downloadLink.click();document.body.removeChild(downloadLink);\r\nMORE RESOURCE\r\n\r\neligrey/FileSaver.js: An\r\nHTML5 saveAs() FileSaver implementation (github.com)\r\njimmywarting/StreamSaver.js:\r\nStreamSaver writes stream to the filesystem directly asynchronous\r\n(github.com)\r\nFileSaver.js 介绍 -\r\nyunser_blog - 博客园 (cnblogs.com)\r\nWorking\r\nwith files - Mozilla | MDN\r\n\r\n","slug":"Dev/Front End/download svg pic","date":"2022-05-12T19:23:23.000Z","categories_index":"Javascripts","tags_index":"Javascripts","author_index":"JBR_Bunjie"},{"id":"a9c12b026b9f323fd06103f80893c3ae","title":"Setup A Flask Application","content":"Setup A Flask Application\r\n一个简单但完整的示例\r\n123456789101112from flask import Flask, jsonifyapp = Flask(__name__)@app.route(&#x27;/api&#x27;)def my_microservice():    return jsonify(&#123;&#x27;Hello&#x27;: &#x27;World!&#x27;&#125;)if __name__ == &#x27;__main__&#x27;:    app.run()\r\n此时，当我们访问/api时，应用会返回一个 JSON 映射。\r\n\r\n变量__name__\r\n\r\n\r\n变量__name__是这个应用软件包的名称，而当运行一个单独的 Python\r\n模块时，变量__name__会赋值为__main__\r\nFlask\r\n会使用这个变量实例化一个新的日志日志记录器(logger)，并在磁盘上定位这个模块所在文件的路径。\r\nFlask\r\n将使用该文件的目录作为助手程序的根目录(例如与应用程序相关的配置文件)，并根据此目录确定静态文件目录(static)与模板目录(templates)的默认存放位置\r\n\r\n在 shell 中运行当前模块时，Flask 会运行其中的内置 Web\r\n服务器，并在默认在 5000 端口监听传入的请求\r\n\r\n访问/api\r\n\r\n123456789101112131415161718root@BUNJIESP8:/mnt/c/Users/m1518/Project/flask# curl -v http://127.0.0.1:5000/api*   Trying 127.0.0.1:5000...* Connected to 127.0.0.1 (127.0.0.1) port 5000 (#0)&gt; GET /api HTTP/1.1&gt; Host: 127.0.0.1:5000&gt; User-Agent: curl/7.81.0&gt; Accept: */*&gt;* Mark bundle as not supporting multiuse&lt; HTTP/1.1 200 OK&lt; Server: Werkzeug/2.2.2 Python/3.10.4&lt; Date: Sat, 10 Sep 2022 11:43:02 GMT&lt; Content-Type: application/json&lt; Content-Length: 19&lt; Connection: close&lt;&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;* Closing connection 0\r\n可以发现，我们得到了一个合法的 JSON 响应和正确的消息头。\r\n\r\njsonity 函数\r\n\r\n该函数会将 Python 字典类型转换为合法的 JSON 响应，并在添加适当的\r\nContent-Type 消息头后，将映射信息存储到响应体中\r\nrequest 对象\r\n与大多数 Web 框架不同，flask 不需要显示地将 request\r\n对象传递到代码中——它隐式地提供了一个全局的 request\r\n变量，并用该全局的变量来指向当前的 request 对象。Flask 把传入的 HTTP\r\n请求解析为 WSGI 环境字典，并利用它来创建这个对象\r\n这样：当服务器的响应不依赖请求的内容时，就没必要处理它。视图只需要确保返回了客户端应该获取的内容，并确保内容能够被\r\nFlask 序列化即可\r\n了解底层到底发生了什么\r\n增加 print 方法，了解 curl 访问具体过程\r\n123456789101112131415161718from flask import Flask, jsonify, requestapp = Flask(__name__)@app.route(&#x27;/api&#x27;)def my_microservice():    print(request)    print(request.environ)    response = jsonify(&#123;&#x27;Hello&#x27;: &#x27;World!&#x27;&#125;)    print(response)    print(response.data)    return responseif __name__ == &#x27;__main__&#x27;:    print(app.url_map)    app.run()\r\n有：\r\n12345678910111213(venv) root@BUNJIESP8:/mnt/c/Users/m1518/Project/flask/chapter2# python app.pyMap([&lt;Rule &#x27;/static/&lt;filename&gt;&#x27; (OPTIONS, GET, HEAD) -&gt; static&gt;, &lt;Rule &#x27;/api&#x27; (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;]) * Serving Flask app &#x27;app&#x27; * Debug mode: offWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Running on http://127.0.0.1:5000Press CTRL+C to quit&lt;Request &#x27;http://127.0.0.1:5000/api&#x27; [GET]&gt;&#123;&#x27;wsgi.version&#x27;: (1, 0), &#x27;wsgi.url_scheme&#x27;: &#x27;http&#x27;, &#x27;wsgi.input&#x27;: &lt;_io.BufferedReader name=4&gt;, &#x27;wsgi.errors&#x27;: &lt;_io.TextIOWrapper name=&#x27;&lt;stderr&gt;&#x27; mode=&#x27;w&#x27; encoding=&#x27;utf-8&#x27;&gt;, &#x27;wsgi.multithread&#x27;: True, &#x27;wsgi.multiprocess&#x27;: False, &#x27;wsgi.run_once&#x27;: False, &#x27;werkzeug.socket&#x27;: &lt;socket.socket fd=4, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&#x27;127.0.0.1&#x27;, 5000), raddr=(&#x27;127.0.0.1&#x27;, 54614)&gt;, &#x27;SERVER_SOFTWARE&#x27;: &#x27;Werkzeug/2.2.2&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;, &#x27;SCRIPT_NAME&#x27;: &#x27;&#x27;, &#x27;PATH_INFO&#x27;: &#x27;/api&#x27;, &#x27;QUERY_STRING&#x27;: &#x27;&#x27;, &#x27;REQUEST_URI&#x27;: &#x27;/api&#x27;, &#x27;RAW_URI&#x27;: &#x27;/api&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: 54614, &#x27;SERVER_NAME&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;5000&#x27;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;, &#x27;HTTP_HOST&#x27;: &#x27;127.0.0.1:5000&#x27;, &#x27;HTTP_USER_AGENT&#x27;: &#x27;curl/7.81.0&#x27;, &#x27;HTTP_ACCEPT&#x27;: &#x27;*/*&#x27;, &#x27;werkzeug.request&#x27;: &lt;Request &#x27;http://127.0.0.1:5000/api&#x27; [GET]&gt;&#125;&lt;Response 19 bytes [200 OK]&gt;b&#x27;&#123;&quot;Hello&quot;:&quot;World!&quot;&#125;\\n&#x27;127.0.0.1 - - [10/Sep/2022 22:55:47] &quot;GET /api HTTP/1.1&quot; 200 -\r\n路由匹配\r\n路由匹配发生在 app.url_map 中，这是 Werzeug 中 Map\r\n类的一个实例。Map([&lt;Rule '/static/&lt;filename&gt;' (OPTIONS, GET, HEAD) -&gt; static&gt;, &lt;Rule '/api' (OPTIONS, GET, HEAD) -&gt; my_microservice&gt;])\r\n该类使用正则表达式来判定被@app.route装饰的函数时候与传入的请求匹配，路由匹配只会姜茶\r\nroute\r\n调用里的路径参数来判断函数时候匹配客户端的请求，默认情况下，声明式路由只支持GET,\r\nOPTIONS, HEAD方法的调用，如果使用了不支持的\r\nHTTP 方法，则会出现 405Method Not Allowed 响应，并在 Allow\r\n响应头中返回其所支持的 HTTP 方法列表（正常访问不会出现 Allow\r\n响应头）\r\n当需要支持指定 HTTP 请求方式时，我们需要给装饰器增加额外的参数：\r\n1@app.route(&#x27;/api&#x27;, method=[&#x27;POST&#x27;, &#x27;DELETE&#x27;, &#x27;GET&#x27;])\r\n不过，\r\n变量与转换器\r\n路由系统支持变量如：/person/&lt;person_id&gt;\r\n请求\r\n响应\r\nFlask 的内置特性\r\n微服务骨架\r\n拓展：\r\n这个 name 变量可能取什么值？\r\n当你直接执行一段脚本的时候，这段脚本的 name变量等于\r\n'main'，当这段脚本被导入其他程序的时候，name\r\n变量等于脚本本身的名字。\r\n这个 name 拿来做什么的？\r\n作为 Python\r\n的内置变量，name变量（前后各有两个下划线）还是挺特殊的。它是每个\r\nPython 模块必备的属性，但它的值取决于你是如何执行这段代码的。\r\n在许多情况下，你的代码不可能全部都放在同一个文件里，或者你在这个文件里写的函数，在其他地方也可以用到。为了更高效地重用这些代码，你需要在\r\nPython 程序中导入来自其他文件的代码。\r\n所以，在name\r\n变量的帮助下，你可以判断出这时代码是被直接运行，还是被导入到其他程序中去了。\r\nPython 的\r\nname 变量，到底是个什么东西？ - 知乎\r\n(zhihu.com)\r\n部署\r\n\r\n部署方式\r\n。\r\nHow\r\nto Deploy Flask Application with Nginx and Gunicorn on Ubuntu 20.04 -\r\nRoseHosting\r\n\r\n","slug":"Dev/Back End/flask/setup_your_flask","date":"2022-04-23T04:23:23.000Z","categories_index":"Python","tags_index":"Python,flask","author_index":"JBR_Bunjie"},{"id":"7c3d41f90666b48d6b76a1cfaa71f837","title":"Python装饰器","content":"Python装饰器\r\n1、闭包\r\n要想了解装饰器，首先要了解一个概念，闭包。\r\n什么是闭包，一句话说就是，在函数中再嵌套一个函数，并且引用外部函数的变量，这就是一个闭包了。光说没有概念，直接上一个例子。\r\n12345678def outer(x):    def inner(y):        return x + y    return innerprint(outer(6)(5))# output: 11\r\n如代码所示，在outer函数内，又定义了一个inner函数，并且inner函数又引用了外部函数outer的变量x，这就是一个闭包了。在输出时，outer(6)(5),第一个括号传进去的值返回inner函数，其实就是返回6\r\n+ y，所以再传第二个参数进去，就可以得到返回值，6 + 5。\r\n2.@符号\r\n含义解释\r\n@符号会使用一个简短的方式来生成一个被装饰的函数，具体过程可以理解为：\r\n12345678910111213141516171819202122232425262728293031323334# 装饰函数：def a_new_decorator(a_func):    def wrapTheFunction():        print(&quot;I am doing some boring work before executing a_func()&quot;)         a_func()         print(&quot;I am doing some boring work after executing a_func()&quot;)     return wrapTheFunction # 需要被装饰的目标函数：def a_function_requiring_decoration():    print(&quot;I am the function which needs some decoration to remove my foul smell&quot;)# 当前 a_function_requiring_decoration 函数的执行结果# outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;# 可行的装饰方式：a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)#now a_function_requiring_decoration is wrapped by wrapTheFunction()#---------或者：@a_new_decoratordef a_function_requiring_decoration():    &quot;&quot;&quot;Now the func is wrapped&quot;&quot;&quot;    print(&quot;I am the function which needs some decoration to remove my foul smell&quot;)# 不管是怎么修饰，都可以在修饰后，执行得到：a_function_requiring_decoration()#outputs:I am doing some boring work before executing a_func()#        I am the function which needs some decoration to remove my foul smell#        I am doing some boring work after executing a_func()\r\n也就是说：@a_new_decorator 就是\r\na_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)的简写\r\n一个小问题\r\n在上方的代码执行完后，如果再打印：\r\n12print(a_function_requiring_decoration.__name__)# Output: wrapTheFunction\r\n为啥？\r\n修饰的实际过程是怎么样的吗？-&gt;就上方的例子而言，该装饰器的修饰过程是：a = a_new_decorator(a)，而a实际上只是一个地址的指向，现在a指向的位置是哪里？\r\n是decorator执行结束时，return的wrapTheFunction，也就是说，a所指向的函数被新的a_new_decorator代替了。\r\n为了解决“名字”的问题，我们可以再用一个装饰器functools.wraps：\r\n12345678910111213141516from functools import wraps def a_new_decorator(a_func):    @wraps(a_func)    def wrapTheFunction():        print(&quot;I am doing some boring work before executing a_func()&quot;)        a_func()        print(&quot;I am doing some boring work after executing a_func()&quot;)    return wrapTheFunction @a_new_decoratordef a_function_requiring_decoration():    print(&quot;I am the function which needs some decoration to remove my foul smell&quot;) print(a_function_requiring_decoration.__name__)# Output: a_function_requiring_decoration\r\n@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。\r\n3、装饰器\r\n解决了两个前置目标后，我们实际上就已经理解了什么是装饰器了\r\n而python对装饰器的定义是：\r\n接下来就讲装饰器，其实装饰器就是一个闭包，装饰器是闭包的一种应用。什么是装饰器呢，简言之，python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。使用时，再需要的函数前加上@demo即可。\r\n1234567891011121314def debug(func):    def wrapper():        print(&quot;[DEBUG]: enter &#123;&#125;()&quot;.format(func.__name__))        return func()    return wrapper@debugdef hello():    print(&quot;hello&quot;)hello()-----------------------------&gt;&gt;&gt;[DEBUG]: enter hello()&gt;&gt;&gt;hello\r\n例子中的装饰器给函数加上一个进入函数的debug模式，不用修改原函数代码就完成了这个功能，可以说是很方便了。\r\n3、带参数的装饰器\r\n上面例子中的装饰器是不是功能太简单了，那么装饰器可以加一些参数吗，当然是可以的，另外装饰的函数当然也是可以传参数的。\r\n12345678910111213141516def logging(level):    def outwrapper(func):        def wrapper(*args, **kwargs):            print(&quot;[&#123;0&#125;]: enter &#123;1&#125;()&quot;.format(level, func.__name__))            return func(*args, **kwargs)        return wrapper    return outwrapper@logging(level=&quot;INFO&quot;)def hello(a, b, c):    print(a, b, c)hello(&quot;hello,&quot;,&quot;good&quot;,&quot;morning&quot;)-----------------------------&gt;&gt;&gt;[INFO]: enter hello()&gt;&gt;&gt;hello, good morning\r\n如上，装饰器中可以传入参数，先形成一个完整的装饰器，然后再来装饰函数，当然函数如果需要传入参数也是可以的，用不定长参数符号就可以接收，例子中传入了三个参数。\r\n123456@logging(level=&quot;INFO&quot;) 可以看做是 hello = logging(level=&quot;INFO&quot;)(hello)# 这里的hello是函数对象，python中一切皆是对象，函数也可以像变量一样传递，加括号后hello()才是执行函数。于是这里就变成了hello = outwrapper(hello)# 而outwrapper() 的返回是 wrapper，hello 就等于 wrapper，执行 hello() 就等价于执行 wrapper()，而等号右边的 hello 已经作为参数传递给 outrapper() 了\r\n4、类装饰器\r\n装饰器也不一定只能用函数来写，也可以使用类装饰器，用法与函数装饰器并没有太大区别，实质是使用了类方法中的call魔法方法来实现类的直接调用。\r\n12345678910111213141516class logging(object):    def __init__(self, func):        self.func = func    def __call__(self, *args, **kwargs):        print(&quot;[DEBUG]: enter &#123;&#125;()&quot;.format(self.func.__name__))        return self.func(*args, **kwargs)@loggingdef hello(a, b, c):    print(a, b, c)hello(&quot;hello,&quot;,&quot;good&quot;,&quot;morning&quot;)\t-----------------------------&gt;&gt;&gt;[DEBUG]: enter hello()&gt;&gt;&gt;hello, good morning\r\n​ 类装饰器也是可以带参数的，如下实现\r\n12345678910111213141516171819class logging(object):    def __init__(self, level):        self.level = level    def __call__(self, func):        @wraps(func)        def wrapper(*args, **kwargs):            print(&quot;[&#123;0&#125;]: enter &#123;1&#125;()&quot;.format(self.level, func.__name__))            return func(*args, **kwargs)        return wrapper@logging(level=&quot;TEST&quot;)def hello(a, b, c):    print(a, b, c)hello(&quot;hello,&quot;,&quot;good&quot;,&quot;morning&quot;)-----------------------------&gt;&gt;&gt;[TEST]: enter hello()&gt;&gt;&gt;hello, good morning\r\n好了，如上就是装饰器的一些概念和大致的用法啦，想更深入的了解装饰器还是需要自己在平时的练习和应用中多体会，本篇只是给出一个概念，谢谢~\r\n编写装饰器\r\nproperty装饰器\r\n既要保护类的封装特性，又要让开发者可以使用“对象.属性”的方式操作操作类属性，除了使用\r\nproperty() 函数，Python\r\n还提供了 @property\r\n装饰器。通过 @property\r\n装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“()”小括号\r\n@property\r\n的语法格式如下：\r\n123@propertydef 方法名(self)  代码块\r\n例如，定义一个矩形类，并定义用 @property 修饰的方法操作类中的 area\r\n私有属性，代码如下：\r\n1234567class Rect:       def __init__(self,area):            self.__area = area    @property     def area(self):            return self.__arearect = Rect(30)  # 直接通过方法名来访问 area 方法print(&quot;矩形的面积是：&quot;,rect.area)  # 运行结果: 30\r\n上面程序中，使用 ＠property 修饰了 area()\r\n方法，这样就使得该方法变成了 area 属性的 getter\r\n方法。需要注意的是，如果类中只包含该方法，那么 area\r\n属性将是一个只读属性。\r\n也就是说，在使用 Rect 类时，无法对 area\r\n属性重新赋值，即运行如下代码会报错：\r\n12rect.area = 90print(&quot;修改后的面积：&quot;,rect.area)\r\n运行结果为：\r\n123Traceback (most recent call last):File &quot;C:\\Users\\mengma\\Desktop\\1.py&quot;, line 10, in &lt;module&gt; rect.area = 90AttributeError: can&#x27;t set attribute\r\n而要想实现修改 area 属性的值，还需要为 area 属性添加 setter\r\n方法，也就需要用到 setter 装饰器\r\nsetter装饰器\r\n它的语法格式如下：\r\n123@方法名.setterdef 方法名(self, value):    代码块\r\n例如，为 Rect 类中的 area 方法添加 setter 方法，代码如下：\r\n123@area.setterdef area(self, value):      self.__area = value\r\n再次运行如下代码：\r\n12rect.area = 90print(&quot;修改后的面积：&quot;,rect.area)  #运行结果 area: 90\r\n这样，area 属性就有了 getter 和 setter\r\n方法，该属性就变成了具有读写功能的属性。\r\n除此之外，还可以使用 deleter 装饰器来删除指定属性\r\ndeleter装饰器\r\n语法格式\r\n123@方法名.deleterdef 方法名(self):  代码块\r\n例如，在 Rect 类中，给 area() 方法添加 deleter\r\n方法，实现代码如下：\r\n123@area.deleterdef area(self):\tself.__area = 0\r\n然后运行如下代码：\r\n1del rect.areaprint(&quot;删除后的area值为：&quot;,rect.area)  # 运行结果 area: 0\r\nAll in one: property() 函数\r\nproperty() 函数的作用是在新式类中返回属性值。\r\n语法\r\n1class property([fget[, fset[, fdel[, doc]]]])\r\n参数\r\n\r\nfget -- 获取属性值的函数\r\nfset -- 设置属性值的函数\r\nfdel -- 删除属性值函数\r\ndoc -- 属性描述信息\r\n\r\n返回值\r\n返回新式类属性。\r\n实例\r\n1234567891011121314class C(object):    def __init__(self):        self._x = None     def getx(self):        return self._x     def setx(self, value):        self._x = value     def delx(self):        del self._x     x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)\r\n如果 c 是 C 的实例化, then =&gt;\r\n\r\nc.{object} 将触发 getter\r\nc.{object} = value 将触发 setter\r\ndel c.{object} 触发 deleter\r\n\r\n如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property\r\n函数就会复制 fget 函数的 docstring（如果有的话）\r\n@wraps()\r\n相当于：\r\n12345678def Wraps(fWrap):    def TmpWraps(func):        def WrapsDecorator(*args, **kwargs):            WrapsDecorator.__name__=fWrap.__name__            WrapsDecorator.__doc__=fWrap.__doc__            return func(*args, **kwargs)        return WrapsDecorator    return TmpWraps\r\n示例代码如下：\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344def Wraps(fWrap):    def TmpWraps(func):        def WrapsDecorator(*args, **kwargs):            WrapsDecorator.__name__=fWrap.__name__            WrapsDecorator.__doc__=fWrap.__doc__            return func(*args, **kwargs)        return WrapsDecorator    return TmpWrapsdef NewDecorator(level):    def TmpDecorator(func):        def anotherFunc():            &#x27;&#x27;&#x27;it&#x27;s another function&#x27;&#x27;&#x27;            pass        #from functools import wraps        #@wraps(anotherFunc)        @Wraps(anotherFunc)        def NewFibonacci(*args, **kwargs):            print(&#x27;[%s]func: %s is called, %s&#x27;%(level,func.__name__,NewFibonacci.__doc__))            from time import time            start = time()            rst=func(*args, **kwargs)            end=time()            print(&#x27;cost time: %.2fs&#x27;%(end-start))            return rst        return NewFibonacci    return TmpDecorator@NewDecorator(&#x27;log&#x27;)def Fibonacci_print(num=10):    if num &lt;= 0:        return    minNum,maxNum=0,1    while num &gt; 0:        tmpNum=minNum        print(tmpNum, end=&#x27;,&#x27;)        minNum=maxNum        maxNum+=tmpNum        num-=1Fibonacci_print()print(Fibonacci_print.__name__)\r\n输出为：\r\n123[log]func: Fibonacci_print is called, it&#x27;s another function0,1,1,2,3,5,8,13,21,34,cost time: 0.07sanotherFunc\r\n再论 @wraps(func) 装饰器实现原理。\r\n纠正下楼上 @DragonZ\r\n描述的基本代码框架，应该是如下：\r\n12345678def Wraps(fWrap):    def TmpWraps(func):        def WrapsDecorator(*args, **kwargs):            return func(*args, **kwargs)            WrapsDecorator.__name__=fWrap.__name__            WrapsDecorator.__doc__=fWrap.__doc__        return WrapsDecorator    return TmpWraps\r\n并且该装饰器不仅仅只是复制了__name__ 和 doc\r\n函数元信息，还有更多其他信息，正确的实现代码如下：\r\n12345678910def mywraps(fwrap):    def TmpWraps(func):        def dec(**args):            return func(**args)        meta_info=[&#x27;__module__&#x27;, &#x27;__name__&#x27;, &#x27;__qualname__&#x27;, &#x27;__doc__&#x27;, &#x27;__annotations__&#x27;]        for meta in meta_info:            setattr(dec,meta,getattr(fwrap,meta))        #逐个获取fwrap函数的元信息，并复制到dec函数上        return dec    return TmpWraps\r\n另外，针对类装饰器，可能下面这样解释，会对初学者更加友好：\r\n装饰器还可以通过类来实现，其实主要是利用类的以下特点来变相实现函数装饰器功能：\r\n函数调用语语法f()等同于类的实例化，即调用类的__init__函数创建对象\r\n对象的调用obj()等同于运行对象的__call__魔法函数\r\n通过类实现装饰器，可以避免函数装饰器超过2层的嵌套情况，因为如果有三层的话，最外层函数可以认为是在调用类的__init__函数，这样可以让代码更易读和维护\r\n本质，只要实现类的__init__和__call__魔法函数，并在__init__函数内接受装饰器参数，在__call__函数内实现具体装饰器结构即可\r\n下面举例，用类实现带参装饰器，可以观察下不同\r\n123456789101112131415161718192021from functools import wraps #定义一个装饰器名称的类class  with_para_decorator:     #在类的__init__函数内接受装饰器参数，并赋值给类的实例参数，这样可以让其他函数随时使用    #当然，如果装饰器没有参数，此处不转a,b即可，相当于类无参实例化    def __init__(self,a,b):            self.a=a        self.b=b    #在类的__call__函数内接受被装饰函数，并具体定义装饰器    def __call__(self,func):       @wraps(func)       def wrap_function(arg1,arg2):          print(&#x27;装饰带参数的函数，函数传的参数为：&#123;0&#125;, &#123;1&#125;&#x27;.format(arg1,arg2))        print(&#x27;带参数的装饰器，装饰器传的参数为：&#123;0&#125;, &#123;1&#125;&#x27;.format(self.a,self.b))        return func(arg1,arg2)       return wrap_function#使用装饰器@with_para_decorator(1,2)  def need_decorate(a,b):   passneed_decorate(4,5) \r\n以上代码具体原理解析如下：\r\n\r\n@with_para_decorator(1,2)，因为是类的名称，相当于使用(1,2)参数创建并返回该类的一个实例对象，比如是\r\nobj\r\n此时，语法变为@obj，相当于need_decorate=obj(need_decorate)，此时会调用obj.__call__魔法函数，而我们在该魔法函数具体实现了装饰器功能\r\n可以看到，其本质的运行原理，和函数装饰器没区别，只是将三层函数嵌套，变成了一个__init__函数和__call__函数的两层嵌套\r\n对比下来，可以看到，类装饰器，代码更加直观\r\n\r\nLink:\r\n\r\nPython\r\n函数装饰器 | 菜鸟教程 (runoob.com)\r\npython 装饰器详解 -\r\n知乎 (zhihu.com)\r\nfunctools\r\n— Higher-order functions and operations on callable objects — Python\r\n3.10.7 documentation\r\n什么是闭包？闭包的优缺点？\r\n| 菜鸟教程 (runoob.com)\r\n闭包\r\n- JavaScript | MDN (mozilla.org)\r\n\r\n","slug":"Language Learning/Python/装饰器","date":"2022-02-13T04:07:03.000Z","categories_index":"Python,Language Learning","tags_index":"Language Learning,Python","author_index":"JBR_Bunjie"},{"id":"ca2444d0b470feb04a7e872fb5786d4a","title":"APT、APT-GET与YUM","content":"APT、APT-GET与YUM\r\napt\r\n什么是 apt\r\napt（Advanced Packaging Tool）基于 DEB 包管理，是一个常见于 Debian 和\r\nUbuntu 中的软件包管理器，也用于 Kali 等系统中\r\n对应着 dpkg\r\napt 和 apt-get 的关系\r\n虽然有些微小的差异，但也可以认为：apt 是\r\napt-get 的超集，它包含\r\napt-get、apt-cache 和 apt-config\r\n中最常用命令选项的集合。\r\n一般的应用场景下 apt 和 apt-get\r\n可以互用\r\n不过也确实可以作一些区分：\r\n\r\nWARNING : apt does not have a stable CLI interface.\r\n\r\n编写高可靠需求的自动化脚本时，使用 apt-get；其余时候可以使用更简练的\r\napt 命令\r\n常用命令\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncommand\r\ndescription\r\n\r\n\r\n\r\n\r\nsudo apt update\r\n列出所有可更新的软件清单命令\r\n\r\n\r\nsudo apt upgrade\r\n升级软件包\r\n\r\n\r\napt list --upgradeable\r\n列出可更新的软件包及版本信息\r\n\r\n\r\nsudo apt full-upgrade\r\n升级软件包，升级前先删除需要更新软件包\r\n\r\n\r\nsudo apt install \r\n安装指定的软件命令\r\n\r\n\r\nsudo apt install   \r\n安装多个软件包\r\n\r\n\r\nsudo apt update \r\n更新指定的软件命令\r\n\r\n\r\nsudo apt show \r\n显示软件包具体信息,例如：版本号，安装大小，依赖关系等等\r\n\r\n\r\nsudo apt remove \r\n删除软件包命令\r\n\r\n\r\nsudo apt autoremove\r\n清理不再使用的依赖和库文件\r\n\r\n\r\nsudo apt purge \r\n移除软件包及配置文件\r\n\r\n\r\nsudo apt search &lt;keyword&gt;\r\n从软件源中查找软件包\r\n\r\n\r\napt list --installed\r\n列出所有已安装的包\r\n\r\n\r\napt list --all-versions\r\n列出所有已安装的包的版本信息\r\n\r\n\r\napt help\r\n帮助\r\n\r\n\r\n\r\n\r\napt-get update：是同步/etc/apt/sources.list和/etc/apt/sources.list.d中列出的软件源的软件包版本，这样才能获取到最新的软件包。\r\napt-get upgrade：是更新已安装的所有或者指定软件包，升级之到本地索引中的对应版本。因此，在执行\r\nupgrade\r\n之前一般要执行update，这样安装的才是最新的版本。\r\n\r\n编辑 source.list 文件\r\n以 ubuntu20.04lts 为例\r\n在使用apt时，我们需要维护一个存储着源地址信息的文本文件：/etc/apt/source.list，\r\napt可以通过这些地址来查询软件最新版本并通过他们进行更新\r\nsource.list 内容(已去除部分注释)：\r\n1234567891011121314151617181920deb http://archive.ubuntu.com/ubuntu/ focal main restricted# deb-src http://archive.ubuntu.com/ubuntu/ focal main restricteddeb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted# deb-src http://archive.ubuntu.com/ubuntu/ focal-updates main restricteddeb http://archive.ubuntu.com/ubuntu/ focal universe# deb-src http://archive.ubuntu.com/ubuntu/ focal universedeb http://archive.ubuntu.com/ubuntu/ focal-updates universe# deb-src http://archive.ubuntu.com/ubuntu/ focal-updates universedeb http://archive.ubuntu.com/ubuntu/ focal multiverse# deb-src http://archive.ubuntu.com/ubuntu/ focal multiversedeb http://archive.ubuntu.com/ubuntu/ focal-updates multiverse# deb-src http://archive.ubuntu.com/ubuntu/ focal-updates multiversedeb http://archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse# deb-src http://archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ focal-security main restricted# deb-src http://security.ubuntu.com/ubuntu/ focal-security main restricteddeb http://security.ubuntu.com/ubuntu/ focal-security universe# deb-src http://security.ubuntu.com/ubuntu/ focal-security universedeb http://security.ubuntu.com/ubuntu/ focal-security multiverse# deb-src http://security.ubuntu.com/ubuntu/ focal-security multiverse\r\n解析规则：\r\n总的来说，解析 list 时遵循以下规则：\r\nuri + \"dists\" + ubuntu 版本信息 + 索引分类 +\r\n仓库类型\r\n\r\n仓库类型：\r\n\r\ndeb： 二进制包仓库\r\ndeb-src： 二进制包的源码库\r\n\r\nuri：\r\n\r\nURI：库所在的地址，可以是网络地址，也可以是本地的镜像地址\r\n\r\n版本信息：\r\n\r\n就是当前 Ubuntu 对应的版本代号。可以用命令 lsb_release -sc\r\n来查看当前系统的代号。\r\n20.04lts 的代号是 focal，所以所有的 uri 后都会有\r\nfocal\r\n具体则有五种后缀：\r\n\r\n无后缀 - 一般不考虑的随发布的 source\r\nSecurity - Important Security Updates.\r\nUpdates - Recommended Updates.\r\nProposed - Pre-released Updates.\r\nBackports - Unsupported Updates.\r\n\r\n\r\n索引分类：\r\n\r\ncomponents： 软件的性质（free 或 non-free 等）\r\n共有四种：\r\n\r\nmain: 完全的自由软件。\r\nrestricted: 不完全的自由软件。\r\nuniverse: Ubuntu 官方不提供支持与补丁，全靠社区支持。\r\nmultiverse：非自由软件，完全不提供支持和补丁。\r\n\r\n例如，现有一个源配置如下：\r\n\r\ndeb http://archive.ubuntu.com/ubuntu/ focal main restricted\r\n\r\n那么，解析出的结果为：\r\nhttp://cn.archive.ubuntu.com/ubuntu/dists/focal/main\r\nhttp://cn.archive.ubuntu.com/ubuntu/dists/focal/restricted\r\n\r\n\r\nimage-20220128141631953\r\n\r\n\r\n\r\nimage-20220128141726663\r\n\r\ndeb-src会对应 source，deb\r\n则会对应 binary-xxx，xxx 就是\r\narch，比如 i386 (32 位)或是 amd64\r\n(64 位)。\r\n如需指定 arch，则对应：\r\n\r\ndeb [arch=amd64] http://cn.archive.ubuntu.com/ubuntu/ focal main\r\n\r\n会指向：\r\n\r\nhttp://cn.archive.ubuntu.com/ubuntu/dists/focal/main/binary-amd64/\r\n\r\n编辑 /etc/apt/sources.list.d/\r\n目录\r\n和sources.list功能一样的是/etc/apt/sources.list.d目录\r\n在此目录下，我们可以随意定制我们所指定的软件源，只要以\r\n.list 结尾即可\r\nsources.list.d 目录下的 .list\r\n文件为软件源的管理提供了全新的思路，我们亦可以用此来安装第三方的软件。\r\n示例：\r\n用 /etc/apt/sources.list.d/google-chrome.list 文件来暂存\r\ngoogle chrome 的源\r\n12&gt;&gt; cat google-chrome.listdeb http://dl.google.com/linux/chrome/deb/ stable main\r\nyum\r\n介绍：\r\nyum(Yellow dog Updater, Modified)基于 RPM 包管理，是一个应用在 Fedora\r\n和 RedHat 系 Linux 中的软件包管理器。\r\n对应着 rpm\r\n常用命令：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncommand\r\ndescription\r\n\r\n\r\n\r\n\r\nyum search\r\n使用 yum (在源内)查找软件包\r\n\r\n\r\nyum install &lt;package_name&gt;\r\n仅安装指定的软件命令\r\n\r\n\r\nyum update &lt;package_name&gt;\r\n仅更新指定的软件命令\r\n\r\n\r\nyum remove &lt;package_name&gt;\r\n删除软件包命令\r\n\r\n\r\nyum list\r\n列出(源内)所有可安装的软件包\r\n\r\n\r\nyum list updates\r\n列出所有可更新的软件包\r\n\r\n\r\nyum list installed\r\n列出所有已安装的软件包\r\n\r\n\r\nyum list extras\r\n列出所有已安装但不在 Yum Repository\r\n内的软件包\r\n\r\n\r\nyum info\r\n使用 YUM 获取软件包信息\r\n\r\n\r\nyum info updates\r\n列出所有可更新的软件包信息\r\n\r\n\r\nyum info installed\r\n列出所有已安装的软件包信息\r\n\r\n\r\nyum info extras\r\n列出所有已安装但不在 Yum Repository\r\n内的软件包信息\r\n\r\n\r\nyum provides\r\n列出软件包提供哪些文件\r\n\r\n\r\n\r\n修改 yum 源：\r\n\r\n进入 yum 源配置目录：\r\n\r\n1cd /etc/yum.repos.d\r\n\r\n备份原配置文件：\r\n\r\n1sudo mv CentOS-Base.repo CentOS-Base.repo.backup\r\n\r\n下载新配置文件：\r\n\r\n123sudo wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo# http://mirrors.aliyun.com/repo先找到对应系统，这里是centos7# 没有wget就用curl，一定要用就在mv前线下载wget\r\n\r\n清除缓存\r\n\r\n12sudo yum clean allsudo yum makecache\r\n\r\n查看是否更新成功\r\n\r\n1yum repolist\r\n\r\n更新所有软件\r\n\r\n1yum update -y\r\n当然，我们也可以使用 yum 自带的插件——fastest-mirror\r\n\r\n\r\nimage-20220128150420505\r\n\r\n\r\nThe fastest mirror plugin is designed for use in repository\r\nconfigurations where you have more than 1 mirror in a repo\r\nconfiguration.\r\nAfter fastestmirror is installed, make sure that it is enabled.\r\nEdit the file /etc/yum/pluginconf.d/fastestmirror.conf\r\nand ensure that it contains the following lines:\r\n123456[main]verbose = 0socket_timeout = 3enabled = 1hostfilepath = /var/cache/yum/timedhosts.txtmaxhostfileage = 1\r\nTo exclude a specific mirror, TLD, or something in between, add an\r\n'exclude=' line to\r\n/etc/yum/pluginconf.d/fastestmirror.conf:\r\n123[main]...exclude=.gov, facebook, myspace, junk-mirror.com\r\nPackageManagement/Yum/FastestMirror\r\n- CentOS Wiki\r\n\r\ndnf——新一代的 RPM\r\n软件包管理器：\r\nDNF 包管理器作为 YUM\r\n包管理器的升级替代品，它能自动完成更多的操作。\r\nDNF/zh-cn - Fedora\r\nProject Wiki\r\n一些对比\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n对比项\r\nrpm\r\nyum\r\ndpkg\r\napt\r\n\r\n\r\n\r\n\r\n系列\r\nRedHat 系\r\nRedHat 系\r\nDebian 系\r\nDebian 系\r\n\r\n\r\n区别\r\n包安装工具\r\n依赖管理工具\r\n包安装工具\r\n依赖管理工具\r\n\r\n\r\n查询已安装\r\nrpm -qa\r\nyum list installed\r\ndkpg -l\r\napt list –installed\r\n\r\n\r\n安装\r\nrpm -i package.rpm 或 rpm –ivh\r\nhttp://www.xxx.net/package.rpm\r\nyum install\r\ndpkg -i package.deb\r\napt install package\r\n\r\n\r\n更新\r\nrpm –U software.rpm\r\nyum update\r\n\r\napt upgrade\r\n\r\n\r\n移除软件包\r\nrpm -e [module1][module2]…\r\nyum remove\r\ndpkg -r package\r\napt remove package\r\n\r\n\r\n移除软件包及配置\r\n\r\n\r\ndpkg -P\r\napt purge package\r\n\r\n\r\n下载的包存放位置\r\n\r\n\r\n\r\n/var/cache/apt/archives\r\n\r\n\r\n软件安装默认位置\r\nrpm -ql\r\n\r\n\r\n/usr/share\r\n\r\n\r\n可执行文件位置\r\n/usr/bin\r\n\r\n\r\n/usr/bin\r\n\r\n\r\n配置文件位置\r\n/etc\r\n\r\n\r\n/etc\r\n\r\n\r\nlib 文件位置\r\n/usr/lib\r\n\r\n\r\n\r\n\r\n\r\n使用手册\r\n/usr/share/doc\r\n\r\n\r\n\r\n\r\n\r\n帮助文档\r\n/usr/share/man\r\n\r\n\r\n\r\n\r\n\r\n更新\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nyum 与\r\napt 的区别_qq_26182553 的博客-CSDN 博客_yum 和 apt\r\nRPM 介绍\r\nRPM\r\n简介与基本使用 - 大师兄啊哈 - 博客园 (cnblogs.com)\r\n","slug":"Deploy/Linux/compareAPTandYUM","date":"2022-01-16T03:27:03.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"JBR_Bunjie"},{"id":"cdbb3c31309c2a4943509b68e63af1ea","title":"Linux Basic","content":"Linux Basic\r\napt 配置\r\napt 切换国内源\r\nlinux\r\n系统默认使用的软件源都是国外源，国内访问速度过慢，所以改为国内镜像源\r\n\r\nsudo su进入 root 模式\r\nvim /etc/apt/sources.list编辑软件源配置文件 \r\n按 i 进入 vim 的编辑模式，用#将 deb\r\n一行的内容注释掉，然后换成国内源地址,这里我直接用阿里云源\r\n\r\n123456789101112131415161718192021222324官方源deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib中科大源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib阿里云源deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib清华大学源deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free浙大源deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freedeb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free东软大学源deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contribdeb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib新加坡kali源deb http://mirror.nus.edu.sg/kali/kali/ kali main non-free contribdeb-src http://mirror.nus.edu.sg/kali/kali/ kali main non-free contrib163 Kali源deb http://mirrors.163.com/debian wheezy main non-free contribdeb-src http://mirrors.163.com/debian wheezy main non-free contrib\r\n 之后 Esc，然后 :wq 保存退出即可 \\4.\r\napt-get update更新索引 \\5.\r\napt-get upgrade更新软件\r\n用户\r\nIn Linux, there are three types of owners: user,\r\ngroup, and others .\r\nLinux User\r\nA user is the default owner and creator of the file. So this user is\r\ncalled owner as well.\r\n\r\nuser == owner\r\n\r\nLinux Group\r\nA user-group is a collection of users. Users that belonging to a\r\ngroup will have the same Linux group permissions to access a file/\r\nfolder.\r\nYou can use groups to assign permissions in a bulk instead of\r\nassigning them individually. A user can belong to more than one group as\r\nwell.\r\nOther\r\nAny users that are not part of the user or group classes belong to\r\nthis class.\r\n更换用户\r\n创建一个全新的用户账号：\r\nuseradd + passwd\r\n更换：\r\nsu 命令：\r\n123su rootsu - root # 不一样！# &quot;su r&quot;只是切换了用户，要想连shell环境一起切换就用后边的&quot;su - root&quot;。\r\n文件\r\n文件分类\r\nLinux 共有七类文件\r\n普通文件类型 [-]:\r\nLinux 中最多的一种文件类型, 包括\r\n纯文本文件(ASCII)；二进制文件(binary)；数据格式的文件(data);各种压缩文件。其第一个属性为\r\n[-]\r\n目录文件 [d]:\r\n就是目录， 能用 # cd 命令进入的。第一个属性为 [d]，例如\r\n[drwxrwxrwx]\r\n块设备文件 [b]:\r\n块设备文件就是存储数据以供系统存取的接口设备，简单而言就是硬盘。\r\n例如一号硬盘的代码是 /dev/hda1 等文件。第一个属性为 [b]\r\n字符设备 [c]:\r\n字符设备文件即串行端口的接口设备，例如键盘、鼠标等等。第一个属性为\r\n[c]\r\n套接字文件 [s]:\r\n这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。\r\n第一个属性为 [s]，最常在 /var/run 目录中看到这种文件类型\r\n管道文件 [p]:\r\nFIFO\r\n也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。\r\nFIFO 是 first-in-first-out(先进先出)的缩写。第一个属性为 [p]\r\n链接文件 [l]:\r\n类似 Windows 下面的快捷方式。第一个属性为 [l]，例如 [lrwxrwxrwx]\r\nHow to\r\nChange File Permissions and Ownership in Linux\r\nchmod 与 chown 的区别\r\nchmod - Used for Changing Permissions 用于改变\r\n具体文件或目录 之于某个用户或用户组的 权限关系: permission\r\nchown - Used for Changing Ownership 用与改变\r\n具体文件或目录 之于某个用户或用户组的 归属关系: ownership\r\nCHMOD PART\r\nSyntax\r\n1chmod [-options] [permissions] [filename]\r\n\r\npermissions can be read,\r\nwrite, execute or a\r\ncombination of them.\r\nfilename is the name of the file for which the\r\npermissions need to change. This parameter can also be a list if files\r\nto change permissions in bulk.\r\n\r\nWe can change permissions using two modes:\r\n\r\nSymbolic mode: this method uses symbols like\r\nu, g, o to represent users,\r\ngroups, and others. Permissions are represented as r, w, x\r\nfor read write and execute, respectively. You can modify permissions\r\nusing +, - and =.\r\nAbsolute mode: this method represents permissions\r\nas 3-digit octal numbers ranging from 0-7.\r\n\r\nExample\r\n123456chmod u+x mymotd.sh# To add execution rights (x) to user(or-&gt; the file owner)(u) using symbolic mode, we can use the command above;chmod 777 test.txt# 把三个分区看作三段被拼接的二进制# 111 -&gt; 7, rwx, u, g, o;\r\nCHOWN PART\r\nSyntax &amp; Example\r\n1234chown [-options] [user:group] [filename]/[path]chown -R root /root/test # 改变文件夹的归属chown :admins /opt/script # To change group ownership, we can use chown by preceding the group name by a colon &#x27;:&#x27;\r\nLinux 中\r\nchown 和 chmod 的区别和用法（转） - EasonJim - 博客园\r\n(cnblogs.com)\r\nLinux\r\nchmod and chown – How to Change File Permissions and Ownership in Linux\r\n(freecodecamp.org)\r\n","slug":"Deploy/Linux/Linux学习-Basic","date":"2022-01-16T03:11:11.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"JBR_Bunjie"},{"id":"df3dbd996fdf6e6a0e262b60be4e5d9a","title":"用户目录下的隐藏文件","content":"用户目录下的隐藏文件\r\n你的 home 目录下藏着很多隐藏文件，而.bashrc 就是其中之一\r\n.bashrc\r\n是什么及修改.bashrc 能做到什么\r\n如果你运行一个基于 Unix 或者类 Unix 的操作系统，bash\r\n很有可能是作为默认终端被安装的。虽然存在很多不同的 shell，bash\r\n却是最常见或许也是最主流的。同时，bash 在每次启动时都会加载 .bashrc\r\n文件的内容。每个用户的 home 目录都有这个 shell\r\n脚本。它用来存储并加载你的终端配置和环境变量。\r\n也就是说，一般情况下，我们能通过修改.bashrc 文件来定制我们当前账户的\r\nbash\r\n修改\r\n为命令设置别名：alias\r\n1alias ll = &quot;ls -lha&quot;\r\n函数:\r\n123456789function_name () &#123;\tcommand_1\tcommand_2&#125;# md () &#123;#   mkdir -p $1#   cd $1# &#125;\r\n什么是\r\n.bashrc，为什么要编辑 .bashrc？ | Linux 中国 - 知乎 (zhihu.com)\r\n更多的隐藏文件？\r\n补习：linux 系统变量的类型\r\n按变量的生存周期划分：\r\n\r\n永久的：需要修改配置文件，变量永久生效。\r\n临时的：使用 export 命令声明即可，变量在关闭 shell\r\n时失效。\r\n\r\n在配置永久的环境变量时，又可以按照作用范围分为：\r\n\r\n用户环境变量\r\n系统环境变量。\r\n\r\n系统环境变量对所有系统用户都有效，用户环境变量仅仅对当前的用户有效。\r\n设置环境变量\r\n直接运行 export 命令定义变量\r\n在 shell 的命令行下直接使用[export 变量名=变量值]\r\n定义变量。该变量只在当前的 shell（BASH）或其子\r\nshell（BASH）下是有效的，shell 关闭了，变量也就失效了，再打开新 shell\r\n时就没有这个变量，需要使用的话还需要重新定义。\r\n修改系统环境变量\r\n系统环境变量一般保存在下面的文件中\r\n1/etc/profile\r\n全局（公有）配置，不管是哪个用户，登录时都会读取该文件。\r\n1/etc/bash.bashrc\r\n它也是全局（公有）的 bash\r\n执行时，不管是何种方式，都会读取此文件。\r\n1/etc/environment\r\n不要轻易修改此文件\r\n修改用户环境变量\r\n用户环境变量通常被存储在下面的文件中：\r\n1~/.profile\r\n若 bash 是以 login\r\n方式执行时，读取~/.bash_profile，若它不存在，则读取~/.bash_login，若前两者不存在，读取~/.profile。\r\n1~/.bash_profile 或者~./bash_login\r\n若 bash 是以 login\r\n方式执行时，读取/.bash_profile，若它不存,则读取/.bash_login，若前两者不存在，读取\r\n~/.profile。 只有 bash 是以 login\r\n形式执行时，才会读取.bash_profile，Unbutu 默认没有此文件，可新建。\r\n通常该配置文件还会配置成去读取~/.bashrc。\r\n1~/.bashrc\r\n当 bash 是以 non-login 形式执行时，读取此文件。若是以 login\r\n形式执行，则不会读取此文件。\r\n~/.bash_profile 是交互式、login 方式进入 bash 运行的 ~/.bashrc\r\n是交互式 non-login 方式进入 bash\r\n运行的通常二者设置大致相同，所以通常前者会调用后者。\r\n修改环境变量配置文件\r\n如想将一个路径加入到环境变量（例如$PATH）中，可以像下面这样做（修改/etc/profile）：\r\nsudo vi /etc/profile 以环境变量 PATH 为例子，环境变量的声明格式：\r\n12PATH=$PATH:PATH_1:PATH_2:PATH_3:------:PATH_Nexport PATH\r\n你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效，如果想立刻生效，则可执行下面的语句：\r\n1$source /etc/profile\r\n环境配置文件的区别\r\nprofile、\r\nbashrc、.bash_profile、 .bashrc 介绍\r\nbash 会在用户登录时，读取下列四个环境配置文件：\r\n12全局环境变量设置文件：/etc/profile、/etc/bashrc。用户环境变量设置文件：~/.bash_profile、~/.bashrc。\r\n读取顺序：① /etc/profile、② ~/.bash_profile、③ ~/.bashrc、④\r\n/etc/bashrc。\r\n1234/etc/profile：此文件为系统的每个用户设置环境信息，系统中每个用户登录时都要执行这个脚本，如果系统管理员希望某个设置对所有用户都生效，可以写在这个脚本里，该文件也会从/etc/profile.d目录中的配置文件中搜集shell的设置。~/.bash_profile：每个用户都可使用该文件设置专用于自己的shell信息，当用户登录时，该文件仅执行一次。默认情况下，他设置一些环境变量，执行用户的.bashrc文件。~/.bashrc：该文件包含专用于自己的shell信息，当登录时以及每次打开新shell时，该文件被读取。/etc/bashrc：为每一个运行bash shell的用户执行此文件，当bash shell被打开时，该文件被读取。\r\n.bashrc 和.bash_profile\r\n的区别\r\n.bash_profile 会用在登陆 shell， .bashrc 使用在交互式非登陆 shell\r\n。简单说来，它们的区别主要是.bash_profile\r\n是在你每次登录的时候执行的；.bashrc\r\n是在你新开了一个命令行窗口时执行的。\r\n当通过控制台进行登录（输入用户名和密码）：在初始化命令行提示符的时候会执行.bash_profile\r\n来配置你的 shell 环境。但是如果已经登录到机器，在 Gnome 或者是 KDE\r\n也开了一个新的终端窗口（xterm），这时，.bashrc\r\n会在窗口命令行提示符出现前被执行。当你在终端敲入/bin/bash 时.bashrc\r\n也会在这个新的 bash 实例启动的时候执行。\r\n建议\r\n大多数的时候你不想维护两个独立的配置文件，一个登录的一个非登录的\r\nshell。当你设置 PATH 时，你想在两个文件都适用。可以在.bash_profile\r\n中调用.bashrc，然后将 PATH 和其他通用的设置放到.bashrc 中。\r\n要做到这几点，添加以下几行到.bash_profile 中：\r\n123if [ -f ~/.bashrc ]; then    . ~/.bashrcfi\r\n现在，当你从控制台登录机器的时候，.bashrc 就会被执行。\r\n常用的环境变量\r\n\r\n\r\n\r\ncommand?\r\nDescription\r\n\r\n\r\n\r\n\r\nBASH\r\nBash Shell 的全路径\r\n\r\n\r\nCDPATH\r\n用于快速进入某个目录。\r\n\r\n\r\nPATH\r\n决定了 shell\r\n将到哪些目录中寻找命令或程序\r\n\r\n\r\nHOME\r\n当前用户主目录\r\n\r\n\r\nHISTSIZE\r\n历史记录数\r\n\r\n\r\nLOGNAME\r\n当前用户的登录名\r\n\r\n\r\nHOSTNAME\r\n指主机的名称\r\n\r\n\r\nSHELL\r\n当前用户 Shell 类型\r\n\r\n\r\nLANGUGE\r\n语言相关的环境变量，多语言可以修改此环境变量\r\n\r\n\r\nMAIL\r\n当前用户的邮件存放目录\r\n\r\n\r\nPS1\r\n基本提示符，对于 root\r\n用户是#，对于普通用户是$\r\n\r\n\r\n\r\nReference\r\n[0] Linux\r\n的环境变量.bash_profile .bashrc profile 文件 - lvmenghui001 - 博客园\r\n(cnblogs.com)\r\n[1] /etc/profile、/etc/bashrc、/.bash_profile、/.bashrc\r\nhttp://blog.chinaunix.net/uid-26435987-id-3400127.html [2] Linux\r\n如何修改 env 看到的环境变量？ .bashrc 和.bash_profile 区别\r\nhttp://blog.csdn.net/xifeijian/article/details/13355031 [3] linux\r\n环境变量，bashrc 与 bashprofile\r\nhttp://blog.sina.com.cn/s/blog_43e5ad4e0101ei43.html\r\n","slug":"Deploy/Linux/用户目录下的隐藏文件","date":"2022-01-16T03:07:12.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"JBR_Bunjie"},{"id":"cf6928b4c9e850c601b4eb72b04e5691","title":"Linux Commands","content":"Linux Commands\r\n清空系统历史命令\r\n1. history -c\r\n该命令只清空本次登入的所有输出命令，且不清空.bash_history 文件\r\n所以下次登陆后，旧命令还将出现，历史命令是存在于当前用户根目录下的./bash_history\r\n文件。\r\n2. echo &gt; $HOME/.bash_history\r\n每个用户根目录下都有一个.bash_history\r\n文件用于保存历史命令，当每次注销时，本次登陆所执行的命令将被写入该文件。所以可以清空该文件，下次登陆后上次保存的命令将消失，清空效果将在下次登陆生效。\r\n3. 利用设备黑洞\r\n对 history 文件执行文本清空\r\n1cat /dev/null &gt; /root/.bash_history\r\n清空文件内容：\r\n1cat /dev/null &gt; [yourfilename]\r\n检查计算机状态\r\n硬件信息\r\n123456789101112&gt; cat /etc/os-rel&gt; cat /proc/cpuinfo # 查看CPU信息 &gt; cat /proc/cpuinfo | grep &quot;model name&quot; # 仅查看CPU内核&gt; cat /proc/meminfo # 查看内存&gt; cat /proc/meminfo | grep MemTotal # 仅查看内存大小&gt; fdisk -l # 硬盘大小 &gt; fdisk -l | grep Disk # 仅查看Disk信息&gt; lsusb -tv # 列出所有USB设备的linux系统信息命令&gt; lspci -tv # 列出所有PCI设备\r\n了解计算机当前操作系统相关信息\r\n12345&gt; uname -a # 查看内核/操作系统/CPU信息 &gt; hostname # 查看计算机名称&gt; cat /etc/issue # 查看操作系统版本，是数字1不是字母L&gt; env # 查看环境变量资源&gt; df -h # 查看各分区使用情况\r\n检测当前计算机进程\r\n1234&gt; top # 实时显示: 进程PID 用户 CPU占用率 等等信息&gt; ps -ef # 查看所有进程&gt; free -m # 查看内存使用量和交换区使用量&gt; lsmod # 列出加载的内核模块\r\n防火墙\r\n1&gt; firewall-cmd --state # 查看火墙状态\r\n环境变量\r\n1&gt; env # 查看环境变量资源\r\nhead 命令可用于查看文件的开头部分的内容，有一个常用的参数\r\n-n 用于显示行数，默认为 10，即显示 10 行的内容。\r\nnohup：Linux nohup\r\n命令 | 菜鸟教程 (runoob.com)\r\n1nohup Command [ Arg … ] [　&amp; ]\r\nCommand：要执行的命令。\r\nArg：一些参数，可以指定输出文件。\r\n&amp;：让命令在后台执行，终端退出后命令仍旧执行。\r\n了解\r\ntar命令\r\ntar命令语句范式：\r\n1tar [options][archive-file] [file or dir to be archived] #\r\ntouch命令：\r\nLinux\r\ntouch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。\r\nls -l 可以显示档案的时间记录。\r\n语法\r\n1touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]\r\n\r\n参数说明：\r\na 改变档案的读取时间记录。\r\nm 改变档案的修改时间记录。\r\nc 假如目的档案不存在，不会建立新的档案。与 --no-create\r\n的效果一样。\r\nf 不使用，是为了与其他 unix 系统的相容性而保留。\r\nr 使用参考档的时间记录，与 --file 的效果一样。\r\nd 设定时间与日期，可以使用各种不同的格式。\r\nt 设定档案的时间记录，格式与 date 指令相同。\r\n--no-create 不会建立新档案。\r\n--help 列出指令格式。\r\n--version 列出版本讯息。\r\n\r\ngetsebool命令:\r\n\r\n\r\nimage-20210918233125352\r\n\r\n将enforcing修改为permissive或者disabled\r\n查看命令路径：\r\n12345type python3# -------where python3# -------whereis python3\r\n启动服务\r\n1234sudo service ssh start#检测：#ssh localhost\r\n重启服务\r\n1sudo service sshd restart\r\nReverse Area\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# uname -a # 查看内核/操作系统/CPU信息 # head -n 1 /etc/issue # 查看操作系统版本 # cat /proc/cpuinfo # 查看CPU信息 # hostname # 查看计算机名 # lsmod # 列出加载的内核模块 # env # 查看环境变量资源 # free -m # 查看内存使用量和交换区使用量 # df -h # 查看各分区使用情况 # du -sh &lt;目录名&gt; # 查看指定目录的大小 # grep MemTotal /proc/meminfo # 查看内存总量 # grep MemFree /proc/meminfo # 查看空闲内存量 # uptime # 查看系统运行时间、用户数、负载 # cat /proc/loadavg # 查看系统负载磁盘和分区 # mount | column -t # 查看挂接的分区状态 # fdisk -l # 查看所有分区 # swapon -s # 查看所有交换分区 # hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) # dmesg | grep IDE # 查看启动时IDE设备检测状况网络 # ifconfig # 查看所有网络接口的属性 # iptables -L # 查看防火墙设置 # route -n # 查看路由表 # netstat -lntp # 查看所有监听端口 # netstat -antp # 查看所有已经建立的连接 # netstat -s # 查看网络统计信息进程 # ps -ef # 查看所有进程 # top # 实时显示进程状态用户 # w # 查看活动用户 # id &lt;用户名&gt; # 查看指定用户信息 # last # 查看用户登录日志 # cut -d: -f1 /etc/passwd # 查看系统所有用户 # cut -d: -f1 /etc/group # 查看系统所有组 # crontab -l # 查看当前用户的计划任务服务 # chkconfig –list # 列出所有系统服务 # chkconfig –list | grep on # 列出所有启动的系统服务程序 # rpm -qa # 查看所有安装的软件包# du -sh # 查看指定目录的大小# 十五、grep MemTotal /proc/meminfo # 查看内存总量# 十六、grep MemFree /proc/meminfo # 查看空闲内存量# 十七、uptime # 查看系统运行时间、用户数、负载# 十八、cat /proc/loadavg # 查看系统负载磁盘和分区# 十九、mount | column -t # 查看挂接的分区状态# 二十、fdisk -l # 查看所有分区# 二十一、swapon -s # 查看所有交换分区# 二十二、hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)# 二十三、dmesg | grep IDE # 查看启动时IDE设备检测状况网络# 二十四、ifconfig # 查看所有网络接口的属性# 二十五、iptables -L # 查看防火墙设置# 二十六、route -n # 查看路由表# 二十七、netstat -lntp # 查看所有监听端口# 二十八、netstat -antp # 查看所有已经建立的连接# 二十九、netstat -s # 查看网络统计信息进程# 三十、ps -ef # 查看所有进程# 三十一、top # 实时显示进程状态用户# 三十二、w # 查看活动用户# 三十三、id # 查看指定用户信息# 三十四、last # 查看用户登录日志# 三十五、cut -d: -f1 /etc/passwd # 查看系统所有用户# 三十六、cut -d: -f1 /etc/group # 查看系统所有组# 三十七、crontab -l # 查看当前用户的计划任务服务# 三十七、chkconfig –list # 列出所有系统服务# 三十八、chkconfig –list | grep on # 列出所有启动的系统服务程序# 三十九、rpm -qa # 查看所有安装的软件包# 四十、cat /proc/cpuinfo ：查看CPU相关参数的linux系统命令# 四十一、cat /proc/partitions ：查看linux硬盘和分区信息的系统信息命令# 四十二、cat /proc/meminfo ：查看linux系统内存信息的linux系统命令# 四十三、cat /proc/version ：查看版本，类似uname -r# 四十四、cat /proc/ioports ：查看设备io端口# 四十五、cat /proc/interrupts ：查看中断# 四十六、cat /proc/pci ：查看pci设备的信息# 四十七、cat /proc/swaps ：查看所有swap分区的信息\r\n","slug":"Deploy/Linux/Linux学习-Commands","date":"2022-01-16T03:07:03.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"JBR_Bunjie"},{"id":"a35bcd91868d87eeb1d5ee97d10a5a01","title":"Markdown","content":"我展示的是一级标题\r\n我展示的是二级标题\r\n一、二级标题上不能有东西\r\n一级标题\r\n二级标题\r\n三级标题\r\n四级标题\r\n五级标题\r\n六级标题\r\n斜体文本 斜体文本 粗体文本\r\n粗体文本 粗斜体文本\r\n粗斜体文本\r\n分隔线:\r\n\r\n\r\n\r\n\r\n\r\n删除线: BAIDU.COM\r\n下划线: 带下划线文本\r\n上标：\r\n23\r\n下标：\r\nH2O\r\n高亮：\r\n==22==\r\n内联公式：\r\n\r\n无序列表：\r\n\r\n第一项\r\n第二项\r\n第三项\r\n第一项\r\n第二项\r\n第三项\r\n第一项\r\n第二项\r\n第三项\r\n\r\n有序列表:\r\n\r\n第一项\r\n第二项\r\n第三项\r\n\r\n允许列表嵌套\r\n区块\r\n\r\n区块引用1 区块引用2 区块引用3 最外层 &gt; 第一层嵌套 &gt; &gt; &gt;\r\n第二层嵌套\r\n\r\n区块中使用列表: &gt; 区块中使用列表 &gt; 1. 第一项\r\n&gt; 2. 第二项 &gt; + 第一项 &gt; + 第二项 &gt; + 第三项\r\n列表中使用区块 如果要在列表项目内放进区块，\r\n那么就需要在 &gt; 前添加四个空格的缩进。\r\n区块中使用列表实例如下：\r\n\r\n第一项 &gt; 区块引用1 &gt; 区块引用2\r\n第二项\r\n\r\n代码 printf() 函数\r\n可以用 ``` 包裹一段代码， 并指定一种语言（也可以不指定）：\r\n123$(document).ready(function () {    alert('RUNOOB');});\r\n链接\r\n这是一个链接：google\r\n或者直接放上地址：https://google.com\r\n\r\n还可以通过变量来设置一个链接，变量赋值在文档末尾进行：\r\n这个链接用 1 作为网址变量 Google\r\n这个链接用 runoob 作为网址变量 Runoob\r\n然后在文档的结尾为变量赋值（网址）\r\n\r\n图片\r\n1![alt 属性文本](图片地址 \"可选标题\")\r\n\r\n\r\nRUNOOB 图标\r\n\r\nMarkdown 还没有办法指定图片的高度与宽度\r\n如果你需要的话，你可以使用普通的  标签。\r\n\r\n表格\r\n\r\n\r\n\r\n左对齐\r\n右对齐\r\n居中对齐\r\n\r\n\r\n\r\n\r\n单元格\r\n单元格\r\n单元格\r\n\r\n\r\n单元格\r\n单元格\r\n单元格\r\n\r\n\r\n\r\n支持的 HTML 元素 不在 Markdown 涵盖范围之内的标签\r\n都可以直接在文档里面用 HTML 撰写\r\n目前支持的 HTML 元素有：      \r\n等，可自行尝试\r\n转义 md使用了很多特殊符号来表示特定的意义\r\n如果需要显示特定的符号则需要使用转义字符 md使用反斜杠转义特殊字符：\r\n文本加粗\r\n** 正常显示星号 **\r\nmd支持以下这些符号前面加上反斜杠 来帮助插入普通的符号：   反斜线 `\r\n反引号\r\n\r\n星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号\r\n加号\r\n减号 . 英文句点 ! 感叹号\r\n\r\n数学公式：\r\nLaTeX数学符号大全_LCCFlccf的博客-CSDN博客_latex\r\n数学符号\r\n【Markdown笔记】数学公式\r\n三角函数_dadalaohua的博客-CSDN博客_markdown 三角函数\r\nmarkdown最全数学公式速查_博客-CSDN博客_markdown数学公式\r\nMarkdown中的行列式和矩阵(LaTex)\r\n- 简书 (jianshu.com)\r\n输入公式：\r\n最速解决：\r\n在线LaTeX公式编辑器-编辑器\r\n(latexlive.com)\r\n公式标签：\r\n在行内输入：符号，在这两个符号之间输入LaTex语法，即可实现在行内插入公式。\r\n在行间输入：符号，在这两对符号之间输入LaTex语法，即可实现在行间插入公式。\r\n示例：\r\n、、、、、 \r\n公式语法：\r\n换行：\r\n\\\\\r\n对齐：\r\n&amp;对齐\r\n\r\n一般对齐：\r\n\r\n\r\n\r\n等号对齐\r\n\r\n\r\n\r\n灵活对齐\r\n\r\n\r\n中心对齐：\r\ndefault\r\n分数：\r\n求和：\r\n\r\n参数位于右方：_{i=1}^{n}\r\n参数位于上下方：_{i=1}^{n}\r\n\r\n求导：\r\n\r\nd - 求导：\r\n∂ - 偏导：\r\n∇ - 梯度：f\r\n\r\n附录：\r\n1.字母的LaTex语法\r\n希腊字母\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n希腊字母小写、大写\r\nLaTeX形式\r\n希腊字母小写、大写\r\nLaTeX形式\r\n\r\n\r\n\r\n\r\nα A\r\nA\r\nμ N\r\nN\r\n\r\n\r\nβ B\r\nB\r\nξ Ξ\r\n\r\n\r\n\r\nγ Γ\r\n\r\no O\r\no O\r\n\r\n\r\nδ Δ\r\n\r\nπ Π\r\n\r\n\r\n\r\nϵ ε E\r\nE\r\nρ ϱ P\r\nP\r\n\r\n\r\nζ Z\r\nZ\r\nσ Σ\r\n\r\n\r\n\r\nη H\r\nH\r\nτ T\r\nT\r\n\r\n\r\nθ ϑ Θ\r\n\r\nυ Υ\r\n\r\n\r\n\r\nι I\r\nI\r\nϕ φ Φ\r\n\r\n\r\n\r\nκ K\r\nK\r\nχ X\r\nX\r\n\r\n\r\nλ Λ\r\n\r\nψ Ψ\r\n\r\n\r\n\r\nμ M\r\nM\r\nω Ω\r\n\r\n\r\n\r\n\r\n2.常用运算符\r\n\r\n\r\n\r\n运算符\r\nlatex\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n或 \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","slug":"Language Learning/MARK LANGUAGE/Markdown","date":"2021-12-23T04:23:23.000Z","categories_index":"Language Learning,Markdown","tags_index":"Language Learning,Markdown","author_index":"JBR_Bunjie"},{"id":"2679faecf929a89d04089c85f6582773","title":"从Json杀到Yaml","content":"从Json杀到Yaml\r\nJson介绍\r\n什么是Json？\r\n\r\nJSON (JavaScript Object Notation) is a lightweight\r\ndata-interchange format. It is easy for humans to read and write. It is\r\neasy for machines to parse and generate. It is based on a subset of the\r\nJavaScript Programming Language Standard ECMA-262 3rd Edition - December\r\n1999. JSON is a text format that is completely language independent but\r\nuses conventions that are familiar to programmers of the C-family of\r\nlanguages, including C, C++, C#, Java, JavaScript, Perl, Python, and\r\nmany others. These properties make JSON an ideal data-interchange\r\nlanguage.\r\n\r\nJson是一种轻量级数据交换格式。它有着可读性高，易于机器解析和生成的优点，它是编程语言Js\r\n第三版ECMA-262规范的一个子集。JSON\r\n是一种完全独立于语言的文本格式，但是却使用了C系程序员熟悉的相关约定如C,\r\nC++, C#, Java, JavaScript, Perl, Python, and many others。这些特性使\r\nJSON 成为一种理想的数据交换语言。\r\n\r\n\r\nJson语法\r\nJson is built on two structures:\r\n\r\nA collection of name/value pairs. In various languages, this is\r\nrealized as an object, record, struct, dictionary, hash table,\r\nkeyed list, or associative array.\r\nAn ordered list of values. In most languages, this is realized as an\r\narray, vector, list, or sequence.\r\n\r\nThese are universal data structures. Virtually all modern programming\r\nlanguages support them in one form or another. It makes sense that a\r\ndata format that is interchangeable with programming languages also be\r\nbased on these structures.\r\n这些是通用的数据结构。几乎所有的现代编程语言都以这样或那样的形式支持它们。所以一个可以融入编程语言的数据格式自然也应当基于这些结构来设计。\r\n123456789&#123;    &quot;object1&quot;: [    &#123; &quot;key1.1&quot;:&quot;value1.1&quot; , &quot;key1.2&quot;:&quot;value1.2&quot; &#125;,     &#123; &quot;key2.1&quot;:&quot;value2.1&quot; , &quot;key2.2&quot;:&quot;value2.2&quot; &#125;,     ...    ],    &quot;object2&quot;:&quot;valueForObject2&quot;,    &quot;object3&quot;: ...&#125;\r\nJson整体是一个对象Object，其中内容是无序的name/value键值对集合，name以string构建，value可以以array,\r\nstring, number, object,\r\ntrue,\r\nfalse和null中的任意一种来构建。array中的元素一般为Object的对象，value又可以直接调用Object，如此便形成嵌套。name与value以\r\n:分隔。\r\n当我们引用Json数据时，我们对Object中的键值使用点计法取名引用，对数组数据用一般引用数组的办法Array[\r\nn ]来引用\r\n\r\n原生Json并不支持注释，如果一定需要使用注释，可以查阅Json\r\nschema或者换用JSON5，虽然JSON5是第三方库，但仍然严格符合JS标准，并且JSON5.parse与JSON.parse的解析结果一致。当然，你也可以直接换用换用下面的Yaml\r\n\r\nYaml介绍\r\n\r\nYAML Ain't Markup Language, YAML is a human\r\nfriendly data serialization language for all programming languages.\r\n\r\n有意思的是，虽然YAML是YAML Ain't Markup\r\nLanguage的缩写，但是这个缩写中的YAML其实是Yet Another Markup\r\nLanguage的缩写，即：这是一个标记语言。正式名称改为了“不是标记语言”，这一点颇为有趣，也耐人寻味——强调其以数据作为重心，而非标记语言。\r\n截止2021.9.27，Yaml的最新版本为1.2.1(发布于2009.10.1)\r\n到2021.10.1，Yaml发布了最新版：1.2.2\r\n\r\nWe are excited to announce the release of Revision 1.2.2 of the YAML 1.2\r\nSpecification. This revision comes 12 years to the day after the previous revision.\r\n\r\n如果你没有耐心啃最新的文档的话，你只需要看一句话：No normative\r\nchanges from the 1.2.1 revision. YAML 1.2 has not been changed. 就行\r\nyaml优点\r\n\r\nThe design goals for YAML are, in decreasing priority: + YAML is\r\neasily readable by humans.（易读 + YAML data is portable between\r\nprogramming languages.（跨语言 + YAML matches the native data structures\r\nof agile languages.（与当前语言的数据结构兼容 + YAML has a consistent\r\nmodel to support generic tools.（支持通用工具 + YAML supports one-pass\r\nprocessing. + YAML is expressive and extensible. + YAML is easy to\r\nimplement and use.\r\n\r\n\r\nYAML中没有额外的定界符，所以相比JSON更轻量级。\r\n没有额外定界符，所以更易读（不过这一点颇为激进，时至今日仍有很多开发者无法接受这种以缩进来界定结构的做法，因为经常出现“一个空格引发的悲剧”）\r\nYAML使数据更易于理解，因此常用于配置文件中（很经常看见别人将.properties改为.yaml）\r\nYAML是JSON\r\n的超集，对于合法的JSON代码，同样可以被YAML解析，这样对于使用JSON和YAML的应用来说，可以使用一个解析器完成两种解析。\r\n然而其并没有如期望中那样受欢迎，具体而言，因为不同的序列化语言都有其特定的适宜语言或者场景（下文可以提到），并且相较于其他广泛使用的序列化语言，YAML有一些不足。\r\n\r\nYAML使用场景\r\n对于序列化语言来说，使用场景如下：\r\n\r\n与服务器之间传输数据\r\n使用一个配置文件来配置应用，这些文件声明对应参数和相应取值\r\n在同一个应用不同组件之间转换数据\r\n中间数据存储：针对此类场景，YAML有一些明确的优势相比于其他同类语言。也是为什么现在越来越多的开发者使用其的地方。\r\n\r\nYAML语法：\r\nYaml与Json一样同时支持对象和数组，但是Yaml将其余的所有值全部归为“纯量”\r\n1234567891011121314151617181920212223# yaml代码示例：languages:  - Ruby  - Perl  - Python   # 以 - 开头的行表示构成一个数组websites:  YAML: yaml.org   Ruby: ruby-lang.org   Python: python.org   Perl: use.perl.org  # 对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。companies:    -        id: 1        name: company1        price: 200W    -        id: 2        name: company2        price: 500W        # 意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\r\n转换为 json 为：\r\n123456789101112131415161718&#123;   languages: [&#x27;Ruby&#x27;, &#x27;Perl&#x27;, &#x27;Python&#x27;],  websites: &#123;    YAML: &#x27;yaml.org&#x27;,    Ruby: &#x27;ruby-lang.org&#x27;,    Python: &#x27;python.org&#x27;,    Perl: &#x27;use.perl.org&#x27;   companies: [&#123;      \tid: 1,      \tname: company1,      \tprice: 200W  \t  &#125;, &#123;    \tid: 2,    \tname: company2,    \tprice: 500W\t&#125;]  &#125; &#125;\r\nyaml相比json？\r\n\r\nofficial document:\r\nBoth JSON and YAML aim to be human readable data interchange formats.\r\nHowever, JSON and YAML have different priorities. JSON’s foremost design\r\ngoal is simplicity and universality. Thus, JSON is trivial to generate\r\nand parse, at the cost of reduced human readability. It also uses a\r\nlowest common denominator information model, ensuring any JSON data can\r\nbe easily processed by every modern programming environment.\r\n\r\nJson和Yaml的目标都是人类可读的数据交换格式。但是，Json和Yaml对于目标有不同的优先级。Json格式设计的首要目标是simplicity和universality。因此Json容易生成和解析，代价就是减少可读性。\r\n\r\nIn contrast, YAML’s foremost design goals are human readability and\r\nsupport for serializing\r\narbitrary native\r\ndata structures. Thus, YAML allows for extremely readable files, but\r\nis more complex to generate and parse. In addition, YAML ventures beyond\r\nthe lowest common denominator data types, requiring more complex\r\nprocessing when crossing between different programming environments.\r\nYAML中有很多方式来体系化数据层级，因此处理时会相对复杂些。性能上相对于XML和JSON会有差别。\r\n\r\nyaml与yml区别?\r\n.yaml与.yml都是yaml格式的拓展名，虽然.yaml才是官方推荐的拓展格式，但是到目前为止，yml仍然被广泛使用：GitHub上\r\n.yml相关总提交次数为1千3百万次，而.yaml总次数仅为5百万次\r\n贴一个比较古早的stackoverflow的问题链接：configuration\r\nfiles - Is it .yaml or .yml? - Stack Overflow\r\n如果你不太想看的话，以下由简略版本：\r\n\r\n正方：I like .yml, it's 25% faster to write. ☝😆. Personally, I'm\r\nfine with whichever is the \"standard\"\r\n反方：Some people like to stick to 3 letter extensions as it was back\r\nin the old days when file systems were still limited to short names\r\n\r\n但是我仍然推荐使用yaml，作为官方推荐的拓展格式，它也许可以帮你避免很多意料之外的error。\r\n关于配置文件：是.yaml还是.yml？\r\n| 码农家园 (codenong.com)\r\n本来找到了原文，但是链接丢了(((φ(◎ロ◎;)φ)))，坏欸\r\n\r\n参考资料：\r\n\r\nJSON\r\nJSON Schema\r\n| The home of JSON Schema (json-schema.org) \r\nJSON5 | JSON for\r\nHumans\r\nThe JSON5 Data\r\nInterchange Format\r\nThe Official YAML Web\r\nSite\r\nYAML File\r\nFormat\r\nYAML Documentation · YAML\r\nYAMLlint\r\n- The YAML Validator\r\nyaml/yaml: YAML language and\r\ncommunity information (github.com)\r\n\r\n\r\n\r\n","slug":"Language Learning/从json杀到yaml","date":"2021-11-16T08:15:04.000Z","categories_index":"Programming Language Learning","tags_index":"Json","author_index":"JBR_Bunjie"},{"id":"2679faecf929a89d04089c85f6582773","title":"从Json杀到Yaml","content":"从 Json 杀到 Yaml\r\nJson 介绍\r\n什么是Json？\r\n\r\nJSON (JavaScript Object Notation) is a lightweight\r\ndata-interchange format. It is easy for humans to read and write. It is\r\neasy for machines to parse and generate. It is based on a subset of the\r\nJavaScript Programming Language Standard ECMA-262 3rd Edition - December\r\n1999. JSON is a text format that is completely language independent but\r\nuses conventions that are familiar to programmers of the C-family of\r\nlanguages, including C, C++, C#, Java, JavaScript, Perl, Python, and\r\nmany others. These properties make JSON an ideal data-interchange\r\nlanguage.\r\n\r\nJson\r\n是一种轻量级数据交换格式。它有着可读性高，易于机器解析和生成的优点，它是编程语言\r\nJs 第三版 ECMA-262 规范的一个子集。JSON\r\n是一种完全独立于语言的文本格式，但是却使用了 C 系程序员熟悉的相关约定如\r\nC, C++, C#, Java, JavaScript, Perl, Python, and many others。这些特性使\r\nJSON 成为一种理想的数据交换语言。\r\n\r\n\r\nJson 语法\r\nJson is built on two structures:\r\n\r\nA collection of name/value pairs. In various languages, this is\r\nrealized as an object, record, struct, dictionary, hash table,\r\nkeyed list, or associative array.\r\nAn ordered list of values. In most languages, this is realized as an\r\narray, vector, list, or sequence.\r\n\r\nThese are universal data structures. Virtually all modern programming\r\nlanguages support them in one form or another. It makes sense that a\r\ndata format that is interchangeable with programming languages also be\r\nbased on these structures.\r\n这些是通用的数据结构。几乎所有的现代编程语言都以这样或那样的形式支持它们。所以一个可以融入编程语言的数据格式自然也应当基于这些结构来设计。\r\n123456789&#123;    &quot;object1&quot;: [    &#123; &quot;key1.1&quot;:&quot;value1.1&quot; , &quot;key1.2&quot;:&quot;value1.2&quot; &#125;,    &#123; &quot;key2.1&quot;:&quot;value2.1&quot; , &quot;key2.2&quot;:&quot;value2.2&quot; &#125;,    ...    ],    &quot;object2&quot;:&quot;valueForObject2&quot;,    &quot;object3&quot;: ...&#125;\r\nJson 整体是一个对象 Object，其中内容是无序的\r\nname/value 键值对集合，name 以 string 构建，value\r\n可以以array, string, number,\r\nobject, true,\r\nfalse和null中的任意一种来构建。array\r\n中的元素一般为 Object 的对象，value 又可以直接调用\r\nObject，如此便形成嵌套。name 与 value 以 :分隔。\r\n当我们引用 Json 数据时，我们对 Object\r\n中的键值使用点计法取名引用，对数组数据用一般引用数组的办法 Array[ n\r\n]来引用\r\n\r\n原生 Json\r\n并不支持注释，如果一定需要使用注释，可以查阅Json\r\nschema或者换用JSON5，虽然 JSON5\r\n是第三方库，但仍然严格符合 JS 标准，并且 JSON5.parse 与 JSON.parse\r\n的解析结果一致。当然，你也可以直接换用换用下面的 Yaml\r\n\r\nYaml 介绍\r\n\r\nYAML Ain't Markup Language, YAML is a human\r\nfriendly data serialization language for all programming languages.\r\n\r\n有意思的是，虽然 YAML 是 YAML Ain't Markup Language\r\n的缩写，但是这个缩写中的 YAML 其实是 Yet Another Markup Language\r\n的缩写，即：这是一个标记语言。正式名称改为了“不是标记语言”，这一点颇为有趣，也耐人寻味——强调其以数据作为重心，而非标记语言。\r\n截止 2021.9.27，Yaml 的最新版本为 1.2.1(发布于 2009.10.1)\r\n到 2021.10.1，Yaml 发布了最新版：1.2.2\r\n\r\nWe are excited to announce the release of Revision 1.2.2 of the YAML 1.2\r\nSpecification. This revision comes 12 years to the day after the previous revision.\r\n\r\n如果你没有耐心啃最新的文档的话，你只需要看一句话：No normative\r\nchanges from the 1.2.1 revision. YAML 1.2 has not been changed. 就行\r\nyaml 优点\r\n\r\nThe design goals for YAML are, in decreasing priority:\r\n\r\nYAML is easily readable by humans.（易读\r\nYAML data is portable between programming languages.（跨语言\r\nYAML matches the native data structures of agile\r\nlanguages.（与当前语言的数据结构兼容\r\nYAML has a consistent model to support generic\r\ntools.（支持通用工具\r\nYAML supports one-pass processing.\r\nYAML is expressive and extensible.\r\nYAML is easy to implement and use.\r\n\r\n\r\n\r\nYAML 中没有额外的定界符，所以相比 JSON 更轻量级。\r\n没有额外定界符，所以更易读（不过这一点颇为激进，时至今日仍有很多开发者无法接受这种以缩进来界定结构的做法，因为经常出现“一个空格引发的悲剧”）\r\nYAML\r\n使数据更易于理解，因此常用于配置文件中（很经常看见别人将.properties\r\n改为.yaml）\r\nYAML 是 JSON 的超集，对于合法的 JSON 代码，同样可以被 YAML\r\n解析，这样对于使用 JSON 和 YAML\r\n的应用来说，可以使用一个解析器完成两种解析。\r\n然而其并没有如期望中那样受欢迎，具体而言，因为不同的序列化语言都有其特定的适宜语言或者场景（下文可以提到），并且相较于其他广泛使用的序列化语言，YAML\r\n有一些不足。\r\n\r\nYAML 使用场景\r\n对于序列化语言来说，使用场景如下：\r\n\r\n与服务器之间传输数据\r\n使用一个配置文件来配置应用，这些文件声明对应参数和相应取值\r\n在同一个应用不同组件之间转换数据\r\n中间数据存储：针对此类场景，YAML\r\n有一些明确的优势相比于其他同类语言。也是为什么现在越来越多的开发者使用其的地方。\r\n\r\nYAML 语法：\r\nYaml 与 Json 一样同时支持对象和数组，但是 Yaml\r\n将其余的所有值全部归为“纯量”\r\n123456789101112131415161718192021# yaml代码示例：languages:  - Ruby  - Perl  - Python  # 以 - 开头的行表示构成一个数组websites:  YAML: yaml.org  Ruby: ruby-lang.org  Python: python.org  Perl: use.perl.org  # 对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。companies:  - id: 1    name: company1    price: 200W  - id: 2    name: company2    price: 500W    # 意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\r\n转换为 json 为：\r\n123456789101112131415161718&#123;  languages: [&#x27;Ruby&#x27;, &#x27;Perl&#x27;, &#x27;Python&#x27;],  websites: &#123;    YAML: &#x27;yaml.org&#x27;,    Ruby: &#x27;ruby-lang.org&#x27;,    Python: &#x27;python.org&#x27;,    Perl: &#x27;use.perl.org&#x27;  companies: [&#123;      \tid: 1,      \tname: company1,      \tprice: 200W  \t  &#125;, &#123;    \tid: 2,    \tname: company2,    \tprice: 500W\t&#125;]  &#125;&#125;\r\nyaml 相比 json？\r\n\r\nofficial document:\r\nBoth JSON and YAML aim to be human readable data interchange formats.\r\nHowever, JSON and YAML have different priorities. JSON’s foremost design\r\ngoal is simplicity and universality. Thus, JSON is trivial to generate\r\nand parse, at the cost of reduced human readability. It also uses a\r\nlowest common denominator information model, ensuring any JSON data can\r\nbe easily processed by every modern programming environment.\r\n\r\nJson 和 Yaml 的目标都是人类可读的数据交换格式。但是，Json 和 Yaml\r\n对于目标有不同的优先级。Json 格式设计的首要目标是 simplicity 和\r\nuniversality。因此 Json 容易生成和解析，代价就是减少可读性。\r\n\r\nIn contrast, YAML’s foremost design goals are human readability and\r\nsupport for serializing\r\narbitrary native\r\ndata structures. Thus, YAML allows for extremely readable files, but\r\nis more complex to generate and parse. In addition, YAML ventures beyond\r\nthe lowest common denominator data types, requiring more complex\r\nprocessing when crossing between different programming environments.\r\nYAML\r\n中有很多方式来体系化数据层级，因此处理时会相对复杂些。性能上相对于 XML\r\n和 JSON 会有差别。\r\n\r\nyaml 与 yml 区别?\r\n.yaml 与.yml 都是 yaml 格式的拓展名，虽然.yaml\r\n才是官方推荐的拓展格式，但是到目前为止，yml 仍然被广泛使用：GitHub 上\r\n.yml 相关总提交次数为 1 千 3 百万次，而.yaml 总次数仅为 5 百万次\r\n贴一个比较古早的 stackoverflow 的问题链接：configuration\r\nfiles - Is it .yaml or .yml? - Stack Overflow\r\n如果你不太想看的话，以下由简略版本：\r\n\r\n正方：I like .yml, it's 25% faster to write. ☝😆. Personally, I'm\r\nfine with whichever is the \"standard\"\r\n反方：Some people like to stick to 3 letter extensions as it was back\r\nin the old days when file systems were still limited to short names\r\n\r\n但是我仍然推荐使用\r\nyaml，作为官方推荐的拓展格式，它也许可以帮你避免很多意料之外的\r\nerror。\r\n关于配置文件：是.yaml\r\n还是.yml？ | 码农家园 (codenong.com)\r\n本来找到了原文，但是链接丢了(((φ(◎ ロ ◎;)φ)))，坏欸\r\n\r\n参考资料：\r\n\r\nJSON\r\nJSON Schema\r\n| The home of JSON Schema (json-schema.org) \r\nJSON5 | JSON for\r\nHumans\r\nThe JSON5 Data\r\nInterchange Format\r\nThe Official YAML Web\r\nSite\r\nYAML File\r\nFormat\r\nYAML Documentation · YAML\r\nYAMLlint\r\n- The YAML Validator\r\nyaml/yaml: YAML language and\r\ncommunity information (github.com)\r\n\r\n\r\n\r\n","slug":"Language Learning/MARK LANGUAGE/从json杀到yaml","date":"2021-11-16T08:15:04.000Z","categories_index":"Language Learning,Json,Yaml","tags_index":"Language Learning,Json,Yaml","author_index":"JBR_Bunjie"},{"id":"0ff372827a992c33dc9a7dba52ce9123","title":"建立一个FTP服务器吧!","content":"建立一个 FTP 服务器吧！\r\n\r\n注意你所购买的云服务商的文档，\r\n比如这里的：\r\n\r\n\r\n主动模式：放通端口 21。\r\n被动模式：放通端口 21，及 修改配置文件\r\n中设置的 pasv_min_port 到 pasv_max_port\r\n之间的所有端口，本文放通端口为 40000 - 45000。\r\n\r\n云服务器\r\nLinux 云服务器搭建 FTP 服务-最佳实践-文档中心-腾讯云\r\n(tencent.com)\r\n\r\nInstall vsftpd\r\n12345678910111213141516# Installsudo apt updatesudo apt install vsftpdsudo cp /etc/vsftpd.conf /etc/vsftpd.conf.orig# Firwall rulessudo ufw allow ftp-datasudo ufw allow ftpsudo ufw status# Preparing Space for Filessudo mkdir -p mapftpsudo chown nobody:nogroup mapftpecho &quot;vsftpd test file&quot; | sudo tee mapftp/test.logsudo mkdir mapftp/maps/sudo chmod a+rwx mapftp/maps/\r\nConfigure Anonymous Access\r\n\r\nEdit /etc/vsftpd.conf\r\nChange the following:\r\n\r\n\r\nanonymous_enable=YES to allow anonymous access\r\nwrite_enable=YES to enable uploading\r\nanon_upload_enable=YES to enable anonymous\r\nuploading\r\nanon_mkdir_write_enable=YES to enable anonymous\r\ndirectory creation\r\n\r\n\r\nAppend the following to the end: 1.anon_umask=022 so\r\nthat new file will be readable by groups and other users. Uploaded files\r\nwill have a permittion set to the value of file_open_mode\r\n(by default, 0666) subtracted by anon_umask.\r\n\r\n\r\nanon_other_write_enable=YES to enable anonymous\r\ndeletion and renaming\r\nanon_root=xxx/mapftp sets the root folder for anonymous\r\nlogins\r\nno_anon_password=YES stops prompting for a password on\r\nthe command line.\r\nhide_ids=YES shows the user and group as\r\nftp:ftp, regardless of the owner.\r\npasv_min_port=40000 and\r\npasv_max_port=50000 limits the range of ports that can be\r\nused for passive FTP\r\n\r\n\r\nOptionally changes the listening port:\r\n\r\n\r\nlisten_port= followed by port number\r\n\r\nConclusion\r\nOn Linux, use the ftp command to access the server, e.g.\r\nftp -p 192.168.0.2 then followed by anonymous\r\nas the username. On Windows, use Windows Explorer or other FTP\r\ntools.\r\n\r\n了解 FTP\r\n什么是 ftp？\r\nFTP 即：File Transfer Protocol，即\r\nftp，可以直译为“文件传输协议”。但是由于 FTP\r\n本身是使用明文进行数据传输，所以有了更多加密版本的 FTP 协议如：FTPS(FTP\r\nover SSL)，SFTP：Secure FTP(FTP over SSH)等\r\n部署 FTP 服务器\r\n以 windows\r\n作为服务端——filezilla实现\r\n推荐视频教程：FileZilla：如何快速搭建\r\nFTP 服务器\r\n\r\nFilezilla Sever 只支持 Windows 平台，而 Client 同时支持\r\nWindows，Linux，Mac\r\n设置 Filezilla 时需要注意：你添加的 Port\r\n不是实际使用时的端口，是管理端口，所以不论设为什么值，只要不和当前系统已有端口重合都是可以的\r\nFilezilla\r\n使用多用户管理机制，不过你在正式使用之前需要先创建用户。在Edit-User-general中创建\r\n\r\n这个单个用户并不意味着是单个自然人，多个人是可以共享一个用户名和密码的，这里的用户主要是用于区分访问种类与权限而非界定访问的实际个人\r\n用户与用户之间可以设置不同目录来访问不同的资源：shared folders中管理，但是每一个用户都需要一个根目录\r\n当你添加一个非根目录的时候，需要手动指定它在访问时所在的目录——即电脑本地的文件路径和访问到的文件路径并不是不统一的。但是根目录是无需指定路径的，或者说根目录的路径是/\r\n注意用户的权限管理，记得设置用户密码\r\n\r\nhome 会占用网址的路径，它不需要指定路径，对于 home\r\n外的目录，添加之后，需要指定新的路径\r\n\r\n需要注意的是，ftp\r\n服务中的添加的目录与本机文件的实际目录是可以没有关系的\r\n例如，对两个同级目录，你可以将一个目录赋在另一个目录的路径的子路径中\r\n配置路径地址时，注意使用反斜杠\r\n\r\n\r\n以 Linux 作为服务端——vsftpd\r\n实现\r\n在云服务器上部署 ftp 服务\r\n这里采用了阿里云服务器的 CentOS7 系统，版本是 7.6\r\n使用了常用的 vsftpd 包来搭建 ftp 服务\r\nvsftpd 项目地址：vsftpd - Secure, fast\r\nFTP server for UNIX-like systems (security.appspot.com)\r\n\r\n安装 ftp 服务\r\n请注意，本文可能仅适用于 CentOS，其他的 Linux 发行版与 CentOS 虽同为\r\nLinux 系统，但是也有诸多不同\r\n例如，第 5 步需要修改的 vsftpd.conf 文件，CentOS 系统下它会出现在\r\n/etc/vsftpd 文件夹下，而 Ubuntu 系统下它则会直接出现在 /etc 文件夹下\r\n如果你需要以本教程做参考的话，请不要照搬本教程。比如将 CentOS\r\n的包管理工具 yum 替换为你当前 Linux 发行版下的包管理工具\r\n\r\n\r\n安装 vsftpd\r\n\r\n1yum install -y vsftpd\r\n\r\n设置 vsftpd 开机启动\r\n\r\n1systemctl enable vsftpd\r\n\r\n启动 vsftpd 服务\r\n\r\n1systemctl start vsftpd\r\n\r\n检验服务是否启动\r\n\r\n1netstat -antup | grep ftp\r\n配置 vsftpd\r\n建立用户并为他配置用户专属文件夹\r\n\r\n执行以下命令，为 FTP 服务创建一个 Linux 用户，本文以 ftpuser\r\n为例。\r\n1useradd ftpuser\r\n当你创建了一个新的用户的时候，Linux 回味这个用户在 /home\r\n目录下建立一个以用户名为名的文件夹，并且这个目录这就是此后用户登陆时的默认路径\r\n~所代指的路径\r\n执行以下命令，设置 ftpuser 用户的密码。\r\n1passwd ftpuser\r\n输入密码后请按 Enter 确认设置，密码默认不显示，本文以 JBRBunjie\r\n为例。\r\n执行以下命令，创建 FTP 服务使用的文件目录，本文以/var/ftp/test\r\n为例。\r\n1mkdir /var/ftp/test\r\n\r\n事实上，这个目录是哪里都可以的。只是一定要记得这个目录路径是什么，因为这个路径过会儿是会写入配置文件的。当客户机访问服务器时，实际地址就是这个地址\r\n\r\n执行以下命令，修改目录权限。\r\n1chown -R ftpuser:ftpuser /var/ftp/test\r\n\r\n你也可以直接新开一个终端，并以 ftpuser 身份登录\r\n这样子可以省去很多没必要的麻烦，因为在 ftpuser 身份下创建的所以文件的\r\nowner 都是 ftpuser，就可以省略用户权限配置这一步\r\n\r\n\r\n修改 vsftpd.conf\r\n配置文件，并设置 chroot\r\n\r\n打开要修改的文件：\r\n1vim /etc/vsftpd/vsftpd.conf\r\n按i切换至编辑模式以修改配置文件\r\nvsftpd.conf：\r\n\r\n\r\n注意：\r\nFTP\r\n可通过主动模式和被动模式与客户端机器进行连接并传输数据。由于大多数客户端机器的防火墙设置及无法获取真实\r\nIP 等原因，一般选择被动模式搭建 FTP\r\n服务。以下修改以设置被动模式为例，如需选择主动模式，可以参看腾讯云的文档：设置\r\nFTP 主动模式。\r\n\r\n\r\n修改以下配置参数，取消它们前面的#注释或者修改对应值，和本地用户的登录权限，设置指定例外用户列表文件的路径，并开启监听\r\nIPv4 sockets。\r\n123456789101112131415161718192021222324252627# Allow anonymous FTP? (Beware - allowed by default if you comment this out).# 是否运行匿名用户登录anonymous_enable=NO# Uncomment this to allow local users to log in.# When SELinux is enforcing check for SE bool ftp_home_dir# 取消此注释来运行本地用户登录local_enable=YES# You may specify an explicit list of local users to chroot() to their home directory. If chroot_local_user is YES, then this list becomes a list of users to NOT chroot(). (Warning! chroot&#x27;ing can be very dangerous. If using chroot, make sure that the user does not have write access to the top level directory within the chroot)# 如果两个配置项都为yes，那么, 凡是加在文件chroot_list中的用户都是不受限止的用户，即, 可以浏览其主目录的上级目录.# 如果不希望某用户能够浏览其主目录上级目录中的内容,可以如上设置,然后在文件vsftpd.chroot_list中去掉或不添加该用户即可。# 也可以如下配置# chroot_local_user＝NO# chroot_list_enable=YES(这行必须要有, 否则文件vsftpd.chroot_list不会起作用)# 则所有用户都能够访问上级目录，你可以把所有不希望有这种浏览其主目录之上的各目录权限的用户添加到文件chroot_list中即可(一行一个用户名，此时, 在该文件中的用户都是不可以浏览其主目录之外的目录的)chroot_local_user=YESchroot_list_enable=YES# chroot_list路径chroot_list_file=/etc/vsftpd/chroot_list# When &quot;listen&quot; directive is enabled, vsftpd runs in standalone mode and# listens on IPv4 sockets. This directive cannot be used in conjunction# with the listen_ipv6 directive.# 监听IPv4 socketslisten=YES\r\n在listen_ipv6=YES行首添加#来将此功能注释掉\r\n12345678910# This directive enables listening on IPv6 sockets. By default, listening# on the IPv6 &quot;any&quot; address (::) will accept connections from both IPv6# and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6# sockets. If you want that (perhaps because you want to listen on specific# addresses) then you must run two copies of vsftpd with two configuration# files.# Make sure, that one of the listen options is commented !!# 关闭监听 IPv6 sockets。# listen_ipv6=YES\r\n添加以下配置参数，开启被动模式，设置本地用户登录后所在目录，以及云服务器建立数据传输可使用的端口范围值\r\n123456local_root=/var/ftp/testallow_writeable_chroot=YESpasv_enable=YESpasv_address=xxx.xx.xxx.xx #请修改为您的 Linux 云服务器公网 IPpasv_min_port=40000pasv_max_port=45000\r\n按 Esc 后输入 :wq! 保存后退出。\r\n创建chroot_list文件\r\n1vim /etc/vsftpd/chroot_list\r\n\r\n按 i\r\n进入编辑模式，输入用户名，一个用户名占据一行，\r\n设置完成后按 Esc 并输入 :wq\r\n保存后退出。\r\n您若没有设置例外用户的需求，可跳过此步骤，输入\r\n:wq 退出文件。或者直接改用 touch\r\n命令来创建文件\r\n\r\n重启 FTP 服务。\r\n1systemctl restart vsftpd\r\n\r\n设置云服务器安全组\r\n增加新的策略：\r\n\r\n开放 ftp 21 端口\r\n开放你在 vsftpd.config 中所配置的端口范围(pasv_min_port -\r\npasv_max_port) 40000 - 45000\r\n\r\n示例：\r\n\r\n\r\nimage-20211002181804382\r\n\r\n\r\n如果你使用的不是云服务器，你只需要将本地的防火墙指定端口打开就行\r\n\r\n验证 FTP 服务\r\n您可通过 FTP 客户端软件、浏览器或文件资源管理器等工具验证 FTP\r\n服务。\r\n\r\n打开客户端的 IE 浏览器，选择【工具】&gt;【Internet\r\n选项】&gt;【高级】，根据您选择的 FTP 模式进行修改：\r\n\r\n主动模式：取消勾选【使用被动 FTP】\r\n被动模式：勾选【使用被动 FTP】\r\n\r\n\r\nimage-20211002180657770\r\n\r\n\r\n打开计算机的 ftp 客户端，如果是 windows\r\n电脑可以直接使用file explorer，在路径栏中访问\"ftp://xxx.xxx.xxx.xxx（你服务器的地址）\"\r\n在弹出的“登录身份”窗口中输入 配置\r\nvsftpd 中已设置的用户名及密码。本文使用的用户名为\r\nftpuser，密码为 JBRBunjie\r\n成功登录后，即可上传及下载文件\r\n\r\n更进一步：为多用户配置不同根目录\r\n埋坑\r\n总之仍然是对 vsftpd 配置文件进行修改来实现\r\n\r\n踩坑集合\r\nLinux 系统环境下\r\n550\r\nNo such file or directory / 550 create directory operation failed\r\n查看当前用户：\r\n如果你能连上远程地址，但是根本看不到文件内容，并且当你输入正确密码时仍然报错：550\r\n建议排查的东西：\r\n\r\n你配置的目录是否正确：/etc/vsftpd/vsftpd.conf 中的\r\nlocal_root 是否是你实际配置的目录\r\nftpuser 是否拥有操作当前\r\nlocal_root=/var/ftp/test 目录及内层文件的权限\r\n1ls -l [option: existed folder in current menu]\r\n服务是否启动\r\n1netstat -antup | grep ftp\r\n修改了配置项但还没有重启服务\r\n1systemctl restart vsftpd\r\n检查 SELinux 服务：\r\n1getsebool -a | grep ftp\r\n如果这条语句的结果是\r\n\r\n\r\nimage-20210918235447255\r\n\r\n代表 SELinux 安全服务处于 disabled\r\n状态，不是这里的错，大概率还是上面四条错误\r\n但是如果是下面这样\r\n\r\n\r\n\r\nimage-20210918235240645\r\n\r\n——几乎所有与 ftp 相关的服务都被关闭掉了\r\n那几乎可以肯定是在这里出错了\r\n解决办法是修改/etc/selinux/config 配置文件：\r\n1vim /etc/selinux/config\r\n把SELINUX默认的permissive或enforcing改为disabled\r\n\r\n\r\nimage-20210918235654741\r\n\r\n\r\n什么是SELinux？\r\nSecurity-Enhanced Linux (SELinux) is a security architecture for\r\nLinux® systems that allows administrators\r\nto have more control over who can access the system. It was originally\r\ndeveloped by the United States National Security Agency (NSA) as a\r\nseries of patches to the Linux kernel using\r\nLinux Security Modules (LSM).\r\nSELinux was released to the open source community in 2000, and was\r\nintegrated into the upstream Linux kernel in 2003.\r\n\r\n\" SELinux(Security-Enhanced Linux)\r\n是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux\r\n历史上最杰出的新安全子系统 \"\r\n\r\n\r\n\r\n最后办法：重启计算机，因为你之前修改的配置文件可能并没有生效\r\n\r\n553 Could not create file\r\n解决方法\r\n\r\n执行以下命令，检查服务器磁盘空间的使用率。\r\n1df -h\r\n\r\n如果磁盘空间不足，将会导致文件无法上传，建议删除磁盘容量较大的文件。\r\n如果磁盘空间正常，请执行下一步。\r\n\r\n执行以下命令，检查 FTP 目录是否有写的权限。\r\n12ls -l /home/test# /home/test 为 FTP 目录，请修改为您实际的 FTP 目录。\r\n\r\n若返回结果中没有\r\nw，则表示该用户没有写的权限，请执行下一步。\r\n若返回结果中已有 w，(⊙﹏⊙)，那我建议你重装系统（\r\n\r\n执行以下命令，对 FTP 目录加上写的权限。\r\n12chmod +w /home/test# /home/test 为 FTP 目录，请修改为您实际的 FTP 目录。\r\n执行以下命令，重新检查写的权限是否设置成功。\r\n12ls -l /home/test# /home/test 为 FTP 目录，请修改为您实际的 FTP 目录。\r\n\r\n设置 FTP 主动模式\r\n主动模式需修改的配置如下，其余配置保持默认设置：\r\n12345678910111213141516anonymous_enable=NO      #禁止匿名用户登录local_enable=YES         #支持本地用户登录chroot_local_user=YES    #全部用户被限制在主目录chroot_list_enable=YES   #启用例外用户名单chroot_list_file=/etc/vsftpd/chroot_list  #指定用户列表文件，该列表中的用户不被锁定在主目录listen=YES               #监听IPv4 sockets#在行首添加#注释掉以下参数#listen_ipv6=YES         #关闭监听IPv6 sockets#添加下列参数allow_writeable_chroot=YESlocal_root=/var/ftp/test #设置本地用户登录后所在的目录\r\n按 Esc 后输入 :wq\r\n保存后退出，并前往这里&gt;继续完成 vsftpd\r\n配置。\r\n参考资料：\r\n部分资源与拓展阅读\r\n\r\nFileZilla - The free FTP\r\nsolution (filezilla-project.org)\r\nWhat is\r\nSELinux? (redhat.com)\r\nWhat is\r\nLinux? (redhat.com)\r\nhttps://www.redhat.com/en/topics/linux/what-is-the-linux-kernel\r\n\r\n进一步配置方向：\r\n\r\n添加用户与用户组并分配不同权限\r\n\r\n","slug":"Deploy/FTP部署","date":"2021-10-05T03:07:03.000Z","categories_index":"FTP","tags_index":"FTP","author_index":"JBR_Bunjie"},{"id":"f859a0dc217f052fa5c43eafb964028a","title":"私有Git仓库搭建","content":"云服务器上的私有Git仓库搭建\r\n\r\n环境：\r\n阿里云服务器CentOS7.6\r\n部署Git\r\n安装Git：\r\n非CentOS安装Git：\r\n绝大多数Linux发行版安装Git只需要一条命令——参看：Git官方指南\r\n关于CentOS安装：\r\n与绝大部分Linux系统不同，redhat发行的系统通过包管理工具yum最高只能安装到1.8.3版本，需要使用更高版本的话都只能通过源码编译安装\r\n\r\nRed Hat Enterprise Linux, Oracle Linux, CentOS, Scientific Linux, et\r\nal.\r\nRHEL and derivatives typically ship older versions of git. You can download a tarball and build from source, or\r\nuse a 3rd-party repository such as the IUS\r\nCommunity Project to obtain a more recent version of git.\r\n\r\n下载源码\r\n首先我们先选择要安装的Git版本，我选择了2.33.0，下载并传到服务器上\r\n\r\n\r\nimage-20211001150441411\r\n\r\n解压，编译，安装\r\n1234567891011121314151617181920# 查看git版本git --version # 卸载# yum remove gityum eras# 进入源码目录$ cd git-2.33.0# 安装工具和依赖$ yum install libcurl-devel$ yum install expat-devel$ yum install openssl-devel # 编译$ make prefix=/usr/local/git all# 编译内容带/usr/locak/git目录$ make prefix=/usr/local/git install# 在/usr/local/git目录完成安装，请注意，这个不是git的默认路径，所以我们还需要为git的bin中文件建立软连接到/usr/bin中\r\n\r\n关于编译命令：make\r\nmake all：编译所有的目标\r\nmake install：安装已编译好的程序\r\n请注意！\r\nBy default, make install will install all the files in\r\n/usr/local/bin, /usr/local/lib etc. You can\r\nspecify an installation prefix other than\r\n/usr/local' using--prefix', for instance\r\n--prefix=$HOME\r\n\r\n添加到环境变量\r\n123456789# 将git路径加入bashrc配置$ echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt;/etc/bashrc # 应用bashrc$ source /etc/bashrc# 验证结果$ git --version# git version 2.33.0\r\n建立软连接\r\n1234ln -s /usr/local/git/bin/git-upload-pack /usr/bin/git-upload-packln -s /usr/local/git/bin/git-r-pack /usr/bin/git-receive-pack# 一定要注意抓取地址和目标地址都要调换！# 如果没有在/usr/bin目录添加这两个文件的话，会因为没有处理请求的命令，报出没有权限的错\r\n创建仓库：\r\n123456cd /home/git # 进入git用户目录# 这个目录下会有三个以.记来隐藏的文件，请不要删除# 请以git用户的身份执行以下命令，否则还要执行修改用户目录权限的命令# 否则当客户端在以git身份执行clone等操作时会因为没有权限而失败git init --bare yourRepositoryName.git # 这个命令有多个版本，如：git init yourRepositoryName.git, git init -bare youreRepositoryName.git 请注意区分\r\n在客户端克隆仓库：\r\n1git clone git@server-IP:/home/git/test.git\r\n完成！\r\n\r\n\r\nimage-20211003154821032\r\n\r\n限制git用户登录：\r\n有的时候我们并不希望用户直接通过git用户的账号以及密码来直接通过SSH登录Linux主机，我们该怎么做？\r\n方法一：禁止Git用户通过ssh直接登录\r\n但是很显然我们不能使用这种方法——当我们禁止Git用户登录时，绝大部分正常的Git操作包括git\r\nclone，git pull等都无法正常进行了\r\n方法二：禁止Git用户进入bash\r\n编辑/etc/passwd这个文件，在文件末尾可以找到类似这样的行：\r\n12345# 原行： git:x:1002:1002::/home/git:/bin/sh      ----------------------------------------------------------# 更改为：git:x:1002:1002::/home/git:/usr/bin/git-shell\r\n把/bin/sh改为/usr/bin/git-shell，这样git这个账户就只能用来克隆或者推送数据到git仓库中了，而不能用它来登录到主机。\r\n\r\n当我们引用git-shell时，我们仍然需要使用 ln\r\n命令来为我们安装于 /usr/local/git 下的文件创建软链接：\r\n1ln -s /usr/local/git/bin/git-shell /usr/bin/git-shell\r\n\r\n重启服务器：\r\n之后，当我们再次通过git用户登录时，便会报：\r\n123fatal: Interactive git shell is not enabled.hint: ~/git-shell-commands should exist and have read and execute access.Connection to x.x.x.x closed.\r\n添加工作空间：\r\n一般来讲，bare仓库不像是普通的仓库那样会在根目录中保存文件，bare仓库不保存文件并将.git文件夹下的全部内容直接暴露在当前仓库根目录中，且不包含工作区\r\n工作空间示例：\r\n\r\n\r\nimage-20211003155529616\r\n\r\n要查看工作空间，我们需要使用一个钩子：post-receive钩子\r\n有了这个钩子，我们要在裸仓库内看到用户提交的工作空间很简单了。只需要创建/编写post-receivek即可：\r\n在服务器裸仓库内\r\n1cd hooks\r\n创建并编辑post-receive\r\n1vim post-receive\r\n输入内容：\r\n12#!/bin/shgit --work-tree=#工作空间# --git-dir=#Git仓库地址# checkout -f\r\n例如，我此处的配置是：\r\n12#!/bin/shgit --work-tree=/home/git/gitWorkspace/testWorkspace --git-dir=/home/git/test.git checkout -f\r\n\r\n工作空间：服务器上空目录地址，git用户需要有读写权限。\r\nGit仓库地址：服务器上本仓库地址。\r\n\r\n赋予执行权限：\r\n12chmod +x post-receive# 用ls -alc\r\n\r\n\r\nimage-20211003171322547\r\n\r\n之后，用户push提交后，–work-tree参数定义的工作空间就可以看到用户提交的具体内容：\r\n\r\n\r\nimage-20211003165533697\r\n\r\n\r\n参考内容：\r\n教程中提到的webstie\r\nGit Website (git-scm.com)\r\nGit\r\nDownload Page(git-scm.com)\r\nIndex of\r\n/pub/software/scm/git/ (kernel.org)\r\nIUS\r\nGit - Git 钩子\r\n(git-scm.com)\r\n拓展资料\r\nall\r\nabout \"bare\" repos -- what, why, and how to fix a non-bare push\r\n(htmlpreview.github.io)\r\ngit\r\n- Where are the files in a bare repository? - Stack Overflow\r\nGit\r\n- Getting Git on a Server (git-scm.com)\r\nAccessing\r\nfiles of a repository from the Git server - Stack Overflow\r\n\r\n\r\n","slug":"Deploy/GitAndGithub/Setup Private Git Repository ","date":"2021-10-05T03:05:03.000Z","categories_index":"Git","tags_index":"Git","author_index":"JBR_Bunjie"},{"id":"fc9433631750b4e2a27c5cd3c21a72be","title":"Python编程入门","content":"Python 3 Basic Grammar\r\nTraining\r\n为什么是 python？\r\n一个最重要的原因——简单，快速，容易上手：\r\n你也可以通过著名的开发语言排行榜 TIOBE 来直观感受 Python 有多么热门index | TIOBE - The Software\r\nQuality Company\r\npython 官网：Welcome to Python.org\r\npython\r\n社区（PYPI）：PyPI · The Python Package\r\nIndex\r\npython 最大的优势：开发效率高\r\npython 最大的劣势：运行效率低\r\n开发效率与运行效率间的取舍是动态语言不可能绕过的问题，Python\r\n选择了开发效率换运行效率。\r\n但是 python 支持嵌入\r\nc，c++等高效率的低级语言，可以在一定程度上缓解这个问题\r\n配置你的电脑环境：\r\n安装 Python 3.8（Python\r\n会自带一个编辑器\"IDLE\"，不过只提供了基础的代码编写功能）\r\n你可以通过我\r\n关于 IDE，我会推荐推荐使用 Jet Brains 公司出品的\r\nPycharm。当然，宇宙第一 IDE——Visual Studio 也是不错的选择\r\n\r\n关于 Python 的版本：\r\nPython3 中的更新与 c/c++的新标准，Java 的新版本等有相通之处；\r\n\r\n每次 Python 更新都会推出很多新的 feature，3.7\r\n版本中更新了这些内容：https://docs.python.org/zh-cn/3.7/whatsnew/3.7.html，如果你需要了解当前版本更新了什么，最好的办法当然是去阅读Python的官方文档，当然，你也可以直接在Python自带的ide：idle来查阅Python的版本变化信息。在idle中，你可以按照Help\r\n&gt;&gt;&gt; Python Docs &gt;&gt; What’s New In Python 3.7\r\n的路径来查看\r\n\r\n简单来说，python 的更新会添加新的语法，提升 python\r\n的稳定性(一般)，少数情况下会删除旧的语法与功能（3.10\r\n的兼容性差大概就是这么来的）\r\n截止本文完成时，Python 已经推出了发布 3.11\r\n版本的计划，并且已经推出了 Python3.11 的文档：What’s New In\r\nPython 3.11 — Python 3.11.0a0 documentation\r\n\r\n正式开始！\r\n从命令行开始！\r\n\r\n\r\nimage-20210923234720280\r\n\r\n这时，cmd 就进入了 python 的编写模式，支持 python\r\n当前版本的所有语法，和 python 自带的编辑器\r\n\r\n当然，你也可以使用 windows 的 powershell，不过相对于 cmd\r\n而言，powershell 更加复杂，而且有各种莫名其妙的限制\r\n\r\n\r\n注意，如果你在 cmd 中输入 python 后打开的是 windows\r\n商店，这是你操作系统的环境变量出了问题，请在 edit the system environment\r\nvariables 下仔细检查 Path 中 python 条目下的环境变量指向的地址！\r\n\r\n现在尝试打印 Hello World 吧\r\n所有你需要做的只是输入\r\n1print(&quot;Hello World&quot;)\r\ncmd 就会显示：\r\n\r\n\r\nimage-20210329193537197\r\n\r\n简单吧！相信你一定会爱上 python 这门简单的语言的\r\n如果你要回到 cmd 的初始状态，只需要用 quit() 即可\r\n\r\n\r\nimage-20210329193638362\r\n\r\n\r\n什么时候需要使用到命令行？\r\n比如我现在已经编写完成了一个基于 python\r\n的脚本。在命令行中，我们甚至无需要进入 python 的编辑模式，只需输入\r\npython + 文件路径即可直接执行。一般来说，启动一个 ide\r\n是很耗费时间的，而这就是我们节约时间的手段。\r\n\r\n\r\nimage-20210923235953188\r\n\r\n在 pycharm 中继续：\r\nPyCharm 介绍\r\n官网：PyCharm: the\r\nPython IDE for Professional Developers by JetBrains\r\n至于为什么选用它，建议逼乎一下 😂\r\n新建项目\r\n\r\n\r\nimage-20210329193807978\r\n\r\n对 pycharm 的一些初始设置：\r\n\r\n设置编码：（都改为 utf-8）\r\n设置新建文件的默认代码和内容：\r\n\r\n你可以在 PyCharm 的官网上找到所有的 File template variables：File\r\ntemplate variables | PyCharm (jetbrains.com)\r\n在 console 里执行命令：\r\n前面已经提到过在命令行中执行 Python 代码，这当然是运行已经编写好的\r\nPython\r\n程序或脚本的好办法。但是命令行中执行程序后就立刻输出结果并结束程序，那要是程序结束后我还想继续执行更多操作怎么办？\r\n这时候你可能需要用到 Python Console 功能\r\npycharm 中的 console 就是一个 pychon\r\n的直接运行环境，这里允许你以解释性的形式逐句输入并运行 python\r\n代码。值得一提的是，在 PyCharm 中运行你的 Python 文件时，默认输出到\r\nPython Console 中，这意味着你可以在程序结束完成之后接着输入更多内容\r\n\r\n当你有不确定的代码需要验证的时候，不妨先复制到 console 里试一试！\r\n\r\n数据类型：\r\n在学习语法之前，你需要了解构成程序的要素是什么\r\n如果你有过其它语言的编程经验的话，你可能会说“数据结构+算法”\r\n但是如果你纯新手的话，那这可能难以理解。那么我会说，程序是由符合当前编程语言语法的语句依次执行生成的，构建程序的基本内容是数据的运算与处理\r\n很显然，就数据的处理而言，直接使用 1 + 2\r\n等既定的数据常量是远远不够的——我们需要应付更多变的情况——这就要用到变量\r\nPython 变量命名规则\r\n和其它语言一样，Python 也有自己的变量命名规则\r\n\r\n第一个字符必须是字母表中字母或下划线 _\r\n标识符的其他的部分由字母、数字和下划线组成\r\n标识符对大小写敏感\r\n注意避开 python 自己的保留字符\r\n你可以通过以下语句来查询 Python 保留的关键字符\r\n12import keywordkeyword.kwlist\r\n\r\n示例： \r\n关于变量的基本数据类型：\r\n在 Python\r\n中，变量就是变量，它没有类型，我们所说的\"类型\"是变量所指的内存中对象的类型。\r\nPython\r\n中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\r\n\r\n不过 Python 中的确存在这些“基本数据类型”如：int，float\r\n之类的，并且它们之间都存在着严格的限制\r\n你可以使用 type() 函数来检查当前变量的数据类型：\r\n\r\n标准数据类型：\r\n\r\n不可变数据（3\r\n个）：Number（数字）、String（字符串）、Tuple（元组）；\r\n可变数据（3\r\n个）：List（列表）、Dictionary（字典）、Set（集合）。\r\n\r\n共六种\r\n关于可变与不可变数据：\r\n什么是不可变数据？\r\n在 Python 中，我们可以设立变量 a = 1，之后我们可以对 a\r\n的值做出改变，比如又执行语句 a = 2，这时 a 当然就不再指向 1，但是 1\r\n这个“内容”本身并没有改变。\r\n而可变数据则是可以改变数据的具体内容：如语句 a = [1, 2]，我们可以将 a\r\n中的[0], [1]等数据单独拎出来并做出改变而并不改变 a 本身的指向\r\n这些“指向”，“内容”都是基于内存地址来说的。\r\n不可变数据类型：\r\n当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。\r\n可变数据类型\r\n：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。\r\n你可以用\r\nid(变量名)来查验对应变量的内存地址是否发生变化\r\n数字：\r\nint float...\r\n列表：Python\r\n中功能最强大的数据类型\r\n用“[ ]”来定义列表！\r\n列表支持：\r\n\r\n列表间的拼接\r\n定义以列表为元素的列表\r\n将整个列表赋给新列表（也可以使用 copy()函数：)\r\n通过 append()，entend()，insert()，实现增\r\n通过 pop()，remove()，实现删\r\n支持通过截取来获取列表内容（截取参看字符串\r\n\r\n元组：”常量列表“\r\n不能改变元素个数的列表，列表中一切涉及改变元素个数改变的功能全部\r\nNG\r\n用 “( )\" 来定义一个元组\r\n\r\n元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：\r\n\r\n\r\nimage-20210402174032001\r\n\r\n\r\n字符串：特化列表\r\n\r\npython 允许直接把字符/字符串存储到一个变量中\r\n\r\n12345678910111213141516171819202122232425&gt;&gt;&gt; a = &quot;bunjie&quot;&gt;&gt;&gt; a[-1]&#x27;e&#x27;&gt;&gt;&gt; a[0]&#x27;b&#x27;&gt;&gt;&gt; a[1]&#x27;u&#x27;&gt;&gt;&gt; a[:]&#x27;bunjie&#x27;&gt;&gt;&gt; a[0:1]&#x27;b&#x27;&gt;&gt;&gt; a[0:5]&#x27;bunji&#x27;&gt;&gt;&gt; a[0:6]&#x27;bunjie&#x27;&gt;&gt;&gt; a[0:7]&#x27;bunjie&#x27; #没有报错&gt;&gt;&gt; a[-1:-2]&#x27;&#x27;&gt;&gt;&gt; a[:-1]&#x27;bunji&#x27;&gt;&gt;&gt; a[:-6]&#x27;&#x27;&gt;&gt;&gt; a[:-5]&#x27;b&#x27;\r\n\r\n\r\nimage-20210402171810502\r\n\r\n字典：\r\n使用键值对进行匹配，类似 c 语言中的“枚举类型”，以键值对构建数据内容\r\n&#123;key: value, ...&#125;\r\n12345d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;print(d[key1])# 输出：value1D = &#123;&#125; # 我们可以使用大括号来创建空字典\r\n字典可能是所有数据类型中最高效的，因为取元素时直接采用 key\r\n来定点查找而不是像是 list 等数据类型依次迭代查找\r\n集合：\r\n是的，就是集合论中的集合\r\n总体来说，集合这种数据类型我们使用得较少，做可以使用大括号 {\r\n} 或者 set()\r\n函数创建集合，注意：创建一个空集合必须用 set() 而不是\r\n{ }，因为 { }\r\n是用来创建一个空字典。\r\n创建格式：\r\n12parame1 = &#123;value01, value02, ...&#125; # 注意格式parame2 = set() # set只允许单个参数，我们一般使用set来创建空集合\r\n\r\n根据我们中学时所学到的知识，我们知道：集合具有确定性、互异性、无序性\r\n根据这些性质，我们获知：单个确定数据只会出现一次。所以如果出现重复的值，集合会把相同的合并。\r\n\r\n语法：\r\n关于注释：\r\n什么是注释？\r\n注释是你在程序中插入的解释性的文字，单纯的只是为了方便别人和自己理解当前程序。程序在运行时会忽略所有被注释的部分，所以你留下的注释并不会对程序功能造成任何实际上的影响\r\npython 中的注释方式：\r\n\r\n以 # 作为单行注释，在 pycharm\r\n中，你可以使用 ctrl + / 来快速注释一整行:\r\n1# 这是一个单行注释\r\n以一对三个连续的单引号''' '''，或一对三个连续的双引号\"\"\" \"\"\"来作为多行注释\r\n1234567&quot;&quot;&quot;这是一个多行注释&quot;&quot;&quot;&#x27;&#x27;&#x27;这也是一个多行注释&#x27;&#x27;&#x27;\r\n\r\n关于缩进：\r\nPython 没有\r\n&#123; &#125;，它采用精确的缩进来确定控制语句的执行范围！\r\n一个项目里最好只采用 tab 和 space\r\n两种中的一种缩进，如果在一个控制体里使用了两种缩进格式是会报错的\r\n个人建议使用 tab 作为缩进\r\n\r\n\r\nimage-20210330153314699\r\n\r\npython 没有分号：“ ; ”， 语句间几乎没有大括号，代价是精确的缩进！\r\n条件控制语句\r\n为什么使用条件控制？\r\n当然是为了以一个程序去应对多种可能性\r\n例如：我们解决除法运算时，我们当然需要以除数不为零来分类，但是我们不可能因为这一点就开发两个程序，并且要求用户根据除数是什么来选择运行那个程序——这就要求我们在设计程序的时候为某些特定情况运行特定代码\r\nPython\r\n中的条件控制语句长什么样？\r\nPython 中 if 语句的一般形式如下所示：\r\n1234567if condition_1:    statement_block_1elif condition_2:    statement_block_2# 更多情况使用elif condiition_3: ... 并以此类推else:    statement_block_3\r\n\r\n如果 \"condition_1\" 为 True 将执行 \"statement_block_1\" 块语句\r\n如果 \"condition_1\" 为 False，将判断\r\n\"condition_2\"\r\n如果\"condition_2\" 为 True 将执行 \"statement_block_2\" 块语句\r\n如果 \"condition_1\"与\"condition_2\"均为\r\nFalse，那么将执行\"statement_block_3\"块语句\r\n\r\n\r\n1、每个条件后面要使用冒号\r\n:，表示接下来是满足条件后要执行的语句块。\r\n2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。\r\n3、在 Python 中没有 switch – case 语句。\r\n\r\n循环语句：\r\n循环的意义有点类似于乘法之于加法，它提供了一种解出某一个条件下的最终结果的方式。借助循环，计算机能够非常高效的完成人很难或无法完成的事情，比如说，在大量文件中查找包含某个搜索词的文档，对几十万条销售数据进行统计汇总等。\r\nwhile 循环：\r\n123while 判断条件(condition)：\t执行语句(statements)……# 每次循环之前都会进行一次condition是否为真的判断，如果结果为false，则立即停止循环\r\nfor 循环：\r\n1234for &lt;variable&gt; in &lt;sequence&gt;:    &lt;statements&gt;else:    &lt;statements&gt;\r\n例一：\r\n例二：\r\n基础语法到此结束！\r\n附录 1：python 包的获取和管理\r\n类似于 Node 的 npm，Linux 中的 yum，apt 等，python\r\n有自己的包管理工具——pip，这也是 Python 安装时自带的\r\n但是直接从 pypi\r\n上获取包的速度太慢长城防火墙，所以我们要借用一些国内的镜像网站，比如清华大学的清华源镜像网站\r\n你可以从 console(非 python 的编辑模式)里用 python 的 pip\r\n语句指定国内的镜像源来直接安装包，如：\r\n12pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple/# -i代表当前安装操作使用后面的临时源\r\n不过我们也可以通过 ctrl + shift + s 打开 pycharm 的 settings 进入\r\nProject: (你当前的项目名) &gt;&gt; Python InterPreter\r\n来直接安装包。记得在 manage repository 中添加国内的 python 源的地址\r\n\r\n国内 Python\r\n源建议使用清华源：https://pypi.tuna.tsinghua.edu.cn/simple/\r\n\r\n附录 2：Python 运算符\r\n运算符：（python\r\n的语法糖很大一部分集中在多种多样的运算符，这也是让书写 python\r\n代码速度起飞的重要原因！）\r\n（虽然刚接触的时候会因为大量的运算符而痛苦 😀）\r\n运算符手册：\r\n算数运算符：（相比 c\r\n语言多了幂运算于取整运算）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n运算符\r\n描述\r\n实例\r\n\r\n\r\n\r\n\r\n+\r\n加 - 两个对象相加\r\na + b 输出结果 31\r\n\r\n\r\n-\r\n减 - 得到负数或是一个数减去另一个数\r\na - b 输出结果 -11\r\n\r\n\r\n*\r\n乘 -\r\n两个数相乘或是返回一个被重复若干次的字符串\r\na * b 输出结果 210\r\n\r\n\r\n/\r\n除 - x 除以 y\r\nb / a 输出结果 2.1\r\n\r\n\r\n%\r\n取模 - 返回除法的余数\r\nb % a 输出结果 1\r\n\r\n\r\n**\r\n幂 - 返回 x 的 y 次幂\r\na**b 为 10 的 21 次方\r\n\r\n\r\n//\r\n取整除 - 向下取接近商的整数\r\n&gt;&gt;&gt; 9//2 4\r\n&gt;&gt;&gt; -9//2 -5\r\n\r\n\r\n\r\n比较运算符：（和 c 语言相同）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n运算符\r\n描述\r\n实例\r\n\r\n\r\n\r\n\r\n==\r\n等于 - 比较对象是否相等\r\n(a == b) 返回 False。\r\n\r\n\r\n!=\r\n不等于 - 比较两个对象是否不相等\r\n(a != b) 返回 True。\r\n\r\n\r\n&gt;\r\n大于 - 返回 x 是否大于 y\r\n(a &gt; b) 返回 False。\r\n\r\n\r\n&lt;\r\n小于 - 返回 x 是否小于\r\ny。所有比较运算符返回 1 表示真，返回 0 表示假。这分别与特殊的变量 True\r\n和 False 等价。注意，这些变量名的大写。\r\n(a &lt; b) 返回 True。\r\n\r\n\r\n&gt;=\r\n大于等于 - 返回 x 是否大于等于 y。\r\n(a &gt;= b) 返回 False。\r\n\r\n\r\n&lt;=\r\n小于等于 - 返回 x 是否小于等于 y。\r\n(a &lt;= b) 返回 True。\r\n\r\n\r\n\r\n赋值运算：\r\n\r\n\r\n\r\n运算符\r\n描述\r\n实例\r\n\r\n\r\n\r\n\r\n=\r\n简单的赋值运算符\r\nc = a + b 将 a + b 的运算结果赋值为 c\r\n\r\n\r\n+=\r\n加法赋值运算符\r\nc += a 等效于 c = c + a\r\n\r\n\r\n-=\r\n减法赋值运算符\r\nc -= a 等效于 c = c - a\r\n\r\n\r\n*=\r\n乘法赋值运算符\r\nc = a 等效于 c = c  a\r\n\r\n\r\n/=\r\n除法赋值运算符\r\nc /= a 等效于 c = c / a\r\n\r\n\r\n%=\r\n取模赋值运算符\r\nc %= a 等效于 c = c % a\r\n\r\n\r\n**=\r\n幂赋值运算符\r\nc = a 等效于 c = c \r\na\r\n\r\n\r\n//=\r\n取整除赋值运算符\r\nc //= a 等效于 c = c // a\r\n\r\n\r\n\r\n\r\n特别提醒！ python 中没有像 c 语言一样的自加运算！\r\n\r\n位运算符：（和 c 语言相同）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n运算符\r\n描述:(下表中变量 a 为 60，b 为 13\r\n二进制格式如下：)\r\n实例\r\n\r\n\r\n\r\n\r\n&amp;\r\n按位与运算符：参与运算的两个值,如果两个相应位都为\r\n1,则该位的结果为 1,否则为 0\r\n(a &amp; b) 输出结果 12 ，二进制解释：\r\n0000 1100\r\n\r\n\r\n|\r\n按位或运算符：只要对应的二个二进位有一个为\r\n1 时，结果位就为 1。\r\n(a | b) 输出结果 61 ，二进制解释： 0011\r\n1101\r\n\r\n\r\n^\r\n按位异或运算符：当两对应的二进位相异时，结果为\r\n1\r\n(a ^ b) 输出结果 49 ，二进制解释： 0011\r\n0001\r\n\r\n\r\n~\r\n按位取反运算符：对数据的每个二进制位取反,即把\r\n1 变为 0,把 0 变为 1。~x 类似于\r\n-x-1\r\n(~a ) 输出结果 -61 ，二进制解释： 1100\r\n0011， 在一个有符号二进制数的补码形式。\r\n\r\n\r\n&lt;&lt;\r\n左移动运算符：运算数的各二进位全部左移若干位，由\"&lt;&lt;\"右边的数指定移动的位数，高位丢弃，低位补\r\n0。\r\na &lt;&lt; 2 输出结果 240 ，二进制解释：\r\n1111 0000\r\n\r\n\r\n&gt;&gt;\r\n右移动运算符：把\"&gt;&gt;\"左边的运算数的各二进位全部右移若干位，\"&gt;&gt;\"右边的数指定移动的位数\r\na &gt;&gt; 2 输出结果 15 ，二进制解释：\r\n0000 1111\r\n\r\n\r\n\r\n逻辑运算符：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n运算符\r\n逻辑表达式\r\n描述（令 a=10， b=20）\r\n实例\r\n\r\n\r\n\r\n\r\nand\r\nx and y\r\n布尔\"与\" - 如果 x 为 False，x and y 返回 x\r\n的值，否则返回 y 的计算值。\r\n(a and b) 返回 20。\r\n\r\n\r\nor\r\nx or y\r\n布尔\"或\" - 如果 x 是 True，它返回 x\r\n的值，否则它返回 y 的计算值。(与“与运算恰好相反”)\r\n(a or b) 返回 10。\r\n\r\n\r\nnot\r\nnot x\r\n布尔\"非\" - 如果 x 为 True，返回 False\r\n。如果 x 为 False，它返回 True。\r\nnot(a and b) 返回 False\r\n\r\n\r\n\r\n\r\n补充说明：\r\n\r\n成员运算符：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n运算符\r\n描述\r\n实例\r\n\r\n\r\n\r\n\r\nin\r\n如果在指定的序列中找到值返回\r\nTrue，否则返回 False。\r\nx 在 y 序列中 , 如果 x 在 y 序列中返回\r\nTrue。\r\n\r\n\r\nnot in\r\n如果在指定的序列中没有找到值返回\r\nTrue，否则返回 False。\r\nx 不在 y 序列中 , 如果 x 不在 y 序列中返回\r\nTrue。\r\n\r\n\r\n\r\n身份运算符：\r\n（有种 == 和 != 的感觉，但是确实不一样！）\r\nis 用于判断两个变量引用对象是否为同一个， ==\r\n用于判断引用变量的值是否相等。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n运算符\r\n描述（注：id ()\r\n函数用于获取对象内存地址。）\r\n实例\r\n\r\n\r\n\r\n\r\nis\r\nis\r\n是判断两个标识符是不是引用自一个对象\r\nx is y, 类似\r\nid(x) == id(y) , 如果引用的是同一个对象则返回\r\nTrue，否则返回 False\r\n\r\n\r\nis not\r\nis not\r\n是判断两个标识符是不是引用自不同对象\r\nx is not y ， 类似\r\nid(a) != id(b)。如果引用的不是同一个对象则返回结果\r\nTrue，否则返回 False。\r\n\r\n\r\n\r\n\r\n\r\nimage-20210402163932528\r\n\r\nPython 运算符优先级\r\n以下表格列出了从最高到最低优先级的所有运算符：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n运算符\r\n描述\r\n\r\n\r\n\r\n\r\n**\r\n指数 (最高优先级)\r\n\r\n\r\n~ + -\r\n按位翻转, 一元加号和减号\r\n(最后两个的方法名为 +@ 和 -@)\r\n\r\n\r\n* / % //\r\n乘，除，求余数和取整除\r\n\r\n\r\n+ -\r\n加法减法\r\n\r\n\r\n&gt;&gt; &lt;&lt;\r\n右移，左移运算符\r\n\r\n\r\n&amp;\r\n位 'AND'\r\n\r\n\r\n^ |\r\n位运算符\r\n\r\n\r\n&lt;= &lt; &gt; &gt;=\r\n比较运算符\r\n\r\n\r\n== !=\r\n等于运算符\r\n\r\n\r\n= %= /= //= -= += *= **=\r\n赋值运算符\r\n\r\n\r\nis is not\r\n身份运算符\r\n\r\n\r\nin not in\r\n成员运算符\r\n\r\n\r\nnot and or\r\n逻辑运算符\r\n\r\n\r\n\r\n最后（传教）:我即使是死了，钉在棺材里了，也要在墓里，用这腐朽的声带喊出：“vocaloid\r\nforever！！！\"\r\n最后的最后：都看到这里了，不听支歌吗?(❁'◡'❁)\r\n\r\n\r\n参考资料：\r\n\r\nPython3 教程\r\n| 菜鸟教程 (runoob.com)\r\n\r\n","slug":"Language Learning/Python/PythonBasicGrammar/PythonBasicGrammar","date":"2021-09-26T09:22:04.000Z","categories_index":"Python,Language Learning","tags_index":"Language Learning,Python","author_index":"JBR_Bunjie"},{"id":"cadb81dd6adf93defe9d2e5bccb01250","title":"美化你的GitHub主页！","content":"一般来说，GitHub主页是很简陋枯燥又单调的：\r\n\r\n\r\nimage-20210907192522519\r\n\r\n但是也许你也见过别人的完全不同的主页：\r\n\r\n\r\nimg\r\n\r\n欸？他的主页怎么有一个markdown文件作为公示栏来展示？怎么做到的？\r\n答案是GitHub的官方彩蛋（后门）：\r\n当↗当↗当↗当↘\r\n\r\n\r\nimage-20210907193059189\r\n\r\n\r\n请注意：你需要创建一个公共仓库，这样才会被GitHub所捕捉到，如果这是私密仓库的话是不会在主页上出现的\r\n\r\n然后你会在这个新创建的仓库的页面右侧看到\r\n\r\n\r\nimage-20210907193619068\r\n\r\n此时，这个“彩蛋”会立即生效\r\n\r\n\r\nimage-20210907194151912\r\n\r\n如果想要有一个不一样的GitHub主页，就需要使用这个小小的“彩蛋”来定制你的主页\r\n当然，你也可以引入很多组件来深度定制你的GitHub主页：比如：\r\ngithub-readme-stats/readme_cn.md\r\nat master · anuraghazra/github-readme-stats\r\n","slug":"Deploy/GitAndGithub/beautifyGithubHome","date":"2021-09-07T15:58:53.000Z","categories_index":"Git","tags_index":"Git,GitHub","author_index":"JBR_Bunjie"},{"id":"6adf345a8e80c4aa1ee89482b75933eb","title":"Hello World, Hello Hexo","content":"Hello World, Hello Hexo\r\nHexo 的基础配置\r\n安装 hexo-cli\r\n1npm install hexo-cli -g\r\n完成 hexo 的部署：\r\n12345npm install hexo-cli -ghexo init &lt;name&gt; # 注意：hexo必须要在空文件夹下完成初始化，如果没有&lt;name&gt;，则在当前目录下完成初始化，否则新建一个&lt;name&gt;文件夹初始化cd &lt;name&gt; # 根据上个命令初始化的文件夹使用npm install # 安装依赖hexo server # 启动hexo服务器，这时候便可以访问所有 source/ 下的所有文章页面了\r\n创建新的页面：\r\n12hexo new [layout] &lt;name&gt; # 创建一个新的post页面，会出现在source文件夹下，内涵一个index.md# 我们可以直接对这个md文件进行编辑，hexo会自动将这个文件渲染为一个html页面\r\n\r\n创建新文件夹或者页面时请注意 \\_config.yml 中\r\n# Directory 下项目的配置\r\n\r\n再次运行 hexo：\r\n123hexo clean # 清除之前hexo的缓存hexo g # g或generate 根据md文件生成html等文件hexo s # s或server 启动hexo服务器\r\n配置 Hexo 快速部署：\r\nOne-Command\r\nDeployment | Hexo\r\n以 git 为例：\r\n安装 hexo 的 git 插件：\r\n1npm install hexo-deployer-git --save\r\n修改 Hexo\r\n中的\\_config.yml文件：\r\n1234567891011deploy:  type: git  repo: &lt;repository url&gt; # https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]# 例如，我自己的仓库配置如下：deploy:  type: git  repo: git@github.com:JBR-Bunjie/JBR-Bunjie.github.io.git  branch: master\r\n配置完成之后，我们便可以使用命令：\r\n1hexo deploy\r\n来直接将我们编写的 Hexo 文档推送到所有远端托管地址上了\r\n\r\n在使用 git 来推送之前，你需要先完成本地 git\r\n工具对远程仓库的权限等配置\r\n\r\n安装别的博客框架\r\n当然，你需要先选定一个博客框架才行\r\n比如如果想要安装aurora，我会选择直接去查阅aurora的官方文档来了解aurora的具体配置项\r\nHome | Hexo Aurora\r\n(tridiamond.tech)\r\n但是当我们想要更替当前 Hexo 框架时，我们需要同时修改 Hexo\r\n项目的\\_config.yml和 Hexo\r\n框架的的\\_config.xxx.yml，例如：Aurora\r\n的\\_config.aurora.yml\r\n123# 修改项：theme: &lt;yourThemeName&gt;\r\n让 Hexo 支持 Latex 表达式\r\n即便是 aurora 这种并非原生支持 Latex 的 theme，也可以通过直接改变\r\nhexo 的\r\n1234567npm uninstall hexo-renderer-marked --save# 注意，pandoc并非渲染引擎本身，我们需要先下载并安装pandoc.exe，之后hexo-renderer-pandoc才能通过调用pandoc.exe来生成页面# https://pandoc.org/installing.html# 如果pandoc不是默认路径的话，是需要在config里写明npm install hexo-renderer-pandoc --savenpm install hexo-filter-mathjex --save\r\n当安装完成后，并且我们在对应页面的 head 中插入：\r\n1mathjex: true\r\n后，我们便可以通过正常的生成语句来得到正确显示的 Latex 公式了！\r\n1234# 以上所有步骤完成后。hexo clhexo ghexo s\r\n\r\n\r\n","slug":"Deploy/Hexo使用","date":"2021-09-07T14:09:05.000Z","categories_index":"Hexo","tags_index":"Hexo","author_index":"JBR_Bunjie"},{"id":"a92e2fc05670d2982e0ff2c87e209a38","title":"RESTful规范 - 如何写API","content":"RESTful规范 - 如何写API\r\n\r\n如果是对同一个表进行数据操作，应该使用同一条 API，然后根据 method\r\n的不同，进行不同的操作\r\n1GET/POST/PUT/DELETE/PATCH\r\n面向资源编程，通过 API 提交的参数最好是名词如\r\nname，尽量少用动词\r\n1http://www.abc.com/name\r\n体现版本，在 API 中加入像 v1, v2 这样的版本代号\r\n12http://www.abc.com/v1/namehttp://www.abc.com/v2/name\r\n体现 API，让使用者一眼能看出这是 API 而不是 URL，应该在 API\r\n中加入提示：\r\n12http://www.abc.com/api/v1/namehttp://www.abc.com/api/v2/name\r\n使用 HTTPS\r\n12https://www.abc.com/api/v1/namehttps://www.abc.com/api/v2/name\r\n响应式设置状态码\r\n1return HttpResponse(&#x27;abcde&#x27;, status=200)\r\nAPI 的参数里加入筛选条件参数，也可以理解为获取资源优先选择 GET\r\n的方式\r\n1https://www.abc.com/api/v2/name?page=1&amp;size=10\r\n返回值的规范，对不同的请求 method，做出相应的响应值如：\r\n1234567891011-&gt; https://www.abc.com/api/v1/name- GET: 所有列表- POST: 新增的数据-&gt; https://www.abc.com/api/v1/name/1- GET: 单条数据- PUT: 更新，返回更新的数据- PATCH: 局部更新，返回更新的数据- DELETE: 删除，返回空文档\r\n返回错误信息，包括错误代号等，让用户直接看出是哪种类型错误\r\n123456ret &#123;    code: 1000,    data: &#123;        1: &#123;&#x27;id&#x27;: 1, &#x27;title&#x27;: &#x27;lala&#x27;&#125;    &#125;&#125;\r\n返回的详细信息，应该以字典的形式存放在 data 中\r\n123456ret &#123;    code: 1000,    data: &#123;        1: &#123;&#x27;id&#x27;: 1, &#x27;title&#x27;: &#x27;lala&#x27;, &#x27;detail&#x27;: &#x27;lalalalala&#x27;&#125;    &#125;&#125;\r\n\r\n","slug":"Dev/Theory/RESTful规范 - 如何写API","date":"2021-07-23T04:23:23.000Z","categories_index":"Theroy","tags_index":"Theroy","author_index":"JBR_Bunjie"},{"id":"a7427683ffea4c224c83d4bf0c430464","title":"formdata使用攻略","content":"formdata使用攻略\r\nFormData\r\n对象的使用 - Web API 接口参考 | MDN (mozilla.org)\r\n\r\nFormData\r\n对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed\r\ndata)，而独立于表单使用。如果表单enctype属性设为\r\nmultipart/form-data ，则会使用表单的submit()方法来发送数据，从而，发送数据具有同样形式。\r\n\r\n从零开始创建 FormData 对象\r\n你可以自己创建一个FormData对象，然后调用它的append()方法来添加字段，像这样：\r\n12345678910111213141516171819var formData = new FormData();// 发送键值对formData.append(&quot;username&quot;, &quot;Groucho&quot;);formData.append(&quot;accountnum&quot;, 123456); //数字123456会被立即转换成字符串 &quot;123456&quot;// HTML 文件类型input，由用户选择formData.append(&quot;userfile&quot;, fileInputElement.files[0]); // fileInputElement是 file类型的input标签// JavaScript file-like 对象var content = &#x27;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&#x27;; // 新文件的正文var blob = new Blob([content], &#123; type: &quot;text/xml&quot; &#125;);formData.append(&quot;webmasterfile&quot;, blob);// 发送var request = new XMLHttpRequest();request.open(&quot;POST&quot;, &quot;http://foo.com/submitform.php&quot;);request.send(formData);\r\n上传文件思路：\r\n利用 h5\r\n的input标签，将其type设置为file\r\n&lt;input\r\ntype=\"file\"&gt; - HTML（超文本标记语言） | MDN (mozilla.org)\r\n此时，注意其一特殊的内置属性：files属性，它会以FileList对象的形式列出已选择的文件\r\nFileList\r\n- Web API 接口参考 | MDN (mozilla.org)\r\n值得注意的是，Filelist不是formdata，请不要尝试直接将Filelist对象发送给后端\r\n同时，如需发送formdata，请先行创建一个FormData对象\r\nFormData并非一定需要一个form来作为基础进行创建，但一定需要键值对\r\n也可以利用\r\n1formdata.append(&quot;file&quot;, document.getElementById(&quot;fileInput&quot;).files[0]);\r\n手动将传入的文件加入 formdata 对象中\r\n发送请求时，需要特别设置其请求头：\r\n123headers: &#123;      &#x27;Content-Type&#x27;: &quot;multipart/form-data&quot;,&#125;\r\n防止所发送的文件被错误地转换了格式\r\n循环获取 formdata 内容\r\njavascript\r\n- How to inspect FormData? - Stack Overflow\r\n123for (var [a, b] of formData.entries()) &#123;  console.log(a, b, &quot;--------------&quot;);&#125;\r\n1formdata.get(key);\r\n\r\n注意:\r\n所有的输入元素都需要有name属性，否则无法访问到值。\r\n——FormData()\r\n- Web API 接口参考 | MDN (mozilla.org)\r\n\r\n上传文件完整攻略：\r\n1234567891011121314151617181920212223242526272829303132&lt;body&gt;  &lt;form id=&quot;form&quot;&gt;    &lt;label&gt;Choose File to Send: &lt;/label&gt;    &lt;input type=&quot;file&quot; multiple name=&quot;file&quot; required /&gt;    &lt;!-- 注意，用于输入的input一定要有name --&gt;    &lt;br /&gt;    &lt;input type=&quot;submit&quot; value=&quot;Send the file!&quot; /&gt;  &lt;/form&gt;  &lt;script&gt;    var form = document.getElementById(&quot;form&quot;);    form.addEventListener(      &quot;submit&quot;,      function (ev) &#123;        var oData = new FormData(form);        axios(&#123;          method: &quot;post&quot;,          url: &quot;upload&quot;,          headers: &#123;            &quot;Content-Type&quot;: &quot;multipart/form-data&quot;,          &#125;,          data: oData,          timeout: 3000,        &#125;).then((res) =&gt; &#123;          console.log(res);        &#125;);        ev.preventDefault(); // 阻止对应组件的默认行为,此处为防止页面刷新导致努力ba      &#125;,      false    );  &lt;/script&gt;&lt;/body&gt;\r\n123456789101112131415# flask 后台@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def upload_file():    if request.method == &#x27;POST&#x27;:        print(request.files)        print(request.files.getlist(&#x27;file&#x27;))        upload_files = request.files.getlist(&#x27;file&#x27;)        for i in upload_files:            i.save(i.filename + &#x27;.jpg&#x27;)        return &quot;OK!&quot;    else:        return &quot;Wrong!&quot;\r\n","slug":"Language Learning/JavaScript/formdata使用攻略","date":"2021-06-02T04:23:23.000Z","categories_index":"Language Learning,Javascripts","tags_index":"Language Learning,Javascripts","author_index":"JBR_Bunjie"},{"id":"3be3467b821b2606f2e2f4a1380f6410","title":"线程、进程、协程、与 CPU 多核","content":"线程、进程、协程、与 CPU 多核\r\n一、进程、线程、协程的概念\r\n进程：\r\n是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。\r\n线程：\r\n是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。\r\n协程：\r\n是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。\r\n二、进程和线程的区别\r\n地址空间：\r\n线程共享本进程的地址空间，而进程之间是独立的地址空间。\r\n资源：\r\n线程共享本进程的资源如内存、I/O、cpu\r\n等，不利于资源的管理和保护，而进程之间的资源是独立的，能很好的进行资源管理和保护。\r\n健壮性：\r\n多进程要比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。\r\n执行过程：\r\n每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口，执行开销大。\r\n但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，执行开销小。\r\n可并发性：\r\n两者均可并发执行。\r\n切换时：\r\n进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。\r\n其他：\r\n线程是处理器调度的基本单位，但是进程不是。\r\n三、协程和线程的区别\r\n协程避免了无意义的调度，由此可以提高性能，但程序员必须自己承担调度的责任。同时，协程也失去了标准线程使用多\r\nCPU 的能力。\r\n线程\r\n相对独立\r\n有自己的上下文\r\n切换受系统控制；\r\n协程\r\n相对独立\r\n有自己的上下文\r\n切换由自己控制，由当前协程切换到其他协程由当前协程来控制。\r\n四、何时使用多进程，何时使用多线程？\r\n对资源的管理和保护要求高，不限制开销和效率时，使用多进程。\r\n要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。\r\n五、为什么会有线程？\r\n每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。\r\n六、*python\r\n多线程的问题（面试问题）\r\n存在问题：\r\npython\r\n由于历史遗留的问题，严格说多个线程并不会同时执行（没法有效利用多核处理器，python\r\n的并发只是在交替执行不同的代码）。\r\n多线程在 Python 中只能交替执行，即使 100 个线程跑在 100 核 CPU\r\n上，也只能用到 1 个核。所以 python\r\n的多线程并发并不能充分利用多核，并发没有 java 的并发严格。\r\n原因：\r\n原因就在于 GIL ，在 Cpython 解释器（Python\r\n语言的主流解释器）中，有一把全局解释锁（GIL, Global Interpreter\r\nLock），在解释器解释执行 Python 代码时，任何 Python\r\n线程执行前，都先要得到这把 GIL 锁。\r\n这个 GIL 全局锁实际上把所有线程的执行代码都给上了锁。\r\n这意味着，python 在任何时候，只可能有一个线程在执行代码。\r\n其它线程要想获得 CPU\r\n执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。\r\n多个线程一起执行反而更加慢的原因：\r\n同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核\r\nCPU，也没办法让多个线程「并行」地同时执行代码，只能是交替执行，因为多线程涉及到上线文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。\r\n什么时候 GIL 被释放？\r\n当一个线程遇到 I/O 任务时，将释放 GIL。\r\n计算密集型（CPU-bound）线程执行 100\r\n次解释器的计步（ticks）时（计步可粗略看作 Python\r\n虚拟机的指令），也会释放 GIL。\r\n即，每执行 100 条字节码，解释器就自动释放 GIL\r\n锁，让别的线程有机会执行。\r\n不过，Python\r\n虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个\r\nPython 进程有各自独立的 GIL 锁，互不影响。\r\n本条参考博客：\r\nhttp://www.sohu.com/a/230407177_99992472\r\n七、*进程通信方式（选读）\r\n管道：\r\n速度慢，容量有限，只有父子进程能通讯\r\nFIFO：\r\n任何进程间都能通讯，但速度慢\r\n消息队列：\r\n容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题\r\n信号量：\r\n不能传递复杂消息，只能用来同步\r\n共享内存区：\r\n能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存\r\n本条参考博客：\r\nhttps://blog.csdn.net/weixin_40283480/article/details/82155704\r\nCPU 线程 和 Java 线程\r\nCPU 线程 和\r\nJava 线程 - webglcn - 博客园 (cnblogs.com)\r\n进程、线程和\r\nCPU 之间的关系（一）nandao158 的博客-CSDN 博客线程和\r\ncpu\r\n进程是程序运行资源分配的最小单位\r\n。进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、 磁盘\r\nIO 等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程\r\n之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次\r\n运行活动,进程是系统进行资源分配和调度的一个独立单位。\r\n进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一\r\n个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进\r\n程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就\r\n是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。\r\n线程是 CPU 调度的最小单位,必须依赖于进程而存在\r\n线程是进程的一个实体,是 CPU 调度和分派的基本单位,它是比进程更小的、\r\n能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中\r\n必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其\r\n他的线程共享进程所拥有的全部资源。 线程无处不在\r\n任何一个程序都必须要创建线程,特别是 Java 不管任何程序都必须启动一个 main\r\n函数的主线程; Java Web 开发里面的定时任务、定时器、JSP 和 Servlet、异\r\n步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都\r\n离不开线程和并发的知识。\r\n\r\nJava 多线程并不是由于 cpu 线程数为多个才称为多线程，当 Java\r\n线程数大于 cpu\r\n线程数，操作系统使用时间片机制，采用线程调度算法，频繁的进行线程切换。\r\n\r\n(10 封私信 / 81\r\n条消息) CPU 的线程与操作系统的线程有何关系？ - 知乎 (zhihu.com)\r\n","slug":"Dev/Theory/线程进程协程与CPU","date":"2021-05-23T04:23:23.000Z","categories_index":"Theroy","tags_index":"Theroy","author_index":"JBR_Bunjie"},{"id":"5b286fb1e51c3a9c0edf1921a9c938c7","title":"计算机编码梳理","content":"计算机编码梳理\r\nASCII码\r\n描述\r\n这是计算机编码发展历程里的第一阶段：ASCII码，即：American Standard Code for Information Interchange，美国信息交换标准代码\r\n设计思路：\r\n在计算机内部存储单元的最小单位时Byte。不过Byte仍然可以细分：每一个二进制位是一个bit，有0和1两种状态。8个bit构成一个byte——所有的信息最终都表示为一个二进制的字符串。\r\n在这个基础上，如果利用0和1各代表一个状态，由于一个byte有8个bit，故总共可以表示2的8次方＝256个状态。若是每个状态对应一个符号，一个byte可以表示256个符号，也就是从0000000到11111111。\r\n根据这个思路，美国在上个世纪60年代制定了一套字符编码，用于安排控制字符、英语字符、数字等符号与二进制位之间对应的关系，形成了大名鼎鼎的ASCII码。\r\n但ASCII码一共只规定了128个字符的编码，比如空格\"SPACE\"是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，而由于使用了8位二进制，故规定最前面的第一位二进制数则为0。\r\n\r\n可以访问：ASCII Code - The\r\nextended ASCII table (ascii-code.com)了解\r\n\r\n现状：\r\n时至今日，仍然有很多语言采用这一编码作为默认编码，比如Python2等语言\r\n\r\nPython2的 默认编码是ASCII，不能识别中文字符，需要显式指定字符编码；\r\n而Python3的默认编码改为了Unicode，可以识别中文字符\r\n\r\n采用ASCII编码主要的字符集：Windows-1252字符集、ISO8859-1字符集\r\nASCII实现思路\r\n\r\n所有的控制字符(比如CR回车、DEL删除等)编码在0-31范围以及127中。\r\n把所有的标点符号，英文大小写全部放在32-126范围中。\r\n\r\nASCII实现形式\r\n\r\n0xxxx xxxx\r\n\r\n示例\r\n12345678910111213141516String str = new String(&quot;华侨永亨银行&quot;);// 采用UTF-8编码得到字节数组byte[] bytes = str.getBytes(&quot;UTF-8&quot;);// bytes: &#123;e5 8d 8e e4 be a8 e6 b0 b8 e4 ba a8 e9 93 b6 e8 a1 8c&#125;// 注意第二个字节0x8d，在下面的编解码中被自动转换成了3f// 采用Windows-1252解码得到字符串str = new String(bytes, &quot;Windows-1252&quot;);// 采用windows-1252编码，还原字节数组bytes = str.getBytes(&quot;Windows-1252&quot;);// bytes: &#123;e5 3f 8e e4 be a8 e6 b0 b8 e4 ba a8 e9 93 b6 e8 a1 8c&#125;// 采用UTF-8解码，预期得到原字符串str = new String(bytes, &quot;UTF-8&quot;);// str: ???侨永亨银行,第一个字被永久性破坏// 引自：https://blog.csdn.net/zou8944/article/details/79859112\r\n\r\n不过，这个例子对Python不生效，因为python取了个巧:\r\n\r\n\r\nimage-20210910211848379\r\n\r\n\r\n\r\nrestsdafa\r\n\r\n\r\nGB2312&amp;GBK\r\n说明\r\n英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。\r\n以中文为例，汉字有10万左右，即使是常用字也有六七千，必须得用多个字节来表示。\r\n最先诞生的是GB2312编码。对于该编码，我们只需要明白以下两点：\r\n\r\n该编码可以表示大概7000左右个字符。其中有中文及一些常见的拉丁字母等。基本可以覆盖我们日常打字使用。\r\n该编码完全兼容ASCII码，计算机去读的时候首先判断最高位，如果是0，那么这个字符只占用一个字节，表示的内容跟ASCII码表示的一样。如果该字符最高位是1，那么该字节连同下一个字节表示一个中文汉字。所以平常咱们常说的英文一个字节，中文两个字节其实是从这里来的。\r\n\r\nGB2312实现形式\r\n\r\n0xxxxxxx：表示为ASCII字符\r\n1xxxxxxx 1xxxxxxx：表示为汉字\r\n\r\n后来？\r\n两个字节最多可以表示的字符数是\r\n2^16＝65536，如果要求首位必须是1，那么最多可以表示 32768\r\n个字符，但是GB2312\r\n只用了其中的7000左右的字符。这显然是没有做到物尽其用，而且如果有些特殊的中文，GB2312根本表示不了。所以GBK就应运而生了。\r\nGBK\r\n就尽量将能用到的状态都表示成中文字符了，当然最终还是有些状态没办法用（具体可以自行查找文档），最终可以表示23940个字符，其中有21003是汉字。\r\nGBK是完全兼容GB2312的，所以GBK的应用是很广泛的，而且从Windows95开始，Windows的中文版默认中文支持就是GBK编码。你可以通过在cmd下输入chcp命令来查看你当前系统的默认编码\r\n\r\n在GBK后还有GB18030等，不再解释\r\n\r\nGBK实现形式：\r\n\r\n0xxxxxxx：表示为ASCII字符\r\n1xxxxxxx xxxxxxxx：表示为汉字\r\n\r\nUnicode\r\nGBK基本解决了中文编码问题，但另外一个大问题随之而来，那就是国际化。\r\n从我们的视角看，我们按照这种方式来表示简体中文和英文，成了是成了，可是繁体中文怎么表示？日文又怎么表示？\r\n而又从他们的视角看，当然他们也利用最高位来做文章，发明了big5（台湾繁体），JIS（日文）等兼容ASCII码的编码格式，但是这几种编码之间是并不兼容的。一段GBK编码的文件在台湾友人的电脑里打开就是乱码了。\r\n这时候，Unicode就诞生了。\r\nUnicode – The World Standard for\r\nText and Emoji\r\n完全弄明白Unicode的细节是非常困难的，我们也是明白以下几点就够了：\r\n\r\nUnicode\r\n只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\r\nUnicode\r\n编码是给世界上所有的符号都分配了一个码。GBK最多也只能表示3万多的汉字，康熙字典里面的大部分汉字都没法用GBK表示，但是Unicode就能，它(大概)可以表示这个星球上所有的符号。\r\nUnicode有UCS-2和UCS-4两种编码，2和4都是代表字节的意思，也就是说前者用两个字节表示，后者用4个字节表示。所以，UCS-2的表示范围是65536个字符，而UCS-4则可以表示超过22亿个字符，我想这真的是可以表示所有的字符了。其实日常使用我们用的只是UCS-2，一般说的Unicode编码也是只它。它包含了所有的简体中文，现用的繁体中文，火星文，以及其他国家的现用文字。古籍中的文字就得去UCS-4中去找了。\r\n\r\n值得注意的是：Unicode中，中文的编码范围为4E00-9FCF，其中9FC4-9FCF之间的区间没有使用。\r\n一个比较突出的问题就是这个区间全部都是文字，而中文标点没有包含在其中，反而散落在各个位置。同时，一些特殊的文字和中文部首以及一些特殊符号也不在此范围内，需要特别注意。\r\nUTF-8\r\n说明\r\n很遗憾，Unicode并不是完美的。不完美的地方主要有两点：\r\n1）不兼容ASCII码。因为Unicode是用两个字节表示，ASCII码范围内的字符都被扩充成了两个字节，前面又补了8个0。所以，如果你的电脑只支持Unicode编码的话，所有的英文资料全都没法阅读了。\r\n2）占用的存储变大，如果涉及到传输，所耗费的流量也会变大。中文文本还好，英文就相当明显。纯英文文本所消耗的存储比以前增大了一倍。\r\n这个时候就出现了诸如UTF-8等实现方式。这里我们只讨论UTF-8，因为它是使用最广泛的。它弥补了Unicode的缺陷，同时主要有以下几个优点。\r\n\r\nUTF-8与Unicode是一一对应的。所以UTF-8是国际化的编码方式。\r\nUTF-8是针对Unicode的可变长度字符编码，最短一个字节，最长3个字节，1个字节表示的就是ASCII码，所以UTF-8是完全兼容ASCII码的。\r\n正是因为UTF-8的变长实现，解决了Unicode的存储多的问题。可能有朋友要问了，UTF-8最多需要用3个字节表示，而Unicode只需要两个，怎么能说UFT-8会省存储呢？因为目前英文是最通用的语言，大部分字符都是ASCII码。\r\n\r\n但UTF-8并不是一点缺点也没有，因为变长表示，所以一段UTF-8编码没法一下子算出有多少个字符。而这一点能力对于以上几种编码格式来说是轻而易举的。所以当今世界上没有最完美的字符编码，只有最合适某个场景的编码。\r\nUTF-8具体实现\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n范围\r\n字节数\r\n存储格式\r\n\r\n\r\n\r\n\r\n0x0000~0x007F (0 ~ 127)\r\n1字节\r\n0xxxxxxx\r\n\r\n\r\n0x0080~0x07FF(128 ~ 2047)\r\n2字节\r\n110xxxxx 10xxxxxx\r\n\r\n\r\n0x0800~FFFF(2048 ~ 65535)\r\n3字节\r\n1110xxxx 10xxxxxx 10xxxxxx\r\n\r\n\r\n0x10000~1FFFFFF(65536 ~ 2097152)\r\n4字节\r\n11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n\r\n\r\n0x2000000~0x3FFFFFF\r\n5字节\r\n111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n\r\n\r\n0x4000000~0x7FFFFFFF)\r\n6字节\r\n1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n\r\n\r\n\r\n番外：多字节编码的一些概念\r\n大尾(big endian)和小尾(little\r\nendian)\r\n大尾和小尾是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big\r\nendian。还是将49写在前面，就是little endian。\r\nBOM\r\nUTF-8以字节为编码单元，故没有字节序的问题。而UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？\r\nUnicode规范中推荐的标记字节顺序的方法是BOM，即Byte Order\r\nMark。BOM是一个有点小聪明的想法：\r\n在UCS编码中有一个叫做\"ZERO WIDTH NO-BREAK SPACE\"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符\"ZERO WIDTH NO-BREAK SPACE\"。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符\"ZERO WIDTH NO-BREAK SPACE\"又被称作BOM。\r\nUTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符\"ZERO WIDTH NO-BREAK SPACE\"的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。\r\n不过话又说回来：理论上说，UTF-8并没有大小尾的困扰，所以并不需要BOM。但是一些Windows应用会指定大小尾，比如Notepad，而且Excel在没有指定BOM的UTF-8文件进行读取时会使用Windows的codepage，从而出现错误。\r\n","slug":"Language Learning/Endcoding","date":"2021-05-20T18:23:23.000Z","categories_index":"Encoding","tags_index":"Encoding","author_index":"JBR_Bunjie"},{"id":"98dbeae72608ff627852a7e0bf228ac0","title":"NPM 基本命令","content":"NPM 基本命令\r\n修改 npm 源\r\n设置 npm 下载来源为淘宝源\r\n\r\n查看当前源\r\n\r\n1npm config get registry\r\n\r\n设置为淘宝源\r\n\r\n1npm config set registry https://registry.npm.taobao.org\r\n\r\n临时使用源（适用于一次性使用）\r\n\r\n1npm --registry https://registry.npm.taobao.org install XXX（module name）\r\n还原默认源：\r\n1npm config set registry https://registry.npmjs.org/\r\n采用 cnpm\r\n\r\ncnpm 介绍： 淘宝搭建的一个国内的 npm 服务器，以 10 分钟每次的速度将\r\nnpm 仓库中的所有内容“搬运”到国内\r\ncnpm 安装： npm install -g cnpm\r\n--registry=https://registry.npm.taobao.org\r\ncnpm 与 npm 的关系：cnpm 就是 npm 的另一个版本，是 node\r\n中一个不同的下载器，只包含了 npm 的下载功能\r\n\r\nnrm\r\n\r\nnrm 介绍： nrm 是 npm 注册表的管理工具，可以添加、删除、查询、切换\r\nnpm 注册表。 什么是 nrm nrm 是一个 npm 源管理器，允许你快速地在 npm\r\n源间切换。\r\nnrm 简单使用：\r\n\r\n修改 NPM\r\n的缓存以及全局安装地址：\r\n\r\n查看设置\r\n\r\n1npm config ls\r\n\r\n设置全局安装地址：\r\n\r\n1npm config set prefix &quot;D:/npm/npm_Download&quot;\r\n\r\n设置缓存地址\r\n\r\n1npm config set cache &quot;D:/npm/npm_Cache&quot;\r\n\r\n清除缓存：\r\n\r\n12npm cache clean --force\t```npm WARN using --force I sure hope you know what you are doing.\r\nNPM 管理安装包：\r\n\r\n查看已经安装的包：\r\n\r\n1npm list -g --depth 0\r\n\r\n更新包：\r\n\r\n1npm update -g xxx\r\n\r\n卸载包：\r\n\r\n1npm uninstall -g xxx\r\n","slug":"Dev/Front End/NPM 基本命令","date":"2021-01-30T21:23:23.000Z","categories_index":"Javascripts","tags_index":"Javascripts","author_index":"JBR_Bunjie"}]